(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.geojsonToArcGIS = exports.arcgisToGeoJSON = void 0;

/* @preserve
* @terraformer/arcgis - v2.0.7 - MIT
* Copyright (c) 2012-2021 Environmental Systems Research Institute, Inc.
* Thu Jul 22 2021 13:58:30 GMT-0700 (Pacific Daylight Time)
*/

/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */
var edgeIntersectsEdge = function edgeIntersectsEdge(a1, a2, b1, b2) {
  var uaT = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0]);
  var ubT = (a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0]);
  var uB = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);

  if (uB !== 0) {
    var ua = uaT / uB;
    var ub = ubT / uB;

    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
      return true;
    }
  }

  return false;
};

var coordinatesContainPoint = function coordinatesContainPoint(coordinates, point) {
  var contains = false;

  for (var i = -1, l = coordinates.length, j = l - 1; ++i < l; j = i) {
    if ((coordinates[i][1] <= point[1] && point[1] < coordinates[j][1] || coordinates[j][1] <= point[1] && point[1] < coordinates[i][1]) && point[0] < (coordinates[j][0] - coordinates[i][0]) * (point[1] - coordinates[i][1]) / (coordinates[j][1] - coordinates[i][1]) + coordinates[i][0]) {
      contains = !contains;
    }
  }

  return contains;
};

var pointsEqual = function pointsEqual(a, b) {
  for (var i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }

  return true;
};

var arrayIntersectsArray = function arrayIntersectsArray(a, b) {
  for (var i = 0; i < a.length - 1; i++) {
    for (var j = 0; j < b.length - 1; j++) {
      if (edgeIntersectsEdge(a[i], a[i + 1], b[j], b[j + 1])) {
        return true;
      }
    }
  }

  return false;
};
/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */


var closeRing = function closeRing(coordinates) {
  if (!pointsEqual(coordinates[0], coordinates[coordinates.length - 1])) {
    coordinates.push(coordinates[0]);
  }

  return coordinates;
}; // determine if polygon ring coordinates are clockwise. clockwise signifies outer ring, counter-clockwise an inner ring
// or hole. this logic was found at http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-
// points-are-in-clockwise-order


var ringIsClockwise = function ringIsClockwise(ringToTest) {
  var total = 0;
  var i = 0;
  var rLength = ringToTest.length;
  var pt1 = ringToTest[i];
  var pt2;

  for (i; i < rLength - 1; i++) {
    pt2 = ringToTest[i + 1];
    total += (pt2[0] - pt1[0]) * (pt2[1] + pt1[1]);
    pt1 = pt2;
  }

  return total >= 0;
}; // This function ensures that rings are oriented in the right directions
// from http://jsperf.com/cloning-an-object/2


var shallowClone = function shallowClone(obj) {
  var target = {};

  for (var i in obj) {
    // both arcgis attributes and geojson props are just hardcoded keys
    if (obj.hasOwnProperty(i)) {
      // eslint-disable-line no-prototype-builtins
      target[i] = obj[i];
    }
  }

  return target;
};
/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */


var coordinatesContainCoordinates = function coordinatesContainCoordinates(outer, inner) {
  var intersects = arrayIntersectsArray(outer, inner);
  var contains = coordinatesContainPoint(outer, inner[0]);

  if (!intersects && contains) {
    return true;
  }

  return false;
}; // do any polygons in this array contain any other polygons in this array?
// used for checking for holes in arcgis rings


var convertRingsToGeoJSON = function convertRingsToGeoJSON(rings) {
  var outerRings = [];
  var holes = [];
  var x; // iterator

  var outerRing; // current outer ring being evaluated

  var hole; // current hole being evaluated
  // for each ring

  for (var r = 0; r < rings.length; r++) {
    var ring = closeRing(rings[r].slice(0));

    if (ring.length < 4) {
      continue;
    } // is this ring an outer ring? is it clockwise?


    if (ringIsClockwise(ring)) {
      var polygon = [ring.slice().reverse()]; // wind outer rings counterclockwise for RFC 7946 compliance

      outerRings.push(polygon); // push to outer rings
    } else {
      holes.push(ring.slice().reverse()); // wind inner rings clockwise for RFC 7946 compliance
    }
  }

  var uncontainedHoles = []; // while there are holes left...

  while (holes.length) {
    // pop a hole off out stack
    hole = holes.pop(); // loop over all outer rings and see if they contain our hole.

    var contained = false;

    for (x = outerRings.length - 1; x >= 0; x--) {
      outerRing = outerRings[x][0];

      if (coordinatesContainCoordinates(outerRing, hole)) {
        // the hole is contained push it into our polygon
        outerRings[x].push(hole);
        contained = true;
        break;
      }
    } // ring is not contained in any outer ring
    // sometimes this happens https://github.com/Esri/esri-leaflet/issues/320


    if (!contained) {
      uncontainedHoles.push(hole);
    }
  } // if we couldn't match any holes using contains we can try intersects...


  while (uncontainedHoles.length) {
    // pop a hole off out stack
    hole = uncontainedHoles.pop(); // loop over all outer rings and see if any intersect our hole.

    var intersects = false;

    for (x = outerRings.length - 1; x >= 0; x--) {
      outerRing = outerRings[x][0];

      if (arrayIntersectsArray(outerRing, hole)) {
        // the hole is contained push it into our polygon
        outerRings[x].push(hole);
        intersects = true;
        break;
      }
    }

    if (!intersects) {
      outerRings.push([hole.reverse()]);
    }
  }

  if (outerRings.length === 1) {
    return {
      type: 'Polygon',
      coordinates: outerRings[0]
    };
  } else {
    return {
      type: 'MultiPolygon',
      coordinates: outerRings
    };
  }
};

var getId = function getId(attributes, idAttribute) {
  var keys = idAttribute ? [idAttribute, 'OBJECTID', 'FID'] : ['OBJECTID', 'FID'];

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];

    if (key in attributes && (typeof attributes[key] === 'string' || typeof attributes[key] === 'number')) {
      return attributes[key];
    }
  }

  throw Error('No valid id attribute found');
};

var arcgisToGeoJSON = function arcgisToGeoJSON(arcgis, idAttribute) {
  var geojson = {};

  if (arcgis.features) {
    geojson.type = 'FeatureCollection';
    geojson.features = [];

    for (var i = 0; i < arcgis.features.length; i++) {
      geojson.features.push(arcgisToGeoJSON(arcgis.features[i], idAttribute));
    }
  }

  if (typeof arcgis.x === 'number' && typeof arcgis.y === 'number') {
    geojson.type = 'Point';
    geojson.coordinates = [arcgis.x, arcgis.y];

    if (typeof arcgis.z === 'number') {
      geojson.coordinates.push(arcgis.z);
    }
  }

  if (arcgis.points) {
    geojson.type = 'MultiPoint';
    geojson.coordinates = arcgis.points.slice(0);
  }

  if (arcgis.paths) {
    if (arcgis.paths.length === 1) {
      geojson.type = 'LineString';
      geojson.coordinates = arcgis.paths[0].slice(0);
    } else {
      geojson.type = 'MultiLineString';
      geojson.coordinates = arcgis.paths.slice(0);
    }
  }

  if (arcgis.rings) {
    geojson = convertRingsToGeoJSON(arcgis.rings.slice(0));
  }

  if (typeof arcgis.xmin === 'number' && typeof arcgis.ymin === 'number' && typeof arcgis.xmax === 'number' && typeof arcgis.ymax === 'number') {
    geojson.type = 'Polygon';
    geojson.coordinates = [[[arcgis.xmax, arcgis.ymax], [arcgis.xmin, arcgis.ymax], [arcgis.xmin, arcgis.ymin], [arcgis.xmax, arcgis.ymin], [arcgis.xmax, arcgis.ymax]]];
  }

  if (arcgis.geometry || arcgis.attributes) {
    geojson.type = 'Feature';
    geojson.geometry = arcgis.geometry ? arcgisToGeoJSON(arcgis.geometry) : null;
    geojson.properties = arcgis.attributes ? shallowClone(arcgis.attributes) : null;

    if (arcgis.attributes) {
      try {
        geojson.id = getId(arcgis.attributes, idAttribute);
      } catch (err) {// don't set an id
      }
    }
  } // if no valid geometry was encountered


  if (JSON.stringify(geojson.geometry) === JSON.stringify({})) {
    geojson.geometry = null;
  }

  if (arcgis.spatialReference && arcgis.spatialReference.wkid && arcgis.spatialReference.wkid !== 4326) {
    console.warn('Object converted in non-standard crs - ' + JSON.stringify(arcgis.spatialReference));
  }

  return geojson;
};
/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */
// outer rings are clockwise, holes are counterclockwise
// used for converting GeoJSON Polygons to ArcGIS Polygons


exports.arcgisToGeoJSON = arcgisToGeoJSON;

var orientRings = function orientRings(poly) {
  var output = [];
  var polygon = poly.slice(0);
  var outerRing = closeRing(polygon.shift().slice(0));

  if (outerRing.length >= 4) {
    if (!ringIsClockwise(outerRing)) {
      outerRing.reverse();
    }

    output.push(outerRing);

    for (var i = 0; i < polygon.length; i++) {
      var hole = closeRing(polygon[i].slice(0));

      if (hole.length >= 4) {
        if (ringIsClockwise(hole)) {
          hole.reverse();
        }

        output.push(hole);
      }
    }
  }

  return output;
}; // This function flattens holes in multipolygons to one array of polygons
// used for converting GeoJSON Polygons to ArcGIS Polygons


var flattenMultiPolygonRings = function flattenMultiPolygonRings(rings) {
  var output = [];

  for (var i = 0; i < rings.length; i++) {
    var polygon = orientRings(rings[i]);

    for (var x = polygon.length - 1; x >= 0; x--) {
      var ring = polygon[x].slice(0);
      output.push(ring);
    }
  }

  return output;
};

var geojsonToArcGIS = function geojsonToArcGIS(geojson, idAttribute) {
  idAttribute = idAttribute || 'OBJECTID';
  var spatialReference = {
    wkid: 4326
  };
  var result = {};
  var i;

  switch (geojson.type) {
    case 'Point':
      result.x = geojson.coordinates[0];
      result.y = geojson.coordinates[1];

      if (geojson.coordinates[2]) {
        result.z = geojson.coordinates[2];
      }

      result.spatialReference = spatialReference;
      break;

    case 'MultiPoint':
      result.points = geojson.coordinates.slice(0);

      if (geojson.coordinates[0][2]) {
        result.hasZ = true;
      }

      result.spatialReference = spatialReference;
      break;

    case 'LineString':
      result.paths = [geojson.coordinates.slice(0)];

      if (geojson.coordinates[0][2]) {
        result.hasZ = true;
      }

      result.spatialReference = spatialReference;
      break;

    case 'MultiLineString':
      result.paths = geojson.coordinates.slice(0);

      if (geojson.coordinates[0][0][2]) {
        result.hasZ = true;
      }

      result.spatialReference = spatialReference;
      break;

    case 'Polygon':
      result.rings = orientRings(geojson.coordinates.slice(0));

      if (geojson.coordinates[0][0][2]) {
        result.hasZ = true;
      }

      result.spatialReference = spatialReference;
      break;

    case 'MultiPolygon':
      result.rings = flattenMultiPolygonRings(geojson.coordinates.slice(0));

      if (geojson.coordinates[0][0][0][2]) {
        result.hasZ = true;
      }

      result.spatialReference = spatialReference;
      break;

    case 'Feature':
      if (geojson.geometry) {
        result.geometry = geojsonToArcGIS(geojson.geometry, idAttribute);
      }

      result.attributes = geojson.properties ? shallowClone(geojson.properties) : {};

      if (geojson.id) {
        result.attributes[idAttribute] = geojson.id;
      }

      break;

    case 'FeatureCollection':
      result = [];

      for (i = 0; i < geojson.features.length; i++) {
        result.push(geojsonToArcGIS(geojson.features[i], idAttribute));
      }

      break;

    case 'GeometryCollection':
      result = [];

      for (i = 0; i < geojson.geometries.length; i++) {
        result.push(geojsonToArcGIS(geojson.geometries[i], idAttribute));
      }

      break;
  }

  return result;
};
/* Copyright (c) 2012-2019 Environmental Systems Research Institute, Inc.
 * Apache-2.0 */


exports.geojsonToArcGIS = geojsonToArcGIS;

},{}],2:[function(require,module,exports){
module.exports={
	"jet":[{"index":0,"rgb":[0,0,131]},{"index":0.125,"rgb":[0,60,170]},{"index":0.375,"rgb":[5,255,255]},{"index":0.625,"rgb":[255,255,0]},{"index":0.875,"rgb":[250,0,0]},{"index":1,"rgb":[128,0,0]}],

	"hsv":[{"index":0,"rgb":[255,0,0]},{"index":0.169,"rgb":[253,255,2]},{"index":0.173,"rgb":[247,255,2]},{"index":0.337,"rgb":[0,252,4]},{"index":0.341,"rgb":[0,252,10]},{"index":0.506,"rgb":[1,249,255]},{"index":0.671,"rgb":[2,0,253]},{"index":0.675,"rgb":[8,0,253]},{"index":0.839,"rgb":[255,0,251]},{"index":0.843,"rgb":[255,0,245]},{"index":1,"rgb":[255,0,6]}],

	"hot":[{"index":0,"rgb":[0,0,0]},{"index":0.3,"rgb":[230,0,0]},{"index":0.6,"rgb":[255,210,0]},{"index":1,"rgb":[255,255,255]}],

	"spring":[{"index":0,"rgb":[255,0,255]},{"index":1,"rgb":[255,255,0]}],

	"summer":[{"index":0,"rgb":[0,128,102]},{"index":1,"rgb":[255,255,102]}],

	"autumn":[{"index":0,"rgb":[255,0,0]},{"index":1,"rgb":[255,255,0]}],

	"winter":[{"index":0,"rgb":[0,0,255]},{"index":1,"rgb":[0,255,128]}],

	"bone":[{"index":0,"rgb":[0,0,0]},{"index":0.376,"rgb":[84,84,116]},{"index":0.753,"rgb":[169,200,200]},{"index":1,"rgb":[255,255,255]}],

	"copper":[{"index":0,"rgb":[0,0,0]},{"index":0.804,"rgb":[255,160,102]},{"index":1,"rgb":[255,199,127]}],

	"greys":[{"index":0,"rgb":[0,0,0]},{"index":1,"rgb":[255,255,255]}],

	"yignbu":[{"index":0,"rgb":[8,29,88]},{"index":0.125,"rgb":[37,52,148]},{"index":0.25,"rgb":[34,94,168]},{"index":0.375,"rgb":[29,145,192]},{"index":0.5,"rgb":[65,182,196]},{"index":0.625,"rgb":[127,205,187]},{"index":0.75,"rgb":[199,233,180]},{"index":0.875,"rgb":[237,248,217]},{"index":1,"rgb":[255,255,217]}],

	"greens":[{"index":0,"rgb":[0,68,27]},{"index":0.125,"rgb":[0,109,44]},{"index":0.25,"rgb":[35,139,69]},{"index":0.375,"rgb":[65,171,93]},{"index":0.5,"rgb":[116,196,118]},{"index":0.625,"rgb":[161,217,155]},{"index":0.75,"rgb":[199,233,192]},{"index":0.875,"rgb":[229,245,224]},{"index":1,"rgb":[247,252,245]}],

	"yiorrd":[{"index":0,"rgb":[128,0,38]},{"index":0.125,"rgb":[189,0,38]},{"index":0.25,"rgb":[227,26,28]},{"index":0.375,"rgb":[252,78,42]},{"index":0.5,"rgb":[253,141,60]},{"index":0.625,"rgb":[254,178,76]},{"index":0.75,"rgb":[254,217,118]},{"index":0.875,"rgb":[255,237,160]},{"index":1,"rgb":[255,255,204]}],

	"bluered":[{"index":0,"rgb":[0,0,255]},{"index":1,"rgb":[255,0,0]}],

	"rdbu":[{"index":0,"rgb":[5,10,172]},{"index":0.35,"rgb":[106,137,247]},{"index":0.5,"rgb":[190,190,190]},{"index":0.6,"rgb":[220,170,132]},{"index":0.7,"rgb":[230,145,90]},{"index":1,"rgb":[178,10,28]}],

	"picnic":[{"index":0,"rgb":[0,0,255]},{"index":0.1,"rgb":[51,153,255]},{"index":0.2,"rgb":[102,204,255]},{"index":0.3,"rgb":[153,204,255]},{"index":0.4,"rgb":[204,204,255]},{"index":0.5,"rgb":[255,255,255]},{"index":0.6,"rgb":[255,204,255]},{"index":0.7,"rgb":[255,153,255]},{"index":0.8,"rgb":[255,102,204]},{"index":0.9,"rgb":[255,102,102]},{"index":1,"rgb":[255,0,0]}],

	"rainbow":[{"index":0,"rgb":[150,0,90]},{"index":0.125,"rgb":[0,0,200]},{"index":0.25,"rgb":[0,25,255]},{"index":0.375,"rgb":[0,152,255]},{"index":0.5,"rgb":[44,255,150]},{"index":0.625,"rgb":[151,255,0]},{"index":0.75,"rgb":[255,234,0]},{"index":0.875,"rgb":[255,111,0]},{"index":1,"rgb":[255,0,0]}],

	"portland":[{"index":0,"rgb":[12,51,131]},{"index":0.25,"rgb":[10,136,186]},{"index":0.5,"rgb":[242,211,56]},{"index":0.75,"rgb":[242,143,56]},{"index":1,"rgb":[217,30,30]}],

	"blackbody":[{"index":0,"rgb":[0,0,0]},{"index":0.2,"rgb":[230,0,0]},{"index":0.4,"rgb":[230,210,0]},{"index":0.7,"rgb":[255,255,255]},{"index":1,"rgb":[160,200,255]}],

	"earth":[{"index":0,"rgb":[0,0,130]},{"index":0.1,"rgb":[0,180,180]},{"index":0.2,"rgb":[40,210,40]},{"index":0.4,"rgb":[230,230,50]},{"index":0.6,"rgb":[120,70,20]},{"index":1,"rgb":[255,255,255]}],

	"electric":[{"index":0,"rgb":[0,0,0]},{"index":0.15,"rgb":[30,0,100]},{"index":0.4,"rgb":[120,0,100]},{"index":0.6,"rgb":[160,90,0]},{"index":0.8,"rgb":[230,200,0]},{"index":1,"rgb":[255,250,220]}],

	"alpha": [{"index":0, "rgb": [255,255,255,0]},{"index":1, "rgb": [255,255,255,1]}],

	"viridis": [{"index":0,"rgb":[68,1,84]},{"index":0.13,"rgb":[71,44,122]},{"index":0.25,"rgb":[59,81,139]},{"index":0.38,"rgb":[44,113,142]},{"index":0.5,"rgb":[33,144,141]},{"index":0.63,"rgb":[39,173,129]},{"index":0.75,"rgb":[92,200,99]},{"index":0.88,"rgb":[170,220,50]},{"index":1,"rgb":[253,231,37]}],

	"inferno": [{"index":0,"rgb":[0,0,4]},{"index":0.13,"rgb":[31,12,72]},{"index":0.25,"rgb":[85,15,109]},{"index":0.38,"rgb":[136,34,106]},{"index":0.5,"rgb":[186,54,85]},{"index":0.63,"rgb":[227,89,51]},{"index":0.75,"rgb":[249,140,10]},{"index":0.88,"rgb":[249,201,50]},{"index":1,"rgb":[252,255,164]}],

	"magma": [{"index":0,"rgb":[0,0,4]},{"index":0.13,"rgb":[28,16,68]},{"index":0.25,"rgb":[79,18,123]},{"index":0.38,"rgb":[129,37,129]},{"index":0.5,"rgb":[181,54,122]},{"index":0.63,"rgb":[229,80,100]},{"index":0.75,"rgb":[251,135,97]},{"index":0.88,"rgb":[254,194,135]},{"index":1,"rgb":[252,253,191]}],

	"plasma": [{"index":0,"rgb":[13,8,135]},{"index":0.13,"rgb":[75,3,161]},{"index":0.25,"rgb":[125,3,168]},{"index":0.38,"rgb":[168,34,150]},{"index":0.5,"rgb":[203,70,121]},{"index":0.63,"rgb":[229,107,93]},{"index":0.75,"rgb":[248,148,65]},{"index":0.88,"rgb":[253,195,40]},{"index":1,"rgb":[240,249,33]}],

	"warm": [{"index":0,"rgb":[125,0,179]},{"index":0.13,"rgb":[172,0,187]},{"index":0.25,"rgb":[219,0,170]},{"index":0.38,"rgb":[255,0,130]},{"index":0.5,"rgb":[255,63,74]},{"index":0.63,"rgb":[255,123,0]},{"index":0.75,"rgb":[234,176,0]},{"index":0.88,"rgb":[190,228,0]},{"index":1,"rgb":[147,255,0]}],

	"cool": [{"index":0,"rgb":[125,0,179]},{"index":0.13,"rgb":[116,0,218]},{"index":0.25,"rgb":[98,74,237]},{"index":0.38,"rgb":[68,146,231]},{"index":0.5,"rgb":[0,204,197]},{"index":0.63,"rgb":[0,247,146]},{"index":0.75,"rgb":[0,255,88]},{"index":0.88,"rgb":[40,255,8]},{"index":1,"rgb":[147,255,0]}],

	"rainbow-soft": [{"index":0,"rgb":[125,0,179]},{"index":0.1,"rgb":[199,0,180]},{"index":0.2,"rgb":[255,0,121]},{"index":0.3,"rgb":[255,108,0]},{"index":0.4,"rgb":[222,194,0]},{"index":0.5,"rgb":[150,255,0]},{"index":0.6,"rgb":[0,255,55]},{"index":0.7,"rgb":[0,246,150]},{"index":0.8,"rgb":[50,167,222]},{"index":0.9,"rgb":[103,51,235]},{"index":1,"rgb":[124,0,186]}],

	"bathymetry": [{"index":0,"rgb":[40,26,44]},{"index":0.13,"rgb":[59,49,90]},{"index":0.25,"rgb":[64,76,139]},{"index":0.38,"rgb":[63,110,151]},{"index":0.5,"rgb":[72,142,158]},{"index":0.63,"rgb":[85,174,163]},{"index":0.75,"rgb":[120,206,163]},{"index":0.88,"rgb":[187,230,172]},{"index":1,"rgb":[253,254,204]}],

	"cdom": [{"index":0,"rgb":[47,15,62]},{"index":0.13,"rgb":[87,23,86]},{"index":0.25,"rgb":[130,28,99]},{"index":0.38,"rgb":[171,41,96]},{"index":0.5,"rgb":[206,67,86]},{"index":0.63,"rgb":[230,106,84]},{"index":0.75,"rgb":[242,149,103]},{"index":0.88,"rgb":[249,193,135]},{"index":1,"rgb":[254,237,176]}],

	"chlorophyll": [{"index":0,"rgb":[18,36,20]},{"index":0.13,"rgb":[25,63,41]},{"index":0.25,"rgb":[24,91,59]},{"index":0.38,"rgb":[13,119,72]},{"index":0.5,"rgb":[18,148,80]},{"index":0.63,"rgb":[80,173,89]},{"index":0.75,"rgb":[132,196,122]},{"index":0.88,"rgb":[175,221,162]},{"index":1,"rgb":[215,249,208]}],

	"density": [{"index":0,"rgb":[54,14,36]},{"index":0.13,"rgb":[89,23,80]},{"index":0.25,"rgb":[110,45,132]},{"index":0.38,"rgb":[120,77,178]},{"index":0.5,"rgb":[120,113,213]},{"index":0.63,"rgb":[115,151,228]},{"index":0.75,"rgb":[134,185,227]},{"index":0.88,"rgb":[177,214,227]},{"index":1,"rgb":[230,241,241]}],

	"freesurface-blue": [{"index":0,"rgb":[30,4,110]},{"index":0.13,"rgb":[47,14,176]},{"index":0.25,"rgb":[41,45,236]},{"index":0.38,"rgb":[25,99,212]},{"index":0.5,"rgb":[68,131,200]},{"index":0.63,"rgb":[114,156,197]},{"index":0.75,"rgb":[157,181,203]},{"index":0.88,"rgb":[200,208,216]},{"index":1,"rgb":[241,237,236]}],

	"freesurface-red": [{"index":0,"rgb":[60,9,18]},{"index":0.13,"rgb":[100,17,27]},{"index":0.25,"rgb":[142,20,29]},{"index":0.38,"rgb":[177,43,27]},{"index":0.5,"rgb":[192,87,63]},{"index":0.63,"rgb":[205,125,105]},{"index":0.75,"rgb":[216,162,148]},{"index":0.88,"rgb":[227,199,193]},{"index":1,"rgb":[241,237,236]}],

	"oxygen": [{"index":0,"rgb":[64,5,5]},{"index":0.13,"rgb":[106,6,15]},{"index":0.25,"rgb":[144,26,7]},{"index":0.38,"rgb":[168,64,3]},{"index":0.5,"rgb":[188,100,4]},{"index":0.63,"rgb":[206,136,11]},{"index":0.75,"rgb":[220,174,25]},{"index":0.88,"rgb":[231,215,44]},{"index":1,"rgb":[248,254,105]}],

	"par": [{"index":0,"rgb":[51,20,24]},{"index":0.13,"rgb":[90,32,35]},{"index":0.25,"rgb":[129,44,34]},{"index":0.38,"rgb":[159,68,25]},{"index":0.5,"rgb":[182,99,19]},{"index":0.63,"rgb":[199,134,22]},{"index":0.75,"rgb":[212,171,35]},{"index":0.88,"rgb":[221,210,54]},{"index":1,"rgb":[225,253,75]}],

	"phase": [{"index":0,"rgb":[145,105,18]},{"index":0.13,"rgb":[184,71,38]},{"index":0.25,"rgb":[186,58,115]},{"index":0.38,"rgb":[160,71,185]},{"index":0.5,"rgb":[110,97,218]},{"index":0.63,"rgb":[50,123,164]},{"index":0.75,"rgb":[31,131,110]},{"index":0.88,"rgb":[77,129,34]},{"index":1,"rgb":[145,105,18]}],

	"salinity": [{"index":0,"rgb":[42,24,108]},{"index":0.13,"rgb":[33,50,162]},{"index":0.25,"rgb":[15,90,145]},{"index":0.38,"rgb":[40,118,137]},{"index":0.5,"rgb":[59,146,135]},{"index":0.63,"rgb":[79,175,126]},{"index":0.75,"rgb":[120,203,104]},{"index":0.88,"rgb":[193,221,100]},{"index":1,"rgb":[253,239,154]}],

	"temperature": [{"index":0,"rgb":[4,35,51]},{"index":0.13,"rgb":[23,51,122]},{"index":0.25,"rgb":[85,59,157]},{"index":0.38,"rgb":[129,79,143]},{"index":0.5,"rgb":[175,95,130]},{"index":0.63,"rgb":[222,112,101]},{"index":0.75,"rgb":[249,146,66]},{"index":0.88,"rgb":[249,196,65]},{"index":1,"rgb":[232,250,91]}],

	"turbidity": [{"index":0,"rgb":[34,31,27]},{"index":0.13,"rgb":[65,50,41]},{"index":0.25,"rgb":[98,69,52]},{"index":0.38,"rgb":[131,89,57]},{"index":0.5,"rgb":[161,112,59]},{"index":0.63,"rgb":[185,140,66]},{"index":0.75,"rgb":[202,174,88]},{"index":0.88,"rgb":[216,209,126]},{"index":1,"rgb":[233,246,171]}],

	"velocity-blue": [{"index":0,"rgb":[17,32,64]},{"index":0.13,"rgb":[35,52,116]},{"index":0.25,"rgb":[29,81,156]},{"index":0.38,"rgb":[31,113,162]},{"index":0.5,"rgb":[50,144,169]},{"index":0.63,"rgb":[87,173,176]},{"index":0.75,"rgb":[149,196,189]},{"index":0.88,"rgb":[203,221,211]},{"index":1,"rgb":[254,251,230]}],

	"velocity-green": [{"index":0,"rgb":[23,35,19]},{"index":0.13,"rgb":[24,64,38]},{"index":0.25,"rgb":[11,95,45]},{"index":0.38,"rgb":[39,123,35]},{"index":0.5,"rgb":[95,146,12]},{"index":0.63,"rgb":[152,165,18]},{"index":0.75,"rgb":[201,186,69]},{"index":0.88,"rgb":[233,216,137]},{"index":1,"rgb":[255,253,205]}],

	"cubehelix": [{"index":0,"rgb":[0,0,0]},{"index":0.07,"rgb":[22,5,59]},{"index":0.13,"rgb":[60,4,105]},{"index":0.2,"rgb":[109,1,135]},{"index":0.27,"rgb":[161,0,147]},{"index":0.33,"rgb":[210,2,142]},{"index":0.4,"rgb":[251,11,123]},{"index":0.47,"rgb":[255,29,97]},{"index":0.53,"rgb":[255,54,69]},{"index":0.6,"rgb":[255,85,46]},{"index":0.67,"rgb":[255,120,34]},{"index":0.73,"rgb":[255,157,37]},{"index":0.8,"rgb":[241,191,57]},{"index":0.87,"rgb":[224,220,93]},{"index":0.93,"rgb":[218,241,142]},{"index":1,"rgb":[227,253,198]}]
};

},{}],3:[function(require,module,exports){
/*
 * Ben Postlethwaite
 * January 2013
 * License MIT
 */
'use strict';

var colorScale = require('./colorScale');
var lerp = require('lerp')

module.exports = createColormap;

function createColormap (spec) {
    /*
     * Default Options
     */
    var indicies, fromrgba, torgba,
        nsteps, cmap, colormap, format,
        nshades, colors, alpha, i;

    if ( !spec ) spec = {};

    nshades = (spec.nshades || 72) - 1;
    format = spec.format || 'hex';

    colormap = spec.colormap;
    if (!colormap) colormap = 'jet';

    if (typeof colormap === 'string') {
        colormap = colormap.toLowerCase();

        if (!colorScale[colormap]) {
            throw Error(colormap + ' not a supported colorscale');
        }

        cmap = colorScale[colormap];

    } else if (Array.isArray(colormap)) {
        cmap = colormap.slice();

    } else {
        throw Error('unsupported colormap option', colormap);
    }

    if (cmap.length > nshades + 1) {
        throw new Error(
            colormap+' map requires nshades to be at least size '+cmap.length
        );
    }

    if (!Array.isArray(spec.alpha)) {

        if (typeof spec.alpha === 'number') {
            alpha = [spec.alpha, spec.alpha];

        } else {
            alpha = [1, 1];
        }

    } else if (spec.alpha.length !== 2) {
        alpha = [1, 1];

    } else {
        alpha = spec.alpha.slice();
    }

    // map index points from 0..1 to 0..n-1
    indicies = cmap.map(function(c) {
        return Math.round(c.index * nshades);
    });

    // Add alpha channel to the map
    alpha[0] = Math.min(Math.max(alpha[0], 0), 1);
    alpha[1] = Math.min(Math.max(alpha[1], 0), 1);

    var steps = cmap.map(function(c, i) {
        var index = cmap[i].index

        var rgba = cmap[i].rgb.slice();

        // if user supplies their own map use it
        if (rgba.length === 4 && rgba[3] >= 0 && rgba[3] <= 1) {
            return rgba
        }
        rgba[3] = alpha[0] + (alpha[1] - alpha[0])*index;

        return rgba
    })


    /*
     * map increasing linear values between indicies to
     * linear steps in colorvalues
     */
    var colors = []
    for (i = 0; i < indicies.length-1; ++i) {
        nsteps = indicies[i+1] - indicies[i];
        fromrgba = steps[i];
        torgba = steps[i+1];

        for (var j = 0; j < nsteps; j++) {
            var amt = j / nsteps
            colors.push([
                Math.round(lerp(fromrgba[0], torgba[0], amt)),
                Math.round(lerp(fromrgba[1], torgba[1], amt)),
                Math.round(lerp(fromrgba[2], torgba[2], amt)),
                lerp(fromrgba[3], torgba[3], amt)
            ])
        }
    }

    //add 1 step as last value
    colors.push(cmap[cmap.length - 1].rgb.concat(alpha[1]))

    if (format === 'hex') colors = colors.map( rgb2hex );
    else if (format === 'rgbaString') colors = colors.map( rgbaStr );
    else if (format === 'float') colors = colors.map( rgb2float );

    return colors;
};

function rgb2float (rgba) {
    return [
        rgba[0] / 255,
        rgba[1] / 255,
        rgba[2] / 255,
        rgba[3]
    ]
}

function rgb2hex (rgba) {
    var dig, hex = '#';
    for (var i = 0; i < 3; ++i) {
        dig = rgba[i];
        dig = dig.toString(16);
        hex += ('00' + dig).substr( dig.length );
    }
    return hex;
}

function rgbaStr (rgba) {
    return 'rgba(' + rgba.join(',') + ')';
}

},{"./colorScale":2,"lerp":30}],4:[function(require,module,exports){
module.exports={
  "_from": "esri-leaflet@^3.0.2",
  "_id": "esri-leaflet@3.0.2",
  "_inBundle": false,
  "_integrity": "sha512-Dr5Ie52yH+gojfnGXdzHGkrgn9U3kp9QKB7xqXZX/mPIE9gKyqC5Er8jRifJx+DTgeM67F+P7F09ZJsIvWbheQ==",
  "_location": "/esri-leaflet",
  "_phantomChildren": {},
  "_requested": {
    "type": "range",
    "registry": true,
    "raw": "esri-leaflet@^3.0.2",
    "name": "esri-leaflet",
    "escapedName": "esri-leaflet",
    "rawSpec": "^3.0.2",
    "saveSpec": null,
    "fetchSpec": "^3.0.2"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/esri-leaflet/-/esri-leaflet-3.0.2.tgz",
  "_shasum": "368ff662aeb8de21d70d59b362a821b0dcabf6b5",
  "_spec": "esri-leaflet@^3.0.2",
  "_where": "/home/dave/code/climate-tool/server/public",
  "author": {
    "name": "Patrick Arlt",
    "email": "parlt@esri.com",
    "url": "http://patrickarlt.com"
  },
  "bugs": {
    "url": "https://github.com/esri/esri-leaflet/issues"
  },
  "bundleDependencies": false,
  "contributors": [
    {
      "name": "Patrick Arlt",
      "email": "parlt@esri.com",
      "url": "http://patrickarlt.com"
    },
    {
      "name": "John Gravois",
      "email": "jgravois@esri.com",
      "url": "http://johngravois.com"
    },
    {
      "name": "Gavin Rehkemper",
      "email": "grehkemper@esri.com"
    },
    {
      "name": "Jacob Wasilkowski",
      "email": "jwasilkowski@esri.com",
      "url": "https://jwasilgeo.github.io"
    }
  ],
  "dependencies": {
    "@terraformer/arcgis": "^2.0.7",
    "tiny-binary-search": "^1.0.3"
  },
  "deprecated": false,
  "description": "Leaflet plugins for consuming ArcGIS Online and ArcGIS Server services.",
  "devDependencies": {
    "@rollup/plugin-json": "^4.0.3",
    "@rollup/plugin-node-resolve": "^7.1.3",
    "chai": "4.2.0",
    "gh-release": "^4.0.3",
    "highlight.js": "^9.12.0",
    "http-server": "^0.12.3",
    "husky": "^1.1.1",
    "istanbul": "^0.4.5",
    "karma": "^5.2.3",
    "karma-chai-sinon": "^0.1.5",
    "karma-chrome-launcher": "^2.2.0",
    "karma-coverage": "^1.1.2",
    "karma-mocha": "^2.0.1",
    "karma-mocha-reporter": "^2.2.5",
    "karma-sourcemap-loader": "^0.3.7",
    "leaflet": "^1.6.0",
    "mkdirp": "^0.5.1",
    "mocha": "^8.1.3",
    "npm-run-all": "^4.0.2",
    "rollup": "^2.0.0",
    "rollup-plugin-uglify": "^6.0.4",
    "semistandard": "^9.0.0",
    "sinon": "^6.3.5",
    "sinon-chai": "3.2.0",
    "snazzy": "^8.0.0",
    "uglify-js": "^2.8.29",
    "watch": "^1.0.2"
  },
  "files": [
    "src/**/*.js",
    "dist/esri-leaflet.js",
    "dist/esri-leaflet.js.map",
    "dist/esri-leaflet-debug.js.map",
    "profiles/*.js"
  ],
  "homepage": "http://esri.github.io/esri-leaflet",
  "jsnext:main": "src/EsriLeaflet.js",
  "jspm": {
    "registry": "npm",
    "format": "es6",
    "main": "src/EsriLeaflet.js"
  },
  "keywords": [
    "arcgis",
    "esri",
    "esri leaflet",
    "gis",
    "leaflet plugin",
    "mapping"
  ],
  "license": "Apache-2.0",
  "main": "dist/esri-leaflet-debug.js",
  "module": "src/EsriLeaflet.js",
  "name": "esri-leaflet",
  "peerDependencies": {
    "leaflet": "^1.0.0"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/Esri/esri-leaflet.git"
  },
  "scripts": {
    "build": "rollup -c profiles/debug.js & rollup -c profiles/production.js",
    "fix": "semistandard --fix",
    "lint": "semistandard | snazzy",
    "prebuild": "mkdirp dist",
    "precommit": "npm run lint",
    "prepare": "npm run build",
    "pretest": "npm run build",
    "release": "./scripts/release.sh",
    "serve": "http-server -p 5000 -c-1 -o",
    "start": "run-p start-watch serve",
    "start-watch": "watch \"npm run build\" src",
    "test": "npm run lint && karma start",
    "test:ci": "npm run lint && karma start --browsers Chrome_travis_ci"
  },
  "semistandard": {
    "globals": [
      "expect",
      "L",
      "XMLHttpRequest",
      "sinon",
      "xhr",
      "proj4"
    ]
  },
  "unpkg": "dist/esri-leaflet-debug.js",
  "version": "3.0.2"
}

},{}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Support", {
  enumerable: true,
  get: function () {
    return _Support.Support;
  }
});
Object.defineProperty(exports, "options", {
  enumerable: true,
  get: function () {
    return _Options.options;
  }
});
Object.defineProperty(exports, "Util", {
  enumerable: true,
  get: function () {
    return _Util.EsriUtil;
  }
});
Object.defineProperty(exports, "get", {
  enumerable: true,
  get: function () {
    return _Request.get;
  }
});
Object.defineProperty(exports, "post", {
  enumerable: true,
  get: function () {
    return _Request.post;
  }
});
Object.defineProperty(exports, "request", {
  enumerable: true,
  get: function () {
    return _Request.request;
  }
});
Object.defineProperty(exports, "Task", {
  enumerable: true,
  get: function () {
    return _Task.Task;
  }
});
Object.defineProperty(exports, "task", {
  enumerable: true,
  get: function () {
    return _Task.task;
  }
});
Object.defineProperty(exports, "Query", {
  enumerable: true,
  get: function () {
    return _Query.Query;
  }
});
Object.defineProperty(exports, "query", {
  enumerable: true,
  get: function () {
    return _Query.query;
  }
});
Object.defineProperty(exports, "Find", {
  enumerable: true,
  get: function () {
    return _Find.Find;
  }
});
Object.defineProperty(exports, "find", {
  enumerable: true,
  get: function () {
    return _Find.find;
  }
});
Object.defineProperty(exports, "Identify", {
  enumerable: true,
  get: function () {
    return _Identify.Identify;
  }
});
Object.defineProperty(exports, "identify", {
  enumerable: true,
  get: function () {
    return _Identify.identify;
  }
});
Object.defineProperty(exports, "IdentifyFeatures", {
  enumerable: true,
  get: function () {
    return _IdentifyFeatures.IdentifyFeatures;
  }
});
Object.defineProperty(exports, "identifyFeatures", {
  enumerable: true,
  get: function () {
    return _IdentifyFeatures.identifyFeatures;
  }
});
Object.defineProperty(exports, "IdentifyImage", {
  enumerable: true,
  get: function () {
    return _IdentifyImage.IdentifyImage;
  }
});
Object.defineProperty(exports, "identifyImage", {
  enumerable: true,
  get: function () {
    return _IdentifyImage.identifyImage;
  }
});
Object.defineProperty(exports, "Service", {
  enumerable: true,
  get: function () {
    return _Service.Service;
  }
});
Object.defineProperty(exports, "service", {
  enumerable: true,
  get: function () {
    return _Service.service;
  }
});
Object.defineProperty(exports, "MapService", {
  enumerable: true,
  get: function () {
    return _MapService.MapService;
  }
});
Object.defineProperty(exports, "mapService", {
  enumerable: true,
  get: function () {
    return _MapService.mapService;
  }
});
Object.defineProperty(exports, "ImageService", {
  enumerable: true,
  get: function () {
    return _ImageService.ImageService;
  }
});
Object.defineProperty(exports, "imageService", {
  enumerable: true,
  get: function () {
    return _ImageService.imageService;
  }
});
Object.defineProperty(exports, "FeatureLayerService", {
  enumerable: true,
  get: function () {
    return _FeatureLayerService.FeatureLayerService;
  }
});
Object.defineProperty(exports, "featureLayerService", {
  enumerable: true,
  get: function () {
    return _FeatureLayerService.featureLayerService;
  }
});
Object.defineProperty(exports, "BasemapLayer", {
  enumerable: true,
  get: function () {
    return _BasemapLayer.BasemapLayer;
  }
});
Object.defineProperty(exports, "basemapLayer", {
  enumerable: true,
  get: function () {
    return _BasemapLayer.basemapLayer;
  }
});
Object.defineProperty(exports, "TiledMapLayer", {
  enumerable: true,
  get: function () {
    return _TiledMapLayer.TiledMapLayer;
  }
});
Object.defineProperty(exports, "tiledMapLayer", {
  enumerable: true,
  get: function () {
    return _TiledMapLayer.tiledMapLayer;
  }
});
Object.defineProperty(exports, "RasterLayer", {
  enumerable: true,
  get: function () {
    return _RasterLayer.RasterLayer;
  }
});
Object.defineProperty(exports, "ImageMapLayer", {
  enumerable: true,
  get: function () {
    return _ImageMapLayer.ImageMapLayer;
  }
});
Object.defineProperty(exports, "imageMapLayer", {
  enumerable: true,
  get: function () {
    return _ImageMapLayer.imageMapLayer;
  }
});
Object.defineProperty(exports, "DynamicMapLayer", {
  enumerable: true,
  get: function () {
    return _DynamicMapLayer.DynamicMapLayer;
  }
});
Object.defineProperty(exports, "dynamicMapLayer", {
  enumerable: true,
  get: function () {
    return _DynamicMapLayer.dynamicMapLayer;
  }
});
Object.defineProperty(exports, "FeatureManager", {
  enumerable: true,
  get: function () {
    return _FeatureManager.FeatureManager;
  }
});
Object.defineProperty(exports, "FeatureLayer", {
  enumerable: true,
  get: function () {
    return _FeatureLayer.FeatureLayer;
  }
});
Object.defineProperty(exports, "featureLayer", {
  enumerable: true,
  get: function () {
    return _FeatureLayer.featureLayer;
  }
});
exports.VERSION = void 0;

var _package = _interopRequireDefault(require("../package.json"));

var _Support = require("./Support");

var _Options = require("./Options");

var _Util = require("./Util");

var _Request = require("./Request");

var _Task = require("./Tasks/Task");

var _Query = require("./Tasks/Query");

var _Find = require("./Tasks/Find");

var _Identify = require("./Tasks/Identify");

var _IdentifyFeatures = require("./Tasks/IdentifyFeatures");

var _IdentifyImage = require("./Tasks/IdentifyImage");

var _Service = require("./Services/Service");

var _MapService = require("./Services/MapService");

var _ImageService = require("./Services/ImageService");

var _FeatureLayerService = require("./Services/FeatureLayerService");

var _BasemapLayer = require("./Layers/BasemapLayer");

var _TiledMapLayer = require("./Layers/TiledMapLayer");

var _RasterLayer = require("./Layers/RasterLayer");

var _ImageMapLayer = require("./Layers/ImageMapLayer");

var _DynamicMapLayer = require("./Layers/DynamicMapLayer");

var _FeatureManager = require("./Layers/FeatureLayer/FeatureManager");

var _FeatureLayer = require("./Layers/FeatureLayer/FeatureLayer");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// export version
var version = _package.default.version;
exports.VERSION = version;

},{"../package.json":4,"./Layers/BasemapLayer":6,"./Layers/DynamicMapLayer":7,"./Layers/FeatureLayer/FeatureLayer":9,"./Layers/FeatureLayer/FeatureManager":10,"./Layers/ImageMapLayer":11,"./Layers/RasterLayer":12,"./Layers/TiledMapLayer":13,"./Options":14,"./Request":15,"./Services/FeatureLayerService":16,"./Services/ImageService":17,"./Services/MapService":18,"./Services/Service":19,"./Support":20,"./Tasks/Find":21,"./Tasks/Identify":22,"./Tasks/IdentifyFeatures":23,"./Tasks/IdentifyImage":24,"./Tasks/Query":25,"./Tasks/Task":26,"./Util":27}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.basemapLayer = basemapLayer;
exports.default = exports.BasemapLayer = void 0;

var _leaflet = require("leaflet");

var _Support = require("../Support");

var _Util = require("../Util");

var tileProtocol = window.location.protocol !== 'https:' ? 'http:' : 'https:';

var BasemapLayer = _leaflet.TileLayer.extend({
  statics: {
    TILES: {
      Streets: {
        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}',
        options: {
          minZoom: 1,
          maxZoom: 19,
          subdomains: ['server', 'services'],
          attribution: 'USGS, NOAA',
          attributionUrl: 'https://static.arcgis.com/attribution/World_Street_Map'
        }
      },
      Topographic: {
        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}',
        options: {
          minZoom: 1,
          maxZoom: 19,
          subdomains: ['server', 'services'],
          attribution: 'USGS, NOAA',
          attributionUrl: 'https://static.arcgis.com/attribution/World_Topo_Map'
        }
      },
      Oceans: {
        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/arcgis/rest/services/Ocean/World_Ocean_Base/MapServer/tile/{z}/{y}/{x}',
        options: {
          minZoom: 1,
          maxZoom: 16,
          subdomains: ['server', 'services'],
          attribution: 'USGS, NOAA',
          attributionUrl: 'https://static.arcgis.com/attribution/Ocean_Basemap'
        }
      },
      OceansLabels: {
        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/arcgis/rest/services/Ocean/World_Ocean_Reference/MapServer/tile/{z}/{y}/{x}',
        options: {
          minZoom: 1,
          maxZoom: 16,
          subdomains: ['server', 'services'],
          pane: _Support.pointerEvents ? 'esri-labels' : 'tilePane',
          attribution: ''
        }
      },
      NationalGeographic: {
        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}',
        options: {
          minZoom: 1,
          maxZoom: 16,
          subdomains: ['server', 'services'],
          attribution: 'National Geographic, DeLorme, HERE, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, GEBCO, NOAA, increment P Corp.'
        }
      },
      DarkGray: {
        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Base/MapServer/tile/{z}/{y}/{x}',
        options: {
          minZoom: 1,
          maxZoom: 16,
          subdomains: ['server', 'services'],
          attribution: 'HERE, DeLorme, MapmyIndia, &copy; OpenStreetMap contributors'
        }
      },
      DarkGrayLabels: {
        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Reference/MapServer/tile/{z}/{y}/{x}',
        options: {
          minZoom: 1,
          maxZoom: 16,
          subdomains: ['server', 'services'],
          pane: _Support.pointerEvents ? 'esri-labels' : 'tilePane',
          attribution: ''
        }
      },
      Gray: {
        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}',
        options: {
          minZoom: 1,
          maxZoom: 16,
          subdomains: ['server', 'services'],
          attribution: 'HERE, DeLorme, MapmyIndia, &copy; OpenStreetMap contributors'
        }
      },
      GrayLabels: {
        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Reference/MapServer/tile/{z}/{y}/{x}',
        options: {
          minZoom: 1,
          maxZoom: 16,
          subdomains: ['server', 'services'],
          pane: _Support.pointerEvents ? 'esri-labels' : 'tilePane',
          attribution: ''
        }
      },
      Imagery: {
        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
        options: {
          minZoom: 1,
          maxZoom: 19,
          subdomains: ['server', 'services'],
          attribution: 'DigitalGlobe, GeoEye, i-cubed, USDA, USGS, AEX, Getmapping, Aerogrid, IGN, IGP, swisstopo, and the GIS User Community',
          attributionUrl: 'https://static.arcgis.com/attribution/World_Imagery'
        }
      },
      ImageryLabels: {
        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}',
        options: {
          minZoom: 1,
          maxZoom: 19,
          subdomains: ['server', 'services'],
          pane: _Support.pointerEvents ? 'esri-labels' : 'tilePane',
          attribution: ''
        }
      },
      ImageryTransportation: {
        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/Reference/World_Transportation/MapServer/tile/{z}/{y}/{x}',
        options: {
          minZoom: 1,
          maxZoom: 19,
          subdomains: ['server', 'services'],
          pane: _Support.pointerEvents ? 'esri-labels' : 'tilePane',
          attribution: ''
        }
      },
      ShadedRelief: {
        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer/tile/{z}/{y}/{x}',
        options: {
          minZoom: 1,
          maxZoom: 13,
          subdomains: ['server', 'services'],
          attribution: 'USGS'
        }
      },
      ShadedReliefLabels: {
        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places_Alternate/MapServer/tile/{z}/{y}/{x}',
        options: {
          minZoom: 1,
          maxZoom: 12,
          subdomains: ['server', 'services'],
          pane: _Support.pointerEvents ? 'esri-labels' : 'tilePane',
          attribution: ''
        }
      },
      Terrain: {
        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{z}/{y}/{x}',
        options: {
          minZoom: 1,
          maxZoom: 13,
          subdomains: ['server', 'services'],
          attribution: 'USGS, NOAA'
        }
      },
      TerrainLabels: {
        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/Reference/World_Reference_Overlay/MapServer/tile/{z}/{y}/{x}',
        options: {
          minZoom: 1,
          maxZoom: 13,
          subdomains: ['server', 'services'],
          pane: _Support.pointerEvents ? 'esri-labels' : 'tilePane',
          attribution: ''
        }
      },
      USATopo: {
        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/ArcGIS/rest/services/USA_Topo_Maps/MapServer/tile/{z}/{y}/{x}',
        options: {
          minZoom: 1,
          maxZoom: 15,
          subdomains: ['server', 'services'],
          attribution: 'USGS, National Geographic Society, i-cubed'
        }
      },
      ImageryClarity: {
        urlTemplate: tileProtocol + '//clarity.maptiles.arcgis.com/arcgis/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
        options: {
          minZoom: 1,
          maxZoom: 19,
          attribution: 'Esri, DigitalGlobe, GeoEye, Earthstar Geographics, CNES/Airbus DS, USDA, USGS, AeroGRID, IGN, and the GIS User Community'
        }
      },
      Physical: {
        urlTemplate: tileProtocol + '//{s}.arcgisonline.com/arcgis/rest/services/World_Physical_Map/MapServer/tile/{z}/{y}/{x}',
        options: {
          minZoom: 1,
          maxZoom: 8,
          subdomains: ['server', 'services'],
          attribution: 'U.S. National Park Service'
        }
      },
      ImageryFirefly: {
        urlTemplate: tileProtocol + '//fly.maptiles.arcgis.com/arcgis/rest/services/World_Imagery_Firefly/MapServer/tile/{z}/{y}/{x}',
        options: {
          minZoom: 1,
          maxZoom: 19,
          attribution: 'Esri, DigitalGlobe, GeoEye, Earthstar Geographics, CNES/Airbus DS, USDA, USGS, AeroGRID, IGN, and the GIS User Community',
          attributionUrl: 'https://static.arcgis.com/attribution/World_Imagery'
        }
      }
    }
  },
  initialize: function (key, options) {
    var config; // set the config variable with the appropriate config object

    if (typeof key === 'object' && key.urlTemplate && key.options) {
      config = key;
    } else if (typeof key === 'string' && BasemapLayer.TILES[key]) {
      config = BasemapLayer.TILES[key];
    } else {
      throw new Error('L.esri.BasemapLayer: Invalid parameter. Use one of "Streets", "Topographic", "Oceans", "OceansLabels", "NationalGeographic", "Physical", "Gray", "GrayLabels", "DarkGray", "DarkGrayLabels", "Imagery", "ImageryLabels", "ImageryTransportation", "ImageryClarity", "ImageryFirefly", ShadedRelief", "ShadedReliefLabels", "Terrain", "TerrainLabels" or "USATopo"');
    } // merge passed options into the config options


    var tileOptions = _leaflet.Util.extend(config.options, options);

    _leaflet.Util.setOptions(this, tileOptions);

    if (this.options.token && config.urlTemplate.indexOf('token=') === -1) {
      config.urlTemplate += '?token=' + this.options.token;
    }

    if (this.options.proxy) {
      config.urlTemplate = this.options.proxy + '?' + config.urlTemplate;
    } // call the initialize method on L.TileLayer to set everything up


    _leaflet.TileLayer.prototype.initialize.call(this, config.urlTemplate, tileOptions);
  },
  onAdd: function (map) {
    // include 'Powered by Esri' in map attribution
    (0, _Util.setEsriAttribution)(map);

    if (this.options.pane === 'esri-labels') {
      this._initPane();
    } // some basemaps can supply dynamic attribution


    if (this.options.attributionUrl) {
      (0, _Util._getAttributionData)((this.options.proxy ? this.options.proxy + '?' : '') + this.options.attributionUrl, map);
    }

    map.on('moveend', _Util._updateMapAttribution);

    _leaflet.TileLayer.prototype.onAdd.call(this, map);
  },
  onRemove: function (map) {
    (0, _Util.removeEsriAttribution)(map);
    map.off('moveend', _Util._updateMapAttribution);

    _leaflet.TileLayer.prototype.onRemove.call(this, map);
  },
  _initPane: function () {
    if (!this._map.getPane(this.options.pane)) {
      var pane = this._map.createPane(this.options.pane);

      pane.style.pointerEvents = 'none';
      pane.style.zIndex = 500;
    }
  },
  getAttribution: function () {
    if (this.options.attribution) {
      var attribution = '<span class="esri-dynamic-attribution">' + this.options.attribution + '</span>';
    }

    return attribution;
  }
});

exports.BasemapLayer = BasemapLayer;

function basemapLayer(key, options) {
  return new BasemapLayer(key, options);
}

var _default = basemapLayer;
exports.default = _default;

},{"../Support":20,"../Util":27,"leaflet":29}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dynamicMapLayer = dynamicMapLayer;
exports.default = exports.DynamicMapLayer = void 0;

var _leaflet = require("leaflet");

var _RasterLayer = require("./RasterLayer");

var _Util = require("../Util");

var _MapService = _interopRequireDefault(require("../Services/MapService"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var DynamicMapLayer = _RasterLayer.RasterLayer.extend({
  options: {
    updateInterval: 150,
    layers: false,
    layerDefs: false,
    timeOptions: false,
    format: 'png32',
    transparent: true,
    f: 'json'
  },
  initialize: function (options) {
    options = (0, _Util.getUrlParams)(options);
    this.service = (0, _MapService.default)(options);
    this.service.addEventParent(this);

    _leaflet.Util.setOptions(this, options);
  },
  getDynamicLayers: function () {
    return this.options.dynamicLayers;
  },
  setDynamicLayers: function (dynamicLayers) {
    this.options.dynamicLayers = dynamicLayers;

    this._update();

    return this;
  },
  getLayers: function () {
    return this.options.layers;
  },
  setLayers: function (layers) {
    this.options.layers = layers;

    this._update();

    return this;
  },
  getLayerDefs: function () {
    return this.options.layerDefs;
  },
  setLayerDefs: function (layerDefs) {
    this.options.layerDefs = layerDefs;

    this._update();

    return this;
  },
  getTimeOptions: function () {
    return this.options.timeOptions;
  },
  setTimeOptions: function (timeOptions) {
    this.options.timeOptions = timeOptions;

    this._update();

    return this;
  },
  query: function () {
    return this.service.query();
  },
  identify: function () {
    return this.service.identify();
  },
  find: function () {
    return this.service.find();
  },
  _getPopupData: function (e) {
    var callback = _leaflet.Util.bind(function (error, featureCollection, response) {
      if (error) {
        return;
      } // we really can't do anything here but authenticate or requesterror will fire


      setTimeout(_leaflet.Util.bind(function () {
        this._renderPopup(e.latlng, error, featureCollection, response);
      }, this), 300);
    }, this);

    var identifyRequest;

    if (this.options.popup) {
      identifyRequest = this.options.popup.on(this._map).at(e.latlng);
    } else {
      identifyRequest = this.identify().on(this._map).at(e.latlng);
    } // remove extraneous vertices from response features if it has not already been done


    identifyRequest.params.maxAllowableOffset ? true : identifyRequest.simplify(this._map, 0.5);

    if (!(this.options.popup && this.options.popup.params && this.options.popup.params.layers)) {
      if (this.options.layers) {
        identifyRequest.layers('visible:' + this.options.layers.join(','));
      } else {
        identifyRequest.layers('visible');
      }
    } // if present, pass layer ids and sql filters through to the identify task


    if (this.options.layerDefs && typeof this.options.layerDefs !== 'string' && !identifyRequest.params.layerDefs) {
      for (var id in this.options.layerDefs) {
        if (this.options.layerDefs.hasOwnProperty(id)) {
          identifyRequest.layerDef(id, this.options.layerDefs[id]);
        }
      }
    }

    identifyRequest.run(callback); // set the flags to show the popup

    this._shouldRenderPopup = true;
    this._lastClick = e.latlng;
  },
  _buildExportParams: function () {
    var sr = parseInt(this._map.options.crs.code.split(':')[1], 10);
    var params = {
      bbox: this._calculateBbox(),
      size: this._calculateImageSize(),
      dpi: 96,
      format: this.options.format,
      transparent: this.options.transparent,
      bboxSR: sr,
      imageSR: sr
    };

    if (this.options.dynamicLayers) {
      params.dynamicLayers = this.options.dynamicLayers;
    }

    if (this.options.layers) {
      if (this.options.layers.length === 0) {
        return;
      } else {
        params.layers = 'show:' + this.options.layers.join(',');
      }
    }

    if (this.options.layerDefs) {
      params.layerDefs = typeof this.options.layerDefs === 'string' ? this.options.layerDefs : JSON.stringify(this.options.layerDefs);
    }

    if (this.options.timeOptions) {
      params.timeOptions = JSON.stringify(this.options.timeOptions);
    }

    if (this.options.from && this.options.to) {
      params.time = this.options.from.valueOf() + ',' + this.options.to.valueOf();
    }

    if (this.service.options.token) {
      params.token = this.service.options.token;
    }

    if (this.options.proxy) {
      params.proxy = this.options.proxy;
    } // use a timestamp to bust server cache


    if (this.options.disableCache) {
      params._ts = Date.now();
    }

    return params;
  },
  _requestExport: function (params, bounds) {
    if (this.options.f === 'json') {
      this.service.request('export', params, function (error, response) {
        if (error) {
          return;
        } // we really can't do anything here but authenticate or requesterror will fire


        if (this.options.token && response.href) {
          response.href += '?token=' + this.options.token;
        }

        if (this.options.proxy && response.href) {
          response.href = this.options.proxy + '?' + response.href;
        }

        if (response.href) {
          this._renderImage(response.href, bounds);
        } else {
          this._renderImage(response.imageData, bounds, response.contentType);
        }
      }, this);
    } else {
      params.f = 'image';

      var fullUrl = this.options.url + 'export' + _leaflet.Util.getParamString(params);

      if (this.options.proxy) {
        fullUrl = this.options.proxy + '?' + fullUrl;
      }

      this._renderImage(fullUrl, bounds);
    }
  }
});

exports.DynamicMapLayer = DynamicMapLayer;

function dynamicMapLayer(url, options) {
  return new DynamicMapLayer(url, options);
}

var _default = dynamicMapLayer;
exports.default = _default;

},{"../Services/MapService":18,"../Util":27,"./RasterLayer":12,"leaflet":29}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FeatureGrid = void 0;

var _leaflet = require("leaflet");

var FeatureGrid = _leaflet.Layer.extend({
  // @section
  // @aka GridLayer options
  options: {
    // @option cellSize: Number|Point = 256
    // Width and height of cells in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
    cellSize: 512,
    // @option updateWhenIdle: Boolean = (depends)
    // Load new cells only when panning ends.
    // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
    // `false` otherwise in order to display new cells _during_ panning, since it is easy to pan outside the
    // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
    updateWhenIdle: _leaflet.Browser.mobile,
    // @option updateInterval: Number = 150
    // Cells will not update more than once every `updateInterval` milliseconds when panning.
    updateInterval: 150,
    // @option noWrap: Boolean = false
    // Whether the layer is wrapped around the antimeridian. If `true`, the
    // GridLayer will only be displayed once at low zoom levels. Has no
    // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
    // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
    // cells outside the CRS limits.
    noWrap: false,
    // @option keepBuffer: Number = 1.5
    // When panning the map, keep this many rows and columns of cells before unloading them.
    keepBuffer: 1.5
  },
  initialize: function (options) {
    _leaflet.Util.setOptions(this, options);
  },
  onAdd: function (map) {
    this._cells = {};
    this._activeCells = {};

    this._resetView();

    this._update();
  },
  onRemove: function (map) {
    this._removeAllCells();

    this._cellZoom = undefined;
  },
  // @method isLoading: Boolean
  // Returns `true` if any cell in the grid layer has not finished loading.
  isLoading: function () {
    return this._loading;
  },
  // @method redraw: this
  // Causes the layer to clear all the cells and request them again.
  redraw: function () {
    if (this._map) {
      this._removeAllCells();

      this._update();
    }

    return this;
  },
  getEvents: function () {
    var events = {
      viewprereset: this._invalidateAll,
      viewreset: this._resetView,
      zoom: this._resetView,
      moveend: this._onMoveEnd
    };

    if (!this.options.updateWhenIdle) {
      // update cells on move, but not more often than once per given interval
      if (!this._onMove) {
        this._onMove = _leaflet.Util.throttle(this._onMoveEnd, this.options.updateInterval, this);
      }

      events.move = this._onMove;
    }

    return events;
  },
  // @section Extension methods
  // Layers extending `GridLayer` shall reimplement the following method.
  // @method createCell(coords: Object, done?: Function): HTMLElement
  // Called only internally, must be overridden by classes extending `GridLayer`.
  // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
  // is specified, it must be called when the cell has finished loading and drawing.
  createCell: function () {
    return document.createElement('div');
  },
  removeCell: function () {
    return;
  },
  reuseCell: function () {
    return;
  },
  cellLeave: function () {
    return;
  },
  cellEnter: function () {
    return;
  },
  // @section
  // @method getCellSize: Point
  // Normalizes the [cellSize option](#gridlayer-cellsize) into a point. Used by the `createCell()` method.
  getCellSize: function () {
    var s = this.options.cellSize;
    return s instanceof _leaflet.Point ? s : new _leaflet.Point(s, s);
  },
  _pruneCells: function () {
    if (!this._map) {
      return;
    }

    var key, cell;

    for (key in this._cells) {
      cell = this._cells[key];
      cell.retain = cell.current;
    }

    for (key in this._cells) {
      cell = this._cells[key];

      if (cell.current && !cell.active) {
        var coords = cell.coords;

        if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
          this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
        }
      }
    }

    for (key in this._cells) {
      if (!this._cells[key].retain) {
        this._removeCell(key);
      }
    }
  },
  _removeAllCells: function () {
    for (var key in this._cells) {
      this._removeCell(key);
    }
  },
  _invalidateAll: function () {
    this._removeAllCells();

    this._cellZoom = undefined;
  },
  _retainParent: function (x, y, z, minZoom) {
    var x2 = Math.floor(x / 2);
    var y2 = Math.floor(y / 2);
    var z2 = z - 1;
    var coords2 = new _leaflet.Point(+x2, +y2);
    coords2.z = +z2;

    var key = this._cellCoordsToKey(coords2);

    var cell = this._cells[key];

    if (cell && cell.active) {
      cell.retain = true;
      return true;
    } else if (cell && cell.loaded) {
      cell.retain = true;
    }

    if (z2 > minZoom) {
      return this._retainParent(x2, y2, z2, minZoom);
    }

    return false;
  },
  _retainChildren: function (x, y, z, maxZoom) {
    for (var i = 2 * x; i < 2 * x + 2; i++) {
      for (var j = 2 * y; j < 2 * y + 2; j++) {
        var coords = new _leaflet.Point(i, j);
        coords.z = z + 1;

        var key = this._cellCoordsToKey(coords);

        var cell = this._cells[key];

        if (cell && cell.active) {
          cell.retain = true;
          continue;
        } else if (cell && cell.loaded) {
          cell.retain = true;
        }

        if (z + 1 < maxZoom) {
          this._retainChildren(i, j, z + 1, maxZoom);
        }
      }
    }
  },
  _resetView: function (e) {
    var animating = e && (e.pinch || e.flyTo);

    if (animating) {
      return;
    }

    this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
  },
  _setView: function (center, zoom, noPrune, noUpdate) {
    var cellZoom = Math.round(zoom);

    if (!noUpdate) {
      this._cellZoom = cellZoom;

      if (this._abortLoading) {
        this._abortLoading();
      }

      this._resetGrid();

      if (cellZoom !== undefined) {
        this._update(center);
      }

      if (!noPrune) {
        this._pruneCells();
      } // Flag to prevent _updateOpacity from pruning cells during
      // a zoom anim or a pinch gesture


      this._noPrune = !!noPrune;
    }
  },
  _resetGrid: function () {
    var map = this._map;
    var crs = map.options.crs;
    var cellSize = this._cellSize = this.getCellSize();
    var cellZoom = this._cellZoom;

    var bounds = this._map.getPixelWorldBounds(this._cellZoom);

    if (bounds) {
      this._globalCellRange = this._pxBoundsToCellRange(bounds);
    }

    this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], cellZoom).x / cellSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], cellZoom).x / cellSize.y)];
    this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], cellZoom).y / cellSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], cellZoom).y / cellSize.y)];
  },
  _onMoveEnd: function (e) {
    var animating = e && (e.pinch || e.flyTo);

    if (animating || !this._map || this._map._animatingZoom) {
      return;
    }

    this._update();
  },
  _getCelldPixelBounds: function (center) {
    var map = this._map;
    var mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom();
    var scale = map.getZoomScale(mapZoom, this._cellZoom);
    var pixelCenter = map.project(center, this._cellZoom).floor();
    var halfSize = map.getSize().divideBy(scale * 2);
    return new _leaflet.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
  },
  // Private method to load cells in the grid's active zoom level according to map bounds
  _update: function (center) {
    var map = this._map;

    if (!map) {
      return;
    }

    var zoom = Math.round(map.getZoom());

    if (center === undefined) {
      center = map.getCenter();
    }

    var pixelBounds = this._getCelldPixelBounds(center);

    var cellRange = this._pxBoundsToCellRange(pixelBounds);

    var cellCenter = cellRange.getCenter();
    var queue = [];
    var margin = this.options.keepBuffer;
    var noPruneRange = new _leaflet.Bounds(cellRange.getBottomLeft().subtract([margin, -margin]), cellRange.getTopRight().add([margin, -margin])); // Sanity check: panic if the cell range contains Infinity somewhere.

    if (!(isFinite(cellRange.min.x) && isFinite(cellRange.min.y) && isFinite(cellRange.max.x) && isFinite(cellRange.max.y))) {
      throw new Error('Attempted to load an infinite number of cells');
    }

    for (var key in this._cells) {
      var c = this._cells[key].coords;

      if (c.z !== this._cellZoom || !noPruneRange.contains(new _leaflet.Point(c.x, c.y))) {
        this._cells[key].current = false;
      }
    } // _update just loads more cells. If the cell zoom level differs too much
    // from the map's, let _setView reset levels and prune old cells.


    if (Math.abs(zoom - this._cellZoom) > 1) {
      this._setView(center, zoom);

      return;
    } // create a queue of coordinates to load cells from


    for (var j = cellRange.min.y; j <= cellRange.max.y; j++) {
      for (var i = cellRange.min.x; i <= cellRange.max.x; i++) {
        var coords = new _leaflet.Point(i, j);
        coords.z = this._cellZoom;

        if (!this._isValidCell(coords)) {
          continue;
        }

        var cell = this._cells[this._cellCoordsToKey(coords)];

        if (cell) {
          cell.current = true;
        } else {
          queue.push(coords);
        }
      }
    } // sort cell queue to load cells in order of their distance to center


    queue.sort(function (a, b) {
      return a.distanceTo(cellCenter) - b.distanceTo(cellCenter);
    });

    if (queue.length !== 0) {
      // if it's the first batch of cells to load
      if (!this._loading) {
        this._loading = true;
      }

      for (i = 0; i < queue.length; i++) {
        var _key = this._cellCoordsToKey(queue[i]);

        var _coords = this._keyToCellCoords(_key);

        if (this._activeCells[_coords]) {
          this._reuseCell(queue[i]);
        } else {
          this._createCell(queue[i]);
        }
      }
    }
  },
  _isValidCell: function (coords) {
    var crs = this._map.options.crs;

    if (!crs.infinite) {
      // don't load cell if it's out of bounds and not wrapped
      var bounds = this._globalCellRange;

      if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
        return false;
      }
    }

    if (!this.options.bounds) {
      return true;
    } // don't load cell if it doesn't intersect the bounds in options


    var cellBounds = this._cellCoordsToBounds(coords);

    return (0, _leaflet.toLatLngBounds)(this.options.bounds).overlaps(cellBounds);
  },
  _keyToBounds: function (key) {
    return this._cellCoordsToBounds(this._keyToCellCoords(key));
  },
  _cellCoordsToNwSe: function (coords) {
    var map = this._map;
    var cellSize = this.getCellSize();
    var nwPoint = coords.scaleBy(cellSize);
    var sePoint = nwPoint.add(cellSize);
    var nw = map.unproject(nwPoint, coords.z);
    var se = map.unproject(sePoint, coords.z);
    return [nw, se];
  },
  // converts cell coordinates to its geographical bounds
  _cellCoordsToBounds: function (coords) {
    var bp = this._cellCoordsToNwSe(coords);

    var bounds = new _leaflet.LatLngBounds(bp[0], bp[1]);

    if (!this.options.noWrap) {
      bounds = this._map.wrapLatLngBounds(bounds);
    }

    return bounds;
  },
  // converts cell coordinates to key for the cell cache
  _cellCoordsToKey: function (coords) {
    return coords.x + ':' + coords.y + ':' + coords.z;
  },
  // converts cell cache key to coordinates
  _keyToCellCoords: function (key) {
    var k = key.split(':');
    var coords = new _leaflet.Point(+k[0], +k[1]);
    coords.z = +k[2];
    return coords;
  },
  _removeCell: function (key) {
    var cell = this._cells[key];

    if (!cell) {
      return;
    }

    var coords = this._keyToCellCoords(key);

    var wrappedCoords = this._wrapCoords(coords);

    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));

    cell.current = false;
    delete this._cells[key];
    this._activeCells[key] = cell;
    this.cellLeave(cellBounds, wrappedCoords, key);
    this.fire('cellleave', {
      key: key,
      coords: wrappedCoords,
      bounds: cellBounds
    });
  },
  _reuseCell: function (coords) {
    var key = this._cellCoordsToKey(coords); // save cell in cache


    this._cells[key] = this._activeCells[key];
    this._cells[key].current = true;

    var wrappedCoords = this._wrapCoords(coords);

    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));

    this.cellEnter(cellBounds, wrappedCoords, key);
    this.fire('cellenter', {
      key: key,
      coords: wrappedCoords,
      bounds: cellBounds
    });
  },
  _createCell: function (coords) {
    var key = this._cellCoordsToKey(coords);

    var wrappedCoords = this._wrapCoords(coords);

    var cellBounds = this._cellCoordsToBounds(this._wrapCoords(coords));

    this.createCell(cellBounds, wrappedCoords, key);
    this.fire('cellcreate', {
      key: key,
      coords: wrappedCoords,
      bounds: cellBounds
    }); // save cell in cache

    this._cells[key] = {
      coords: coords,
      current: true
    };

    _leaflet.Util.requestAnimFrame(this._pruneCells, this);
  },
  _cellReady: function (coords, err, cell) {
    var key = this._cellCoordsToKey(coords);

    cell = this._cells[key];

    if (!cell) {
      return;
    }

    cell.loaded = +new Date();
    cell.active = true;
  },
  _getCellPos: function (coords) {
    return coords.scaleBy(this.getCellSize());
  },
  _wrapCoords: function (coords) {
    var newCoords = new _leaflet.Point(this._wrapX ? _leaflet.Util.wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? _leaflet.Util.wrapNum(coords.y, this._wrapY) : coords.y);
    newCoords.z = coords.z;
    return newCoords;
  },
  _pxBoundsToCellRange: function (bounds) {
    var cellSize = this.getCellSize();
    return new _leaflet.Bounds(bounds.min.unscaleBy(cellSize).floor(), bounds.max.unscaleBy(cellSize).ceil().subtract([1, 1]));
  }
});

exports.FeatureGrid = FeatureGrid;

},{"leaflet":29}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.featureLayer = featureLayer;
exports.default = exports.FeatureLayer = void 0;

var _leaflet = require("leaflet");

var _FeatureManager = require("./FeatureManager");

var _Util = require("../../Util");

var FeatureLayer = _FeatureManager.FeatureManager.extend({
  options: {
    cacheLayers: true
  },

  /**
   * Constructor
   */
  initialize: function (options) {
    if (options.apikey) {
      options.token = options.apikey;
    }

    _FeatureManager.FeatureManager.prototype.initialize.call(this, options);

    this._originalStyle = this.options.style;
    this._layers = {};
  },

  /**
   * Layer Interface
   */
  onRemove: function (map) {
    for (var i in this._layers) {
      map.removeLayer(this._layers[i]); // trigger the event when the entire featureLayer is removed from the map

      this.fire('removefeature', {
        feature: this._layers[i].feature,
        permanent: false
      }, true);
    }

    return _FeatureManager.FeatureManager.prototype.onRemove.call(this, map);
  },
  createNewLayer: function (geojson) {
    var layer = _leaflet.GeoJSON.geometryToLayer(geojson, this.options); // trap for GeoJSON without geometry


    if (layer) {
      layer.defaultOptions = layer.options;
    }

    return layer;
  },
  _updateLayer: function (layer, geojson) {
    // convert the geojson coordinates into a Leaflet LatLng array/nested arrays
    // pass it to setLatLngs to update layer geometries
    var latlngs = [];
    var coordsToLatLng = this.options.coordsToLatLng || _leaflet.GeoJSON.coordsToLatLng; // copy new attributes, if present

    if (geojson.properties) {
      layer.feature.properties = geojson.properties;
    }

    switch (geojson.geometry.type) {
      case 'Point':
        latlngs = _leaflet.GeoJSON.coordsToLatLng(geojson.geometry.coordinates);
        layer.setLatLng(latlngs);
        break;

      case 'LineString':
        latlngs = _leaflet.GeoJSON.coordsToLatLngs(geojson.geometry.coordinates, 0, coordsToLatLng);
        layer.setLatLngs(latlngs);
        break;

      case 'MultiLineString':
        latlngs = _leaflet.GeoJSON.coordsToLatLngs(geojson.geometry.coordinates, 1, coordsToLatLng);
        layer.setLatLngs(latlngs);
        break;

      case 'Polygon':
        latlngs = _leaflet.GeoJSON.coordsToLatLngs(geojson.geometry.coordinates, 1, coordsToLatLng);
        layer.setLatLngs(latlngs);
        break;

      case 'MultiPolygon':
        latlngs = _leaflet.GeoJSON.coordsToLatLngs(geojson.geometry.coordinates, 2, coordsToLatLng);
        layer.setLatLngs(latlngs);
        break;
    }
  },

  /**
   * Feature Management Methods
   */
  createLayers: function (features) {
    for (var i = features.length - 1; i >= 0; i--) {
      var geojson = features[i];
      var layer = this._layers[geojson.id];
      var newLayer;

      if (this._visibleZoom() && layer && !this._map.hasLayer(layer) && (!this.options.timeField || this._featureWithinTimeRange(geojson))) {
        this._map.addLayer(layer);

        this.fire('addfeature', {
          feature: layer.feature
        }, true);
      } // update geometry if necessary


      if (layer && this.options.simplifyFactor > 0 && (layer.setLatLngs || layer.setLatLng)) {
        this._updateLayer(layer, geojson);
      }

      if (!layer) {
        newLayer = this.createNewLayer(geojson);

        if (!newLayer) {
          (0, _Util.warn)('invalid GeoJSON encountered');
        } else {
          newLayer.feature = geojson; // bubble events from individual layers to the feature layer

          newLayer.addEventParent(this);

          if (this.options.onEachFeature) {
            this.options.onEachFeature(newLayer.feature, newLayer);
          } // cache the layer


          this._layers[newLayer.feature.id] = newLayer; // style the layer

          this.setFeatureStyle(newLayer.feature.id, this.options.style);
          this.fire('createfeature', {
            feature: newLayer.feature
          }, true); // add the layer if the current zoom level is inside the range defined for the layer, it is within the current time bounds or our layer is not time enabled

          if (this._visibleZoom() && (!this.options.timeField || this.options.timeField && this._featureWithinTimeRange(geojson))) {
            this._map.addLayer(newLayer);
          }
        }
      }
    }
  },
  addLayers: function (ids) {
    for (var i = ids.length - 1; i >= 0; i--) {
      var layer = this._layers[ids[i]];

      if (layer && (!this.options.timeField || this._featureWithinTimeRange(layer.feature))) {
        this._map.addLayer(layer);
      }
    }
  },
  removeLayers: function (ids, permanent) {
    for (var i = ids.length - 1; i >= 0; i--) {
      var id = ids[i];
      var layer = this._layers[id];

      if (layer) {
        this.fire('removefeature', {
          feature: layer.feature,
          permanent: permanent
        }, true);

        this._map.removeLayer(layer);
      }

      if (layer && permanent) {
        delete this._layers[id];
      }
    }
  },
  cellEnter: function (bounds, coords) {
    if (this._visibleZoom() && !this._zooming && this._map) {
      _leaflet.Util.requestAnimFrame(_leaflet.Util.bind(function () {
        var cacheKey = this._cacheKey(coords);

        var cellKey = this._cellCoordsToKey(coords);

        var layers = this._cache[cacheKey];

        if (this._activeCells[cellKey] && layers) {
          this.addLayers(layers);
        }
      }, this));
    }
  },
  cellLeave: function (bounds, coords) {
    if (!this._zooming) {
      _leaflet.Util.requestAnimFrame(_leaflet.Util.bind(function () {
        if (this._map) {
          var cacheKey = this._cacheKey(coords);

          var cellKey = this._cellCoordsToKey(coords);

          var layers = this._cache[cacheKey];

          var mapBounds = this._map.getBounds();

          if (!this._activeCells[cellKey] && layers) {
            var removable = true;

            for (var i = 0; i < layers.length; i++) {
              var layer = this._layers[layers[i]];

              if (layer && layer.getBounds && mapBounds.intersects(layer.getBounds())) {
                removable = false;
              }
            }

            if (removable) {
              this.removeLayers(layers, !this.options.cacheLayers);
            }

            if (!this.options.cacheLayers && removable) {
              delete this._cache[cacheKey];
              delete this._cells[cellKey];
              delete this._activeCells[cellKey];
            }
          }
        }
      }, this));
    }
  },

  /**
   * Styling Methods
   */
  resetStyle: function () {
    this.options.style = this._originalStyle;
    this.eachFeature(function (layer) {
      this.resetFeatureStyle(layer.feature.id);
    }, this);
    return this;
  },
  setStyle: function (style) {
    this.options.style = style;
    this.eachFeature(function (layer) {
      this.setFeatureStyle(layer.feature.id, style);
    }, this);
    return this;
  },
  resetFeatureStyle: function (id) {
    var layer = this._layers[id];
    var style = this._originalStyle || _leaflet.Path.prototype.options;

    if (layer) {
      _leaflet.Util.extend(layer.options, layer.defaultOptions);

      this.setFeatureStyle(id, style);
    }

    return this;
  },
  setFeatureStyle: function (id, style) {
    var layer = this._layers[id];

    if (typeof style === 'function') {
      style = style(layer.feature);
    }

    if (layer.setStyle) {
      layer.setStyle(style);
    }

    return this;
  },

  /**
   * Utility Methods
   */
  eachActiveFeature: function (fn, context) {
    // figure out (roughly) which layers are in view
    if (this._map) {
      var activeBounds = this._map.getBounds();

      for (var i in this._layers) {
        if (this._currentSnapshot.indexOf(this._layers[i].feature.id) !== -1) {
          // a simple point in poly test for point geometries
          if (typeof this._layers[i].getLatLng === 'function' && activeBounds.contains(this._layers[i].getLatLng())) {
            fn.call(context, this._layers[i]);
          } else if (typeof this._layers[i].getBounds === 'function' && activeBounds.intersects(this._layers[i].getBounds())) {
            // intersecting bounds check for polyline and polygon geometries
            fn.call(context, this._layers[i]);
          }
        }
      }
    }

    return this;
  },
  eachFeature: function (fn, context) {
    for (var i in this._layers) {
      fn.call(context, this._layers[i]);
    }

    return this;
  },
  getFeature: function (id) {
    return this._layers[id];
  },
  bringToBack: function () {
    this.eachFeature(function (layer) {
      if (layer.bringToBack) {
        layer.bringToBack();
      }
    });
  },
  bringToFront: function () {
    this.eachFeature(function (layer) {
      if (layer.bringToFront) {
        layer.bringToFront();
      }
    });
  },
  redraw: function (id) {
    if (id) {
      this._redraw(id);
    }

    return this;
  },
  _redraw: function (id) {
    var layer = this._layers[id];
    var geojson = layer.feature; // if this looks like a marker

    if (layer && layer.setIcon && this.options.pointToLayer) {
      // update custom symbology, if necessary
      if (this.options.pointToLayer) {
        var getIcon = this.options.pointToLayer(geojson, (0, _leaflet.latLng)(geojson.geometry.coordinates[1], geojson.geometry.coordinates[0]));
        var updatedIcon = getIcon.options.icon;
        layer.setIcon(updatedIcon);
      }
    } // looks like a vector marker (circleMarker)


    if (layer && layer.setStyle && this.options.pointToLayer) {
      var getStyle = this.options.pointToLayer(geojson, (0, _leaflet.latLng)(geojson.geometry.coordinates[1], geojson.geometry.coordinates[0]));
      var updatedStyle = getStyle.options;
      this.setFeatureStyle(geojson.id, updatedStyle);
    } // looks like a path (polygon/polyline)


    if (layer && layer.setStyle && this.options.style) {
      this.resetStyle(geojson.id);
    }
  }
});

exports.FeatureLayer = FeatureLayer;

function featureLayer(options) {
  return new FeatureLayer(options);
}

var _default = featureLayer;
exports.default = _default;

},{"../../Util":27,"./FeatureManager":10,"leaflet":29}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FeatureManager = void 0;

var _leaflet = require("leaflet");

var _FeatureLayerService = _interopRequireDefault(require("../../Services/FeatureLayerService"));

var _Util = require("../../Util");

var _FeatureGrid = require("./FeatureGrid");

var _tinyBinarySearch = _interopRequireDefault(require("tiny-binary-search"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FeatureManager = _FeatureGrid.FeatureGrid.extend({
  /**
   * Options
   */
  options: {
    attribution: null,
    where: '1=1',
    fields: ['*'],
    from: false,
    to: false,
    timeField: false,
    timeFilterMode: 'server',
    simplifyFactor: 0,
    precision: 6,
    fetchAllFeatures: false
  },

  /**
   * Constructor
   */
  initialize: function (options) {
    _FeatureGrid.FeatureGrid.prototype.initialize.call(this, options);

    options = (0, _Util.getUrlParams)(options);
    options = _leaflet.Util.setOptions(this, options);
    this.service = (0, _FeatureLayerService.default)(options);
    this.service.addEventParent(this); // use case insensitive regex to look for common fieldnames used for indexing

    if (this.options.fields[0] !== '*') {
      var oidCheck = false;

      for (var i = 0; i < this.options.fields.length; i++) {
        if (this.options.fields[i].match(/^(OBJECTID|FID|OID|ID)$/i)) {
          oidCheck = true;
        }
      }

      if (oidCheck === false) {
        (0, _Util.warn)('no known esriFieldTypeOID field detected in fields Array.  Please add an attribute field containing unique IDs to ensure the layer can be drawn correctly.');
      }
    }

    if (this.options.timeField.start && this.options.timeField.end) {
      this._startTimeIndex = new _tinyBinarySearch.default();
      this._endTimeIndex = new _tinyBinarySearch.default();
    } else if (this.options.timeField) {
      this._timeIndex = new _tinyBinarySearch.default();
    }

    this._cache = {};
    this._currentSnapshot = []; // cache of what layers should be active

    this._activeRequests = 0;
  },

  /**
   * Layer Interface
   */
  onAdd: function (map) {
    // include 'Powered by Esri' in map attribution
    (0, _Util.setEsriAttribution)(map);
    this.service.metadata(function (err, metadata) {
      if (!err) {
        var supportedFormats = metadata.supportedQueryFormats; // Check if someone has requested that we don't use geoJSON, even if it's available

        var forceJsonFormat = false;

        if (this.service.options.isModern === false || this.options.fetchAllFeatures) {
          forceJsonFormat = true;
        } // Unless we've been told otherwise, check to see whether service can emit GeoJSON natively


        if (!forceJsonFormat && supportedFormats && supportedFormats.indexOf('geoJSON') !== -1) {
          this.service.options.isModern = true;
        }

        if (metadata.objectIdField) {
          this.service.options.idAttribute = metadata.objectIdField;
        } // add copyright text listed in service metadata


        if (!this.options.attribution && map.attributionControl && metadata.copyrightText) {
          this.options.attribution = metadata.copyrightText;
          map.attributionControl.addAttribution(this.getAttribution());
        }
      }
    }, this);
    map.on('zoomend', this._handleZoomChange, this);
    return _FeatureGrid.FeatureGrid.prototype.onAdd.call(this, map);
  },
  onRemove: function (map) {
    (0, _Util.removeEsriAttribution)(map);
    map.off('zoomend', this._handleZoomChange, this);
    return _FeatureGrid.FeatureGrid.prototype.onRemove.call(this, map);
  },
  getAttribution: function () {
    return this.options.attribution;
  },

  /**
   * Feature Management
   */
  createCell: function (bounds, coords) {
    // dont fetch features outside the scale range defined for the layer
    if (this._visibleZoom()) {
      this._requestFeatures(bounds, coords);
    }
  },
  _requestFeatures: function (bounds, coords, callback, offset) {
    this._activeRequests++; // default param

    offset = offset || 0;
    var originalWhere = this.options.where; // our first active request fires loading

    if (this._activeRequests === 1) {
      this.fire('loading', {
        bounds: bounds
      }, true);
    }

    return this._buildQuery(bounds, offset).run(function (error, featureCollection, response) {
      if (response && response.exceededTransferLimit) {
        this.fire('drawlimitexceeded');
      } // the where changed while this request was being run so don't it.


      if (this.options.where !== originalWhere) {
        return;
      } // no error, features


      if (!error && featureCollection && featureCollection.features.length) {
        // schedule adding features until the next animation frame
        _leaflet.Util.requestAnimFrame(_leaflet.Util.bind(function () {
          this._addFeatures(featureCollection.features, coords);

          this._postProcessFeatures(bounds);
        }, this));
      } // no error, no features


      if (!error && featureCollection && !featureCollection.features.length) {
        this._postProcessFeatures(bounds);
      }

      if (error) {
        this._postProcessFeatures(bounds);
      }

      if (callback) {
        callback.call(this, error, featureCollection);
      }

      if (response && (response.exceededTransferLimit || response.properties && response.properties.exceededTransferLimit) && this.options.fetchAllFeatures) {
        this._requestFeatures(bounds, coords, callback, offset + featureCollection.features.length);
      }
    }, this);
  },
  _postProcessFeatures: function (bounds) {
    // deincrement the request counter now that we have processed features
    this._activeRequests--; // if there are no more active requests fire a load event for this view

    if (this._activeRequests <= 0) {
      this.fire('load', {
        bounds: bounds
      });
    }
  },
  _cacheKey: function (coords) {
    return coords.z + ':' + coords.x + ':' + coords.y;
  },
  _addFeatures: function (features, coords) {
    // coords is optional - will be false if coming from addFeatures() function
    if (coords) {
      var key = this._cacheKey(coords);

      this._cache[key] = this._cache[key] || [];
    }

    for (var i = features.length - 1; i >= 0; i--) {
      var id = features[i].id;

      if (this._currentSnapshot.indexOf(id) === -1) {
        this._currentSnapshot.push(id);
      }

      if (typeof key !== 'undefined' && this._cache[key].indexOf(id) === -1) {
        this._cache[key].push(id);
      }
    }

    if (this.options.timeField) {
      this._buildTimeIndexes(features);
    }

    this.createLayers(features);
  },
  _buildQuery: function (bounds, offset) {
    var query = this.service.query().intersects(bounds).where(this.options.where).fields(this.options.fields).precision(this.options.precision);

    if (this.options.fetchAllFeatures && !isNaN(parseInt(offset))) {
      query = query.offset(offset);
    }

    query.params['resultType'] = 'tile';

    if (this.options.requestParams) {
      _leaflet.Util.extend(query.params, this.options.requestParams);
    }

    if (this.options.simplifyFactor) {
      query.simplify(this._map, this.options.simplifyFactor);
    }

    if (this.options.timeFilterMode === 'server' && this.options.from && this.options.to) {
      query.between(this.options.from, this.options.to);
    }

    return query;
  },

  /**
   * Where Methods
   */
  setWhere: function (where, callback, context) {
    this.options.where = where && where.length ? where : '1=1';
    var oldSnapshot = [];
    var newSnapshot = [];
    var pendingRequests = 0;
    var requestError = null;

    var requestCallback = _leaflet.Util.bind(function (error, featureCollection) {
      if (error) {
        requestError = error;
      }

      if (featureCollection) {
        for (var i = featureCollection.features.length - 1; i >= 0; i--) {
          newSnapshot.push(featureCollection.features[i].id);
        }
      }

      pendingRequests--;

      if (pendingRequests <= 0 && this._visibleZoom() && where === this.options.where // the where is still the same so use this one
      ) {
          this._currentSnapshot = newSnapshot; // schedule adding features for the next animation frame

          _leaflet.Util.requestAnimFrame(_leaflet.Util.bind(function () {
            this.removeLayers(oldSnapshot);
            this.addLayers(newSnapshot);

            if (callback) {
              callback.call(context, requestError);
            }
          }, this));
        }
    }, this);

    for (var i = this._currentSnapshot.length - 1; i >= 0; i--) {
      oldSnapshot.push(this._currentSnapshot[i]);
    }

    this._cache = {};

    for (var key in this._cells) {
      pendingRequests++;

      var coords = this._keyToCellCoords(key);

      var bounds = this._cellCoordsToBounds(coords);

      this._requestFeatures(bounds, coords, requestCallback);
    }

    return this;
  },
  getWhere: function () {
    return this.options.where;
  },

  /**
   * Time Range Methods
   */
  getTimeRange: function () {
    return [this.options.from, this.options.to];
  },
  setTimeRange: function (from, to, callback, context) {
    var oldFrom = this.options.from;
    var oldTo = this.options.to;
    var pendingRequests = 0;
    var requestError = null;

    var requestCallback = _leaflet.Util.bind(function (error) {
      if (error) {
        requestError = error;
      }

      this._filterExistingFeatures(oldFrom, oldTo, from, to);

      pendingRequests--;

      if (callback && pendingRequests <= 0) {
        callback.call(context, requestError);
      }
    }, this);

    this.options.from = from;
    this.options.to = to;

    this._filterExistingFeatures(oldFrom, oldTo, from, to);

    if (this.options.timeFilterMode === 'server') {
      for (var key in this._cells) {
        pendingRequests++;

        var coords = this._keyToCellCoords(key);

        var bounds = this._cellCoordsToBounds(coords);

        this._requestFeatures(bounds, coords, requestCallback);
      }
    }

    return this;
  },
  refresh: function () {
    this.setWhere(this.options.where);
  },
  _filterExistingFeatures: function (oldFrom, oldTo, newFrom, newTo) {
    var layersToRemove = oldFrom && oldTo ? this._getFeaturesInTimeRange(oldFrom, oldTo) : this._currentSnapshot;

    var layersToAdd = this._getFeaturesInTimeRange(newFrom, newTo);

    if (layersToAdd.indexOf) {
      for (var i = 0; i < layersToAdd.length; i++) {
        var shouldRemoveLayer = layersToRemove.indexOf(layersToAdd[i]);

        if (shouldRemoveLayer >= 0) {
          layersToRemove.splice(shouldRemoveLayer, 1);
        }
      }
    } // schedule adding features until the next animation frame


    _leaflet.Util.requestAnimFrame(_leaflet.Util.bind(function () {
      this.removeLayers(layersToRemove);
      this.addLayers(layersToAdd);
    }, this));
  },
  _getFeaturesInTimeRange: function (start, end) {
    var ids = [];
    var search;

    if (this.options.timeField.start && this.options.timeField.end) {
      var startTimes = this._startTimeIndex.between(start, end);

      var endTimes = this._endTimeIndex.between(start, end);

      search = startTimes.concat(endTimes);
    } else if (this._timeIndex) {
      search = this._timeIndex.between(start, end);
    } else {
      (0, _Util.warn)('You must set timeField in the layer constructor in order to manipulate the start and end time filter.');
      return [];
    }

    for (var i = search.length - 1; i >= 0; i--) {
      ids.push(search[i].id);
    }

    return ids;
  },
  _buildTimeIndexes: function (geojson) {
    var i;
    var feature;

    if (this.options.timeField.start && this.options.timeField.end) {
      var startTimeEntries = [];
      var endTimeEntries = [];

      for (i = geojson.length - 1; i >= 0; i--) {
        feature = geojson[i];
        startTimeEntries.push({
          id: feature.id,
          value: new Date(feature.properties[this.options.timeField.start])
        });
        endTimeEntries.push({
          id: feature.id,
          value: new Date(feature.properties[this.options.timeField.end])
        });
      }

      this._startTimeIndex.bulkAdd(startTimeEntries);

      this._endTimeIndex.bulkAdd(endTimeEntries);
    } else {
      var timeEntries = [];

      for (i = geojson.length - 1; i >= 0; i--) {
        feature = geojson[i];
        timeEntries.push({
          id: feature.id,
          value: new Date(feature.properties[this.options.timeField])
        });
      }

      this._timeIndex.bulkAdd(timeEntries);
    }
  },
  _featureWithinTimeRange: function (feature) {
    if (!this.options.from || !this.options.to) {
      return true;
    }

    var from = +this.options.from.valueOf();
    var to = +this.options.to.valueOf();

    if (typeof this.options.timeField === 'string') {
      var date = +feature.properties[this.options.timeField];
      return date >= from && date <= to;
    }

    if (this.options.timeField.start && this.options.timeField.end) {
      var startDate = +feature.properties[this.options.timeField.start];
      var endDate = +feature.properties[this.options.timeField.end];
      return startDate >= from && startDate <= to || endDate >= from && endDate <= to || startDate <= from && endDate >= to;
    }
  },
  _visibleZoom: function () {
    // check to see whether the current zoom level of the map is within the optional limit defined for the FeatureLayer
    if (!this._map) {
      return false;
    }

    var zoom = this._map.getZoom();

    if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
      return false;
    } else {
      return true;
    }
  },
  _handleZoomChange: function () {
    if (!this._visibleZoom()) {
      this.removeLayers(this._currentSnapshot);
    } else {
      /*
      for every cell in this._cells
        1. Get the cache key for the coords of the cell
        2. If this._cache[key] exists it will be an array of feature IDs.
        3. Call this.addLayers(this._cache[key]) to instruct the feature layer to add the layers back.
      */
      for (var i in this._cells) {
        var coords = this._cells[i].coords;

        var key = this._cacheKey(coords);

        if (this._cache[key]) {
          this.addLayers(this._cache[key]);
        }
      }
    }
  },

  /**
   * Service Methods
   */
  authenticate: function (token) {
    this.service.authenticate(token);
    return this;
  },
  metadata: function (callback, context) {
    this.service.metadata(callback, context);
    return this;
  },
  query: function () {
    return this.service.query();
  },
  _getMetadata: function (callback) {
    if (this._metadata) {
      var error;
      callback(error, this._metadata);
    } else {
      this.metadata(_leaflet.Util.bind(function (error, response) {
        this._metadata = response;
        callback(error, this._metadata);
      }, this));
    }
  },
  addFeature: function (feature, callback, context) {
    this.addFeatures(feature, callback, context);
  },
  addFeatures: function (features, callback, context) {
    this._getMetadata(_leaflet.Util.bind(function (error, metadata) {
      if (error) {
        if (callback) {
          callback.call(this, error, null);
        }

        return;
      } // GeoJSON featureCollection or simple feature


      var featuresArray = features.features ? features.features : [features];
      this.service.addFeatures(features, _leaflet.Util.bind(function (error, response) {
        if (!error) {
          for (var i = featuresArray.length - 1; i >= 0; i--) {
            // assign ID from result to appropriate objectid field from service metadata
            featuresArray[i].properties[metadata.objectIdField] = featuresArray.length > 1 ? response[i].objectId : response.objectId; // we also need to update the geojson id for createLayers() to function

            featuresArray[i].id = featuresArray.length > 1 ? response[i].objectId : response.objectId;
          }

          this._addFeatures(featuresArray);
        }

        if (callback) {
          callback.call(context, error, response);
        }
      }, this));
    }, this));
  },
  updateFeature: function (feature, callback, context) {
    this.updateFeatures(feature, callback, context);
  },
  updateFeatures: function (features, callback, context) {
    // GeoJSON featureCollection or simple feature
    var featuresArray = features.features ? features.features : [features];
    this.service.updateFeatures(features, function (error, response) {
      if (!error) {
        for (var i = featuresArray.length - 1; i >= 0; i--) {
          this.removeLayers([featuresArray[i].id], true);
        }

        this._addFeatures(featuresArray);
      }

      if (callback) {
        callback.call(context, error, response);
      }
    }, this);
  },
  deleteFeature: function (id, callback, context) {
    this.deleteFeatures(id, callback, context);
  },
  deleteFeatures: function (ids, callback, context) {
    return this.service.deleteFeatures(ids, function (error, response) {
      var responseArray = response.length ? response : [response];

      if (!error && responseArray.length > 0) {
        for (var i = responseArray.length - 1; i >= 0; i--) {
          this.removeLayers([responseArray[i].objectId], true);
        }
      }

      if (callback) {
        callback.call(context, error, response);
      }
    }, this);
  }
});

exports.FeatureManager = FeatureManager;

},{"../../Services/FeatureLayerService":16,"../../Util":27,"./FeatureGrid":8,"leaflet":29,"tiny-binary-search":31}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.imageMapLayer = imageMapLayer;
exports.default = exports.ImageMapLayer = void 0;

var _leaflet = require("leaflet");

var _RasterLayer = require("./RasterLayer");

var _Util = require("../Util");

var _ImageService = _interopRequireDefault(require("../Services/ImageService"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ImageMapLayer = _RasterLayer.RasterLayer.extend({
  options: {
    updateInterval: 150,
    format: 'jpgpng',
    transparent: true,
    f: 'image'
  },
  query: function () {
    return this.service.query();
  },
  identify: function () {
    return this.service.identify();
  },
  initialize: function (options) {
    options = (0, _Util.getUrlParams)(options);
    this.service = (0, _ImageService.default)(options);
    this.service.addEventParent(this);

    _leaflet.Util.setOptions(this, options);
  },
  setPixelType: function (pixelType) {
    this.options.pixelType = pixelType;

    this._update();

    return this;
  },
  getPixelType: function () {
    return this.options.pixelType;
  },
  setBandIds: function (bandIds) {
    if (_leaflet.Util.isArray(bandIds)) {
      this.options.bandIds = bandIds.join(',');
    } else {
      this.options.bandIds = bandIds.toString();
    }

    this._update();

    return this;
  },
  getBandIds: function () {
    return this.options.bandIds;
  },
  setNoData: function (noData, noDataInterpretation) {
    if (_leaflet.Util.isArray(noData)) {
      this.options.noData = noData.join(',');
    } else {
      this.options.noData = noData.toString();
    }

    if (noDataInterpretation) {
      this.options.noDataInterpretation = noDataInterpretation;
    }

    this._update();

    return this;
  },
  getNoData: function () {
    return this.options.noData;
  },
  getNoDataInterpretation: function () {
    return this.options.noDataInterpretation;
  },
  setRenderingRule: function (renderingRule) {
    this.options.renderingRule = renderingRule;

    this._update();
  },
  getRenderingRule: function () {
    return this.options.renderingRule;
  },
  setMosaicRule: function (mosaicRule) {
    this.options.mosaicRule = mosaicRule;

    this._update();
  },
  getMosaicRule: function () {
    return this.options.mosaicRule;
  },
  _getPopupData: function (e) {
    var callback = _leaflet.Util.bind(function (error, results, response) {
      if (error) {
        return;
      } // we really can't do anything here but authenticate or requesterror will fire


      setTimeout(_leaflet.Util.bind(function () {
        this._renderPopup(e.latlng, error, results, response);
      }, this), 300);
    }, this);

    var identifyRequest = this.identify().at(e.latlng); // set mosaic rule for identify task if it is set for layer

    if (this.options.mosaicRule) {
      identifyRequest.setMosaicRule(this.options.mosaicRule); // @TODO: force return catalog items too?
    } // @TODO: set rendering rule? Not sure,
    // sometimes you want raw pixel values
    // if (this.options.renderingRule) {
    //   identifyRequest.setRenderingRule(this.options.renderingRule);
    // }


    identifyRequest.run(callback); // set the flags to show the popup

    this._shouldRenderPopup = true;
    this._lastClick = e.latlng;
  },
  _buildExportParams: function () {
    var sr = parseInt(this._map.options.crs.code.split(':')[1], 10);
    var params = {
      bbox: this._calculateBbox(),
      size: this._calculateImageSize(),
      format: this.options.format,
      transparent: this.options.transparent,
      bboxSR: sr,
      imageSR: sr
    };

    if (this.options.from && this.options.to) {
      params.time = this.options.from.valueOf() + ',' + this.options.to.valueOf();
    }

    if (this.options.pixelType) {
      params.pixelType = this.options.pixelType;
    }

    if (this.options.interpolation) {
      params.interpolation = this.options.interpolation;
    }

    if (this.options.compressionQuality) {
      params.compressionQuality = this.options.compressionQuality;
    }

    if (this.options.bandIds) {
      params.bandIds = this.options.bandIds;
    } // 0 is falsy *and* a valid input parameter


    if (this.options.noData === 0 || this.options.noData) {
      params.noData = this.options.noData;
    }

    if (this.options.noDataInterpretation) {
      params.noDataInterpretation = this.options.noDataInterpretation;
    }

    if (this.service.options.token) {
      params.token = this.service.options.token;
    }

    if (this.options.renderingRule) {
      params.renderingRule = JSON.stringify(this.options.renderingRule);
    }

    if (this.options.mosaicRule) {
      params.mosaicRule = JSON.stringify(this.options.mosaicRule);
    }

    return params;
  },
  _requestExport: function (params, bounds) {
    if (this.options.f === 'json') {
      this.service.request('exportImage', params, function (error, response) {
        if (error) {
          return;
        } // we really can't do anything here but authenticate or requesterror will fire


        if (this.options.token) {
          response.href += '?token=' + this.options.token;
        }

        if (this.options.proxy) {
          response.href = this.options.proxy + '?' + response.href;
        }

        this._renderImage(response.href, bounds);
      }, this);
    } else {
      params.f = 'image';

      var fullUrl = this.options.url + 'exportImage' + _leaflet.Util.getParamString(params);

      if (this.options.proxy) {
        fullUrl = this.options.proxy + '?' + fullUrl;
      }

      this._renderImage(fullUrl, bounds);
    }
  }
});

exports.ImageMapLayer = ImageMapLayer;

function imageMapLayer(url, options) {
  return new ImageMapLayer(url, options);
}

var _default = imageMapLayer;
exports.default = _default;

},{"../Services/ImageService":17,"../Util":27,"./RasterLayer":12,"leaflet":29}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RasterLayer = void 0;

var _leaflet = require("leaflet");

var _Support = require("../Support");

var _Util = require("../Util");

var Overlay = _leaflet.ImageOverlay.extend({
  onAdd: function (map) {
    this._topLeft = map.getPixelBounds().min;

    _leaflet.ImageOverlay.prototype.onAdd.call(this, map);
  },
  _reset: function () {
    if (this._map.options.crs === _leaflet.CRS.EPSG3857) {
      _leaflet.ImageOverlay.prototype._reset.call(this);
    } else {
      _leaflet.DomUtil.setPosition(this._image, this._topLeft.subtract(this._map.getPixelOrigin()));
    }
  }
});

var RasterLayer = _leaflet.Layer.extend({
  options: {
    opacity: 1,
    position: 'front',
    f: 'image',
    useCors: _Support.cors,
    attribution: null,
    interactive: false,
    alt: ''
  },
  onAdd: function (map) {
    // include 'Powered by Esri' in map attribution
    (0, _Util.setEsriAttribution)(map);

    if (this.options.zIndex) {
      this.options.position = null;
    }

    this._update = _leaflet.Util.throttle(this._update, this.options.updateInterval, this);
    map.on('moveend', this._update, this); // if we had an image loaded and it matches the
    // current bounds show the image otherwise remove it

    if (this._currentImage && this._currentImage._bounds.equals(this._map.getBounds())) {
      map.addLayer(this._currentImage);
    } else if (this._currentImage) {
      this._map.removeLayer(this._currentImage);

      this._currentImage = null;
    }

    this._update();

    if (this._popup) {
      this._map.on('click', this._getPopupData, this);

      this._map.on('dblclick', this._resetPopupState, this);
    } // add copyright text listed in service metadata


    this.metadata(function (err, metadata) {
      if (!err && !this.options.attribution && map.attributionControl && metadata.copyrightText) {
        this.options.attribution = metadata.copyrightText;
        map.attributionControl.addAttribution(this.getAttribution());
      }
    }, this);
  },
  onRemove: function (map) {
    (0, _Util.removeEsriAttribution)(map);

    if (this._currentImage) {
      this._map.removeLayer(this._currentImage);
    }

    if (this._popup) {
      this._map.off('click', this._getPopupData, this);

      this._map.off('dblclick', this._resetPopupState, this);
    }

    this._map.off('moveend', this._update, this);
  },
  bindPopup: function (fn, popupOptions) {
    this._shouldRenderPopup = false;
    this._lastClick = false;
    this._popup = (0, _leaflet.popup)(popupOptions);
    this._popupFunction = fn;

    if (this._map) {
      this._map.on('click', this._getPopupData, this);

      this._map.on('dblclick', this._resetPopupState, this);
    }

    return this;
  },
  unbindPopup: function () {
    if (this._map) {
      this._map.closePopup(this._popup);

      this._map.off('click', this._getPopupData, this);

      this._map.off('dblclick', this._resetPopupState, this);
    }

    this._popup = false;
    return this;
  },
  bringToFront: function () {
    this.options.position = 'front';

    if (this._currentImage) {
      this._currentImage.bringToFront();

      this._setAutoZIndex(Math.max);
    }

    return this;
  },
  bringToBack: function () {
    this.options.position = 'back';

    if (this._currentImage) {
      this._currentImage.bringToBack();

      this._setAutoZIndex(Math.min);
    }

    return this;
  },
  setZIndex: function (value) {
    this.options.zIndex = value;

    if (this._currentImage) {
      this._currentImage.setZIndex(value);
    }

    return this;
  },
  _setAutoZIndex: function (compare) {
    // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)
    if (!this._currentImage) {
      return;
    }

    var layers = this._currentImage.getPane().children;

    var edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

    for (var i = 0, len = layers.length, zIndex; i < len; i++) {
      zIndex = layers[i].style.zIndex;

      if (layers[i] !== this._currentImage._image && zIndex) {
        edgeZIndex = compare(edgeZIndex, +zIndex);
      }
    }

    if (isFinite(edgeZIndex)) {
      this.options.zIndex = edgeZIndex + compare(-1, 1);
      this.setZIndex(this.options.zIndex);
    }
  },
  getAttribution: function () {
    return this.options.attribution;
  },
  getOpacity: function () {
    return this.options.opacity;
  },
  setOpacity: function (opacity) {
    this.options.opacity = opacity;

    if (this._currentImage) {
      this._currentImage.setOpacity(opacity);
    }

    return this;
  },
  getTimeRange: function () {
    return [this.options.from, this.options.to];
  },
  setTimeRange: function (from, to) {
    this.options.from = from;
    this.options.to = to;

    this._update();

    return this;
  },
  metadata: function (callback, context) {
    this.service.metadata(callback, context);
    return this;
  },
  authenticate: function (token) {
    this.service.authenticate(token);
    return this;
  },
  redraw: function () {
    this._update();
  },
  _renderImage: function (url, bounds, contentType) {
    if (this._map) {
      // if no output directory has been specified for a service, MIME data will be returned
      if (contentType) {
        url = 'data:' + contentType + ';base64,' + url;
      } // if server returns an inappropriate response, abort.


      if (!url) return; // create a new image overlay and add it to the map
      // to start loading the image
      // opacity is 0 while the image is loading

      var image = new Overlay(url, bounds, {
        opacity: 0,
        crossOrigin: this.options.withCredentials ? 'use-credentials' : this.options.useCors,
        alt: this.options.alt,
        pane: this.options.pane || this.getPane(),
        interactive: this.options.interactive
      }).addTo(this._map);

      var onOverlayError = function () {
        this._map.removeLayer(image);

        this.fire('error');
        image.off('load', onOverlayLoad, this);
      };

      var onOverlayLoad = function (e) {
        image.off('error', onOverlayLoad, this);

        if (this._map) {
          var newImage = e.target;
          var oldImage = this._currentImage; // if the bounds of this image matches the bounds that
          // _renderImage was called with and we have a map with the same bounds
          // hide the old image if there is one and set the opacity
          // of the new image otherwise remove the new image

          if (newImage._bounds.equals(bounds) && newImage._bounds.equals(this._map.getBounds())) {
            this._currentImage = newImage;

            if (this.options.position === 'front') {
              this.bringToFront();
            } else if (this.options.position === 'back') {
              this.bringToBack();
            }

            if (this.options.zIndex) {
              this.setZIndex(this.options.zIndex);
            }

            if (this._map && this._currentImage._map) {
              this._currentImage.setOpacity(this.options.opacity);
            } else {
              this._currentImage._map.removeLayer(this._currentImage);
            }

            if (oldImage && this._map) {
              this._map.removeLayer(oldImage);
            }

            if (oldImage && oldImage._map) {
              oldImage._map.removeLayer(oldImage);
            }
          } else {
            this._map.removeLayer(newImage);
          }
        }

        this.fire('load', {
          bounds: bounds
        });
      }; // If loading the image fails


      image.once('error', onOverlayError, this); // once the image loads

      image.once('load', onOverlayLoad, this);
    }
  },
  _update: function () {
    if (!this._map) {
      return;
    }

    var zoom = this._map.getZoom();

    var bounds = this._map.getBounds();

    if (this._animatingZoom) {
      return;
    }

    if (this._map._panTransition && this._map._panTransition._inProgress) {
      return;
    }

    if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
      if (this._currentImage) {
        this._currentImage._map.removeLayer(this._currentImage);

        this._currentImage = null;
      }

      return;
    }

    var params = this._buildExportParams();

    _leaflet.Util.extend(params, this.options.requestParams);

    if (params) {
      this._requestExport(params, bounds);

      this.fire('loading', {
        bounds: bounds
      });
    } else if (this._currentImage) {
      this._currentImage._map.removeLayer(this._currentImage);

      this._currentImage = null;
    }
  },
  _renderPopup: function (latlng, error, results, response) {
    latlng = (0, _leaflet.latLng)(latlng);

    if (this._shouldRenderPopup && this._lastClick.equals(latlng)) {
      // add the popup to the map where the mouse was clicked at
      var content = this._popupFunction(error, results, response);

      if (content) {
        this._popup.setLatLng(latlng).setContent(content).openOn(this._map);
      }
    }
  },
  _resetPopupState: function (e) {
    this._shouldRenderPopup = false;
    this._lastClick = e.latlng;
  },
  _calculateBbox: function () {
    var pixelBounds = this._map.getPixelBounds();

    var sw = this._map.unproject(pixelBounds.getBottomLeft());

    var ne = this._map.unproject(pixelBounds.getTopRight());

    var neProjected = this._map.options.crs.project(ne);

    var swProjected = this._map.options.crs.project(sw); // this ensures ne/sw are switched in polar maps where north/top bottom/south is inverted


    var boundsProjected = (0, _leaflet.bounds)(neProjected, swProjected);
    return [boundsProjected.getBottomLeft().x, boundsProjected.getBottomLeft().y, boundsProjected.getTopRight().x, boundsProjected.getTopRight().y].join(',');
  },
  _calculateImageSize: function () {
    // ensure that we don't ask ArcGIS Server for a taller image than we have actual map displaying within the div
    var bounds = this._map.getPixelBounds();

    var size = this._map.getSize();

    var sw = this._map.unproject(bounds.getBottomLeft());

    var ne = this._map.unproject(bounds.getTopRight());

    var top = this._map.latLngToLayerPoint(ne).y;

    var bottom = this._map.latLngToLayerPoint(sw).y;

    if (top > 0 || bottom < size.y) {
      size.y = bottom - top;
    }

    return size.x + ',' + size.y;
  }
});

exports.RasterLayer = RasterLayer;

},{"../Support":20,"../Util":27,"leaflet":29}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tiledMapLayer = tiledMapLayer;
exports.default = exports.TiledMapLayer = void 0;

var _leaflet = require("leaflet");

var _Util = require("../Util");

var _MapService = _interopRequireDefault(require("../Services/MapService"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TiledMapLayer = _leaflet.TileLayer.extend({
  options: {
    zoomOffsetAllowance: 0.1,
    errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEABAMAAACuXLVVAAAAA1BMVEUzNDVszlHHAAAAAXRSTlMAQObYZgAAAAlwSFlzAAAAAAAAAAAB6mUWpAAAADZJREFUeJztwQEBAAAAgiD/r25IQAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7waBAAABw08RwAAAAABJRU5ErkJggg=='
  },
  statics: {
    MercatorZoomLevels: {
      '0': 156543.03392799999,
      '1': 78271.516963999893,
      '2': 39135.758482000099,
      '3': 19567.879240999901,
      '4': 9783.9396204999593,
      '5': 4891.9698102499797,
      '6': 2445.9849051249898,
      '7': 1222.9924525624899,
      '8': 611.49622628138002,
      '9': 305.74811314055802,
      '10': 152.874056570411,
      '11': 76.437028285073197,
      '12': 38.218514142536598,
      '13': 19.109257071268299,
      '14': 9.5546285356341496,
      '15': 4.7773142679493699,
      '16': 2.38865713397468,
      '17': 1.1943285668550501,
      '18': 0.59716428355981699,
      '19': 0.29858214164761698,
      '20': 0.14929107082381,
      '21': 0.07464553541191,
      '22': 0.0373227677059525,
      '23': 0.0186613838529763
    }
  },
  initialize: function (options) {
    options = _leaflet.Util.setOptions(this, options); // set the urls

    options = (0, _Util.getUrlParams)(options);
    this.tileUrl = (options.proxy ? options.proxy + '?' : '') + options.url + 'tile/{z}/{y}/{x}' + (options.requestParams && Object.keys(options.requestParams).length > 0 ? _leaflet.Util.getParamString(options.requestParams) : ''); // Remove subdomain in url
    // https://github.com/Esri/esri-leaflet/issues/991

    if (options.url.indexOf('{s}') !== -1 && options.subdomains) {
      options.url = options.url.replace('{s}', options.subdomains[0]);
    }

    this.service = (0, _MapService.default)(options);
    this.service.addEventParent(this);
    var arcgisonline = new RegExp(/tiles.arcgis(online)?\.com/g);

    if (arcgisonline.test(options.url)) {
      this.tileUrl = this.tileUrl.replace('://tiles', '://tiles{s}');
      options.subdomains = ['1', '2', '3', '4'];
    }

    if (this.options.token) {
      this.tileUrl += '?token=' + this.options.token;
    } // init layer by calling TileLayers initialize method


    _leaflet.TileLayer.prototype.initialize.call(this, this.tileUrl, options);
  },
  getTileUrl: function (tilePoint) {
    var zoom = this._getZoomForUrl();

    return _leaflet.Util.template(this.tileUrl, _leaflet.Util.extend({
      s: this._getSubdomain(tilePoint),
      x: tilePoint.x,
      y: tilePoint.y,
      // try lod map first, then just default to zoom level
      z: this._lodMap && this._lodMap[zoom] ? this._lodMap[zoom] : zoom
    }, this.options));
  },
  createTile: function (coords, done) {
    var tile = document.createElement('img');

    _leaflet.DomEvent.on(tile, 'load', _leaflet.Util.bind(this._tileOnLoad, this, done, tile));

    _leaflet.DomEvent.on(tile, 'error', _leaflet.Util.bind(this._tileOnError, this, done, tile));

    if (this.options.crossOrigin) {
      tile.crossOrigin = '';
    }
    /*
     Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
     http://www.w3.org/TR/WCAG20-TECHS/H67
    */


    tile.alt = ''; // if there is no lod map or an lod map with a proper zoom load the tile
    // otherwise wait for the lod map to become available

    if (!this._lodMap || this._lodMap && this._lodMap[this._getZoomForUrl()]) {
      tile.src = this.getTileUrl(coords);
    } else {
      this.once('lodmap', function () {
        tile.src = this.getTileUrl(coords);
      }, this);
    }

    return tile;
  },
  onAdd: function (map) {
    // include 'Powered by Esri' in map attribution
    (0, _Util.setEsriAttribution)(map);

    if (!this._lodMap) {
      this.metadata(function (error, metadata) {
        if (!error && metadata.spatialReference) {
          var sr = metadata.spatialReference.latestWkid || metadata.spatialReference.wkid; // display the copyright text from the service using leaflet's attribution control

          if (!this.options.attribution && map.attributionControl && metadata.copyrightText) {
            this.options.attribution = metadata.copyrightText;
            map.attributionControl.addAttribution(this.getAttribution());
          } // if the service tiles were published in web mercator using conventional LODs but missing levels, we can try and remap them


          if (map.options.crs === _leaflet.CRS.EPSG3857 && (sr === 102100 || sr === 3857)) {
            this._lodMap = {}; // create the zoom level data

            var arcgisLODs = metadata.tileInfo.lods;
            var correctResolutions = TiledMapLayer.MercatorZoomLevels;

            for (var i = 0; i < arcgisLODs.length; i++) {
              var arcgisLOD = arcgisLODs[i];

              for (var ci in correctResolutions) {
                var correctRes = correctResolutions[ci];

                if (this._withinPercentage(arcgisLOD.resolution, correctRes, this.options.zoomOffsetAllowance)) {
                  this._lodMap[ci] = arcgisLOD.level;
                  break;
                }
              }
            }

            this.fire('lodmap');
          } else if (map.options.crs && map.options.crs.code && map.options.crs.code.indexOf(sr) > -1) {// if the projection is WGS84, or the developer is using Proj4 to define a custom CRS, no action is required
          } else {
            // if the service was cached in a custom projection and an appropriate LOD hasn't been defined in the map, guide the developer to our Proj4 sample
            (0, _Util.warn)('L.esri.TiledMapLayer is using a non-mercator spatial reference. Support may be available through Proj4Leaflet http://esri.github.io/esri-leaflet/examples/non-mercator-projection.html');
          }
        }
      }, this);
    }

    _leaflet.TileLayer.prototype.onAdd.call(this, map);
  },
  onRemove: function (map) {
    (0, _Util.removeEsriAttribution)(map);

    _leaflet.TileLayer.prototype.onRemove.call(this, map);
  },
  metadata: function (callback, context) {
    this.service.metadata(callback, context);
    return this;
  },
  identify: function () {
    return this.service.identify();
  },
  find: function () {
    return this.service.find();
  },
  query: function () {
    return this.service.query();
  },
  authenticate: function (token) {
    var tokenQs = '?token=' + token;
    this.tileUrl = this.options.token ? this.tileUrl.replace(/\?token=(.+)/g, tokenQs) : this.tileUrl + tokenQs;
    this.options.token = token;
    this.service.authenticate(token);
    return this;
  },
  _withinPercentage: function (a, b, percentage) {
    var diff = Math.abs(a / b - 1);
    return diff < percentage;
  }
});

exports.TiledMapLayer = TiledMapLayer;

function tiledMapLayer(url, options) {
  return new TiledMapLayer(url, options);
}

var _default = tiledMapLayer;
exports.default = _default;

},{"../Services/MapService":18,"../Util":27,"leaflet":29}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.options = void 0;
var options = {
  attributionWidthOffset: 55
};
exports.options = options;
var _default = options;
exports.default = _default;

},{}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.request = request;
exports.jsonp = jsonp;
exports.warn = warn;
exports.post = xmlHttpPost;
exports.default = exports.Request = exports.get = void 0;

var _leaflet = require("leaflet");

var _Support = require("./Support");

var callbacks = 0;

function serialize(params) {
  var data = '';
  params.f = params.f || 'json';

  for (var key in params) {
    if (params.hasOwnProperty(key)) {
      var param = params[key];
      var type = Object.prototype.toString.call(param);
      var value;

      if (data.length) {
        data += '&';
      }

      if (type === '[object Array]') {
        value = Object.prototype.toString.call(param[0]) === '[object Object]' ? JSON.stringify(param) : param.join(',');
      } else if (type === '[object Object]') {
        value = JSON.stringify(param);
      } else if (type === '[object Date]') {
        value = param.valueOf();
      } else {
        value = param;
      }

      data += encodeURIComponent(key) + '=' + encodeURIComponent(value);
    }
  }

  return data;
}

function createRequest(callback, context) {
  var httpRequest = new window.XMLHttpRequest();

  httpRequest.onerror = function (e) {
    httpRequest.onreadystatechange = _leaflet.Util.falseFn;
    callback.call(context, {
      error: {
        code: 500,
        message: 'XMLHttpRequest error'
      }
    }, null);
  };

  httpRequest.onreadystatechange = function () {
    var response;
    var error;

    if (httpRequest.readyState === 4) {
      try {
        response = JSON.parse(httpRequest.responseText);
      } catch (e) {
        response = null;
        error = {
          code: 500,
          message: 'Could not parse response as JSON. This could also be caused by a CORS or XMLHttpRequest error.'
        };
      }

      if (!error && response.error) {
        error = response.error;
        response = null;
      }

      httpRequest.onerror = _leaflet.Util.falseFn;
      callback.call(context, error, response);
    }
  };

  httpRequest.ontimeout = function () {
    this.onerror();
  };

  return httpRequest;
}

function xmlHttpPost(url, params, callback, context) {
  var httpRequest = createRequest(callback, context);
  httpRequest.open('POST', url);

  if (typeof context !== 'undefined' && context !== null) {
    if (typeof context.options !== 'undefined') {
      httpRequest.timeout = context.options.timeout;
    }
  }

  httpRequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
  httpRequest.send(serialize(params));
  return httpRequest;
}

function xmlHttpGet(url, params, callback, context) {
  var httpRequest = createRequest(callback, context);
  httpRequest.open('GET', url + '?' + serialize(params), true);

  if (typeof context !== 'undefined' && context !== null) {
    if (typeof context.options !== 'undefined') {
      httpRequest.timeout = context.options.timeout;

      if (context.options.withCredentials) {
        httpRequest.withCredentials = true;
      }
    }
  }

  httpRequest.send(null);
  return httpRequest;
} // AJAX handlers for CORS (modern browsers) or JSONP (older browsers)


function request(url, params, callback, context) {
  var paramString = serialize(params);
  var httpRequest = createRequest(callback, context);
  var requestLength = (url + '?' + paramString).length; // ie10/11 require the request be opened before a timeout is applied

  if (requestLength <= 2000 && _Support.Support.cors) {
    httpRequest.open('GET', url + '?' + paramString);
  } else if (requestLength > 2000 && _Support.Support.cors) {
    httpRequest.open('POST', url);
    httpRequest.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
  }

  if (typeof context !== 'undefined' && context !== null) {
    if (typeof context.options !== 'undefined') {
      httpRequest.timeout = context.options.timeout;

      if (context.options.withCredentials) {
        httpRequest.withCredentials = true;
      }
    }
  } // request is less than 2000 characters and the browser supports CORS, make GET request with XMLHttpRequest


  if (requestLength <= 2000 && _Support.Support.cors) {
    httpRequest.send(null); // request is more than 2000 characters and the browser supports CORS, make POST request with XMLHttpRequest
  } else if (requestLength > 2000 && _Support.Support.cors) {
    httpRequest.send(paramString); // request is less  than 2000 characters and the browser does not support CORS, make a JSONP request
  } else if (requestLength <= 2000 && !_Support.Support.cors) {
    return jsonp(url, params, callback, context); // request is longer then 2000 characters and the browser does not support CORS, log a warning
  } else {
    warn('a request to ' + url + ' was longer then 2000 characters and this browser cannot make a cross-domain post request. Please use a proxy http://esri.github.io/esri-leaflet/api-reference/request.html');
    return;
  }

  return httpRequest;
}

function jsonp(url, params, callback, context) {
  window._EsriLeafletCallbacks = window._EsriLeafletCallbacks || {};
  var callbackId = 'c' + callbacks;
  params.callback = 'window._EsriLeafletCallbacks.' + callbackId;

  window._EsriLeafletCallbacks[callbackId] = function (response) {
    if (window._EsriLeafletCallbacks[callbackId] !== true) {
      var error;
      var responseType = Object.prototype.toString.call(response);

      if (!(responseType === '[object Object]' || responseType === '[object Array]')) {
        error = {
          error: {
            code: 500,
            message: 'Expected array or object as JSONP response'
          }
        };
        response = null;
      }

      if (!error && response.error) {
        error = response;
        response = null;
      }

      callback.call(context, error, response);
      window._EsriLeafletCallbacks[callbackId] = true;
    }
  };

  var script = _leaflet.DomUtil.create('script', null, document.body);

  script.type = 'text/javascript';
  script.src = url + '?' + serialize(params);
  script.id = callbackId;

  script.onerror = function (error) {
    if (error && window._EsriLeafletCallbacks[callbackId] !== true) {
      // Can't get true error code: it can be 404, or 401, or 500
      var err = {
        error: {
          code: 500,
          message: 'An unknown error occurred'
        }
      };
      callback.call(context, err);
      window._EsriLeafletCallbacks[callbackId] = true;
    }
  };

  _leaflet.DomUtil.addClass(script, 'esri-leaflet-jsonp');

  callbacks++;
  return {
    id: callbackId,
    url: script.src,
    abort: function () {
      window._EsriLeafletCallbacks._callback[callbackId]({
        code: 0,
        message: 'Request aborted.'
      });
    }
  };
}

var get = _Support.Support.cors ? xmlHttpGet : jsonp;
exports.get = get;
get.CORS = xmlHttpGet;
get.JSONP = jsonp;

function warn() {
  if (console && console.warn) {
    console.warn.apply(console, arguments);
  }
} // choose the correct AJAX handler depending on CORS support


// export the Request object to call the different handlers for debugging
var Request = {
  request: request,
  get: get,
  post: xmlHttpPost
};
exports.Request = Request;
var _default = Request;
exports.default = _default;

},{"./Support":20,"leaflet":29}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.featureLayerService = featureLayerService;
exports.default = exports.FeatureLayerService = void 0;

var _Service = require("./Service");

var _Query = _interopRequireDefault(require("../Tasks/Query"));

var _Util = require("../Util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FeatureLayerService = _Service.Service.extend({
  options: {
    idAttribute: 'OBJECTID'
  },
  query: function () {
    return (0, _Query.default)(this);
  },
  addFeature: function (feature, callback, context) {
    this.addFeatures(feature, callback, context);
  },
  addFeatures: function (features, callback, context) {
    var featuresArray = features.features ? features.features : [features];

    for (var i = featuresArray.length - 1; i >= 0; i--) {
      delete featuresArray[i].id;
    }

    features = (0, _Util.geojsonToArcGIS)(features);
    features = featuresArray.length > 1 ? features : [features];
    return this.post('addFeatures', {
      features: features
    }, function (error, response) {
      // For compatibility reason with former addFeature function,
      // we return the object in the array and not the array itself
      var result = response && response.addResults ? response.addResults.length > 1 ? response.addResults : response.addResults[0] : undefined;

      if (callback) {
        callback.call(context, error || response.addResults[0].error, result);
      }
    }, context);
  },
  updateFeature: function (feature, callback, context) {
    this.updateFeatures(feature, callback, context);
  },
  updateFeatures: function (features, callback, context) {
    var featuresArray = features.features ? features.features : [features];
    features = (0, _Util.geojsonToArcGIS)(features, this.options.idAttribute);
    features = featuresArray.length > 1 ? features : [features];
    return this.post('updateFeatures', {
      features: features
    }, function (error, response) {
      // For compatibility reason with former updateFeature function,
      // we return the object in the array and not the array itself
      var result = response && response.updateResults ? response.updateResults.length > 1 ? response.updateResults : response.updateResults[0] : undefined;

      if (callback) {
        callback.call(context, error || response.updateResults[0].error, result);
      }
    }, context);
  },
  deleteFeature: function (id, callback, context) {
    this.deleteFeatures(id, callback, context);
  },
  deleteFeatures: function (ids, callback, context) {
    return this.post('deleteFeatures', {
      objectIds: ids
    }, function (error, response) {
      // For compatibility reason with former deleteFeature function,
      // we return the object in the array and not the array itself
      var result = response && response.deleteResults ? response.deleteResults.length > 1 ? response.deleteResults : response.deleteResults[0] : undefined;

      if (callback) {
        callback.call(context, error || response.deleteResults[0].error, result);
      }
    }, context);
  }
});

exports.FeatureLayerService = FeatureLayerService;

function featureLayerService(options) {
  return new FeatureLayerService(options);
}

var _default = featureLayerService;
exports.default = _default;

},{"../Tasks/Query":25,"../Util":27,"./Service":19}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.imageService = imageService;
exports.default = exports.ImageService = void 0;

var _Service = require("./Service");

var _IdentifyImage = _interopRequireDefault(require("../Tasks/IdentifyImage"));

var _Query = _interopRequireDefault(require("../Tasks/Query"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ImageService = _Service.Service.extend({
  query: function () {
    return (0, _Query.default)(this);
  },
  identify: function () {
    return (0, _IdentifyImage.default)(this);
  }
});

exports.ImageService = ImageService;

function imageService(options) {
  return new ImageService(options);
}

var _default = imageService;
exports.default = _default;

},{"../Tasks/IdentifyImage":24,"../Tasks/Query":25,"./Service":19}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapService = mapService;
exports.default = exports.MapService = void 0;

var _Service = require("./Service");

var _IdentifyFeatures = _interopRequireDefault(require("../Tasks/IdentifyFeatures"));

var _Query = _interopRequireDefault(require("../Tasks/Query"));

var _Find = _interopRequireDefault(require("../Tasks/Find"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MapService = _Service.Service.extend({
  identify: function () {
    return (0, _IdentifyFeatures.default)(this);
  },
  find: function () {
    return (0, _Find.default)(this);
  },
  query: function () {
    return (0, _Query.default)(this);
  }
});

exports.MapService = MapService;

function mapService(options) {
  return new MapService(options);
}

var _default = mapService;
exports.default = _default;

},{"../Tasks/Find":21,"../Tasks/IdentifyFeatures":23,"../Tasks/Query":25,"./Service":19}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.service = service;
exports.default = exports.Service = void 0;

var _leaflet = require("leaflet");

var _Support = require("../Support");

var _Util = require("../Util");

var _Request = _interopRequireDefault(require("../Request"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Service = _leaflet.Evented.extend({
  options: {
    proxy: false,
    useCors: _Support.cors,
    timeout: 0
  },
  initialize: function (options) {
    options = options || {};
    this._requestQueue = [];
    this._authenticating = false;

    _leaflet.Util.setOptions(this, options);

    this.options.url = (0, _Util.cleanUrl)(this.options.url);
  },
  get: function (path, params, callback, context) {
    return this._request('get', path, params, callback, context);
  },
  post: function (path, params, callback, context) {
    return this._request('post', path, params, callback, context);
  },
  request: function (path, params, callback, context) {
    return this._request('request', path, params, callback, context);
  },
  metadata: function (callback, context) {
    return this._request('get', '', {}, callback, context);
  },
  authenticate: function (token) {
    this._authenticating = false;
    this.options.token = token;

    this._runQueue();

    return this;
  },
  getTimeout: function () {
    return this.options.timeout;
  },
  setTimeout: function (timeout) {
    this.options.timeout = timeout;
  },
  _request: function (method, path, params, callback, context) {
    this.fire('requeststart', {
      url: this.options.url + path,
      params: params,
      method: method
    }, true);

    var wrappedCallback = this._createServiceCallback(method, path, params, callback, context);

    if (this.options.token) {
      params.token = this.options.token;
    }

    if (this.options.requestParams) {
      _leaflet.Util.extend(params, this.options.requestParams);
    }

    if (this._authenticating) {
      this._requestQueue.push([method, path, params, callback, context]);

      return;
    } else {
      var url = this.options.proxy ? this.options.proxy + '?' + this.options.url + path : this.options.url + path;

      if ((method === 'get' || method === 'request') && !this.options.useCors) {
        return _Request.default.get.JSONP(url, params, wrappedCallback, context);
      } else {
        return _Request.default[method](url, params, wrappedCallback, context);
      }
    }
  },
  _createServiceCallback: function (method, path, params, callback, context) {
    return _leaflet.Util.bind(function (error, response) {
      if (error && (error.code === 499 || error.code === 498)) {
        this._authenticating = true;

        this._requestQueue.push([method, path, params, callback, context]); // fire an event for users to handle and re-authenticate


        this.fire('authenticationrequired', {
          authenticate: _leaflet.Util.bind(this.authenticate, this)
        }, true); // if the user has access to a callback they can handle the auth error

        error.authenticate = _leaflet.Util.bind(this.authenticate, this);
      }

      callback.call(context, error, response);

      if (error) {
        this.fire('requesterror', {
          url: this.options.url + path,
          params: params,
          message: error.message,
          code: error.code,
          method: method
        }, true);
      } else {
        this.fire('requestsuccess', {
          url: this.options.url + path,
          params: params,
          response: response,
          method: method
        }, true);
      }

      this.fire('requestend', {
        url: this.options.url + path,
        params: params,
        method: method
      }, true);
    }, this);
  },
  _runQueue: function () {
    for (var i = this._requestQueue.length - 1; i >= 0; i--) {
      var request = this._requestQueue[i];
      var method = request.shift();
      this[method].apply(this, request);
    }

    this._requestQueue = [];
  }
});

exports.Service = Service;

function service(options) {
  options = (0, _Util.getUrlParams)(options);
  return new Service(options);
}

var _default = service;
exports.default = _default;

},{"../Request":15,"../Support":20,"../Util":27,"leaflet":29}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Support = exports.pointerEvents = exports.cors = void 0;
var cors = window.XMLHttpRequest && 'withCredentials' in new window.XMLHttpRequest();
exports.cors = cors;
var pointerEvents = document.documentElement.style.pointerEvents === '';
exports.pointerEvents = pointerEvents;
var Support = {
  cors: cors,
  pointerEvents: pointerEvents
};
exports.Support = Support;
var _default = Support;
exports.default = _default;

},{}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.find = find;
exports.default = exports.Find = void 0;

var _Task = require("./Task");

var _Util = require("../Util");

var Find = _Task.Task.extend({
  setters: {
    // method name > param name
    'contains': 'contains',
    'text': 'searchText',
    'fields': 'searchFields',
    // denote an array or single string
    'spatialReference': 'sr',
    'sr': 'sr',
    'layers': 'layers',
    'returnGeometry': 'returnGeometry',
    'maxAllowableOffset': 'maxAllowableOffset',
    'precision': 'geometryPrecision',
    'dynamicLayers': 'dynamicLayers',
    'returnZ': 'returnZ',
    'returnM': 'returnM',
    'gdbVersion': 'gdbVersion',
    // skipped implementing this (for now) because the REST service implementation isnt consistent between operations
    // 'transform': 'datumTransformations',
    'token': 'token'
  },
  path: 'find',
  params: {
    sr: 4326,
    contains: true,
    returnGeometry: true,
    returnZ: true,
    returnM: false
  },
  layerDefs: function (id, where) {
    this.params.layerDefs = this.params.layerDefs ? this.params.layerDefs + ';' : '';
    this.params.layerDefs += [id, where].join(':');
    return this;
  },
  simplify: function (map, factor) {
    var mapWidth = Math.abs(map.getBounds().getWest() - map.getBounds().getEast());
    this.params.maxAllowableOffset = mapWidth / map.getSize().y * factor;
    return this;
  },
  run: function (callback, context) {
    return this.request(function (error, response) {
      callback.call(context, error, response && (0, _Util.responseToFeatureCollection)(response), response);
    }, context);
  }
});

exports.Find = Find;

function find(options) {
  return new Find(options);
}

var _default = find;
exports.default = _default;

},{"../Util":27,"./Task":26}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.identify = identify;
exports.default = exports.Identify = void 0;

var _Task = require("./Task");

var Identify = _Task.Task.extend({
  path: 'identify',
  between: function (start, end) {
    this.params.time = [start.valueOf(), end.valueOf()];
    return this;
  }
});

exports.Identify = Identify;

function identify(options) {
  return new Identify(options);
}

var _default = identify;
exports.default = _default;

},{"./Task":26}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.identifyFeatures = identifyFeatures;
exports.default = exports.IdentifyFeatures = void 0;

var _leaflet = require("leaflet");

var _Identify = require("./Identify");

var _Util = require("../Util");

var IdentifyFeatures = _Identify.Identify.extend({
  setters: {
    'layers': 'layers',
    'precision': 'geometryPrecision',
    'tolerance': 'tolerance',
    // skipped implementing this (for now) because the REST service implementation isnt consistent between operations.
    // 'transform': 'datumTransformations'
    'returnGeometry': 'returnGeometry'
  },
  params: {
    sr: 4326,
    layers: 'all',
    tolerance: 3,
    returnGeometry: true
  },
  on: function (map) {
    var extent = (0, _Util.boundsToExtent)(map.getBounds());
    var size = map.getSize();
    this.params.imageDisplay = [size.x, size.y, 96];
    this.params.mapExtent = [extent.xmin, extent.ymin, extent.xmax, extent.ymax];
    return this;
  },
  at: function (geometry) {
    // cast lat, long pairs in raw array form manually
    if (geometry.length === 2) {
      geometry = (0, _leaflet.latLng)(geometry);
    }

    this._setGeometryParams(geometry);

    return this;
  },
  layerDef: function (id, where) {
    this.params.layerDefs = this.params.layerDefs ? this.params.layerDefs + ';' : '';
    this.params.layerDefs += [id, where].join(':');
    return this;
  },
  simplify: function (map, factor) {
    var mapWidth = Math.abs(map.getBounds().getWest() - map.getBounds().getEast());
    this.params.maxAllowableOffset = mapWidth / map.getSize().y * factor;
    return this;
  },
  run: function (callback, context) {
    return this.request(function (error, response) {
      // immediately invoke with an error
      if (error) {
        callback.call(context, error, undefined, response);
        return; // ok no error lets just assume we have features...
      } else {
        var featureCollection = (0, _Util.responseToFeatureCollection)(response);
        response.results = response.results.reverse();

        for (var i = 0; i < featureCollection.features.length; i++) {
          var feature = featureCollection.features[i];
          feature.layerId = response.results[i].layerId;
        }

        callback.call(context, undefined, featureCollection, response);
      }
    });
  },
  _setGeometryParams: function (geometry) {
    var converted = (0, _Util._setGeometry)(geometry);
    this.params.geometry = converted.geometry;
    this.params.geometryType = converted.geometryType;
  }
});

exports.IdentifyFeatures = IdentifyFeatures;

function identifyFeatures(options) {
  return new IdentifyFeatures(options);
}

var _default = identifyFeatures;
exports.default = _default;

},{"../Util":27,"./Identify":22,"leaflet":29}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.identifyImage = identifyImage;
exports.default = exports.IdentifyImage = void 0;

var _leaflet = require("leaflet");

var _Identify = require("./Identify");

var _Util = require("../Util");

var IdentifyImage = _Identify.Identify.extend({
  setters: {
    'setMosaicRule': 'mosaicRule',
    'setRenderingRule': 'renderingRule',
    'setPixelSize': 'pixelSize',
    'returnCatalogItems': 'returnCatalogItems',
    'returnGeometry': 'returnGeometry'
  },
  params: {
    returnGeometry: false
  },
  at: function (latlng) {
    latlng = (0, _leaflet.latLng)(latlng);
    this.params.geometry = JSON.stringify({
      x: latlng.lng,
      y: latlng.lat,
      spatialReference: {
        wkid: 4326
      }
    });
    this.params.geometryType = 'esriGeometryPoint';
    return this;
  },
  getMosaicRule: function () {
    return this.params.mosaicRule;
  },
  getRenderingRule: function () {
    return this.params.renderingRule;
  },
  getPixelSize: function () {
    return this.params.pixelSize;
  },
  run: function (callback, context) {
    return this.request(function (error, response) {
      callback.call(context, error, response && this._responseToGeoJSON(response), response);
    }, this);
  },
  // get pixel data and return as geoJSON point
  // populate catalog items (if any)
  // merging in any catalogItemVisibilities as a propery of each feature
  _responseToGeoJSON: function (response) {
    var location = response.location;
    var catalogItems = response.catalogItems;
    var catalogItemVisibilities = response.catalogItemVisibilities;
    var geoJSON = {
      'pixel': {
        'type': 'Feature',
        'geometry': {
          'type': 'Point',
          'coordinates': [location.x, location.y]
        },
        'crs': {
          'type': 'EPSG',
          'properties': {
            'code': location.spatialReference.wkid
          }
        },
        'properties': {
          'OBJECTID': response.objectId,
          'name': response.name,
          'value': response.value
        },
        'id': response.objectId
      }
    };

    if (response.properties && response.properties.Values) {
      geoJSON.pixel.properties.values = response.properties.Values;
    }

    if (catalogItems && catalogItems.features) {
      geoJSON.catalogItems = (0, _Util.responseToFeatureCollection)(catalogItems);

      if (catalogItemVisibilities && catalogItemVisibilities.length === geoJSON.catalogItems.features.length) {
        for (var i = catalogItemVisibilities.length - 1; i >= 0; i--) {
          geoJSON.catalogItems.features[i].properties.catalogItemVisibility = catalogItemVisibilities[i];
        }
      }
    }

    return geoJSON;
  }
});

exports.IdentifyImage = IdentifyImage;

function identifyImage(params) {
  return new IdentifyImage(params);
}

var _default = identifyImage;
exports.default = _default;

},{"../Util":27,"./Identify":22,"leaflet":29}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.query = query;
exports.default = exports.Query = void 0;

var _leaflet = require("leaflet");

var _Task = require("./Task");

var _Util = require("../Util");

var Query = _Task.Task.extend({
  setters: {
    'offset': 'resultOffset',
    'limit': 'resultRecordCount',
    'fields': 'outFields',
    'precision': 'geometryPrecision',
    'featureIds': 'objectIds',
    'returnGeometry': 'returnGeometry',
    'returnM': 'returnM',
    'transform': 'datumTransformation',
    'token': 'token'
  },
  path: 'query',
  params: {
    returnGeometry: true,
    where: '1=1',
    outSR: 4326,
    outFields: '*'
  },
  // Returns a feature if its shape is wholly contained within the search geometry. Valid for all shape type combinations.
  within: function (geometry) {
    this._setGeometryParams(geometry);

    this.params.spatialRel = 'esriSpatialRelContains'; // to the REST api this reads geometry **contains** layer

    return this;
  },
  // Returns a feature if any spatial relationship is found. Applies to all shape type combinations.
  intersects: function (geometry) {
    this._setGeometryParams(geometry);

    this.params.spatialRel = 'esriSpatialRelIntersects';
    return this;
  },
  // Returns a feature if its shape wholly contains the search geometry. Valid for all shape type combinations.
  contains: function (geometry) {
    this._setGeometryParams(geometry);

    this.params.spatialRel = 'esriSpatialRelWithin'; // to the REST api this reads geometry **within** layer

    return this;
  },
  // Returns a feature if the intersection of the interiors of the two shapes is not empty and has a lower dimension than the maximum dimension of the two shapes. Two lines that share an endpoint in common do not cross. Valid for Line/Line, Line/Area, Multi-point/Area, and Multi-point/Line shape type combinations.
  crosses: function (geometry) {
    this._setGeometryParams(geometry);

    this.params.spatialRel = 'esriSpatialRelCrosses';
    return this;
  },
  // Returns a feature if the two shapes share a common boundary. However, the intersection of the interiors of the two shapes must be empty. In the Point/Line case, the point may touch an endpoint only of the line. Applies to all combinations except Point/Point.
  touches: function (geometry) {
    this._setGeometryParams(geometry);

    this.params.spatialRel = 'esriSpatialRelTouches';
    return this;
  },
  // Returns a feature if the intersection of the two shapes results in an object of the same dimension, but different from both of the shapes. Applies to Area/Area, Line/Line, and Multi-point/Multi-point shape type combinations.
  overlaps: function (geometry) {
    this._setGeometryParams(geometry);

    this.params.spatialRel = 'esriSpatialRelOverlaps';
    return this;
  },
  // Returns a feature if the envelope of the two shapes intersects.
  bboxIntersects: function (geometry) {
    this._setGeometryParams(geometry);

    this.params.spatialRel = 'esriSpatialRelEnvelopeIntersects';
    return this;
  },
  // if someone can help decipher the ArcObjects explanation and translate to plain speak, we should mention this method in the doc
  indexIntersects: function (geometry) {
    this._setGeometryParams(geometry);

    this.params.spatialRel = 'esriSpatialRelIndexIntersects'; // Returns a feature if the envelope of the query geometry intersects the index entry for the target geometry

    return this;
  },
  // only valid for Feature Services running on ArcGIS Server 10.3+ or ArcGIS Online
  nearby: function (latlng, radius) {
    latlng = (0, _leaflet.latLng)(latlng);
    this.params.geometry = [latlng.lng, latlng.lat];
    this.params.geometryType = 'esriGeometryPoint';
    this.params.spatialRel = 'esriSpatialRelIntersects';
    this.params.units = 'esriSRUnit_Meter';
    this.params.distance = radius;
    this.params.inSR = 4326;
    return this;
  },
  where: function (string) {
    // instead of converting double-quotes to single quotes, pass as is, and provide a more informative message if a 400 is encountered
    this.params.where = string;
    return this;
  },
  between: function (start, end) {
    this.params.time = [start.valueOf(), end.valueOf()];
    return this;
  },
  simplify: function (map, factor) {
    var mapWidth = Math.abs(map.getBounds().getWest() - map.getBounds().getEast());
    this.params.maxAllowableOffset = mapWidth / map.getSize().y * factor;
    return this;
  },
  orderBy: function (fieldName, order) {
    order = order || 'ASC';
    this.params.orderByFields = this.params.orderByFields ? this.params.orderByFields + ',' : '';
    this.params.orderByFields += [fieldName, order].join(' ');
    return this;
  },
  run: function (callback, context) {
    this._cleanParams(); // services hosted on ArcGIS Online and ArcGIS Server 10.3.1+ support requesting geojson directly


    if (this.options.isModern || (0, _Util.isArcgisOnline)(this.options.url) && this.options.isModern === undefined) {
      this.params.f = 'geojson';
      return this.request(function (error, response) {
        this._trapSQLerrors(error);

        callback.call(context, error, response, response);
      }, this); // otherwise convert it in the callback then pass it on
    } else {
      return this.request(function (error, response) {
        this._trapSQLerrors(error);

        callback.call(context, error, response && (0, _Util.responseToFeatureCollection)(response), response);
      }, this);
    }
  },
  count: function (callback, context) {
    this._cleanParams();

    this.params.returnCountOnly = true;
    return this.request(function (error, response) {
      callback.call(this, error, response && response.count, response);
    }, context);
  },
  ids: function (callback, context) {
    this._cleanParams();

    this.params.returnIdsOnly = true;
    return this.request(function (error, response) {
      callback.call(this, error, response && response.objectIds, response);
    }, context);
  },
  // only valid for Feature Services running on ArcGIS Server 10.3+ or ArcGIS Online
  bounds: function (callback, context) {
    this._cleanParams();

    this.params.returnExtentOnly = true;
    return this.request(function (error, response) {
      if (response && response.extent && (0, _Util.extentToBounds)(response.extent)) {
        callback.call(context, error, (0, _Util.extentToBounds)(response.extent), response);
      } else {
        error = {
          message: 'Invalid Bounds'
        };
        callback.call(context, error, null, response);
      }
    }, context);
  },
  distinct: function () {
    // geometry must be omitted for queries requesting distinct values
    this.params.returnGeometry = false;
    this.params.returnDistinctValues = true;
    return this;
  },
  // only valid for image services
  pixelSize: function (rawPoint) {
    var castPoint = (0, _leaflet.point)(rawPoint);
    this.params.pixelSize = [castPoint.x, castPoint.y];
    return this;
  },
  // only valid for map services
  layer: function (layer) {
    this.path = layer + '/query';
    return this;
  },
  _trapSQLerrors: function (error) {
    if (error) {
      if (error.code === '400') {
        (0, _Util.warn)('one common syntax error in query requests is encasing string values in double quotes instead of single quotes');
      }
    }
  },
  _cleanParams: function () {
    delete this.params.returnIdsOnly;
    delete this.params.returnExtentOnly;
    delete this.params.returnCountOnly;
  },
  _setGeometryParams: function (geometry) {
    this.params.inSR = 4326;
    var converted = (0, _Util._setGeometry)(geometry);
    this.params.geometry = converted.geometry;
    this.params.geometryType = converted.geometryType;
  }
});

exports.Query = Query;

function query(options) {
  return new Query(options);
}

var _default = query;
exports.default = _default;

},{"../Util":27,"./Task":26,"leaflet":29}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.task = task;
exports.default = exports.Task = void 0;

var _leaflet = require("leaflet");

var _Support = require("../Support");

var _Util = require("../Util");

var _Request = _interopRequireDefault(require("../Request"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Task = _leaflet.Class.extend({
  options: {
    proxy: false,
    useCors: _Support.cors
  },
  // Generate a method for each methodName:paramName in the setters for this task.
  generateSetter: function (param, context) {
    return _leaflet.Util.bind(function (value) {
      this.params[param] = value;
      return this;
    }, context);
  },
  initialize: function (endpoint) {
    // endpoint can be either a url (and options) for an ArcGIS Rest Service or an instance of EsriLeaflet.Service
    if (endpoint.request && endpoint.options) {
      this._service = endpoint;

      _leaflet.Util.setOptions(this, endpoint.options);
    } else {
      _leaflet.Util.setOptions(this, endpoint);

      this.options.url = (0, _Util.cleanUrl)(endpoint.url);
    } // clone default params into this object


    this.params = _leaflet.Util.extend({}, this.params || {}); // generate setter methods based on the setters object implimented a child class

    if (this.setters) {
      for (var setter in this.setters) {
        var param = this.setters[setter];
        this[setter] = this.generateSetter(param, this);
      }
    }
  },
  token: function (token) {
    if (this._service) {
      this._service.authenticate(token);
    } else {
      this.params.token = token;
    }

    return this;
  },
  apikey: function (apikey) {
    return this.token(apikey);
  },
  // ArcGIS Server Find/Identify 10.5+
  format: function (boolean) {
    // use double negative to expose a more intuitive positive method name
    this.params.returnUnformattedValues = !boolean;
    return this;
  },
  request: function (callback, context) {
    if (this.options.requestParams) {
      _leaflet.Util.extend(this.params, this.options.requestParams);
    }

    if (this._service) {
      return this._service.request(this.path, this.params, callback, context);
    }

    return this._request('request', this.path, this.params, callback, context);
  },
  _request: function (method, path, params, callback, context) {
    var url = this.options.proxy ? this.options.proxy + '?' + this.options.url + path : this.options.url + path;

    if ((method === 'get' || method === 'request') && !this.options.useCors) {
      return _Request.default.get.JSONP(url, params, callback, context);
    }

    return _Request.default[method](url, params, callback, context);
  }
});

exports.Task = Task;

function task(options) {
  options = (0, _Util.getUrlParams)(options);
  return new Task(options);
}

var _default = task;
exports.default = _default;

},{"../Request":15,"../Support":20,"../Util":27,"leaflet":29}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.geojsonToArcGIS = geojsonToArcGIS;
exports.arcgisToGeoJSON = arcgisToGeoJSON;
exports.extentToBounds = extentToBounds;
exports.boundsToExtent = boundsToExtent;
exports._findIdAttributeFromResponse = _findIdAttributeFromResponse;
exports._findIdAttributeFromFeature = _findIdAttributeFromFeature;
exports.responseToFeatureCollection = responseToFeatureCollection;
exports.cleanUrl = cleanUrl;
exports.getUrlParams = getUrlParams;
exports.isArcgisOnline = isArcgisOnline;
exports.geojsonTypeToArcGIS = geojsonTypeToArcGIS;
exports.calcAttributionWidth = calcAttributionWidth;
exports.setEsriAttribution = setEsriAttribution;
exports.removeEsriAttribution = removeEsriAttribution;
exports._setGeometry = _setGeometry;
exports._getAttributionData = _getAttributionData;
exports._updateMapAttribution = _updateMapAttribution;
Object.defineProperty(exports, "warn", {
  enumerable: true,
  get: function () {
    return _Request.warn;
  }
});
exports.default = exports.EsriUtil = void 0;

var _leaflet = require("leaflet");

var _Request = require("./Request");

var _Options = require("./Options");

var _Support = require("./Support");

var _arcgis = require("@terraformer/arcgis");

var BASE_LEAFLET_ATTRIBUTION_STRING = '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>';
var POWERED_BY_ESRI_ATTRIBUTION_STRING = 'Powered by <a href="https://www.esri.com">Esri</a>';

function geojsonToArcGIS(geojson, idAttr) {
  return (0, _arcgis.geojsonToArcGIS)(geojson, idAttr);
}

function arcgisToGeoJSON(arcgis, idAttr) {
  return (0, _arcgis.arcgisToGeoJSON)(arcgis, idAttr);
} // convert an extent (ArcGIS) to LatLngBounds (Leaflet)


function extentToBounds(extent) {
  // "NaN" coordinates from ArcGIS Server indicate a null geometry
  if (extent.xmin !== 'NaN' && extent.ymin !== 'NaN' && extent.xmax !== 'NaN' && extent.ymax !== 'NaN') {
    var sw = (0, _leaflet.latLng)(extent.ymin, extent.xmin);
    var ne = (0, _leaflet.latLng)(extent.ymax, extent.xmax);
    return (0, _leaflet.latLngBounds)(sw, ne);
  } else {
    return null;
  }
} // convert an LatLngBounds (Leaflet) to extent (ArcGIS)


function boundsToExtent(bounds) {
  bounds = (0, _leaflet.latLngBounds)(bounds);
  return {
    'xmin': bounds.getSouthWest().lng,
    'ymin': bounds.getSouthWest().lat,
    'xmax': bounds.getNorthEast().lng,
    'ymax': bounds.getNorthEast().lat,
    'spatialReference': {
      'wkid': 4326
    }
  };
}

var knownFieldNames = /^(OBJECTID|FID|OID|ID)$/i; // Attempts to find the ID Field from response

function _findIdAttributeFromResponse(response) {
  var result;

  if (response.objectIdFieldName) {
    // Find Id Field directly
    result = response.objectIdFieldName;
  } else if (response.fields) {
    // Find ID Field based on field type
    for (var j = 0; j <= response.fields.length - 1; j++) {
      if (response.fields[j].type === 'esriFieldTypeOID') {
        result = response.fields[j].name;
        break;
      }
    }

    if (!result) {
      // If no field was marked as being the esriFieldTypeOID try well known field names
      for (j = 0; j <= response.fields.length - 1; j++) {
        if (response.fields[j].name.match(knownFieldNames)) {
          result = response.fields[j].name;
          break;
        }
      }
    }
  }

  return result;
} // This is the 'last' resort, find the Id field from the specified feature


function _findIdAttributeFromFeature(feature) {
  for (var key in feature.attributes) {
    if (key.match(knownFieldNames)) {
      return key;
    }
  }
}

function responseToFeatureCollection(response, idAttribute) {
  var objectIdField;
  var features = response.features || response.results;
  var count = features && features.length;

  if (idAttribute) {
    objectIdField = idAttribute;
  } else {
    objectIdField = _findIdAttributeFromResponse(response);
  }

  var featureCollection = {
    type: 'FeatureCollection',
    features: []
  };

  if (count) {
    for (var i = features.length - 1; i >= 0; i--) {
      var feature = arcgisToGeoJSON(features[i], objectIdField || _findIdAttributeFromFeature(features[i]));
      featureCollection.features.push(feature);
    }
  }

  return featureCollection;
} // trim url whitespace and add a trailing slash if needed


function cleanUrl(url) {
  // trim leading and trailing spaces, but not spaces inside the url
  url = _leaflet.Util.trim(url); // add a trailing slash to the url if the user omitted it

  if (url[url.length - 1] !== '/') {
    url += '/';
  }

  return url;
}
/* Extract url params if any and store them in requestParams attribute.
   Return the options params updated */


function getUrlParams(options) {
  if (options.url.indexOf('?') !== -1) {
    options.requestParams = options.requestParams || {};
    var queryString = options.url.substring(options.url.indexOf('?') + 1);
    options.url = options.url.split('?')[0];
    options.requestParams = JSON.parse('{"' + decodeURI(queryString).replace(/"/g, '\\"').replace(/&/g, '","').replace(/=/g, '":"') + '"}');
  }

  options.url = cleanUrl(options.url.split('?')[0]);
  return options;
}

function isArcgisOnline(url) {
  /* hosted feature services support geojson as an output format
  utility.arcgis.com services are proxied from a variety of ArcGIS Server vintages, and may not */
  return /^(?!.*utility\.arcgis\.com).*\.arcgis\.com.*FeatureServer/i.test(url);
}

function geojsonTypeToArcGIS(geoJsonType) {
  var arcgisGeometryType;

  switch (geoJsonType) {
    case 'Point':
      arcgisGeometryType = 'esriGeometryPoint';
      break;

    case 'MultiPoint':
      arcgisGeometryType = 'esriGeometryMultipoint';
      break;

    case 'LineString':
      arcgisGeometryType = 'esriGeometryPolyline';
      break;

    case 'MultiLineString':
      arcgisGeometryType = 'esriGeometryPolyline';
      break;

    case 'Polygon':
      arcgisGeometryType = 'esriGeometryPolygon';
      break;

    case 'MultiPolygon':
      arcgisGeometryType = 'esriGeometryPolygon';
      break;
  }

  return arcgisGeometryType;
}

function calcAttributionWidth(map) {
  // either crop at 55px or user defined buffer
  return map.getSize().x - _Options.options.attributionWidthOffset + 'px';
}

function setEsriAttribution(map) {
  if (!map.attributionControl) {
    return;
  }

  if (!map.attributionControl._esriAttributionLayerCount) {
    map.attributionControl._esriAttributionLayerCount = 0;
  }

  if (map.attributionControl._esriAttributionLayerCount === 0) {
    // Dynamically creating the CSS rules, only run this once per page load:
    if (!map.attributionControl._esriAttributionAddedOnce) {
      var hoverAttributionStyle = document.createElement('style');
      hoverAttributionStyle.type = 'text/css';
      hoverAttributionStyle.innerHTML = '.esri-truncated-attribution:hover {' + 'white-space: normal;' + '}';
      document.getElementsByTagName('head')[0].appendChild(hoverAttributionStyle); // define a new css class in JS to trim attribution into a single line

      var attributionStyle = document.createElement('style');
      attributionStyle.type = 'text/css';
      attributionStyle.innerHTML = '.esri-truncated-attribution {' + 'vertical-align: -3px;' + 'white-space: nowrap;' + 'overflow: hidden;' + 'text-overflow: ellipsis;' + 'display: inline-block;' + 'transition: 0s white-space;' + 'transition-delay: 1s;' + 'max-width: ' + calcAttributionWidth(map) + ';' + '}';
      document.getElementsByTagName('head')[0].appendChild(attributionStyle); // update the width used to truncate when the map itself is resized

      map.on('resize', function (e) {
        if (map.attributionControl) {
          map.attributionControl._container.style.maxWidth = calcAttributionWidth(e.target);
        }
      });
      map.attributionControl._esriAttributionAddedOnce = true;
    }

    map.attributionControl.setPrefix(BASE_LEAFLET_ATTRIBUTION_STRING + ' | ' + POWERED_BY_ESRI_ATTRIBUTION_STRING);

    _leaflet.DomUtil.addClass(map.attributionControl._container, 'esri-truncated-attribution:hover');

    _leaflet.DomUtil.addClass(map.attributionControl._container, 'esri-truncated-attribution');
  } // Track the number of esri-leaflet layers that are on the map so we can know when we can remove the attribution (below in removeEsriAttribution)


  map.attributionControl._esriAttributionLayerCount = map.attributionControl._esriAttributionLayerCount + 1;
}

function removeEsriAttribution(map) {
  if (!map.attributionControl) {
    return;
  } // Only remove the attribution if we're about to remove the LAST esri-leaflet layer (_esriAttributionLayerCount)


  if (map.attributionControl._esriAttributionLayerCount && map.attributionControl._esriAttributionLayerCount === 1) {
    map.attributionControl.setPrefix(BASE_LEAFLET_ATTRIBUTION_STRING);

    _leaflet.DomUtil.removeClass(map.attributionControl._container, 'esri-truncated-attribution:hover');

    _leaflet.DomUtil.removeClass(map.attributionControl._container, 'esri-truncated-attribution');
  }

  map.attributionControl._esriAttributionLayerCount = map.attributionControl._esriAttributionLayerCount - 1;
}

function _setGeometry(geometry) {
  var params = {
    geometry: null,
    geometryType: null
  }; // convert bounds to extent and finish

  if (geometry instanceof _leaflet.LatLngBounds) {
    // set geometry + geometryType
    params.geometry = boundsToExtent(geometry);
    params.geometryType = 'esriGeometryEnvelope';
    return params;
  } // convert L.Marker > L.LatLng


  if (geometry.getLatLng) {
    geometry = geometry.getLatLng();
  } // convert L.LatLng to a geojson point and continue;


  if (geometry instanceof _leaflet.LatLng) {
    geometry = {
      type: 'Point',
      coordinates: [geometry.lng, geometry.lat]
    };
  } // handle L.GeoJSON, pull out the first geometry


  if (geometry instanceof _leaflet.GeoJSON) {
    // reassign geometry to the GeoJSON value  (we are assuming that only one feature is present)
    geometry = geometry.getLayers()[0].feature.geometry;
    params.geometry = geojsonToArcGIS(geometry);
    params.geometryType = geojsonTypeToArcGIS(geometry.type);
  } // Handle L.Polyline and L.Polygon


  if (geometry.toGeoJSON) {
    geometry = geometry.toGeoJSON();
  } // handle GeoJSON feature by pulling out the geometry


  if (geometry.type === 'Feature') {
    // get the geometry of the geojson feature
    geometry = geometry.geometry;
  } // confirm that our GeoJSON is a point, line or polygon


  if (geometry.type === 'Point' || geometry.type === 'LineString' || geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') {
    params.geometry = geojsonToArcGIS(geometry);
    params.geometryType = geojsonTypeToArcGIS(geometry.type);
    return params;
  } // warn the user if we havn't found an appropriate object


  (0, _Request.warn)('invalid geometry passed to spatial query. Should be L.LatLng, L.LatLngBounds, L.Marker or a GeoJSON Point, Line, Polygon or MultiPolygon object');
  return;
}

function _getAttributionData(url, map) {
  if (_Support.Support.cors) {
    (0, _Request.request)(url, {}, _leaflet.Util.bind(function (error, attributions) {
      if (error) {
        return;
      }

      map._esriAttributions = [];

      for (var c = 0; c < attributions.contributors.length; c++) {
        var contributor = attributions.contributors[c];

        for (var i = 0; i < contributor.coverageAreas.length; i++) {
          var coverageArea = contributor.coverageAreas[i];
          var southWest = (0, _leaflet.latLng)(coverageArea.bbox[0], coverageArea.bbox[1]);
          var northEast = (0, _leaflet.latLng)(coverageArea.bbox[2], coverageArea.bbox[3]);

          map._esriAttributions.push({
            attribution: contributor.attribution,
            score: coverageArea.score,
            bounds: (0, _leaflet.latLngBounds)(southWest, northEast),
            minZoom: coverageArea.zoomMin,
            maxZoom: coverageArea.zoomMax
          });
        }
      }

      map._esriAttributions.sort(function (a, b) {
        return b.score - a.score;
      }); // pass the same argument as the map's 'moveend' event


      var obj = {
        target: map
      };

      _updateMapAttribution(obj);
    }, this));
  }
}

function _updateMapAttribution(evt) {
  var map = evt.target;
  var oldAttributions = map._esriAttributions;
  if (!map || !map.attributionControl) return;

  var attributionElement = map.attributionControl._container.querySelector('.esri-dynamic-attribution');

  if (attributionElement && oldAttributions) {
    var newAttributions = '';
    var bounds = map.getBounds();
    var wrappedBounds = (0, _leaflet.latLngBounds)(bounds.getSouthWest().wrap(), bounds.getNorthEast().wrap());
    var zoom = map.getZoom();

    for (var i = 0; i < oldAttributions.length; i++) {
      var attribution = oldAttributions[i];
      var text = attribution.attribution;

      if (!newAttributions.match(text) && attribution.bounds.intersects(wrappedBounds) && zoom >= attribution.minZoom && zoom <= attribution.maxZoom) {
        newAttributions += ', ' + text;
      }
    }

    newAttributions = newAttributions.substr(2);
    attributionElement.innerHTML = newAttributions;
    attributionElement.style.maxWidth = calcAttributionWidth(map);
    map.fire('attributionupdated', {
      attribution: newAttributions
    });
  }
} // for backwards compatibility


var EsriUtil = {
  warn: _Request.warn,
  cleanUrl: cleanUrl,
  getUrlParams: getUrlParams,
  isArcgisOnline: isArcgisOnline,
  geojsonTypeToArcGIS: geojsonTypeToArcGIS,
  responseToFeatureCollection: responseToFeatureCollection,
  geojsonToArcGIS: geojsonToArcGIS,
  arcgisToGeoJSON: arcgisToGeoJSON,
  boundsToExtent: boundsToExtent,
  extentToBounds: extentToBounds,
  calcAttributionWidth: calcAttributionWidth,
  setEsriAttribution: setEsriAttribution,
  _setGeometry: _setGeometry,
  _getAttributionData: _getAttributionData,
  _updateMapAttribution: _updateMapAttribution,
  _findIdAttributeFromFeature: _findIdAttributeFromFeature,
  _findIdAttributeFromResponse: _findIdAttributeFromResponse
};
exports.EsriUtil = EsriUtil;
var _default = EsriUtil;
exports.default = _default;

},{"./Options":14,"./Request":15,"./Support":20,"@terraformer/arcgis":1,"leaflet":29}],28:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v3.6.0
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2021-03-02T17:08Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.6.0",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
						[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.6
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2021-02-16
 */
( function( window ) {
var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ( {} ).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	pushNative = arr.push,
	push = arr.push,
	slice = arr.slice,

	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[ i ] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
		"ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5]
		// or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
		whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
		"*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
			whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
			whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		return nonHex ?

			// Strip the backslash prefix from a non-hex escape sequence
			nonHex :

			// Replace a hexadecimal escape sequence with the encoded Unicode code point
			// Support: IE <=11+
			// For values outside the Basic Multilingual Plane (BMP), manually construct a
			// surrogate pair
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" +
				ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android<4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;

			// Can't trust NodeList.length
			while ( ( target[ j++ ] = els[ i++ ] ) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&

				// Support: IE 8 only
				// Exclude object elements
				( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					if ( newContext !== context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split( "|" ),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[ i ] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( ( cur = cur.nextSibling ) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return ( name === "input" || name === "button" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
					inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem && elem.namespaceURI,
		docElem = elem && ( elem.ownerDocument || elem ).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
	// Safari 4 - 5 only, Opera <=11.6 - 12.x only
	// IE/Edge & older browsers don't support the :scope pseudo-class.
	// Support: Safari 6.0 only
	// Safari 6.0 supports :scope but it's an alias of :root there.
	support.scope = assert( function( el ) {
		docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
		return typeof el.querySelectorAll !== "undefined" &&
			!el.querySelectorAll( ":scope fieldset div" ).length;
	} );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert( function( el ) {
		el.className = "i";
		return !el.getAttribute( "className" );
	} );

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert( function( el ) {
		el.appendChild( document.createComment( "" ) );
		return !el.getElementsByTagName( "*" ).length;
	} );

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter[ "ID" ] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter[ "ID" ] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find[ "TAG" ] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( ( elem = results[ i++ ] ) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert( function( el ) {

			var input;

			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll( "[selected]" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push( "~=" );
			}

			// Support: IE 11+, Edge 15 - 18+
			// IE 11/Edge don't find elements on a `[name='']` query in some cases.
			// Adding a temporary attribute to the document before the selection works
			// around the issue.
			// Interestingly, IE 10 & older don't seem to have the issue.
			input = document.createElement( "input" );
			input.setAttribute( "name", "" );
			el.appendChild( input );
			if ( !el.querySelectorAll( "[name='']" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
					whitespace + "*(?:''|\"\")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll( ":checked" ).length ) {
				rbuggyQSA.push( ":checked" );
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push( ".#.+[+~]" );
			}

			// Support: Firefox <=3.6 - 5 only
			// Old Firefox doesn't throw on a badly-escaped identifier.
			el.querySelectorAll( "\\\f" );
			rbuggyQSA.push( "[\\r\\n\\f]" );
		} );

		assert( function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement( "input" );
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll( "[name=d]" ).length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: Opera 10 - 11 only
			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll( "*,:x" );
			rbuggyQSA.push( ",.*:" );
		} );
	}

	if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector ) ) ) ) {

		assert( function( el ) {

			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		} );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			) );
		} :
		function( a, b ) {
			if ( b ) {
				while ( ( b = b.parentNode ) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a == document || a.ownerDocument == preferredDoc &&
				contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b == document || b.ownerDocument == preferredDoc &&
				contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {

		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			return a == document ? -1 :
				b == document ? 1 :
				/* eslint-enable eqeqeq */
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( ( cur = cur.parentNode ) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( ( cur = cur.parentNode ) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[ i ] === bp[ i ] ) {
			i++;
		}

		return i ?

			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[ i ], bp[ i ] ) :

			// Otherwise nodes in our document sort first
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			ap[ i ] == preferredDoc ? -1 :
			bp[ i ] == preferredDoc ? 1 :
			/* eslint-enable eqeqeq */
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

				// As well, disconnected nodes are said to be in a document
				// fragment in IE 9
				elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			( val = elem.getAttributeNode( name ) ) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {

		// If no nodeType, this is expected to be an array
		while ( ( node = elem[ i++ ] ) ) {

			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {

		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {

			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}

	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
				match[ 5 ] || "" ).replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					Sizzle.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

				// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				Sizzle.error( match[ 0 ] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace +
					")" + className + "(" + whitespace + "|$)" ) ) && classCache(
						className, function( elem ) {
							return pattern.test(
								typeof elem.className === "string" && elem.className ||
								typeof elem.getAttribute !== "undefined" &&
									elem.getAttribute( "class" ) ||
								""
							);
				} );
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				/* eslint-disable max-len */

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
				/* eslint-enable max-len */

			};
		},

		"CHILD": function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || ( node[ expando ] = {} );

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								( outerCache[ node.uniqueID ] = {} );

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {

								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || ( node[ expando ] = {} );

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									( outerCache[ node.uniqueID ] = {} );

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												( outerCache[ node.uniqueID ] = {} );

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		"not": markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element (issue #299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		"has": markFunction( function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		} ),

		"contains": markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement &&
				( !document.hasFocus || document.hasFocus() ) &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return ( nodeName === "input" && !!elem.checked ) ||
				( nodeName === "option" && !!elem.selected );
		},

		"selected": function( elem ) {

			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {

			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos[ "empty" ]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		"last": createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		"eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		"even": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"odd": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rcombinators.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrim, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :

			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] ||
							( outerCache[ elem.uniqueID ] = {} );

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = uniqueCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts(
				selector || "*",
				context.nodeType ? [ context ] : context,
				[]
			),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?

				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

					// If the preceding token was a descendant combinator, insert an implicit any-element `*`
					tokens
						.slice( 0, i - 1 )
						.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache(
			selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers )
		);

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
			context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
				.replace( runescape, funescape ), context ) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
						context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert( function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute( "href" ) === "#";
} ) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	} );
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert( function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
} ) ) {
	addHandle( "value", function( elem, _name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	} );
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert( function( el ) {
	return el.getAttribute( "disabled" ) == null;
} ) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
				( val = elem.getAttributeNode( name ) ) && val.specified ?
					val.value :
					null;
		}
	} );
}

return Sizzle;

} )( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the primary Deferred
			primary = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						primary.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( primary.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return primary.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
		}

		return primary.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
				dataPriv.get( this, "events" ) || Object.create( null )
			)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
						return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
						return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();

						// Support: Chrome 86+
						// In Chrome, if an element having a focusout handler is blurred by
						// clicking outside of it, it invokes the handler synchronously. If
						// that handler calls `.remove()` on the element, the data is cleared,
						// leaving `result` undefined. We need to guard against this.
						return result && result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		// Suppress native focus or blur as it's already being fired
		// in leverageNative.
		_default: function() {
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		//
		// Support: Firefox 70+
		// Only Firefox includes border widths
		// in computed dimensions. (gh-4529)
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "border:1px solid";

				// Support: Chrome 86+
				// Height set through cssText does not get applied.
				// Computed height then comes back as 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Support: Android 8 Chrome 86+
				// In our bodyBackground.html iframe,
				// display for all div elements is set to "inline",
				// which causes a problem only in Android 8 Chrome 86.
				// Ensuring the div is display: block
				// gets around this issue.
				trChild.style.display = "block";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
					swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, dimension, extra );
					} ) :
					getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

				/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
					animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};

		doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {

				// Handle: regular nodes (via `this.ownerDocument`), window
				// (via `this.document`) & document (via `this`).
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, parserErrorElem;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {}

	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Invalid XML: " + (
			parserErrorElem ?
				jQuery.map( parserErrorElem.childNodes, function( el ) {
					return el.textContent;
				} ).join( "\n" ) :
				data
		) );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} ).filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} ).map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script but not if jsonp
			if ( !isSuccess &&
				jQuery.inArray( "script", s.dataTypes ) > -1 &&
				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( {
		padding: "inner" + name,
		content: type,
		"": "outer" + name
	}, function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );

jQuery.each(
	( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

},{}],29:[function(require,module,exports){
"use strict";

/* @preserve
 * Leaflet 1.7.1, a JS library for interactive maps. http://leafletjs.com
 * (c) 2010-2019 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.L = {});
})(void 0, function (exports) {
  'use strict';

  var version = "1.7.1";
  /*
   * @namespace Util
   *
   * Various utility functions, used by Leaflet internally.
   */
  // @function extend(dest: Object, src?: Object): Object
  // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.

  function extend(dest) {
    var i, j, len, src;

    for (j = 1, len = arguments.length; j < len; j++) {
      src = arguments[j];

      for (i in src) {
        dest[i] = src[i];
      }
    }

    return dest;
  } // @function create(proto: Object, properties?: Object): Object
  // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)


  var create = Object.create || function () {
    function F() {}

    return function (proto) {
      F.prototype = proto;
      return new F();
    };
  }(); // @function bind(fn: Function, …): Function
  // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
  // Has a `L.bind()` shortcut.


  function bind(fn, obj) {
    var slice = Array.prototype.slice;

    if (fn.bind) {
      return fn.bind.apply(fn, slice.call(arguments, 1));
    }

    var args = slice.call(arguments, 2);
    return function () {
      return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
    };
  } // @property lastId: Number
  // Last unique ID used by [`stamp()`](#util-stamp)


  var lastId = 0; // @function stamp(obj: Object): Number
  // Returns the unique ID of an object, assigning it one if it doesn't have it.

  function stamp(obj) {
    /*eslint-disable */
    obj._leaflet_id = obj._leaflet_id || ++lastId;
    return obj._leaflet_id;
    /* eslint-enable */
  } // @function throttle(fn: Function, time: Number, context: Object): Function
  // Returns a function which executes function `fn` with the given scope `context`
  // (so that the `this` keyword refers to `context` inside `fn`'s code). The function
  // `fn` will be called no more than one time per given amount of `time`. The arguments
  // received by the bound function will be any arguments passed when binding the
  // function, followed by any arguments passed when invoking the bound function.
  // Has an `L.throttle` shortcut.


  function throttle(fn, time, context) {
    var lock, args, wrapperFn, later;

    later = function () {
      // reset lock and call if queued
      lock = false;

      if (args) {
        wrapperFn.apply(context, args);
        args = false;
      }
    };

    wrapperFn = function () {
      if (lock) {
        // called too soon, queue to call later
        args = arguments;
      } else {
        // call and lock until later
        fn.apply(context, arguments);
        setTimeout(later, time);
        lock = true;
      }
    };

    return wrapperFn;
  } // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
  // Returns the number `num` modulo `range` in such a way so it lies within
  // `range[0]` and `range[1]`. The returned value will be always smaller than
  // `range[1]` unless `includeMax` is set to `true`.


  function wrapNum(x, range, includeMax) {
    var max = range[1],
        min = range[0],
        d = max - min;
    return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
  } // @function falseFn(): Function
  // Returns a function which always returns `false`.


  function falseFn() {
    return false;
  } // @function formatNum(num: Number, digits?: Number): Number
  // Returns the number `num` rounded to `digits` decimals, or to 6 decimals by default.


  function formatNum(num, digits) {
    var pow = Math.pow(10, digits === undefined ? 6 : digits);
    return Math.round(num * pow) / pow;
  } // @function trim(str: String): String
  // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)


  function trim(str) {
    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
  } // @function splitWords(str: String): String[]
  // Trims and splits the string on whitespace and returns the array of parts.


  function splitWords(str) {
    return trim(str).split(/\s+/);
  } // @function setOptions(obj: Object, options: Object): Object
  // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.


  function setOptions(obj, options) {
    if (!Object.prototype.hasOwnProperty.call(obj, 'options')) {
      obj.options = obj.options ? create(obj.options) : {};
    }

    for (var i in options) {
      obj.options[i] = options[i];
    }

    return obj.options;
  } // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
  // Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
  // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
  // be appended at the end. If `uppercase` is `true`, the parameter names will
  // be uppercased (e.g. `'?A=foo&B=bar'`)


  function getParamString(obj, existingUrl, uppercase) {
    var params = [];

    for (var i in obj) {
      params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
    }

    return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');
  }

  var templateRe = /\{ *([\w_-]+) *\}/g; // @function template(str: String, data: Object): String
  // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
  // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
  // `('Hello foo, bar')`. You can also specify functions instead of strings for
  // data values — they will be evaluated passing `data` as an argument.

  function template(str, data) {
    return str.replace(templateRe, function (str, key) {
      var value = data[key];

      if (value === undefined) {
        throw new Error('No value provided for variable ' + str);
      } else if (typeof value === 'function') {
        value = value(data);
      }

      return value;
    });
  } // @function isArray(obj): Boolean
  // Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)


  var isArray = Array.isArray || function (obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
  }; // @function indexOf(array: Array, el: Object): Number
  // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)


  function indexOf(array, el) {
    for (var i = 0; i < array.length; i++) {
      if (array[i] === el) {
        return i;
      }
    }

    return -1;
  } // @property emptyImageUrl: String
  // Data URI string containing a base64-encoded empty GIF image.
  // Used as a hack to free memory from unused images on WebKit-powered
  // mobile devices (by setting image `src` to this string).


  var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='; // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

  function getPrefixed(name) {
    return window['webkit' + name] || window['moz' + name] || window['ms' + name];
  }

  var lastTime = 0; // fallback for IE 7-8

  function timeoutDefer(fn) {
    var time = +new Date(),
        timeToCall = Math.max(0, 16 - (time - lastTime));
    lastTime = time + timeToCall;
    return window.setTimeout(fn, timeToCall);
  }

  var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;

  var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {
    window.clearTimeout(id);
  }; // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
  // Schedules `fn` to be executed when the browser repaints. `fn` is bound to
  // `context` if given. When `immediate` is set, `fn` is called immediately if
  // the browser doesn't have native support for
  // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
  // otherwise it's delayed. Returns a request ID that can be used to cancel the request.


  function requestAnimFrame(fn, context, immediate) {
    if (immediate && requestFn === timeoutDefer) {
      fn.call(context);
    } else {
      return requestFn.call(window, bind(fn, context));
    }
  } // @function cancelAnimFrame(id: Number): undefined
  // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).


  function cancelAnimFrame(id) {
    if (id) {
      cancelFn.call(window, id);
    }
  }

  var Util = {
    extend: extend,
    create: create,
    bind: bind,
    lastId: lastId,
    stamp: stamp,
    throttle: throttle,
    wrapNum: wrapNum,
    falseFn: falseFn,
    formatNum: formatNum,
    trim: trim,
    splitWords: splitWords,
    setOptions: setOptions,
    getParamString: getParamString,
    template: template,
    isArray: isArray,
    indexOf: indexOf,
    emptyImageUrl: emptyImageUrl,
    requestFn: requestFn,
    cancelFn: cancelFn,
    requestAnimFrame: requestAnimFrame,
    cancelAnimFrame: cancelAnimFrame
  }; // @class Class
  // @aka L.Class
  // @section
  // @uninheritable
  // Thanks to John Resig and Dean Edwards for inspiration!

  function Class() {}

  Class.extend = function (props) {
    // @function extend(props: Object): Function
    // [Extends the current class](#class-inheritance) given the properties to be included.
    // Returns a Javascript function that is a class constructor (to be called with `new`).
    var NewClass = function () {
      // call the constructor
      if (this.initialize) {
        this.initialize.apply(this, arguments);
      } // call all constructor hooks


      this.callInitHooks();
    };

    var parentProto = NewClass.__super__ = this.prototype;
    var proto = create(parentProto);
    proto.constructor = NewClass;
    NewClass.prototype = proto; // inherit parent's statics

    for (var i in this) {
      if (Object.prototype.hasOwnProperty.call(this, i) && i !== 'prototype' && i !== '__super__') {
        NewClass[i] = this[i];
      }
    } // mix static properties into the class


    if (props.statics) {
      extend(NewClass, props.statics);
      delete props.statics;
    } // mix includes into the prototype


    if (props.includes) {
      checkDeprecatedMixinEvents(props.includes);
      extend.apply(null, [proto].concat(props.includes));
      delete props.includes;
    } // merge options


    if (proto.options) {
      props.options = extend(create(proto.options), props.options);
    } // mix given properties into the prototype


    extend(proto, props);
    proto._initHooks = []; // add method for calling all hooks

    proto.callInitHooks = function () {
      if (this._initHooksCalled) {
        return;
      }

      if (parentProto.callInitHooks) {
        parentProto.callInitHooks.call(this);
      }

      this._initHooksCalled = true;

      for (var i = 0, len = proto._initHooks.length; i < len; i++) {
        proto._initHooks[i].call(this);
      }
    };

    return NewClass;
  }; // @function include(properties: Object): this
  // [Includes a mixin](#class-includes) into the current class.


  Class.include = function (props) {
    extend(this.prototype, props);
    return this;
  }; // @function mergeOptions(options: Object): this
  // [Merges `options`](#class-options) into the defaults of the class.


  Class.mergeOptions = function (options) {
    extend(this.prototype.options, options);
    return this;
  }; // @function addInitHook(fn: Function): this
  // Adds a [constructor hook](#class-constructor-hooks) to the class.


  Class.addInitHook = function (fn) {
    // (Function) || (String, args...)
    var args = Array.prototype.slice.call(arguments, 1);
    var init = typeof fn === 'function' ? fn : function () {
      this[fn].apply(this, args);
    };
    this.prototype._initHooks = this.prototype._initHooks || [];

    this.prototype._initHooks.push(init);

    return this;
  };

  function checkDeprecatedMixinEvents(includes) {
    if (typeof L === 'undefined' || !L || !L.Mixin) {
      return;
    }

    includes = isArray(includes) ? includes : [includes];

    for (var i = 0; i < includes.length; i++) {
      if (includes[i] === L.Mixin.Events) {
        console.warn('Deprecated include of L.Mixin.Events: ' + 'this property will be removed in future releases, ' + 'please inherit from L.Evented instead.', new Error().stack);
      }
    }
  }
  /*
   * @class Evented
   * @aka L.Evented
   * @inherits Class
   *
   * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
   *
   * @example
   *
   * ```js
   * map.on('click', function(e) {
   * 	alert(e.latlng);
   * } );
   * ```
   *
   * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
   *
   * ```js
   * function onClick(e) { ... }
   *
   * map.on('click', onClick);
   * map.off('click', onClick);
   * ```
   */


  var Events = {
    /* @method on(type: String, fn: Function, context?: Object): this
     * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
     *
     * @alternative
     * @method on(eventMap: Object): this
     * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
     */
    on: function (types, fn, context) {
      // types can be a map of types/handlers
      if (typeof types === 'object') {
        for (var type in types) {
          // we don't process space-separated events here for performance;
          // it's a hot path since Layer uses the on(obj) syntax
          this._on(type, types[type], fn);
        }
      } else {
        // types can be a string of space-separated words
        types = splitWords(types);

        for (var i = 0, len = types.length; i < len; i++) {
          this._on(types[i], fn, context);
        }
      }

      return this;
    },

    /* @method off(type: String, fn?: Function, context?: Object): this
     * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
     *
     * @alternative
     * @method off(eventMap: Object): this
     * Removes a set of type/listener pairs.
     *
     * @alternative
     * @method off: this
     * Removes all listeners to all events on the object. This includes implicitly attached events.
     */
    off: function (types, fn, context) {
      if (!types) {
        // clear all listeners if called without arguments
        delete this._events;
      } else if (typeof types === 'object') {
        for (var type in types) {
          this._off(type, types[type], fn);
        }
      } else {
        types = splitWords(types);

        for (var i = 0, len = types.length; i < len; i++) {
          this._off(types[i], fn, context);
        }
      }

      return this;
    },
    // attach listener (without syntactic sugar now)
    _on: function (type, fn, context) {
      this._events = this._events || {};
      /* get/init listeners for type */

      var typeListeners = this._events[type];

      if (!typeListeners) {
        typeListeners = [];
        this._events[type] = typeListeners;
      }

      if (context === this) {
        // Less memory footprint.
        context = undefined;
      }

      var newListener = {
        fn: fn,
        ctx: context
      },
          listeners = typeListeners; // check if fn already there

      for (var i = 0, len = listeners.length; i < len; i++) {
        if (listeners[i].fn === fn && listeners[i].ctx === context) {
          return;
        }
      }

      listeners.push(newListener);
    },
    _off: function (type, fn, context) {
      var listeners, i, len;

      if (!this._events) {
        return;
      }

      listeners = this._events[type];

      if (!listeners) {
        return;
      }

      if (!fn) {
        // Set all removed listeners to noop so they are not called if remove happens in fire
        for (i = 0, len = listeners.length; i < len; i++) {
          listeners[i].fn = falseFn;
        } // clear all listeners for a type if function isn't specified


        delete this._events[type];
        return;
      }

      if (context === this) {
        context = undefined;
      }

      if (listeners) {
        // find fn and remove it
        for (i = 0, len = listeners.length; i < len; i++) {
          var l = listeners[i];

          if (l.ctx !== context) {
            continue;
          }

          if (l.fn === fn) {
            // set the removed listener to noop so that's not called if remove happens in fire
            l.fn = falseFn;

            if (this._firingCount) {
              /* copy array in case events are being fired */
              this._events[type] = listeners = listeners.slice();
            }

            listeners.splice(i, 1);
            return;
          }
        }
      }
    },
    // @method fire(type: String, data?: Object, propagate?: Boolean): this
    // Fires an event of the specified type. You can optionally provide an data
    // object — the first argument of the listener function will contain its
    // properties. The event can optionally be propagated to event parents.
    fire: function (type, data, propagate) {
      if (!this.listens(type, propagate)) {
        return this;
      }

      var event = extend({}, data, {
        type: type,
        target: this,
        sourceTarget: data && data.sourceTarget || this
      });

      if (this._events) {
        var listeners = this._events[type];

        if (listeners) {
          this._firingCount = this._firingCount + 1 || 1;

          for (var i = 0, len = listeners.length; i < len; i++) {
            var l = listeners[i];
            l.fn.call(l.ctx || this, event);
          }

          this._firingCount--;
        }
      }

      if (propagate) {
        // propagate the event to parents (set with addEventParent)
        this._propagateEvent(event);
      }

      return this;
    },
    // @method listens(type: String): Boolean
    // Returns `true` if a particular event type has any listeners attached to it.
    listens: function (type, propagate) {
      var listeners = this._events && this._events[type];

      if (listeners && listeners.length) {
        return true;
      }

      if (propagate) {
        // also check parents for listeners if event propagates
        for (var id in this._eventParents) {
          if (this._eventParents[id].listens(type, propagate)) {
            return true;
          }
        }
      }

      return false;
    },
    // @method once(…): this
    // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
    once: function (types, fn, context) {
      if (typeof types === 'object') {
        for (var type in types) {
          this.once(type, types[type], fn);
        }

        return this;
      }

      var handler = bind(function () {
        this.off(types, fn, context).off(types, handler, context);
      }, this); // add a listener that's executed once and removed after that

      return this.on(types, fn, context).on(types, handler, context);
    },
    // @method addEventParent(obj: Evented): this
    // Adds an event parent - an `Evented` that will receive propagated events
    addEventParent: function (obj) {
      this._eventParents = this._eventParents || {};
      this._eventParents[stamp(obj)] = obj;
      return this;
    },
    // @method removeEventParent(obj: Evented): this
    // Removes an event parent, so it will stop receiving propagated events
    removeEventParent: function (obj) {
      if (this._eventParents) {
        delete this._eventParents[stamp(obj)];
      }

      return this;
    },
    _propagateEvent: function (e) {
      for (var id in this._eventParents) {
        this._eventParents[id].fire(e.type, extend({
          layer: e.target,
          propagatedFrom: e.target
        }, e), true);
      }
    }
  }; // aliases; we should ditch those eventually
  // @method addEventListener(…): this
  // Alias to [`on(…)`](#evented-on)

  Events.addEventListener = Events.on; // @method removeEventListener(…): this
  // Alias to [`off(…)`](#evented-off)
  // @method clearAllEventListeners(…): this
  // Alias to [`off()`](#evented-off)

  Events.removeEventListener = Events.clearAllEventListeners = Events.off; // @method addOneTimeEventListener(…): this
  // Alias to [`once(…)`](#evented-once)

  Events.addOneTimeEventListener = Events.once; // @method fireEvent(…): this
  // Alias to [`fire(…)`](#evented-fire)

  Events.fireEvent = Events.fire; // @method hasEventListeners(…): Boolean
  // Alias to [`listens(…)`](#evented-listens)

  Events.hasEventListeners = Events.listens;
  var Evented = Class.extend(Events);
  /*
   * @class Point
   * @aka L.Point
   *
   * Represents a point with `x` and `y` coordinates in pixels.
   *
   * @example
   *
   * ```js
   * var point = L.point(200, 300);
   * ```
   *
   * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
   *
   * ```js
   * map.panBy([200, 300]);
   * map.panBy(L.point(200, 300));
   * ```
   *
   * Note that `Point` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */

  function Point(x, y, round) {
    // @property x: Number; The `x` coordinate of the point
    this.x = round ? Math.round(x) : x; // @property y: Number; The `y` coordinate of the point

    this.y = round ? Math.round(y) : y;
  }

  var trunc = Math.trunc || function (v) {
    return v > 0 ? Math.floor(v) : Math.ceil(v);
  };

  Point.prototype = {
    // @method clone(): Point
    // Returns a copy of the current point.
    clone: function () {
      return new Point(this.x, this.y);
    },
    // @method add(otherPoint: Point): Point
    // Returns the result of addition of the current and the given points.
    add: function (point) {
      // non-destructive, returns a new point
      return this.clone()._add(toPoint(point));
    },
    _add: function (point) {
      // destructive, used directly for performance in situations where it's safe to modify existing point
      this.x += point.x;
      this.y += point.y;
      return this;
    },
    // @method subtract(otherPoint: Point): Point
    // Returns the result of subtraction of the given point from the current.
    subtract: function (point) {
      return this.clone()._subtract(toPoint(point));
    },
    _subtract: function (point) {
      this.x -= point.x;
      this.y -= point.y;
      return this;
    },
    // @method divideBy(num: Number): Point
    // Returns the result of division of the current point by the given number.
    divideBy: function (num) {
      return this.clone()._divideBy(num);
    },
    _divideBy: function (num) {
      this.x /= num;
      this.y /= num;
      return this;
    },
    // @method multiplyBy(num: Number): Point
    // Returns the result of multiplication of the current point by the given number.
    multiplyBy: function (num) {
      return this.clone()._multiplyBy(num);
    },
    _multiplyBy: function (num) {
      this.x *= num;
      this.y *= num;
      return this;
    },
    // @method scaleBy(scale: Point): Point
    // Multiply each coordinate of the current point by each coordinate of
    // `scale`. In linear algebra terms, multiply the point by the
    // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
    // defined by `scale`.
    scaleBy: function (point) {
      return new Point(this.x * point.x, this.y * point.y);
    },
    // @method unscaleBy(scale: Point): Point
    // Inverse of `scaleBy`. Divide each coordinate of the current point by
    // each coordinate of `scale`.
    unscaleBy: function (point) {
      return new Point(this.x / point.x, this.y / point.y);
    },
    // @method round(): Point
    // Returns a copy of the current point with rounded coordinates.
    round: function () {
      return this.clone()._round();
    },
    _round: function () {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    },
    // @method floor(): Point
    // Returns a copy of the current point with floored coordinates (rounded down).
    floor: function () {
      return this.clone()._floor();
    },
    _floor: function () {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    },
    // @method ceil(): Point
    // Returns a copy of the current point with ceiled coordinates (rounded up).
    ceil: function () {
      return this.clone()._ceil();
    },
    _ceil: function () {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    },
    // @method trunc(): Point
    // Returns a copy of the current point with truncated coordinates (rounded towards zero).
    trunc: function () {
      return this.clone()._trunc();
    },
    _trunc: function () {
      this.x = trunc(this.x);
      this.y = trunc(this.y);
      return this;
    },
    // @method distanceTo(otherPoint: Point): Number
    // Returns the cartesian distance between the current and the given points.
    distanceTo: function (point) {
      point = toPoint(point);
      var x = point.x - this.x,
          y = point.y - this.y;
      return Math.sqrt(x * x + y * y);
    },
    // @method equals(otherPoint: Point): Boolean
    // Returns `true` if the given point has the same coordinates.
    equals: function (point) {
      point = toPoint(point);
      return point.x === this.x && point.y === this.y;
    },
    // @method contains(otherPoint: Point): Boolean
    // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
    contains: function (point) {
      point = toPoint(point);
      return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
    },
    // @method toString(): String
    // Returns a string representation of the point for debugging purposes.
    toString: function () {
      return 'Point(' + formatNum(this.x) + ', ' + formatNum(this.y) + ')';
    }
  }; // @factory L.point(x: Number, y: Number, round?: Boolean)
  // Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.
  // @alternative
  // @factory L.point(coords: Number[])
  // Expects an array of the form `[x, y]` instead.
  // @alternative
  // @factory L.point(coords: Object)
  // Expects a plain object of the form `{x: Number, y: Number}` instead.

  function toPoint(x, y, round) {
    if (x instanceof Point) {
      return x;
    }

    if (isArray(x)) {
      return new Point(x[0], x[1]);
    }

    if (x === undefined || x === null) {
      return x;
    }

    if (typeof x === 'object' && 'x' in x && 'y' in x) {
      return new Point(x.x, x.y);
    }

    return new Point(x, y, round);
  }
  /*
   * @class Bounds
   * @aka L.Bounds
   *
   * Represents a rectangular area in pixel coordinates.
   *
   * @example
   *
   * ```js
   * var p1 = L.point(10, 10),
   * p2 = L.point(40, 60),
   * bounds = L.bounds(p1, p2);
   * ```
   *
   * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
   *
   * ```js
   * otherBounds.intersects([[10, 10], [40, 60]]);
   * ```
   *
   * Note that `Bounds` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */


  function Bounds(a, b) {
    if (!a) {
      return;
    }

    var points = b ? [a, b] : a;

    for (var i = 0, len = points.length; i < len; i++) {
      this.extend(points[i]);
    }
  }

  Bounds.prototype = {
    // @method extend(point: Point): this
    // Extends the bounds to contain the given point.
    extend: function (point) {
      // (Point)
      point = toPoint(point); // @property min: Point
      // The top left corner of the rectangle.
      // @property max: Point
      // The bottom right corner of the rectangle.

      if (!this.min && !this.max) {
        this.min = point.clone();
        this.max = point.clone();
      } else {
        this.min.x = Math.min(point.x, this.min.x);
        this.max.x = Math.max(point.x, this.max.x);
        this.min.y = Math.min(point.y, this.min.y);
        this.max.y = Math.max(point.y, this.max.y);
      }

      return this;
    },
    // @method getCenter(round?: Boolean): Point
    // Returns the center point of the bounds.
    getCenter: function (round) {
      return new Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);
    },
    // @method getBottomLeft(): Point
    // Returns the bottom-left point of the bounds.
    getBottomLeft: function () {
      return new Point(this.min.x, this.max.y);
    },
    // @method getTopRight(): Point
    // Returns the top-right point of the bounds.
    getTopRight: function () {
      // -> Point
      return new Point(this.max.x, this.min.y);
    },
    // @method getTopLeft(): Point
    // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
    getTopLeft: function () {
      return this.min; // left, top
    },
    // @method getBottomRight(): Point
    // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
    getBottomRight: function () {
      return this.max; // right, bottom
    },
    // @method getSize(): Point
    // Returns the size of the given bounds
    getSize: function () {
      return this.max.subtract(this.min);
    },
    // @method contains(otherBounds: Bounds): Boolean
    // Returns `true` if the rectangle contains the given one.
    // @alternative
    // @method contains(point: Point): Boolean
    // Returns `true` if the rectangle contains the given point.
    contains: function (obj) {
      var min, max;

      if (typeof obj[0] === 'number' || obj instanceof Point) {
        obj = toPoint(obj);
      } else {
        obj = toBounds(obj);
      }

      if (obj instanceof Bounds) {
        min = obj.min;
        max = obj.max;
      } else {
        min = max = obj;
      }

      return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
    },
    // @method intersects(otherBounds: Bounds): Boolean
    // Returns `true` if the rectangle intersects the given bounds. Two bounds
    // intersect if they have at least one point in common.
    intersects: function (bounds) {
      // (Bounds) -> Boolean
      bounds = toBounds(bounds);
      var min = this.min,
          max = this.max,
          min2 = bounds.min,
          max2 = bounds.max,
          xIntersects = max2.x >= min.x && min2.x <= max.x,
          yIntersects = max2.y >= min.y && min2.y <= max.y;
      return xIntersects && yIntersects;
    },
    // @method overlaps(otherBounds: Bounds): Boolean
    // Returns `true` if the rectangle overlaps the given bounds. Two bounds
    // overlap if their intersection is an area.
    overlaps: function (bounds) {
      // (Bounds) -> Boolean
      bounds = toBounds(bounds);
      var min = this.min,
          max = this.max,
          min2 = bounds.min,
          max2 = bounds.max,
          xOverlaps = max2.x > min.x && min2.x < max.x,
          yOverlaps = max2.y > min.y && min2.y < max.y;
      return xOverlaps && yOverlaps;
    },
    isValid: function () {
      return !!(this.min && this.max);
    }
  }; // @factory L.bounds(corner1: Point, corner2: Point)
  // Creates a Bounds object from two corners coordinate pairs.
  // @alternative
  // @factory L.bounds(points: Point[])
  // Creates a Bounds object from the given array of points.

  function toBounds(a, b) {
    if (!a || a instanceof Bounds) {
      return a;
    }

    return new Bounds(a, b);
  }
  /*
   * @class LatLngBounds
   * @aka L.LatLngBounds
   *
   * Represents a rectangular geographical area on a map.
   *
   * @example
   *
   * ```js
   * var corner1 = L.latLng(40.712, -74.227),
   * corner2 = L.latLng(40.774, -74.125),
   * bounds = L.latLngBounds(corner1, corner2);
   * ```
   *
   * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
   *
   * ```js
   * map.fitBounds([
   * 	[40.712, -74.227],
   * 	[40.774, -74.125]
   * ]);
   * ```
   *
   * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
   *
   * Note that `LatLngBounds` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */


  function LatLngBounds(corner1, corner2) {
    // (LatLng, LatLng) or (LatLng[])
    if (!corner1) {
      return;
    }

    var latlngs = corner2 ? [corner1, corner2] : corner1;

    for (var i = 0, len = latlngs.length; i < len; i++) {
      this.extend(latlngs[i]);
    }
  }

  LatLngBounds.prototype = {
    // @method extend(latlng: LatLng): this
    // Extend the bounds to contain the given point
    // @alternative
    // @method extend(otherBounds: LatLngBounds): this
    // Extend the bounds to contain the given bounds
    extend: function (obj) {
      var sw = this._southWest,
          ne = this._northEast,
          sw2,
          ne2;

      if (obj instanceof LatLng) {
        sw2 = obj;
        ne2 = obj;
      } else if (obj instanceof LatLngBounds) {
        sw2 = obj._southWest;
        ne2 = obj._northEast;

        if (!sw2 || !ne2) {
          return this;
        }
      } else {
        return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
      }

      if (!sw && !ne) {
        this._southWest = new LatLng(sw2.lat, sw2.lng);
        this._northEast = new LatLng(ne2.lat, ne2.lng);
      } else {
        sw.lat = Math.min(sw2.lat, sw.lat);
        sw.lng = Math.min(sw2.lng, sw.lng);
        ne.lat = Math.max(ne2.lat, ne.lat);
        ne.lng = Math.max(ne2.lng, ne.lng);
      }

      return this;
    },
    // @method pad(bufferRatio: Number): LatLngBounds
    // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
    // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
    // Negative values will retract the bounds.
    pad: function (bufferRatio) {
      var sw = this._southWest,
          ne = this._northEast,
          heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
          widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
      return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
    },
    // @method getCenter(): LatLng
    // Returns the center point of the bounds.
    getCenter: function () {
      return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
    },
    // @method getSouthWest(): LatLng
    // Returns the south-west point of the bounds.
    getSouthWest: function () {
      return this._southWest;
    },
    // @method getNorthEast(): LatLng
    // Returns the north-east point of the bounds.
    getNorthEast: function () {
      return this._northEast;
    },
    // @method getNorthWest(): LatLng
    // Returns the north-west point of the bounds.
    getNorthWest: function () {
      return new LatLng(this.getNorth(), this.getWest());
    },
    // @method getSouthEast(): LatLng
    // Returns the south-east point of the bounds.
    getSouthEast: function () {
      return new LatLng(this.getSouth(), this.getEast());
    },
    // @method getWest(): Number
    // Returns the west longitude of the bounds
    getWest: function () {
      return this._southWest.lng;
    },
    // @method getSouth(): Number
    // Returns the south latitude of the bounds
    getSouth: function () {
      return this._southWest.lat;
    },
    // @method getEast(): Number
    // Returns the east longitude of the bounds
    getEast: function () {
      return this._northEast.lng;
    },
    // @method getNorth(): Number
    // Returns the north latitude of the bounds
    getNorth: function () {
      return this._northEast.lat;
    },
    // @method contains(otherBounds: LatLngBounds): Boolean
    // Returns `true` if the rectangle contains the given one.
    // @alternative
    // @method contains (latlng: LatLng): Boolean
    // Returns `true` if the rectangle contains the given point.
    contains: function (obj) {
      // (LatLngBounds) or (LatLng) -> Boolean
      if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {
        obj = toLatLng(obj);
      } else {
        obj = toLatLngBounds(obj);
      }

      var sw = this._southWest,
          ne = this._northEast,
          sw2,
          ne2;

      if (obj instanceof LatLngBounds) {
        sw2 = obj.getSouthWest();
        ne2 = obj.getNorthEast();
      } else {
        sw2 = ne2 = obj;
      }

      return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
    },
    // @method intersects(otherBounds: LatLngBounds): Boolean
    // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
    intersects: function (bounds) {
      bounds = toLatLngBounds(bounds);
      var sw = this._southWest,
          ne = this._northEast,
          sw2 = bounds.getSouthWest(),
          ne2 = bounds.getNorthEast(),
          latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat,
          lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
      return latIntersects && lngIntersects;
    },
    // @method overlaps(otherBounds: LatLngBounds): Boolean
    // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
    overlaps: function (bounds) {
      bounds = toLatLngBounds(bounds);
      var sw = this._southWest,
          ne = this._northEast,
          sw2 = bounds.getSouthWest(),
          ne2 = bounds.getNorthEast(),
          latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat,
          lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
      return latOverlaps && lngOverlaps;
    },
    // @method toBBoxString(): String
    // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
    toBBoxString: function () {
      return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
    },
    // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
    // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
    equals: function (bounds, maxMargin) {
      if (!bounds) {
        return false;
      }

      bounds = toLatLngBounds(bounds);
      return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
    },
    // @method isValid(): Boolean
    // Returns `true` if the bounds are properly initialized.
    isValid: function () {
      return !!(this._southWest && this._northEast);
    }
  }; // TODO International date line?
  // @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
  // Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.
  // @alternative
  // @factory L.latLngBounds(latlngs: LatLng[])
  // Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).

  function toLatLngBounds(a, b) {
    if (a instanceof LatLngBounds) {
      return a;
    }

    return new LatLngBounds(a, b);
  }
  /* @class LatLng
   * @aka L.LatLng
   *
   * Represents a geographical point with a certain latitude and longitude.
   *
   * @example
   *
   * ```
   * var latlng = L.latLng(50.5, 30.5);
   * ```
   *
   * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
   *
   * ```
   * map.panTo([50, 30]);
   * map.panTo({lon: 30, lat: 50});
   * map.panTo({lat: 50, lng: 30});
   * map.panTo(L.latLng(50, 30));
   * ```
   *
   * Note that `LatLng` does not inherit from Leaflet's `Class` object,
   * which means new classes can't inherit from it, and new methods
   * can't be added to it with the `include` function.
   */


  function LatLng(lat, lng, alt) {
    if (isNaN(lat) || isNaN(lng)) {
      throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
    } // @property lat: Number
    // Latitude in degrees


    this.lat = +lat; // @property lng: Number
    // Longitude in degrees

    this.lng = +lng; // @property alt: Number
    // Altitude in meters (optional)

    if (alt !== undefined) {
      this.alt = +alt;
    }
  }

  LatLng.prototype = {
    // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
    // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
    equals: function (obj, maxMargin) {
      if (!obj) {
        return false;
      }

      obj = toLatLng(obj);
      var margin = Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng));
      return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
    },
    // @method toString(): String
    // Returns a string representation of the point (for debugging purposes).
    toString: function (precision) {
      return 'LatLng(' + formatNum(this.lat, precision) + ', ' + formatNum(this.lng, precision) + ')';
    },
    // @method distanceTo(otherLatLng: LatLng): Number
    // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
    distanceTo: function (other) {
      return Earth.distance(this, toLatLng(other));
    },
    // @method wrap(): LatLng
    // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
    wrap: function () {
      return Earth.wrapLatLng(this);
    },
    // @method toBounds(sizeInMeters: Number): LatLngBounds
    // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
    toBounds: function (sizeInMeters) {
      var latAccuracy = 180 * sizeInMeters / 40075017,
          lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
      return toLatLngBounds([this.lat - latAccuracy, this.lng - lngAccuracy], [this.lat + latAccuracy, this.lng + lngAccuracy]);
    },
    clone: function () {
      return new LatLng(this.lat, this.lng, this.alt);
    }
  }; // @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
  // Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).
  // @alternative
  // @factory L.latLng(coords: Array): LatLng
  // Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.
  // @alternative
  // @factory L.latLng(coords: Object): LatLng
  // Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

  function toLatLng(a, b, c) {
    if (a instanceof LatLng) {
      return a;
    }

    if (isArray(a) && typeof a[0] !== 'object') {
      if (a.length === 3) {
        return new LatLng(a[0], a[1], a[2]);
      }

      if (a.length === 2) {
        return new LatLng(a[0], a[1]);
      }

      return null;
    }

    if (a === undefined || a === null) {
      return a;
    }

    if (typeof a === 'object' && 'lat' in a) {
      return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
    }

    if (b === undefined) {
      return null;
    }

    return new LatLng(a, b, c);
  }
  /*
   * @namespace CRS
   * @crs L.CRS.Base
   * Object that defines coordinate reference systems for projecting
   * geographical points into pixel (screen) coordinates and back (and to
   * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
   * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
   *
   * Leaflet defines the most usual CRSs by default. If you want to use a
   * CRS not defined by default, take a look at the
   * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
   *
   * Note that the CRS instances do not inherit from Leaflet's `Class` object,
   * and can't be instantiated. Also, new classes can't inherit from them,
   * and methods can't be added to them with the `include` function.
   */


  var CRS = {
    // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
    // Projects geographical coordinates into pixel coordinates for a given zoom.
    latLngToPoint: function (latlng, zoom) {
      var projectedPoint = this.projection.project(latlng),
          scale = this.scale(zoom);
      return this.transformation._transform(projectedPoint, scale);
    },
    // @method pointToLatLng(point: Point, zoom: Number): LatLng
    // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
    // zoom into geographical coordinates.
    pointToLatLng: function (point, zoom) {
      var scale = this.scale(zoom),
          untransformedPoint = this.transformation.untransform(point, scale);
      return this.projection.unproject(untransformedPoint);
    },
    // @method project(latlng: LatLng): Point
    // Projects geographical coordinates into coordinates in units accepted for
    // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
    project: function (latlng) {
      return this.projection.project(latlng);
    },
    // @method unproject(point: Point): LatLng
    // Given a projected coordinate returns the corresponding LatLng.
    // The inverse of `project`.
    unproject: function (point) {
      return this.projection.unproject(point);
    },
    // @method scale(zoom: Number): Number
    // Returns the scale used when transforming projected coordinates into
    // pixel coordinates for a particular zoom. For example, it returns
    // `256 * 2^zoom` for Mercator-based CRS.
    scale: function (zoom) {
      return 256 * Math.pow(2, zoom);
    },
    // @method zoom(scale: Number): Number
    // Inverse of `scale()`, returns the zoom level corresponding to a scale
    // factor of `scale`.
    zoom: function (scale) {
      return Math.log(scale / 256) / Math.LN2;
    },
    // @method getProjectedBounds(zoom: Number): Bounds
    // Returns the projection's bounds scaled and transformed for the provided `zoom`.
    getProjectedBounds: function (zoom) {
      if (this.infinite) {
        return null;
      }

      var b = this.projection.bounds,
          s = this.scale(zoom),
          min = this.transformation.transform(b.min, s),
          max = this.transformation.transform(b.max, s);
      return new Bounds(min, max);
    },
    // @method distance(latlng1: LatLng, latlng2: LatLng): Number
    // Returns the distance between two geographical coordinates.
    // @property code: String
    // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
    //
    // @property wrapLng: Number[]
    // An array of two numbers defining whether the longitude (horizontal) coordinate
    // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
    // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
    //
    // @property wrapLat: Number[]
    // Like `wrapLng`, but for the latitude (vertical) axis.
    // wrapLng: [min, max],
    // wrapLat: [min, max],
    // @property infinite: Boolean
    // If true, the coordinate space will be unbounded (infinite in both axes)
    infinite: false,
    // @method wrapLatLng(latlng: LatLng): LatLng
    // Returns a `LatLng` where lat and lng has been wrapped according to the
    // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
    wrapLatLng: function (latlng) {
      var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
          lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
          alt = latlng.alt;
      return new LatLng(lat, lng, alt);
    },
    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
    // Returns a `LatLngBounds` with the same size as the given one, ensuring
    // that its center is within the CRS's bounds.
    // Only accepts actual `L.LatLngBounds` instances, not arrays.
    wrapLatLngBounds: function (bounds) {
      var center = bounds.getCenter(),
          newCenter = this.wrapLatLng(center),
          latShift = center.lat - newCenter.lat,
          lngShift = center.lng - newCenter.lng;

      if (latShift === 0 && lngShift === 0) {
        return bounds;
      }

      var sw = bounds.getSouthWest(),
          ne = bounds.getNorthEast(),
          newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),
          newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);
      return new LatLngBounds(newSw, newNe);
    }
  };
  /*
   * @namespace CRS
   * @crs L.CRS.Earth
   *
   * Serves as the base for CRS that are global such that they cover the earth.
   * Can only be used as the base for other CRS and cannot be used directly,
   * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
   * meters.
   */

  var Earth = extend({}, CRS, {
    wrapLng: [-180, 180],
    // Mean Earth Radius, as recommended for use by
    // the International Union of Geodesy and Geophysics,
    // see http://rosettacode.org/wiki/Haversine_formula
    R: 6371000,
    // distance between two geographical points using spherical law of cosines approximation
    distance: function (latlng1, latlng2) {
      var rad = Math.PI / 180,
          lat1 = latlng1.lat * rad,
          lat2 = latlng2.lat * rad,
          sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),
          sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),
          a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,
          c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return this.R * c;
    }
  });
  /*
   * @namespace Projection
   * @projection L.Projection.SphericalMercator
   *
   * Spherical Mercator projection — the most common projection for online maps,
   * used by almost all free and commercial tile providers. Assumes that Earth is
   * a sphere. Used by the `EPSG:3857` CRS.
   */

  var earthRadius = 6378137;
  var SphericalMercator = {
    R: earthRadius,
    MAX_LATITUDE: 85.0511287798,
    project: function (latlng) {
      var d = Math.PI / 180,
          max = this.MAX_LATITUDE,
          lat = Math.max(Math.min(max, latlng.lat), -max),
          sin = Math.sin(lat * d);
      return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);
    },
    unproject: function (point) {
      var d = 180 / Math.PI;
      return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);
    },
    bounds: function () {
      var d = earthRadius * Math.PI;
      return new Bounds([-d, -d], [d, d]);
    }()
  };
  /*
   * @class Transformation
   * @aka L.Transformation
   *
   * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
   * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
   * the reverse. Used by Leaflet in its projections code.
   *
   * @example
   *
   * ```js
   * var transformation = L.transformation(2, 5, -1, 10),
   * 	p = L.point(1, 2),
   * 	p2 = transformation.transform(p), //  L.point(7, 8)
   * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
   * ```
   */
  // factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
  // Creates a `Transformation` object with the given coefficients.

  function Transformation(a, b, c, d) {
    if (isArray(a)) {
      // use array properties
      this._a = a[0];
      this._b = a[1];
      this._c = a[2];
      this._d = a[3];
      return;
    }

    this._a = a;
    this._b = b;
    this._c = c;
    this._d = d;
  }

  Transformation.prototype = {
    // @method transform(point: Point, scale?: Number): Point
    // Returns a transformed point, optionally multiplied by the given scale.
    // Only accepts actual `L.Point` instances, not arrays.
    transform: function (point, scale) {
      // (Point, Number) -> Point
      return this._transform(point.clone(), scale);
    },
    // destructive transform (faster)
    _transform: function (point, scale) {
      scale = scale || 1;
      point.x = scale * (this._a * point.x + this._b);
      point.y = scale * (this._c * point.y + this._d);
      return point;
    },
    // @method untransform(point: Point, scale?: Number): Point
    // Returns the reverse transformation of the given point, optionally divided
    // by the given scale. Only accepts actual `L.Point` instances, not arrays.
    untransform: function (point, scale) {
      scale = scale || 1;
      return new Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);
    }
  }; // factory L.transformation(a: Number, b: Number, c: Number, d: Number)
  // @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
  // Instantiates a Transformation object with the given coefficients.
  // @alternative
  // @factory L.transformation(coefficients: Array): Transformation
  // Expects an coefficients array of the form
  // `[a: Number, b: Number, c: Number, d: Number]`.

  function toTransformation(a, b, c, d) {
    return new Transformation(a, b, c, d);
  }
  /*
   * @namespace CRS
   * @crs L.CRS.EPSG3857
   *
   * The most common CRS for online maps, used by almost all free and commercial
   * tile providers. Uses Spherical Mercator projection. Set in by default in
   * Map's `crs` option.
   */


  var EPSG3857 = extend({}, Earth, {
    code: 'EPSG:3857',
    projection: SphericalMercator,
    transformation: function () {
      var scale = 0.5 / (Math.PI * SphericalMercator.R);
      return toTransformation(scale, 0.5, -scale, 0.5);
    }()
  });
  var EPSG900913 = extend({}, EPSG3857, {
    code: 'EPSG:900913'
  }); // @namespace SVG; @section
  // There are several static functions which can be called without instantiating L.SVG:
  // @function create(name: String): SVGElement
  // Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
  // corresponding to the class name passed. For example, using 'line' will return
  // an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).

  function svgCreate(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
  } // @function pointsToPath(rings: Point[], closed: Boolean): String
  // Generates a SVG path string for multiple rings, with each ring turning
  // into "M..L..L.." instructions


  function pointsToPath(rings, closed) {
    var str = '',
        i,
        j,
        len,
        len2,
        points,
        p;

    for (i = 0, len = rings.length; i < len; i++) {
      points = rings[i];

      for (j = 0, len2 = points.length; j < len2; j++) {
        p = points[j];
        str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
      } // closes the ring for polygons; "x" is VML syntax


      str += closed ? svg ? 'z' : 'x' : '';
    } // SVG complains about empty path strings


    return str || 'M0 0';
  }
  /*
   * @namespace Browser
   * @aka L.Browser
   *
   * A namespace with static properties for browser/feature detection used by Leaflet internally.
   *
   * @example
   *
   * ```js
   * if (L.Browser.ielt9) {
   *   alert('Upgrade your browser, dude!');
   * }
   * ```
   */


  var style$1 = document.documentElement.style; // @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).

  var ie = ('ActiveXObject' in window); // @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.

  var ielt9 = ie && !document.addEventListener; // @property edge: Boolean; `true` for the Edge web browser.

  var edge = 'msLaunchUri' in navigator && !('documentMode' in document); // @property webkit: Boolean;
  // `true` for webkit-based browsers like Chrome and Safari (including mobile versions).

  var webkit = userAgentContains('webkit'); // @property android: Boolean
  // `true` for any browser running on an Android platform.

  var android = userAgentContains('android'); // @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.

  var android23 = userAgentContains('android 2') || userAgentContains('android 3');
  /* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */

  var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit
  // @property androidStock: Boolean; `true` for the Android stock browser (i.e. not Chrome)

  var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window); // @property opera: Boolean; `true` for the Opera browser

  var opera = !!window.opera; // @property chrome: Boolean; `true` for the Chrome browser.

  var chrome = !edge && userAgentContains('chrome'); // @property gecko: Boolean; `true` for gecko-based browsers like Firefox.

  var gecko = userAgentContains('gecko') && !webkit && !opera && !ie; // @property safari: Boolean; `true` for the Safari browser.

  var safari = !chrome && userAgentContains('safari');
  var phantom = userAgentContains('phantom'); // @property opera12: Boolean
  // `true` for the Opera browser supporting CSS transforms (version 12 or later).

  var opera12 = ('OTransition' in style$1); // @property win: Boolean; `true` when the browser is running in a Windows platform

  var win = navigator.platform.indexOf('Win') === 0; // @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.

  var ie3d = ie && 'transition' in style$1; // @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.

  var webkit3d = 'WebKitCSSMatrix' in window && 'm11' in new window.WebKitCSSMatrix() && !android23; // @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.

  var gecko3d = ('MozPerspective' in style$1); // @property any3d: Boolean
  // `true` for all browsers supporting CSS transforms.

  var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom; // @property mobile: Boolean; `true` for all browsers running in a mobile device.

  var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile'); // @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.

  var mobileWebkit = mobile && webkit; // @property mobileWebkit3d: Boolean
  // `true` for all webkit-based browsers in a mobile device supporting CSS transforms.

  var mobileWebkit3d = mobile && webkit3d; // @property msPointer: Boolean
  // `true` for browsers implementing the Microsoft touch events model (notably IE10).

  var msPointer = !window.PointerEvent && window.MSPointerEvent; // @property pointer: Boolean
  // `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).

  var pointer = !!(window.PointerEvent || msPointer); // @property touch: Boolean
  // `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
  // This does not necessarily mean that the browser is running in a computer with
  // a touchscreen, it only means that the browser is capable of understanding
  // touch events.

  var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch); // @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.

  var mobileOpera = mobile && opera; // @property mobileGecko: Boolean
  // `true` for gecko-based browsers running in a mobile device.

  var mobileGecko = mobile && gecko; // @property retina: Boolean
  // `true` for browsers on a high-resolution "retina" screen or on any screen when browser's display zoom is more than 100%.

  var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1; // @property passiveEvents: Boolean
  // `true` for browsers that support passive events.

  var passiveEvents = function () {
    var supportsPassiveOption = false;

    try {
      var opts = Object.defineProperty({}, 'passive', {
        get: function () {
          // eslint-disable-line getter-return
          supportsPassiveOption = true;
        }
      });
      window.addEventListener('testPassiveEventSupport', falseFn, opts);
      window.removeEventListener('testPassiveEventSupport', falseFn, opts);
    } catch (e) {// Errors can safely be ignored since this is only a browser support test.
    }

    return supportsPassiveOption;
  }(); // @property canvas: Boolean
  // `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).


  var canvas = function () {
    return !!document.createElement('canvas').getContext;
  }(); // @property svg: Boolean
  // `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).


  var svg = !!(document.createElementNS && svgCreate('svg').createSVGRect); // @property vml: Boolean
  // `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).

  var vml = !svg && function () {
    try {
      var div = document.createElement('div');
      div.innerHTML = '<v:shape adj="1"/>';
      var shape = div.firstChild;
      shape.style.behavior = 'url(#default#VML)';
      return shape && typeof shape.adj === 'object';
    } catch (e) {
      return false;
    }
  }();

  function userAgentContains(str) {
    return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
  }

  var Browser = {
    ie: ie,
    ielt9: ielt9,
    edge: edge,
    webkit: webkit,
    android: android,
    android23: android23,
    androidStock: androidStock,
    opera: opera,
    chrome: chrome,
    gecko: gecko,
    safari: safari,
    phantom: phantom,
    opera12: opera12,
    win: win,
    ie3d: ie3d,
    webkit3d: webkit3d,
    gecko3d: gecko3d,
    any3d: any3d,
    mobile: mobile,
    mobileWebkit: mobileWebkit,
    mobileWebkit3d: mobileWebkit3d,
    msPointer: msPointer,
    pointer: pointer,
    touch: touch,
    mobileOpera: mobileOpera,
    mobileGecko: mobileGecko,
    retina: retina,
    passiveEvents: passiveEvents,
    canvas: canvas,
    svg: svg,
    vml: vml
  };
  /*
   * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
   */

  var POINTER_DOWN = msPointer ? 'MSPointerDown' : 'pointerdown';
  var POINTER_MOVE = msPointer ? 'MSPointerMove' : 'pointermove';
  var POINTER_UP = msPointer ? 'MSPointerUp' : 'pointerup';
  var POINTER_CANCEL = msPointer ? 'MSPointerCancel' : 'pointercancel';
  var _pointers = {};
  var _pointerDocListener = false; // Provides a touch events wrapper for (ms)pointer events.
  // ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

  function addPointerListener(obj, type, handler, id) {
    if (type === 'touchstart') {
      _addPointerStart(obj, handler, id);
    } else if (type === 'touchmove') {
      _addPointerMove(obj, handler, id);
    } else if (type === 'touchend') {
      _addPointerEnd(obj, handler, id);
    }

    return this;
  }

  function removePointerListener(obj, type, id) {
    var handler = obj['_leaflet_' + type + id];

    if (type === 'touchstart') {
      obj.removeEventListener(POINTER_DOWN, handler, false);
    } else if (type === 'touchmove') {
      obj.removeEventListener(POINTER_MOVE, handler, false);
    } else if (type === 'touchend') {
      obj.removeEventListener(POINTER_UP, handler, false);
      obj.removeEventListener(POINTER_CANCEL, handler, false);
    }

    return this;
  }

  function _addPointerStart(obj, handler, id) {
    var onDown = bind(function (e) {
      // IE10 specific: MsTouch needs preventDefault. See #2000
      if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
        preventDefault(e);
      }

      _handlePointer(e, handler);
    });
    obj['_leaflet_touchstart' + id] = onDown;
    obj.addEventListener(POINTER_DOWN, onDown, false); // need to keep track of what pointers and how many are active to provide e.touches emulation

    if (!_pointerDocListener) {
      // we listen document as any drags that end by moving the touch off the screen get fired there
      document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
      document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
      document.addEventListener(POINTER_UP, _globalPointerUp, true);
      document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
      _pointerDocListener = true;
    }
  }

  function _globalPointerDown(e) {
    _pointers[e.pointerId] = e;
  }

  function _globalPointerMove(e) {
    if (_pointers[e.pointerId]) {
      _pointers[e.pointerId] = e;
    }
  }

  function _globalPointerUp(e) {
    delete _pointers[e.pointerId];
  }

  function _handlePointer(e, handler) {
    e.touches = [];

    for (var i in _pointers) {
      e.touches.push(_pointers[i]);
    }

    e.changedTouches = [e];
    handler(e);
  }

  function _addPointerMove(obj, handler, id) {
    var onMove = function (e) {
      // don't fire touch moves when mouse isn't down
      if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || 'mouse') && e.buttons === 0) {
        return;
      }

      _handlePointer(e, handler);
    };

    obj['_leaflet_touchmove' + id] = onMove;
    obj.addEventListener(POINTER_MOVE, onMove, false);
  }

  function _addPointerEnd(obj, handler, id) {
    var onUp = function (e) {
      _handlePointer(e, handler);
    };

    obj['_leaflet_touchend' + id] = onUp;
    obj.addEventListener(POINTER_UP, onUp, false);
    obj.addEventListener(POINTER_CANCEL, onUp, false);
  }
  /*
   * Extends the event handling code with double tap support for mobile browsers.
   */


  var _touchstart = msPointer ? 'MSPointerDown' : pointer ? 'pointerdown' : 'touchstart';

  var _touchend = msPointer ? 'MSPointerUp' : pointer ? 'pointerup' : 'touchend';

  var _pre = '_leaflet_'; // inspired by Zepto touch code by Thomas Fuchs

  function addDoubleTapListener(obj, handler, id) {
    var last,
        touch$$1,
        doubleTap = false,
        delay = 250;

    function onTouchStart(e) {
      if (pointer) {
        if (!e.isPrimary) {
          return;
        }

        if (e.pointerType === 'mouse') {
          return;
        } // mouse fires native dblclick

      } else if (e.touches.length > 1) {
        return;
      }

      var now = Date.now(),
          delta = now - (last || now);
      touch$$1 = e.touches ? e.touches[0] : e;
      doubleTap = delta > 0 && delta <= delay;
      last = now;
    }

    function onTouchEnd(e) {
      if (doubleTap && !touch$$1.cancelBubble) {
        if (pointer) {
          if (e.pointerType === 'mouse') {
            return;
          } // work around .type being readonly with MSPointer* events


          var newTouch = {},
              prop,
              i;

          for (i in touch$$1) {
            prop = touch$$1[i];
            newTouch[i] = prop && prop.bind ? prop.bind(touch$$1) : prop;
          }

          touch$$1 = newTouch;
        }

        touch$$1.type = 'dblclick';
        touch$$1.button = 0;
        handler(touch$$1);
        last = null;
      }
    }

    obj[_pre + _touchstart + id] = onTouchStart;
    obj[_pre + _touchend + id] = onTouchEnd;
    obj[_pre + 'dblclick' + id] = handler;
    obj.addEventListener(_touchstart, onTouchStart, passiveEvents ? {
      passive: false
    } : false);
    obj.addEventListener(_touchend, onTouchEnd, passiveEvents ? {
      passive: false
    } : false); // On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),
    // the browser doesn't fire touchend/pointerup events but does fire
    // native dblclicks. See #4127.
    // Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.

    obj.addEventListener('dblclick', handler, false);
    return this;
  }

  function removeDoubleTapListener(obj, id) {
    var touchstart = obj[_pre + _touchstart + id],
        touchend = obj[_pre + _touchend + id],
        dblclick = obj[_pre + 'dblclick' + id];
    obj.removeEventListener(_touchstart, touchstart, passiveEvents ? {
      passive: false
    } : false);
    obj.removeEventListener(_touchend, touchend, passiveEvents ? {
      passive: false
    } : false);
    obj.removeEventListener('dblclick', dblclick, false);
    return this;
  }
  /*
   * @namespace DomUtil
   *
   * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
   * tree, used by Leaflet internally.
   *
   * Most functions expecting or returning a `HTMLElement` also work for
   * SVG elements. The only difference is that classes refer to CSS classes
   * in HTML and SVG classes in SVG.
   */
  // @property TRANSFORM: String
  // Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).


  var TRANSFORM = testProp(['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']); // webkitTransition comes first because some browser versions that drop vendor prefix don't do
  // the same for the transitionend event, in particular the Android 4.1 stock browser
  // @property TRANSITION: String
  // Vendor-prefixed transition style name.

  var TRANSITION = testProp(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']); // @property TRANSITION_END: String
  // Vendor-prefixed transitionend event name.

  var TRANSITION_END = TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend'; // @function get(id: String|HTMLElement): HTMLElement
  // Returns an element given its DOM id, or returns the element itself
  // if it was passed directly.

  function get(id) {
    return typeof id === 'string' ? document.getElementById(id) : id;
  } // @function getStyle(el: HTMLElement, styleAttrib: String): String
  // Returns the value for a certain style attribute on an element,
  // including computed values or values set through CSS.


  function getStyle(el, style) {
    var value = el.style[style] || el.currentStyle && el.currentStyle[style];

    if ((!value || value === 'auto') && document.defaultView) {
      var css = document.defaultView.getComputedStyle(el, null);
      value = css ? css[style] : null;
    }

    return value === 'auto' ? null : value;
  } // @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
  // Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.


  function create$1(tagName, className, container) {
    var el = document.createElement(tagName);
    el.className = className || '';

    if (container) {
      container.appendChild(el);
    }

    return el;
  } // @function remove(el: HTMLElement)
  // Removes `el` from its parent element


  function remove(el) {
    var parent = el.parentNode;

    if (parent) {
      parent.removeChild(el);
    }
  } // @function empty(el: HTMLElement)
  // Removes all of `el`'s children elements from `el`


  function empty(el) {
    while (el.firstChild) {
      el.removeChild(el.firstChild);
    }
  } // @function toFront(el: HTMLElement)
  // Makes `el` the last child of its parent, so it renders in front of the other children.


  function toFront(el) {
    var parent = el.parentNode;

    if (parent && parent.lastChild !== el) {
      parent.appendChild(el);
    }
  } // @function toBack(el: HTMLElement)
  // Makes `el` the first child of its parent, so it renders behind the other children.


  function toBack(el) {
    var parent = el.parentNode;

    if (parent && parent.firstChild !== el) {
      parent.insertBefore(el, parent.firstChild);
    }
  } // @function hasClass(el: HTMLElement, name: String): Boolean
  // Returns `true` if the element's class attribute contains `name`.


  function hasClass(el, name) {
    if (el.classList !== undefined) {
      return el.classList.contains(name);
    }

    var className = getClass(el);
    return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
  } // @function addClass(el: HTMLElement, name: String)
  // Adds `name` to the element's class attribute.


  function addClass(el, name) {
    if (el.classList !== undefined) {
      var classes = splitWords(name);

      for (var i = 0, len = classes.length; i < len; i++) {
        el.classList.add(classes[i]);
      }
    } else if (!hasClass(el, name)) {
      var className = getClass(el);
      setClass(el, (className ? className + ' ' : '') + name);
    }
  } // @function removeClass(el: HTMLElement, name: String)
  // Removes `name` from the element's class attribute.


  function removeClass(el, name) {
    if (el.classList !== undefined) {
      el.classList.remove(name);
    } else {
      setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
    }
  } // @function setClass(el: HTMLElement, name: String)
  // Sets the element's class.


  function setClass(el, name) {
    if (el.className.baseVal === undefined) {
      el.className = name;
    } else {
      // in case of SVG element
      el.className.baseVal = name;
    }
  } // @function getClass(el: HTMLElement): String
  // Returns the element's class.


  function getClass(el) {
    // Check if the element is an SVGElementInstance and use the correspondingElement instead
    // (Required for linked SVG elements in IE11.)
    if (el.correspondingElement) {
      el = el.correspondingElement;
    }

    return el.className.baseVal === undefined ? el.className : el.className.baseVal;
  } // @function setOpacity(el: HTMLElement, opacity: Number)
  // Set the opacity of an element (including old IE support).
  // `opacity` must be a number from `0` to `1`.


  function setOpacity(el, value) {
    if ('opacity' in el.style) {
      el.style.opacity = value;
    } else if ('filter' in el.style) {
      _setOpacityIE(el, value);
    }
  }

  function _setOpacityIE(el, value) {
    var filter = false,
        filterName = 'DXImageTransform.Microsoft.Alpha'; // filters collection throws an error if we try to retrieve a filter that doesn't exist

    try {
      filter = el.filters.item(filterName);
    } catch (e) {
      // don't set opacity to 1 if we haven't already set an opacity,
      // it isn't needed and breaks transparent pngs.
      if (value === 1) {
        return;
      }
    }

    value = Math.round(value * 100);

    if (filter) {
      filter.Enabled = value !== 100;
      filter.Opacity = value;
    } else {
      el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
    }
  } // @function testProp(props: String[]): String|false
  // Goes through the array of style names and returns the first name
  // that is a valid style name for an element. If no such name is found,
  // it returns false. Useful for vendor-prefixed styles like `transform`.


  function testProp(props) {
    var style = document.documentElement.style;

    for (var i = 0; i < props.length; i++) {
      if (props[i] in style) {
        return props[i];
      }
    }

    return false;
  } // @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
  // Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
  // and optionally scaled by `scale`. Does not have an effect if the
  // browser doesn't support 3D CSS transforms.


  function setTransform(el, offset, scale) {
    var pos = offset || new Point(0, 0);
    el.style[TRANSFORM] = (ie3d ? 'translate(' + pos.x + 'px,' + pos.y + 'px)' : 'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') + (scale ? ' scale(' + scale + ')' : '');
  } // @function setPosition(el: HTMLElement, position: Point)
  // Sets the position of `el` to coordinates specified by `position`,
  // using CSS translate or top/left positioning depending on the browser
  // (used by Leaflet internally to position its layers).


  function setPosition(el, point) {
    /*eslint-disable */
    el._leaflet_pos = point;
    /* eslint-enable */

    if (any3d) {
      setTransform(el, point);
    } else {
      el.style.left = point.x + 'px';
      el.style.top = point.y + 'px';
    }
  } // @function getPosition(el: HTMLElement): Point
  // Returns the coordinates of an element previously positioned with setPosition.


  function getPosition(el) {
    // this method is only used for elements previously positioned using setPosition,
    // so it's safe to cache the position for performance
    return el._leaflet_pos || new Point(0, 0);
  } // @function disableTextSelection()
  // Prevents the user from generating `selectstart` DOM events, usually generated
  // when the user drags the mouse through a page with text. Used internally
  // by Leaflet to override the behaviour of any click-and-drag interaction on
  // the map. Affects drag interactions on the whole document.
  // @function enableTextSelection()
  // Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).


  var disableTextSelection;
  var enableTextSelection;

  var _userSelect;

  if ('onselectstart' in document) {
    disableTextSelection = function () {
      on(window, 'selectstart', preventDefault);
    };

    enableTextSelection = function () {
      off(window, 'selectstart', preventDefault);
    };
  } else {
    var userSelectProperty = testProp(['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

    disableTextSelection = function () {
      if (userSelectProperty) {
        var style = document.documentElement.style;
        _userSelect = style[userSelectProperty];
        style[userSelectProperty] = 'none';
      }
    };

    enableTextSelection = function () {
      if (userSelectProperty) {
        document.documentElement.style[userSelectProperty] = _userSelect;
        _userSelect = undefined;
      }
    };
  } // @function disableImageDrag()
  // As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
  // for `dragstart` DOM events, usually generated when the user drags an image.


  function disableImageDrag() {
    on(window, 'dragstart', preventDefault);
  } // @function enableImageDrag()
  // Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).


  function enableImageDrag() {
    off(window, 'dragstart', preventDefault);
  }

  var _outlineElement, _outlineStyle; // @function preventOutline(el: HTMLElement)
  // Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
  // of the element `el` invisible. Used internally by Leaflet to prevent
  // focusable elements from displaying an outline when the user performs a
  // drag interaction on them.


  function preventOutline(element) {
    while (element.tabIndex === -1) {
      element = element.parentNode;
    }

    if (!element.style) {
      return;
    }

    restoreOutline();
    _outlineElement = element;
    _outlineStyle = element.style.outline;
    element.style.outline = 'none';
    on(window, 'keydown', restoreOutline);
  } // @function restoreOutline()
  // Cancels the effects of a previous [`L.DomUtil.preventOutline`]().


  function restoreOutline() {
    if (!_outlineElement) {
      return;
    }

    _outlineElement.style.outline = _outlineStyle;
    _outlineElement = undefined;
    _outlineStyle = undefined;
    off(window, 'keydown', restoreOutline);
  } // @function getSizedParentNode(el: HTMLElement): HTMLElement
  // Finds the closest parent node which size (width and height) is not null.


  function getSizedParentNode(element) {
    do {
      element = element.parentNode;
    } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);

    return element;
  } // @function getScale(el: HTMLElement): Object
  // Computes the CSS scale currently applied on the element.
  // Returns an object with `x` and `y` members as horizontal and vertical scales respectively,
  // and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).


  function getScale(element) {
    var rect = element.getBoundingClientRect(); // Read-only in old browsers.

    return {
      x: rect.width / element.offsetWidth || 1,
      y: rect.height / element.offsetHeight || 1,
      boundingClientRect: rect
    };
  }

  var DomUtil = {
    TRANSFORM: TRANSFORM,
    TRANSITION: TRANSITION,
    TRANSITION_END: TRANSITION_END,
    get: get,
    getStyle: getStyle,
    create: create$1,
    remove: remove,
    empty: empty,
    toFront: toFront,
    toBack: toBack,
    hasClass: hasClass,
    addClass: addClass,
    removeClass: removeClass,
    setClass: setClass,
    getClass: getClass,
    setOpacity: setOpacity,
    testProp: testProp,
    setTransform: setTransform,
    setPosition: setPosition,
    getPosition: getPosition,
    disableTextSelection: disableTextSelection,
    enableTextSelection: enableTextSelection,
    disableImageDrag: disableImageDrag,
    enableImageDrag: enableImageDrag,
    preventOutline: preventOutline,
    restoreOutline: restoreOutline,
    getSizedParentNode: getSizedParentNode,
    getScale: getScale
  };
  /*
   * @namespace DomEvent
   * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
   */
  // Inspired by John Resig, Dean Edwards and YUI addEvent implementations.
  // @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
  // Adds a listener function (`fn`) to a particular DOM event type of the
  // element `el`. You can optionally specify the context of the listener
  // (object the `this` keyword will point to). You can also pass several
  // space-separated types (e.g. `'click dblclick'`).
  // @alternative
  // @function on(el: HTMLElement, eventMap: Object, context?: Object): this
  // Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`

  function on(obj, types, fn, context) {
    if (typeof types === 'object') {
      for (var type in types) {
        addOne(obj, type, types[type], fn);
      }
    } else {
      types = splitWords(types);

      for (var i = 0, len = types.length; i < len; i++) {
        addOne(obj, types[i], fn, context);
      }
    }

    return this;
  }

  var eventsKey = '_leaflet_events'; // @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
  // Removes a previously added listener function.
  // Note that if you passed a custom context to on, you must pass the same
  // context to `off` in order to remove the listener.
  // @alternative
  // @function off(el: HTMLElement, eventMap: Object, context?: Object): this
  // Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`

  function off(obj, types, fn, context) {
    if (typeof types === 'object') {
      for (var type in types) {
        removeOne(obj, type, types[type], fn);
      }
    } else if (types) {
      types = splitWords(types);

      for (var i = 0, len = types.length; i < len; i++) {
        removeOne(obj, types[i], fn, context);
      }
    } else {
      for (var j in obj[eventsKey]) {
        removeOne(obj, j, obj[eventsKey][j]);
      }

      delete obj[eventsKey];
    }

    return this;
  }

  function browserFiresNativeDblClick() {
    // See https://github.com/w3c/pointerevents/issues/171
    if (pointer) {
      return !(edge || safari);
    }
  }

  var mouseSubst = {
    mouseenter: 'mouseover',
    mouseleave: 'mouseout',
    wheel: !('onwheel' in window) && 'mousewheel'
  };

  function addOne(obj, type, fn, context) {
    var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');

    if (obj[eventsKey] && obj[eventsKey][id]) {
      return this;
    }

    var handler = function (e) {
      return fn.call(context || obj, e || window.event);
    };

    var originalHandler = handler;

    if (pointer && type.indexOf('touch') === 0) {
      // Needs DomEvent.Pointer.js
      addPointerListener(obj, type, handler, id);
    } else if (touch && type === 'dblclick' && !browserFiresNativeDblClick()) {
      addDoubleTapListener(obj, handler, id);
    } else if ('addEventListener' in obj) {
      if (type === 'touchstart' || type === 'touchmove' || type === 'wheel' || type === 'mousewheel') {
        obj.addEventListener(mouseSubst[type] || type, handler, passiveEvents ? {
          passive: false
        } : false);
      } else if (type === 'mouseenter' || type === 'mouseleave') {
        handler = function (e) {
          e = e || window.event;

          if (isExternalTarget(obj, e)) {
            originalHandler(e);
          }
        };

        obj.addEventListener(mouseSubst[type], handler, false);
      } else {
        obj.addEventListener(type, originalHandler, false);
      }
    } else if ('attachEvent' in obj) {
      obj.attachEvent('on' + type, handler);
    }

    obj[eventsKey] = obj[eventsKey] || {};
    obj[eventsKey][id] = handler;
  }

  function removeOne(obj, type, fn, context) {
    var id = type + stamp(fn) + (context ? '_' + stamp(context) : ''),
        handler = obj[eventsKey] && obj[eventsKey][id];

    if (!handler) {
      return this;
    }

    if (pointer && type.indexOf('touch') === 0) {
      removePointerListener(obj, type, id);
    } else if (touch && type === 'dblclick' && !browserFiresNativeDblClick()) {
      removeDoubleTapListener(obj, id);
    } else if ('removeEventListener' in obj) {
      obj.removeEventListener(mouseSubst[type] || type, handler, false);
    } else if ('detachEvent' in obj) {
      obj.detachEvent('on' + type, handler);
    }

    obj[eventsKey][id] = null;
  } // @function stopPropagation(ev: DOMEvent): this
  // Stop the given event from propagation to parent elements. Used inside the listener functions:
  // ```js
  // L.DomEvent.on(div, 'click', function (ev) {
  // 	L.DomEvent.stopPropagation(ev);
  // });
  // ```


  function stopPropagation(e) {
    if (e.stopPropagation) {
      e.stopPropagation();
    } else if (e.originalEvent) {
      // In case of Leaflet event.
      e.originalEvent._stopped = true;
    } else {
      e.cancelBubble = true;
    }

    skipped(e);
    return this;
  } // @function disableScrollPropagation(el: HTMLElement): this
  // Adds `stopPropagation` to the element's `'wheel'` events (plus browser variants).


  function disableScrollPropagation(el) {
    addOne(el, 'wheel', stopPropagation);
    return this;
  } // @function disableClickPropagation(el: HTMLElement): this
  // Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
  // `'mousedown'` and `'touchstart'` events (plus browser variants).


  function disableClickPropagation(el) {
    on(el, 'mousedown touchstart dblclick', stopPropagation);
    addOne(el, 'click', fakeStop);
    return this;
  } // @function preventDefault(ev: DOMEvent): this
  // Prevents the default action of the DOM Event `ev` from happening (such as
  // following a link in the href of the a element, or doing a POST request
  // with page reload when a `<form>` is submitted).
  // Use it inside listener functions.


  function preventDefault(e) {
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.returnValue = false;
    }

    return this;
  } // @function stop(ev: DOMEvent): this
  // Does `stopPropagation` and `preventDefault` at the same time.


  function stop(e) {
    preventDefault(e);
    stopPropagation(e);
    return this;
  } // @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
  // Gets normalized mouse position from a DOM event relative to the
  // `container` (border excluded) or to the whole page if not specified.


  function getMousePosition(e, container) {
    if (!container) {
      return new Point(e.clientX, e.clientY);
    }

    var scale = getScale(container),
        offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)

    return new Point( // offset.left/top values are in page scale (like clientX/Y),
    // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
    (e.clientX - offset.left) / scale.x - container.clientLeft, (e.clientY - offset.top) / scale.y - container.clientTop);
  } // Chrome on Win scrolls double the pixels as in other platforms (see #4538),
  // and Firefox scrolls device pixels, not CSS pixels


  var wheelPxFactor = win && chrome ? 2 * window.devicePixelRatio : gecko ? window.devicePixelRatio : 1; // @function getWheelDelta(ev: DOMEvent): Number
  // Gets normalized wheel delta from a wheel DOM event, in vertical
  // pixels scrolled (negative if scrolling down).
  // Events from pointing devices without precise scrolling are mapped to
  // a best guess of 60 pixels.

  function getWheelDelta(e) {
    return edge ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
    e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : // Pixels
    e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : // Lines
    e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : // Pages
    e.deltaX || e.deltaZ ? 0 : // Skip horizontal/depth wheel events
    e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
    e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : // Legacy Moz lines
    e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
    0;
  }

  var skipEvents = {};

  function fakeStop(e) {
    // fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)
    skipEvents[e.type] = true;
  }

  function skipped(e) {
    var events = skipEvents[e.type]; // reset when checking, as it's only used in map container and propagates outside of the map

    skipEvents[e.type] = false;
    return events;
  } // check if element really left/entered the event target (for mouseenter/mouseleave)


  function isExternalTarget(el, e) {
    var related = e.relatedTarget;

    if (!related) {
      return true;
    }

    try {
      while (related && related !== el) {
        related = related.parentNode;
      }
    } catch (err) {
      return false;
    }

    return related !== el;
  }

  var DomEvent = {
    on: on,
    off: off,
    stopPropagation: stopPropagation,
    disableScrollPropagation: disableScrollPropagation,
    disableClickPropagation: disableClickPropagation,
    preventDefault: preventDefault,
    stop: stop,
    getMousePosition: getMousePosition,
    getWheelDelta: getWheelDelta,
    fakeStop: fakeStop,
    skipped: skipped,
    isExternalTarget: isExternalTarget,
    addListener: on,
    removeListener: off
  };
  /*
   * @class PosAnimation
   * @aka L.PosAnimation
   * @inherits Evented
   * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
   *
   * @example
   * ```js
   * var fx = new L.PosAnimation();
   * fx.run(el, [300, 500], 0.5);
   * ```
   *
   * @constructor L.PosAnimation()
   * Creates a `PosAnimation` object.
   *
   */

  var PosAnimation = Evented.extend({
    // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
    // Run an animation of a given element to a new position, optionally setting
    // duration in seconds (`0.25` by default) and easing linearity factor (3rd
    // argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
    // `0.5` by default).
    run: function (el, newPos, duration, easeLinearity) {
      this.stop();
      this._el = el;
      this._inProgress = true;
      this._duration = duration || 0.25;
      this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
      this._startPos = getPosition(el);
      this._offset = newPos.subtract(this._startPos);
      this._startTime = +new Date(); // @event start: Event
      // Fired when the animation starts

      this.fire('start');

      this._animate();
    },
    // @method stop()
    // Stops the animation (if currently running).
    stop: function () {
      if (!this._inProgress) {
        return;
      }

      this._step(true);

      this._complete();
    },
    _animate: function () {
      // animation loop
      this._animId = requestAnimFrame(this._animate, this);

      this._step();
    },
    _step: function (round) {
      var elapsed = +new Date() - this._startTime,
          duration = this._duration * 1000;

      if (elapsed < duration) {
        this._runFrame(this._easeOut(elapsed / duration), round);
      } else {
        this._runFrame(1);

        this._complete();
      }
    },
    _runFrame: function (progress, round) {
      var pos = this._startPos.add(this._offset.multiplyBy(progress));

      if (round) {
        pos._round();
      }

      setPosition(this._el, pos); // @event step: Event
      // Fired continuously during the animation.

      this.fire('step');
    },
    _complete: function () {
      cancelAnimFrame(this._animId);
      this._inProgress = false; // @event end: Event
      // Fired when the animation ends.

      this.fire('end');
    },
    _easeOut: function (t) {
      return 1 - Math.pow(1 - t, this._easeOutPower);
    }
  });
  /*
   * @class Map
   * @aka L.Map
   * @inherits Evented
   *
   * The central class of the API — it is used to create a map on a page and manipulate it.
   *
   * @example
   *
   * ```js
   * // initialize the map on the "map" div with a given center and zoom
   * var map = L.map('map', {
   * 	center: [51.505, -0.09],
   * 	zoom: 13
   * });
   * ```
   *
   */

  var Map = Evented.extend({
    options: {
      // @section Map State Options
      // @option crs: CRS = L.CRS.EPSG3857
      // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
      // sure what it means.
      crs: EPSG3857,
      // @option center: LatLng = undefined
      // Initial geographic center of the map
      center: undefined,
      // @option zoom: Number = undefined
      // Initial map zoom level
      zoom: undefined,
      // @option minZoom: Number = *
      // Minimum zoom level of the map.
      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
      // the lowest of their `minZoom` options will be used instead.
      minZoom: undefined,
      // @option maxZoom: Number = *
      // Maximum zoom level of the map.
      // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
      // the highest of their `maxZoom` options will be used instead.
      maxZoom: undefined,
      // @option layers: Layer[] = []
      // Array of layers that will be added to the map initially
      layers: [],
      // @option maxBounds: LatLngBounds = null
      // When this option is set, the map restricts the view to the given
      // geographical bounds, bouncing the user back if the user tries to pan
      // outside the view. To set the restriction dynamically, use
      // [`setMaxBounds`](#map-setmaxbounds) method.
      maxBounds: undefined,
      // @option renderer: Renderer = *
      // The default method for drawing vector layers on the map. `L.SVG`
      // or `L.Canvas` by default depending on browser support.
      renderer: undefined,
      // @section Animation Options
      // @option zoomAnimation: Boolean = true
      // Whether the map zoom animation is enabled. By default it's enabled
      // in all browsers that support CSS3 Transitions except Android.
      zoomAnimation: true,
      // @option zoomAnimationThreshold: Number = 4
      // Won't animate zoom if the zoom difference exceeds this value.
      zoomAnimationThreshold: 4,
      // @option fadeAnimation: Boolean = true
      // Whether the tile fade animation is enabled. By default it's enabled
      // in all browsers that support CSS3 Transitions except Android.
      fadeAnimation: true,
      // @option markerZoomAnimation: Boolean = true
      // Whether markers animate their zoom with the zoom animation, if disabled
      // they will disappear for the length of the animation. By default it's
      // enabled in all browsers that support CSS3 Transitions except Android.
      markerZoomAnimation: true,
      // @option transform3DLimit: Number = 2^23
      // Defines the maximum size of a CSS translation transform. The default
      // value should not be changed unless a web browser positions layers in
      // the wrong place after doing a large `panBy`.
      transform3DLimit: 8388608,
      // Precision limit of a 32-bit float
      // @section Interaction Options
      // @option zoomSnap: Number = 1
      // Forces the map's zoom level to always be a multiple of this, particularly
      // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
      // By default, the zoom level snaps to the nearest integer; lower values
      // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
      // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
      zoomSnap: 1,
      // @option zoomDelta: Number = 1
      // Controls how much the map's zoom level will change after a
      // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
      // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
      // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
      zoomDelta: 1,
      // @option trackResize: Boolean = true
      // Whether the map automatically handles browser window resize to update itself.
      trackResize: true
    },
    initialize: function (id, options) {
      // (HTMLElement or String, Object)
      options = setOptions(this, options); // Make sure to assign internal flags at the beginning,
      // to avoid inconsistent state in some edge cases.

      this._handlers = [];
      this._layers = {};
      this._zoomBoundLayers = {};
      this._sizeChanged = true;

      this._initContainer(id);

      this._initLayout(); // hack for https://github.com/Leaflet/Leaflet/issues/1980


      this._onResize = bind(this._onResize, this);

      this._initEvents();

      if (options.maxBounds) {
        this.setMaxBounds(options.maxBounds);
      }

      if (options.zoom !== undefined) {
        this._zoom = this._limitZoom(options.zoom);
      }

      if (options.center && options.zoom !== undefined) {
        this.setView(toLatLng(options.center), options.zoom, {
          reset: true
        });
      }

      this.callInitHooks(); // don't animate on browsers without hardware-accelerated transitions or old Android/Opera

      this._zoomAnimated = TRANSITION && any3d && !mobileOpera && this.options.zoomAnimation; // zoom transitions run with the same duration for all layers, so if one of transitionend events
      // happens after starting zoom animation (propagating to the map pane), we know that it ended globally

      if (this._zoomAnimated) {
        this._createAnimProxy();

        on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
      }

      this._addLayers(this.options.layers);
    },
    // @section Methods for modifying map state
    // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
    // Sets the view of the map (geographical center and zoom) with the given
    // animation options.
    setView: function (center, zoom, options) {
      zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
      center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);
      options = options || {};

      this._stop();

      if (this._loaded && !options.reset && options !== true) {
        if (options.animate !== undefined) {
          options.zoom = extend({
            animate: options.animate
          }, options.zoom);
          options.pan = extend({
            animate: options.animate,
            duration: options.duration
          }, options.pan);
        } // try animating pan or zoom


        var moved = this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan);

        if (moved) {
          // prevent resize handler call, the view will refresh after animation anyway
          clearTimeout(this._sizeTimer);
          return this;
        }
      } // animation didn't start, just reset the map view


      this._resetView(center, zoom);

      return this;
    },
    // @method setZoom(zoom: Number, options?: Zoom/pan options): this
    // Sets the zoom of the map.
    setZoom: function (zoom, options) {
      if (!this._loaded) {
        this._zoom = zoom;
        return this;
      }

      return this.setView(this.getCenter(), zoom, {
        zoom: options
      });
    },
    // @method zoomIn(delta?: Number, options?: Zoom options): this
    // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
    zoomIn: function (delta, options) {
      delta = delta || (any3d ? this.options.zoomDelta : 1);
      return this.setZoom(this._zoom + delta, options);
    },
    // @method zoomOut(delta?: Number, options?: Zoom options): this
    // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
    zoomOut: function (delta, options) {
      delta = delta || (any3d ? this.options.zoomDelta : 1);
      return this.setZoom(this._zoom - delta, options);
    },
    // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
    // Zooms the map while keeping a specified geographical point on the map
    // stationary (e.g. used internally for scroll zoom and double-click zoom).
    // @alternative
    // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
    // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
    setZoomAround: function (latlng, zoom, options) {
      var scale = this.getZoomScale(zoom),
          viewHalf = this.getSize().divideBy(2),
          containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),
          centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
          newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
      return this.setView(newCenter, zoom, {
        zoom: options
      });
    },
    _getBoundsCenterZoom: function (bounds, options) {
      options = options || {};
      bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
          paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),
          zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
      zoom = typeof options.maxZoom === 'number' ? Math.min(options.maxZoom, zoom) : zoom;

      if (zoom === Infinity) {
        return {
          center: bounds.getCenter(),
          zoom: zoom
        };
      }

      var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),
          swPoint = this.project(bounds.getSouthWest(), zoom),
          nePoint = this.project(bounds.getNorthEast(), zoom),
          center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);
      return {
        center: center,
        zoom: zoom
      };
    },
    // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
    // Sets a map view that contains the given geographical bounds with the
    // maximum zoom level possible.
    fitBounds: function (bounds, options) {
      bounds = toLatLngBounds(bounds);

      if (!bounds.isValid()) {
        throw new Error('Bounds are not valid.');
      }

      var target = this._getBoundsCenterZoom(bounds, options);

      return this.setView(target.center, target.zoom, options);
    },
    // @method fitWorld(options?: fitBounds options): this
    // Sets a map view that mostly contains the whole world with the maximum
    // zoom level possible.
    fitWorld: function (options) {
      return this.fitBounds([[-90, -180], [90, 180]], options);
    },
    // @method panTo(latlng: LatLng, options?: Pan options): this
    // Pans the map to a given center.
    panTo: function (center, options) {
      // (LatLng)
      return this.setView(center, this._zoom, {
        pan: options
      });
    },
    // @method panBy(offset: Point, options?: Pan options): this
    // Pans the map by a given number of pixels (animated).
    panBy: function (offset, options) {
      offset = toPoint(offset).round();
      options = options || {};

      if (!offset.x && !offset.y) {
        return this.fire('moveend');
      } // If we pan too far, Chrome gets issues with tiles
      // and makes them disappear or appear in the wrong place (slightly offset) #2602


      if (options.animate !== true && !this.getSize().contains(offset)) {
        this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());

        return this;
      }

      if (!this._panAnim) {
        this._panAnim = new PosAnimation();

        this._panAnim.on({
          'step': this._onPanTransitionStep,
          'end': this._onPanTransitionEnd
        }, this);
      } // don't fire movestart if animating inertia


      if (!options.noMoveStart) {
        this.fire('movestart');
      } // animate pan unless animate: false specified


      if (options.animate !== false) {
        addClass(this._mapPane, 'leaflet-pan-anim');

        var newPos = this._getMapPanePos().subtract(offset).round();

        this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
      } else {
        this._rawPanBy(offset);

        this.fire('move').fire('moveend');
      }

      return this;
    },
    // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
    // Sets the view of the map (geographical center and zoom) performing a smooth
    // pan-zoom animation.
    flyTo: function (targetCenter, targetZoom, options) {
      options = options || {};

      if (options.animate === false || !any3d) {
        return this.setView(targetCenter, targetZoom, options);
      }

      this._stop();

      var from = this.project(this.getCenter()),
          to = this.project(targetCenter),
          size = this.getSize(),
          startZoom = this._zoom;
      targetCenter = toLatLng(targetCenter);
      targetZoom = targetZoom === undefined ? startZoom : targetZoom;
      var w0 = Math.max(size.x, size.y),
          w1 = w0 * this.getZoomScale(startZoom, targetZoom),
          u1 = to.distanceTo(from) || 1,
          rho = 1.42,
          rho2 = rho * rho;

      function r(i) {
        var s1 = i ? -1 : 1,
            s2 = i ? w1 : w0,
            t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
            b1 = 2 * s2 * rho2 * u1,
            b = t1 / b1,
            sq = Math.sqrt(b * b + 1) - b; // workaround for floating point precision bug when sq = 0, log = -Infinite,
        // thus triggering an infinite loop in flyTo

        var log = sq < 0.000000001 ? -18 : Math.log(sq);
        return log;
      }

      function sinh(n) {
        return (Math.exp(n) - Math.exp(-n)) / 2;
      }

      function cosh(n) {
        return (Math.exp(n) + Math.exp(-n)) / 2;
      }

      function tanh(n) {
        return sinh(n) / cosh(n);
      }

      var r0 = r(0);

      function w(s) {
        return w0 * (cosh(r0) / cosh(r0 + rho * s));
      }

      function u(s) {
        return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
      }

      function easeOut(t) {
        return 1 - Math.pow(1 - t, 1.5);
      }

      var start = Date.now(),
          S = (r(1) - r0) / rho,
          duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

      function frame() {
        var t = (Date.now() - start) / duration,
            s = easeOut(t) * S;

        if (t <= 1) {
          this._flyToFrame = requestAnimFrame(frame, this);

          this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), {
            flyTo: true
          });
        } else {
          this._move(targetCenter, targetZoom)._moveEnd(true);
        }
      }

      this._moveStart(true, options.noMoveStart);

      frame.call(this);
      return this;
    },
    // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
    // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
    // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
    flyToBounds: function (bounds, options) {
      var target = this._getBoundsCenterZoom(bounds, options);

      return this.flyTo(target.center, target.zoom, options);
    },
    // @method setMaxBounds(bounds: LatLngBounds): this
    // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
    setMaxBounds: function (bounds) {
      bounds = toLatLngBounds(bounds);

      if (!bounds.isValid()) {
        this.options.maxBounds = null;
        return this.off('moveend', this._panInsideMaxBounds);
      } else if (this.options.maxBounds) {
        this.off('moveend', this._panInsideMaxBounds);
      }

      this.options.maxBounds = bounds;

      if (this._loaded) {
        this._panInsideMaxBounds();
      }

      return this.on('moveend', this._panInsideMaxBounds);
    },
    // @method setMinZoom(zoom: Number): this
    // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
    setMinZoom: function (zoom) {
      var oldZoom = this.options.minZoom;
      this.options.minZoom = zoom;

      if (this._loaded && oldZoom !== zoom) {
        this.fire('zoomlevelschange');

        if (this.getZoom() < this.options.minZoom) {
          return this.setZoom(zoom);
        }
      }

      return this;
    },
    // @method setMaxZoom(zoom: Number): this
    // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
    setMaxZoom: function (zoom) {
      var oldZoom = this.options.maxZoom;
      this.options.maxZoom = zoom;

      if (this._loaded && oldZoom !== zoom) {
        this.fire('zoomlevelschange');

        if (this.getZoom() > this.options.maxZoom) {
          return this.setZoom(zoom);
        }
      }

      return this;
    },
    // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
    // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
    panInsideBounds: function (bounds, options) {
      this._enforcingBounds = true;

      var center = this.getCenter(),
          newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));

      if (!center.equals(newCenter)) {
        this.panTo(newCenter, options);
      }

      this._enforcingBounds = false;
      return this;
    },
    // @method panInside(latlng: LatLng, options?: options): this
    // Pans the map the minimum amount to make the `latlng` visible. Use
    // `padding`, `paddingTopLeft` and `paddingTopRight` options to fit
    // the display to more restricted bounds, like [`fitBounds`](#map-fitbounds).
    // If `latlng` is already within the (optionally padded) display bounds,
    // the map will not be panned.
    panInside: function (latlng, options) {
      options = options || {};
      var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
          paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),
          center = this.getCenter(),
          pixelCenter = this.project(center),
          pixelPoint = this.project(latlng),
          pixelBounds = this.getPixelBounds(),
          halfPixelBounds = pixelBounds.getSize().divideBy(2),
          paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]);

      if (!paddedBounds.contains(pixelPoint)) {
        this._enforcingBounds = true;
        var diff = pixelCenter.subtract(pixelPoint),
            newCenter = toPoint(pixelPoint.x + diff.x, pixelPoint.y + diff.y);

        if (pixelPoint.x < paddedBounds.min.x || pixelPoint.x > paddedBounds.max.x) {
          newCenter.x = pixelCenter.x - diff.x;

          if (diff.x > 0) {
            newCenter.x += halfPixelBounds.x - paddingTL.x;
          } else {
            newCenter.x -= halfPixelBounds.x - paddingBR.x;
          }
        }

        if (pixelPoint.y < paddedBounds.min.y || pixelPoint.y > paddedBounds.max.y) {
          newCenter.y = pixelCenter.y - diff.y;

          if (diff.y > 0) {
            newCenter.y += halfPixelBounds.y - paddingTL.y;
          } else {
            newCenter.y -= halfPixelBounds.y - paddingBR.y;
          }
        }

        this.panTo(this.unproject(newCenter), options);
        this._enforcingBounds = false;
      }

      return this;
    },
    // @method invalidateSize(options: Zoom/pan options): this
    // Checks if the map container size changed and updates the map if so —
    // call it after you've changed the map size dynamically, also animating
    // pan by default. If `options.pan` is `false`, panning will not occur.
    // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
    // that it doesn't happen often even if the method is called many
    // times in a row.
    // @alternative
    // @method invalidateSize(animate: Boolean): this
    // Checks if the map container size changed and updates the map if so —
    // call it after you've changed the map size dynamically, also animating
    // pan by default.
    invalidateSize: function (options) {
      if (!this._loaded) {
        return this;
      }

      options = extend({
        animate: false,
        pan: true
      }, options === true ? {
        animate: true
      } : options);
      var oldSize = this.getSize();
      this._sizeChanged = true;
      this._lastCenter = null;
      var newSize = this.getSize(),
          oldCenter = oldSize.divideBy(2).round(),
          newCenter = newSize.divideBy(2).round(),
          offset = oldCenter.subtract(newCenter);

      if (!offset.x && !offset.y) {
        return this;
      }

      if (options.animate && options.pan) {
        this.panBy(offset);
      } else {
        if (options.pan) {
          this._rawPanBy(offset);
        }

        this.fire('move');

        if (options.debounceMoveend) {
          clearTimeout(this._sizeTimer);
          this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);
        } else {
          this.fire('moveend');
        }
      } // @section Map state change events
      // @event resize: ResizeEvent
      // Fired when the map is resized.


      return this.fire('resize', {
        oldSize: oldSize,
        newSize: newSize
      });
    },
    // @section Methods for modifying map state
    // @method stop(): this
    // Stops the currently running `panTo` or `flyTo` animation, if any.
    stop: function () {
      this.setZoom(this._limitZoom(this._zoom));

      if (!this.options.zoomSnap) {
        this.fire('viewreset');
      }

      return this._stop();
    },
    // @section Geolocation methods
    // @method locate(options?: Locate options): this
    // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
    // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
    // and optionally sets the map view to the user's location with respect to
    // detection accuracy (or to the world view if geolocation failed).
    // Note that, if your page doesn't use HTTPS, this method will fail in
    // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
    // See `Locate options` for more details.
    locate: function (options) {
      options = this._locateOptions = extend({
        timeout: 10000,
        watch: false // setView: false
        // maxZoom: <Number>
        // maximumAge: 0
        // enableHighAccuracy: false

      }, options);

      if (!('geolocation' in navigator)) {
        this._handleGeolocationError({
          code: 0,
          message: 'Geolocation not supported.'
        });

        return this;
      }

      var onResponse = bind(this._handleGeolocationResponse, this),
          onError = bind(this._handleGeolocationError, this);

      if (options.watch) {
        this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
      } else {
        navigator.geolocation.getCurrentPosition(onResponse, onError, options);
      }

      return this;
    },
    // @method stopLocate(): this
    // Stops watching location previously initiated by `map.locate({watch: true})`
    // and aborts resetting the map view if map.locate was called with
    // `{setView: true}`.
    stopLocate: function () {
      if (navigator.geolocation && navigator.geolocation.clearWatch) {
        navigator.geolocation.clearWatch(this._locationWatchId);
      }

      if (this._locateOptions) {
        this._locateOptions.setView = false;
      }

      return this;
    },
    _handleGeolocationError: function (error) {
      var c = error.code,
          message = error.message || (c === 1 ? 'permission denied' : c === 2 ? 'position unavailable' : 'timeout');

      if (this._locateOptions.setView && !this._loaded) {
        this.fitWorld();
      } // @section Location events
      // @event locationerror: ErrorEvent
      // Fired when geolocation (using the [`locate`](#map-locate) method) failed.


      this.fire('locationerror', {
        code: c,
        message: 'Geolocation error: ' + message + '.'
      });
    },
    _handleGeolocationResponse: function (pos) {
      var lat = pos.coords.latitude,
          lng = pos.coords.longitude,
          latlng = new LatLng(lat, lng),
          bounds = latlng.toBounds(pos.coords.accuracy * 2),
          options = this._locateOptions;

      if (options.setView) {
        var zoom = this.getBoundsZoom(bounds);
        this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
      }

      var data = {
        latlng: latlng,
        bounds: bounds,
        timestamp: pos.timestamp
      };

      for (var i in pos.coords) {
        if (typeof pos.coords[i] === 'number') {
          data[i] = pos.coords[i];
        }
      } // @event locationfound: LocationEvent
      // Fired when geolocation (using the [`locate`](#map-locate) method)
      // went successfully.


      this.fire('locationfound', data);
    },
    // TODO Appropriate docs section?
    // @section Other Methods
    // @method addHandler(name: String, HandlerClass: Function): this
    // Adds a new `Handler` to the map, given its name and constructor function.
    addHandler: function (name, HandlerClass) {
      if (!HandlerClass) {
        return this;
      }

      var handler = this[name] = new HandlerClass(this);

      this._handlers.push(handler);

      if (this.options[name]) {
        handler.enable();
      }

      return this;
    },
    // @method remove(): this
    // Destroys the map and clears all related event listeners.
    remove: function () {
      this._initEvents(true);

      this.off('moveend', this._panInsideMaxBounds);

      if (this._containerId !== this._container._leaflet_id) {
        throw new Error('Map container is being reused by another instance');
      }

      try {
        // throws error in IE6-8
        delete this._container._leaflet_id;
        delete this._containerId;
      } catch (e) {
        /*eslint-disable */
        this._container._leaflet_id = undefined;
        /* eslint-enable */

        this._containerId = undefined;
      }

      if (this._locationWatchId !== undefined) {
        this.stopLocate();
      }

      this._stop();

      remove(this._mapPane);

      if (this._clearControlPos) {
        this._clearControlPos();
      }

      if (this._resizeRequest) {
        cancelAnimFrame(this._resizeRequest);
        this._resizeRequest = null;
      }

      this._clearHandlers();

      if (this._loaded) {
        // @section Map state change events
        // @event unload: Event
        // Fired when the map is destroyed with [remove](#map-remove) method.
        this.fire('unload');
      }

      var i;

      for (i in this._layers) {
        this._layers[i].remove();
      }

      for (i in this._panes) {
        remove(this._panes[i]);
      }

      this._layers = [];
      this._panes = [];
      delete this._mapPane;
      delete this._renderer;
      return this;
    },
    // @section Other Methods
    // @method createPane(name: String, container?: HTMLElement): HTMLElement
    // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
    // then returns it. The pane is created as a child of `container`, or
    // as a child of the main map pane if not set.
    createPane: function (name, container) {
      var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
          pane = create$1('div', className, container || this._mapPane);

      if (name) {
        this._panes[name] = pane;
      }

      return pane;
    },
    // @section Methods for Getting Map State
    // @method getCenter(): LatLng
    // Returns the geographical center of the map view
    getCenter: function () {
      this._checkIfLoaded();

      if (this._lastCenter && !this._moved()) {
        return this._lastCenter;
      }

      return this.layerPointToLatLng(this._getCenterLayerPoint());
    },
    // @method getZoom(): Number
    // Returns the current zoom level of the map view
    getZoom: function () {
      return this._zoom;
    },
    // @method getBounds(): LatLngBounds
    // Returns the geographical bounds visible in the current map view
    getBounds: function () {
      var bounds = this.getPixelBounds(),
          sw = this.unproject(bounds.getBottomLeft()),
          ne = this.unproject(bounds.getTopRight());
      return new LatLngBounds(sw, ne);
    },
    // @method getMinZoom(): Number
    // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
    getMinZoom: function () {
      return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
    },
    // @method getMaxZoom(): Number
    // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
    getMaxZoom: function () {
      return this.options.maxZoom === undefined ? this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom : this.options.maxZoom;
    },
    // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
    // Returns the maximum zoom level on which the given bounds fit to the map
    // view in its entirety. If `inside` (optional) is set to `true`, the method
    // instead returns the minimum zoom level on which the map view fits into
    // the given bounds in its entirety.
    getBoundsZoom: function (bounds, inside, padding) {
      // (LatLngBounds[, Boolean, Point]) -> Number
      bounds = toLatLngBounds(bounds);
      padding = toPoint(padding || [0, 0]);
      var zoom = this.getZoom() || 0,
          min = this.getMinZoom(),
          max = this.getMaxZoom(),
          nw = bounds.getNorthWest(),
          se = bounds.getSouthEast(),
          size = this.getSize().subtract(padding),
          boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),
          snap = any3d ? this.options.zoomSnap : 1,
          scalex = size.x / boundsSize.x,
          scaley = size.y / boundsSize.y,
          scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
      zoom = this.getScaleZoom(scale, zoom);

      if (snap) {
        zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level

        zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
      }

      return Math.max(min, Math.min(max, zoom));
    },
    // @method getSize(): Point
    // Returns the current size of the map container (in pixels).
    getSize: function () {
      if (!this._size || this._sizeChanged) {
        this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0);
        this._sizeChanged = false;
      }

      return this._size.clone();
    },
    // @method getPixelBounds(): Bounds
    // Returns the bounds of the current map view in projected pixel
    // coordinates (sometimes useful in layer and overlay implementations).
    getPixelBounds: function (center, zoom) {
      var topLeftPoint = this._getTopLeftPoint(center, zoom);

      return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
    },
    // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
    // the map pane? "left point of the map layer" can be confusing, specially
    // since there can be negative offsets.
    // @method getPixelOrigin(): Point
    // Returns the projected pixel coordinates of the top left point of
    // the map layer (useful in custom layer and overlay implementations).
    getPixelOrigin: function () {
      this._checkIfLoaded();

      return this._pixelOrigin;
    },
    // @method getPixelWorldBounds(zoom?: Number): Bounds
    // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
    // If `zoom` is omitted, the map's current zoom level is used.
    getPixelWorldBounds: function (zoom) {
      return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
    },
    // @section Other Methods
    // @method getPane(pane: String|HTMLElement): HTMLElement
    // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
    getPane: function (pane) {
      return typeof pane === 'string' ? this._panes[pane] : pane;
    },
    // @method getPanes(): Object
    // Returns a plain object containing the names of all [panes](#map-pane) as keys and
    // the panes as values.
    getPanes: function () {
      return this._panes;
    },
    // @method getContainer: HTMLElement
    // Returns the HTML element that contains the map.
    getContainer: function () {
      return this._container;
    },
    // @section Conversion Methods
    // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
    // Returns the scale factor to be applied to a map transition from zoom level
    // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
    getZoomScale: function (toZoom, fromZoom) {
      // TODO replace with universal implementation after refactoring projections
      var crs = this.options.crs;
      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
      return crs.scale(toZoom) / crs.scale(fromZoom);
    },
    // @method getScaleZoom(scale: Number, fromZoom: Number): Number
    // Returns the zoom level that the map would end up at, if it is at `fromZoom`
    // level and everything is scaled by a factor of `scale`. Inverse of
    // [`getZoomScale`](#map-getZoomScale).
    getScaleZoom: function (scale, fromZoom) {
      var crs = this.options.crs;
      fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
      var zoom = crs.zoom(scale * crs.scale(fromZoom));
      return isNaN(zoom) ? Infinity : zoom;
    },
    // @method project(latlng: LatLng, zoom: Number): Point
    // Projects a geographical coordinate `LatLng` according to the projection
    // of the map's CRS, then scales it according to `zoom` and the CRS's
    // `Transformation`. The result is pixel coordinate relative to
    // the CRS origin.
    project: function (latlng, zoom) {
      zoom = zoom === undefined ? this._zoom : zoom;
      return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
    },
    // @method unproject(point: Point, zoom: Number): LatLng
    // Inverse of [`project`](#map-project).
    unproject: function (point, zoom) {
      zoom = zoom === undefined ? this._zoom : zoom;
      return this.options.crs.pointToLatLng(toPoint(point), zoom);
    },
    // @method layerPointToLatLng(point: Point): LatLng
    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
    // returns the corresponding geographical coordinate (for the current zoom level).
    layerPointToLatLng: function (point) {
      var projectedPoint = toPoint(point).add(this.getPixelOrigin());
      return this.unproject(projectedPoint);
    },
    // @method latLngToLayerPoint(latlng: LatLng): Point
    // Given a geographical coordinate, returns the corresponding pixel coordinate
    // relative to the [origin pixel](#map-getpixelorigin).
    latLngToLayerPoint: function (latlng) {
      var projectedPoint = this.project(toLatLng(latlng))._round();

      return projectedPoint._subtract(this.getPixelOrigin());
    },
    // @method wrapLatLng(latlng: LatLng): LatLng
    // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
    // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
    // CRS's bounds.
    // By default this means longitude is wrapped around the dateline so its
    // value is between -180 and +180 degrees.
    wrapLatLng: function (latlng) {
      return this.options.crs.wrapLatLng(toLatLng(latlng));
    },
    // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
    // Returns a `LatLngBounds` with the same size as the given one, ensuring that
    // its center is within the CRS's bounds.
    // By default this means the center longitude is wrapped around the dateline so its
    // value is between -180 and +180 degrees, and the majority of the bounds
    // overlaps the CRS's bounds.
    wrapLatLngBounds: function (latlng) {
      return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
    },
    // @method distance(latlng1: LatLng, latlng2: LatLng): Number
    // Returns the distance between two geographical coordinates according to
    // the map's CRS. By default this measures distance in meters.
    distance: function (latlng1, latlng2) {
      return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
    },
    // @method containerPointToLayerPoint(point: Point): Point
    // Given a pixel coordinate relative to the map container, returns the corresponding
    // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
    containerPointToLayerPoint: function (point) {
      // (Point)
      return toPoint(point).subtract(this._getMapPanePos());
    },
    // @method layerPointToContainerPoint(point: Point): Point
    // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
    // returns the corresponding pixel coordinate relative to the map container.
    layerPointToContainerPoint: function (point) {
      // (Point)
      return toPoint(point).add(this._getMapPanePos());
    },
    // @method containerPointToLatLng(point: Point): LatLng
    // Given a pixel coordinate relative to the map container, returns
    // the corresponding geographical coordinate (for the current zoom level).
    containerPointToLatLng: function (point) {
      var layerPoint = this.containerPointToLayerPoint(toPoint(point));
      return this.layerPointToLatLng(layerPoint);
    },
    // @method latLngToContainerPoint(latlng: LatLng): Point
    // Given a geographical coordinate, returns the corresponding pixel coordinate
    // relative to the map container.
    latLngToContainerPoint: function (latlng) {
      return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
    },
    // @method mouseEventToContainerPoint(ev: MouseEvent): Point
    // Given a MouseEvent object, returns the pixel coordinate relative to the
    // map container where the event took place.
    mouseEventToContainerPoint: function (e) {
      return getMousePosition(e, this._container);
    },
    // @method mouseEventToLayerPoint(ev: MouseEvent): Point
    // Given a MouseEvent object, returns the pixel coordinate relative to
    // the [origin pixel](#map-getpixelorigin) where the event took place.
    mouseEventToLayerPoint: function (e) {
      return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
    },
    // @method mouseEventToLatLng(ev: MouseEvent): LatLng
    // Given a MouseEvent object, returns geographical coordinate where the
    // event took place.
    mouseEventToLatLng: function (e) {
      // (MouseEvent)
      return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
    },
    // map initialization methods
    _initContainer: function (id) {
      var container = this._container = get(id);

      if (!container) {
        throw new Error('Map container not found.');
      } else if (container._leaflet_id) {
        throw new Error('Map container is already initialized.');
      }

      on(container, 'scroll', this._onScroll, this);
      this._containerId = stamp(container);
    },
    _initLayout: function () {
      var container = this._container;
      this._fadeAnimated = this.options.fadeAnimation && any3d;
      addClass(container, 'leaflet-container' + (touch ? ' leaflet-touch' : '') + (retina ? ' leaflet-retina' : '') + (ielt9 ? ' leaflet-oldie' : '') + (safari ? ' leaflet-safari' : '') + (this._fadeAnimated ? ' leaflet-fade-anim' : ''));
      var position = getStyle(container, 'position');

      if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
        container.style.position = 'relative';
      }

      this._initPanes();

      if (this._initControlPos) {
        this._initControlPos();
      }
    },
    _initPanes: function () {
      var panes = this._panes = {};
      this._paneRenderers = {}; // @section
      //
      // Panes are DOM elements used to control the ordering of layers on the map. You
      // can access panes with [`map.getPane`](#map-getpane) or
      // [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
      // [`map.createPane`](#map-createpane) method.
      //
      // Every map has the following default panes that differ only in zIndex.
      //
      // @pane mapPane: HTMLElement = 'auto'
      // Pane that contains all other map panes

      this._mapPane = this.createPane('mapPane', this._container);
      setPosition(this._mapPane, new Point(0, 0)); // @pane tilePane: HTMLElement = 200
      // Pane for `GridLayer`s and `TileLayer`s

      this.createPane('tilePane'); // @pane overlayPane: HTMLElement = 400
      // Pane for overlay shadows (e.g. `Marker` shadows)

      this.createPane('shadowPane'); // @pane shadowPane: HTMLElement = 500
      // Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s

      this.createPane('overlayPane'); // @pane markerPane: HTMLElement = 600
      // Pane for `Icon`s of `Marker`s

      this.createPane('markerPane'); // @pane tooltipPane: HTMLElement = 650
      // Pane for `Tooltip`s.

      this.createPane('tooltipPane'); // @pane popupPane: HTMLElement = 700
      // Pane for `Popup`s.

      this.createPane('popupPane');

      if (!this.options.markerZoomAnimation) {
        addClass(panes.markerPane, 'leaflet-zoom-hide');
        addClass(panes.shadowPane, 'leaflet-zoom-hide');
      }
    },
    // private methods that modify map state
    // @section Map state change events
    _resetView: function (center, zoom) {
      setPosition(this._mapPane, new Point(0, 0));
      var loading = !this._loaded;
      this._loaded = true;
      zoom = this._limitZoom(zoom);
      this.fire('viewprereset');
      var zoomChanged = this._zoom !== zoom;

      this._moveStart(zoomChanged, false)._move(center, zoom)._moveEnd(zoomChanged); // @event viewreset: Event
      // Fired when the map needs to redraw its content (this usually happens
      // on map zoom or load). Very useful for creating custom overlays.


      this.fire('viewreset'); // @event load: Event
      // Fired when the map is initialized (when its center and zoom are set
      // for the first time).

      if (loading) {
        this.fire('load');
      }
    },
    _moveStart: function (zoomChanged, noMoveStart) {
      // @event zoomstart: Event
      // Fired when the map zoom is about to change (e.g. before zoom animation).
      // @event movestart: Event
      // Fired when the view of the map starts changing (e.g. user starts dragging the map).
      if (zoomChanged) {
        this.fire('zoomstart');
      }

      if (!noMoveStart) {
        this.fire('movestart');
      }

      return this;
    },
    _move: function (center, zoom, data) {
      if (zoom === undefined) {
        zoom = this._zoom;
      }

      var zoomChanged = this._zoom !== zoom;
      this._zoom = zoom;
      this._lastCenter = center;
      this._pixelOrigin = this._getNewPixelOrigin(center); // @event zoom: Event
      // Fired repeatedly during any change in zoom level, including zoom
      // and fly animations.

      if (zoomChanged || data && data.pinch) {
        // Always fire 'zoom' if pinching because #3530
        this.fire('zoom', data);
      } // @event move: Event
      // Fired repeatedly during any movement of the map, including pan and
      // fly animations.


      return this.fire('move', data);
    },
    _moveEnd: function (zoomChanged) {
      // @event zoomend: Event
      // Fired when the map has changed, after any animations.
      if (zoomChanged) {
        this.fire('zoomend');
      } // @event moveend: Event
      // Fired when the center of the map stops changing (e.g. user stopped
      // dragging the map).


      return this.fire('moveend');
    },
    _stop: function () {
      cancelAnimFrame(this._flyToFrame);

      if (this._panAnim) {
        this._panAnim.stop();
      }

      return this;
    },
    _rawPanBy: function (offset) {
      setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
    },
    _getZoomSpan: function () {
      return this.getMaxZoom() - this.getMinZoom();
    },
    _panInsideMaxBounds: function () {
      if (!this._enforcingBounds) {
        this.panInsideBounds(this.options.maxBounds);
      }
    },
    _checkIfLoaded: function () {
      if (!this._loaded) {
        throw new Error('Set map center and zoom first.');
      }
    },
    // DOM event handling
    // @section Interaction events
    _initEvents: function (remove$$1) {
      this._targets = {};
      this._targets[stamp(this._container)] = this;
      var onOff = remove$$1 ? off : on; // @event click: MouseEvent
      // Fired when the user clicks (or taps) the map.
      // @event dblclick: MouseEvent
      // Fired when the user double-clicks (or double-taps) the map.
      // @event mousedown: MouseEvent
      // Fired when the user pushes the mouse button on the map.
      // @event mouseup: MouseEvent
      // Fired when the user releases the mouse button on the map.
      // @event mouseover: MouseEvent
      // Fired when the mouse enters the map.
      // @event mouseout: MouseEvent
      // Fired when the mouse leaves the map.
      // @event mousemove: MouseEvent
      // Fired while the mouse moves over the map.
      // @event contextmenu: MouseEvent
      // Fired when the user pushes the right mouse button on the map, prevents
      // default browser context menu from showing if there are listeners on
      // this event. Also fired on mobile when the user holds a single touch
      // for a second (also called long press).
      // @event keypress: KeyboardEvent
      // Fired when the user presses a key from the keyboard that produces a character value while the map is focused.
      // @event keydown: KeyboardEvent
      // Fired when the user presses a key from the keyboard while the map is focused. Unlike the `keypress` event,
      // the `keydown` event is fired for keys that produce a character value and for keys
      // that do not produce a character value.
      // @event keyup: KeyboardEvent
      // Fired when the user releases a key from the keyboard while the map is focused.

      onOff(this._container, 'click dblclick mousedown mouseup ' + 'mouseover mouseout mousemove contextmenu keypress keydown keyup', this._handleDOMEvent, this);

      if (this.options.trackResize) {
        onOff(window, 'resize', this._onResize, this);
      }

      if (any3d && this.options.transform3DLimit) {
        (remove$$1 ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);
      }
    },
    _onResize: function () {
      cancelAnimFrame(this._resizeRequest);
      this._resizeRequest = requestAnimFrame(function () {
        this.invalidateSize({
          debounceMoveend: true
        });
      }, this);
    },
    _onScroll: function () {
      this._container.scrollTop = 0;
      this._container.scrollLeft = 0;
    },
    _onMoveEnd: function () {
      var pos = this._getMapPanePos();

      if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
        // a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
        this._resetView(this.getCenter(), this.getZoom());
      }
    },
    _findEventTargets: function (e, type) {
      var targets = [],
          target,
          isHover = type === 'mouseout' || type === 'mouseover',
          src = e.target || e.srcElement,
          dragging = false;

      while (src) {
        target = this._targets[stamp(src)];

        if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
          // Prevent firing click after you just dragged an object.
          dragging = true;
          break;
        }

        if (target && target.listens(type, true)) {
          if (isHover && !isExternalTarget(src, e)) {
            break;
          }

          targets.push(target);

          if (isHover) {
            break;
          }
        }

        if (src === this._container) {
          break;
        }

        src = src.parentNode;
      }

      if (!targets.length && !dragging && !isHover && isExternalTarget(src, e)) {
        targets = [this];
      }

      return targets;
    },
    _handleDOMEvent: function (e) {
      if (!this._loaded || skipped(e)) {
        return;
      }

      var type = e.type;

      if (type === 'mousedown' || type === 'keypress' || type === 'keyup' || type === 'keydown') {
        // prevents outline when clicking on keyboard-focusable element
        preventOutline(e.target || e.srcElement);
      }

      this._fireDOMEvent(e, type);
    },
    _mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],
    _fireDOMEvent: function (e, type, targets) {
      if (e.type === 'click') {
        // Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
        // @event preclick: MouseEvent
        // Fired before mouse click on the map (sometimes useful when you
        // want something to happen on click before any existing click
        // handlers start running).
        var synth = extend({}, e);
        synth.type = 'preclick';

        this._fireDOMEvent(synth, synth.type, targets);
      }

      if (e._stopped) {
        return;
      } // Find the layer the event is propagating from and its parents.


      targets = (targets || []).concat(this._findEventTargets(e, type));

      if (!targets.length) {
        return;
      }

      var target = targets[0];

      if (type === 'contextmenu' && target.listens(type, true)) {
        preventDefault(e);
      }

      var data = {
        originalEvent: e
      };

      if (e.type !== 'keypress' && e.type !== 'keydown' && e.type !== 'keyup') {
        var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
        data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
        data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
        data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
      }

      for (var i = 0; i < targets.length; i++) {
        targets[i].fire(type, data, true);

        if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {
          return;
        }
      }
    },
    _draggableMoved: function (obj) {
      obj = obj.dragging && obj.dragging.enabled() ? obj : this;
      return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
    },
    _clearHandlers: function () {
      for (var i = 0, len = this._handlers.length; i < len; i++) {
        this._handlers[i].disable();
      }
    },
    // @section Other Methods
    // @method whenReady(fn: Function, context?: Object): this
    // Runs the given function `fn` when the map gets initialized with
    // a view (center and zoom) and at least one layer, or immediately
    // if it's already initialized, optionally passing a function context.
    whenReady: function (callback, context) {
      if (this._loaded) {
        callback.call(context || this, {
          target: this
        });
      } else {
        this.on('load', callback, context);
      }

      return this;
    },
    // private methods for getting map state
    _getMapPanePos: function () {
      return getPosition(this._mapPane) || new Point(0, 0);
    },
    _moved: function () {
      var pos = this._getMapPanePos();

      return pos && !pos.equals([0, 0]);
    },
    _getTopLeftPoint: function (center, zoom) {
      var pixelOrigin = center && zoom !== undefined ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin();
      return pixelOrigin.subtract(this._getMapPanePos());
    },
    _getNewPixelOrigin: function (center, zoom) {
      var viewHalf = this.getSize()._divideBy(2);

      return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
    },
    _latLngToNewLayerPoint: function (latlng, zoom, center) {
      var topLeft = this._getNewPixelOrigin(center, zoom);

      return this.project(latlng, zoom)._subtract(topLeft);
    },
    _latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {
      var topLeft = this._getNewPixelOrigin(center, zoom);

      return toBounds([this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)]);
    },
    // layer point of the current center
    _getCenterLayerPoint: function () {
      return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
    },
    // offset of the specified place to the current center in pixels
    _getCenterOffset: function (latlng) {
      return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
    },
    // adjust center for view to get inside bounds
    _limitCenter: function (center, zoom, bounds) {
      if (!bounds) {
        return center;
      }

      var centerPoint = this.project(center, zoom),
          viewHalf = this.getSize().divideBy(2),
          viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
          offset = this._getBoundsOffset(viewBounds, bounds, zoom); // If offset is less than a pixel, ignore.
      // This prevents unstable projections from getting into
      // an infinite loop of tiny offsets.


      if (offset.round().equals([0, 0])) {
        return center;
      }

      return this.unproject(centerPoint.add(offset), zoom);
    },
    // adjust offset for view to get inside bounds
    _limitOffset: function (offset, bounds) {
      if (!bounds) {
        return offset;
      }

      var viewBounds = this.getPixelBounds(),
          newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
      return offset.add(this._getBoundsOffset(newBounds, bounds));
    },
    // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
    _getBoundsOffset: function (pxBounds, maxBounds, zoom) {
      var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)),
          minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
          maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),
          dx = this._rebound(minOffset.x, -maxOffset.x),
          dy = this._rebound(minOffset.y, -maxOffset.y);

      return new Point(dx, dy);
    },
    _rebound: function (left, right) {
      return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
    },
    _limitZoom: function (zoom) {
      var min = this.getMinZoom(),
          max = this.getMaxZoom(),
          snap = any3d ? this.options.zoomSnap : 1;

      if (snap) {
        zoom = Math.round(zoom / snap) * snap;
      }

      return Math.max(min, Math.min(max, zoom));
    },
    _onPanTransitionStep: function () {
      this.fire('move');
    },
    _onPanTransitionEnd: function () {
      removeClass(this._mapPane, 'leaflet-pan-anim');
      this.fire('moveend');
    },
    _tryAnimatedPan: function (center, options) {
      // difference between the new and current centers in pixels
      var offset = this._getCenterOffset(center)._trunc(); // don't animate too far unless animate: true specified in options


      if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
        return false;
      }

      this.panBy(offset, options);
      return true;
    },
    _createAnimProxy: function () {
      var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');

      this._panes.mapPane.appendChild(proxy);

      this.on('zoomanim', function (e) {
        var prop = TRANSFORM,
            transform = this._proxy.style[prop];
        setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1)); // workaround for case when transform is the same and so transitionend event is not fired

        if (transform === this._proxy.style[prop] && this._animatingZoom) {
          this._onZoomTransitionEnd();
        }
      }, this);
      this.on('load moveend', this._animMoveEnd, this);

      this._on('unload', this._destroyAnimProxy, this);
    },
    _destroyAnimProxy: function () {
      remove(this._proxy);
      this.off('load moveend', this._animMoveEnd, this);
      delete this._proxy;
    },
    _animMoveEnd: function () {
      var c = this.getCenter(),
          z = this.getZoom();
      setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
    },
    _catchTransitionEnd: function (e) {
      if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
        this._onZoomTransitionEnd();
      }
    },
    _nothingToAnimate: function () {
      return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
    },
    _tryAnimatedZoom: function (center, zoom, options) {
      if (this._animatingZoom) {
        return true;
      }

      options = options || {}; // don't animate if disabled, not supported or zoom difference is too large

      if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) {
        return false;
      } // offset is the pixel coords of the zoom origin relative to the current center


      var scale = this.getZoomScale(zoom),
          offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale); // don't animate if the zoom origin isn't within one screen from the current center, unless forced


      if (options.animate !== true && !this.getSize().contains(offset)) {
        return false;
      }

      requestAnimFrame(function () {
        this._moveStart(true, false)._animateZoom(center, zoom, true);
      }, this);
      return true;
    },
    _animateZoom: function (center, zoom, startAnim, noUpdate) {
      if (!this._mapPane) {
        return;
      }

      if (startAnim) {
        this._animatingZoom = true; // remember what center/zoom to set after animation

        this._animateToCenter = center;
        this._animateToZoom = zoom;
        addClass(this._mapPane, 'leaflet-zoom-anim');
      } // @section Other Events
      // @event zoomanim: ZoomAnimEvent
      // Fired at least once per zoom animation. For continuous zoom, like pinch zooming, fired once per frame during zoom.


      this.fire('zoomanim', {
        center: center,
        zoom: zoom,
        noUpdate: noUpdate
      }); // Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693

      setTimeout(bind(this._onZoomTransitionEnd, this), 250);
    },
    _onZoomTransitionEnd: function () {
      if (!this._animatingZoom) {
        return;
      }

      if (this._mapPane) {
        removeClass(this._mapPane, 'leaflet-zoom-anim');
      }

      this._animatingZoom = false;

      this._move(this._animateToCenter, this._animateToZoom); // This anim frame should prevent an obscure iOS webkit tile loading race condition.


      requestAnimFrame(function () {
        this._moveEnd(true);
      }, this);
    }
  }); // @section
  // @factory L.map(id: String, options?: Map options)
  // Instantiates a map object given the DOM ID of a `<div>` element
  // and optionally an object literal with `Map options`.
  //
  // @alternative
  // @factory L.map(el: HTMLElement, options?: Map options)
  // Instantiates a map object given an instance of a `<div>` HTML element
  // and optionally an object literal with `Map options`.

  function createMap(id, options) {
    return new Map(id, options);
  }
  /*
   * @class Control
   * @aka L.Control
   * @inherits Class
   *
   * L.Control is a base class for implementing map controls. Handles positioning.
   * All other controls extend from this class.
   */


  var Control = Class.extend({
    // @section
    // @aka Control options
    options: {
      // @option position: String = 'topright'
      // The position of the control (one of the map corners). Possible values are `'topleft'`,
      // `'topright'`, `'bottomleft'` or `'bottomright'`
      position: 'topright'
    },
    initialize: function (options) {
      setOptions(this, options);
    },

    /* @section
     * Classes extending L.Control will inherit the following methods:
     *
     * @method getPosition: string
     * Returns the position of the control.
     */
    getPosition: function () {
      return this.options.position;
    },
    // @method setPosition(position: string): this
    // Sets the position of the control.
    setPosition: function (position) {
      var map = this._map;

      if (map) {
        map.removeControl(this);
      }

      this.options.position = position;

      if (map) {
        map.addControl(this);
      }

      return this;
    },
    // @method getContainer: HTMLElement
    // Returns the HTMLElement that contains the control.
    getContainer: function () {
      return this._container;
    },
    // @method addTo(map: Map): this
    // Adds the control to the given map.
    addTo: function (map) {
      this.remove();
      this._map = map;
      var container = this._container = this.onAdd(map),
          pos = this.getPosition(),
          corner = map._controlCorners[pos];
      addClass(container, 'leaflet-control');

      if (pos.indexOf('bottom') !== -1) {
        corner.insertBefore(container, corner.firstChild);
      } else {
        corner.appendChild(container);
      }

      this._map.on('unload', this.remove, this);

      return this;
    },
    // @method remove: this
    // Removes the control from the map it is currently active on.
    remove: function () {
      if (!this._map) {
        return this;
      }

      remove(this._container);

      if (this.onRemove) {
        this.onRemove(this._map);
      }

      this._map.off('unload', this.remove, this);

      this._map = null;
      return this;
    },
    _refocusOnMap: function (e) {
      // if map exists and event is not a keyboard event
      if (this._map && e && e.screenX > 0 && e.screenY > 0) {
        this._map.getContainer().focus();
      }
    }
  });

  var control = function (options) {
    return new Control(options);
  };
  /* @section Extension methods
   * @uninheritable
   *
   * Every control should extend from `L.Control` and (re-)implement the following methods.
   *
   * @method onAdd(map: Map): HTMLElement
   * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
   *
   * @method onRemove(map: Map)
   * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
   */

  /* @namespace Map
   * @section Methods for Layers and Controls
   */


  Map.include({
    // @method addControl(control: Control): this
    // Adds the given control to the map
    addControl: function (control) {
      control.addTo(this);
      return this;
    },
    // @method removeControl(control: Control): this
    // Removes the given control from the map
    removeControl: function (control) {
      control.remove();
      return this;
    },
    _initControlPos: function () {
      var corners = this._controlCorners = {},
          l = 'leaflet-',
          container = this._controlContainer = create$1('div', l + 'control-container', this._container);

      function createCorner(vSide, hSide) {
        var className = l + vSide + ' ' + l + hSide;
        corners[vSide + hSide] = create$1('div', className, container);
      }

      createCorner('top', 'left');
      createCorner('top', 'right');
      createCorner('bottom', 'left');
      createCorner('bottom', 'right');
    },
    _clearControlPos: function () {
      for (var i in this._controlCorners) {
        remove(this._controlCorners[i]);
      }

      remove(this._controlContainer);
      delete this._controlCorners;
      delete this._controlContainer;
    }
  });
  /*
   * @class Control.Layers
   * @aka L.Control.Layers
   * @inherits Control
   *
   * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control/)). Extends `Control`.
   *
   * @example
   *
   * ```js
   * var baseLayers = {
   * 	"Mapbox": mapbox,
   * 	"OpenStreetMap": osm
   * };
   *
   * var overlays = {
   * 	"Marker": marker,
   * 	"Roads": roadsLayer
   * };
   *
   * L.control.layers(baseLayers, overlays).addTo(map);
   * ```
   *
   * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
   *
   * ```js
   * {
   *     "<someName1>": layer1,
   *     "<someName2>": layer2
   * }
   * ```
   *
   * The layer names can contain HTML, which allows you to add additional styling to the items:
   *
   * ```js
   * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
   * ```
   */

  var Layers = Control.extend({
    // @section
    // @aka Control.Layers options
    options: {
      // @option collapsed: Boolean = true
      // If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
      collapsed: true,
      position: 'topright',
      // @option autoZIndex: Boolean = true
      // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
      autoZIndex: true,
      // @option hideSingleBase: Boolean = false
      // If `true`, the base layers in the control will be hidden when there is only one.
      hideSingleBase: false,
      // @option sortLayers: Boolean = false
      // Whether to sort the layers. When `false`, layers will keep the order
      // in which they were added to the control.
      sortLayers: false,
      // @option sortFunction: Function = *
      // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
      // that will be used for sorting the layers, when `sortLayers` is `true`.
      // The function receives both the `L.Layer` instances and their names, as in
      // `sortFunction(layerA, layerB, nameA, nameB)`.
      // By default, it sorts layers alphabetically by their name.
      sortFunction: function (layerA, layerB, nameA, nameB) {
        return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
      }
    },
    initialize: function (baseLayers, overlays, options) {
      setOptions(this, options);
      this._layerControlInputs = [];
      this._layers = [];
      this._lastZIndex = 0;
      this._handlingClick = false;

      for (var i in baseLayers) {
        this._addLayer(baseLayers[i], i);
      }

      for (i in overlays) {
        this._addLayer(overlays[i], i, true);
      }
    },
    onAdd: function (map) {
      this._initLayout();

      this._update();

      this._map = map;
      map.on('zoomend', this._checkDisabledLayers, this);

      for (var i = 0; i < this._layers.length; i++) {
        this._layers[i].layer.on('add remove', this._onLayerChange, this);
      }

      return this._container;
    },
    addTo: function (map) {
      Control.prototype.addTo.call(this, map); // Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.

      return this._expandIfNotCollapsed();
    },
    onRemove: function () {
      this._map.off('zoomend', this._checkDisabledLayers, this);

      for (var i = 0; i < this._layers.length; i++) {
        this._layers[i].layer.off('add remove', this._onLayerChange, this);
      }
    },
    // @method addBaseLayer(layer: Layer, name: String): this
    // Adds a base layer (radio button entry) with the given name to the control.
    addBaseLayer: function (layer, name) {
      this._addLayer(layer, name);

      return this._map ? this._update() : this;
    },
    // @method addOverlay(layer: Layer, name: String): this
    // Adds an overlay (checkbox entry) with the given name to the control.
    addOverlay: function (layer, name) {
      this._addLayer(layer, name, true);

      return this._map ? this._update() : this;
    },
    // @method removeLayer(layer: Layer): this
    // Remove the given layer from the control.
    removeLayer: function (layer) {
      layer.off('add remove', this._onLayerChange, this);

      var obj = this._getLayer(stamp(layer));

      if (obj) {
        this._layers.splice(this._layers.indexOf(obj), 1);
      }

      return this._map ? this._update() : this;
    },
    // @method expand(): this
    // Expand the control container if collapsed.
    expand: function () {
      addClass(this._container, 'leaflet-control-layers-expanded');
      this._section.style.height = null;
      var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);

      if (acceptableHeight < this._section.clientHeight) {
        addClass(this._section, 'leaflet-control-layers-scrollbar');
        this._section.style.height = acceptableHeight + 'px';
      } else {
        removeClass(this._section, 'leaflet-control-layers-scrollbar');
      }

      this._checkDisabledLayers();

      return this;
    },
    // @method collapse(): this
    // Collapse the control container if expanded.
    collapse: function () {
      removeClass(this._container, 'leaflet-control-layers-expanded');
      return this;
    },
    _initLayout: function () {
      var className = 'leaflet-control-layers',
          container = this._container = create$1('div', className),
          collapsed = this.options.collapsed; // makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released

      container.setAttribute('aria-haspopup', true);
      disableClickPropagation(container);
      disableScrollPropagation(container);
      var section = this._section = create$1('section', className + '-list');

      if (collapsed) {
        this._map.on('click', this.collapse, this);

        if (!android) {
          on(container, {
            mouseenter: this.expand,
            mouseleave: this.collapse
          }, this);
        }
      }

      var link = this._layersLink = create$1('a', className + '-toggle', container);
      link.href = '#';
      link.title = 'Layers';

      if (touch) {
        on(link, 'click', stop);
        on(link, 'click', this.expand, this);
      } else {
        on(link, 'focus', this.expand, this);
      }

      if (!collapsed) {
        this.expand();
      }

      this._baseLayersList = create$1('div', className + '-base', section);
      this._separator = create$1('div', className + '-separator', section);
      this._overlaysList = create$1('div', className + '-overlays', section);
      container.appendChild(section);
    },
    _getLayer: function (id) {
      for (var i = 0; i < this._layers.length; i++) {
        if (this._layers[i] && stamp(this._layers[i].layer) === id) {
          return this._layers[i];
        }
      }
    },
    _addLayer: function (layer, name, overlay) {
      if (this._map) {
        layer.on('add remove', this._onLayerChange, this);
      }

      this._layers.push({
        layer: layer,
        name: name,
        overlay: overlay
      });

      if (this.options.sortLayers) {
        this._layers.sort(bind(function (a, b) {
          return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
        }, this));
      }

      if (this.options.autoZIndex && layer.setZIndex) {
        this._lastZIndex++;
        layer.setZIndex(this._lastZIndex);
      }

      this._expandIfNotCollapsed();
    },
    _update: function () {
      if (!this._container) {
        return this;
      }

      empty(this._baseLayersList);
      empty(this._overlaysList);
      this._layerControlInputs = [];
      var baseLayersPresent,
          overlaysPresent,
          i,
          obj,
          baseLayersCount = 0;

      for (i = 0; i < this._layers.length; i++) {
        obj = this._layers[i];

        this._addItem(obj);

        overlaysPresent = overlaysPresent || obj.overlay;
        baseLayersPresent = baseLayersPresent || !obj.overlay;
        baseLayersCount += !obj.overlay ? 1 : 0;
      } // Hide base layers section if there's only one layer.


      if (this.options.hideSingleBase) {
        baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
        this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
      }

      this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';
      return this;
    },
    _onLayerChange: function (e) {
      if (!this._handlingClick) {
        this._update();
      }

      var obj = this._getLayer(stamp(e.target)); // @namespace Map
      // @section Layer events
      // @event baselayerchange: LayersControlEvent
      // Fired when the base layer is changed through the [layers control](#control-layers).
      // @event overlayadd: LayersControlEvent
      // Fired when an overlay is selected through the [layers control](#control-layers).
      // @event overlayremove: LayersControlEvent
      // Fired when an overlay is deselected through the [layers control](#control-layers).
      // @namespace Control.Layers


      var type = obj.overlay ? e.type === 'add' ? 'overlayadd' : 'overlayremove' : e.type === 'add' ? 'baselayerchange' : null;

      if (type) {
        this._map.fire(type, obj);
      }
    },
    // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
    _createRadioElement: function (name, checked) {
      var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : '') + '/>';
      var radioFragment = document.createElement('div');
      radioFragment.innerHTML = radioHtml;
      return radioFragment.firstChild;
    },
    _addItem: function (obj) {
      var label = document.createElement('label'),
          checked = this._map.hasLayer(obj.layer),
          input;

      if (obj.overlay) {
        input = document.createElement('input');
        input.type = 'checkbox';
        input.className = 'leaflet-control-layers-selector';
        input.defaultChecked = checked;
      } else {
        input = this._createRadioElement('leaflet-base-layers_' + stamp(this), checked);
      }

      this._layerControlInputs.push(input);

      input.layerId = stamp(obj.layer);
      on(input, 'click', this._onInputClick, this);
      var name = document.createElement('span');
      name.innerHTML = ' ' + obj.name; // Helps from preventing layer control flicker when checkboxes are disabled
      // https://github.com/Leaflet/Leaflet/issues/2771

      var holder = document.createElement('div');
      label.appendChild(holder);
      holder.appendChild(input);
      holder.appendChild(name);
      var container = obj.overlay ? this._overlaysList : this._baseLayersList;
      container.appendChild(label);

      this._checkDisabledLayers();

      return label;
    },
    _onInputClick: function () {
      var inputs = this._layerControlInputs,
          input,
          layer;
      var addedLayers = [],
          removedLayers = [];
      this._handlingClick = true;

      for (var i = inputs.length - 1; i >= 0; i--) {
        input = inputs[i];
        layer = this._getLayer(input.layerId).layer;

        if (input.checked) {
          addedLayers.push(layer);
        } else if (!input.checked) {
          removedLayers.push(layer);
        }
      } // Bugfix issue 2318: Should remove all old layers before readding new ones


      for (i = 0; i < removedLayers.length; i++) {
        if (this._map.hasLayer(removedLayers[i])) {
          this._map.removeLayer(removedLayers[i]);
        }
      }

      for (i = 0; i < addedLayers.length; i++) {
        if (!this._map.hasLayer(addedLayers[i])) {
          this._map.addLayer(addedLayers[i]);
        }
      }

      this._handlingClick = false;

      this._refocusOnMap();
    },
    _checkDisabledLayers: function () {
      var inputs = this._layerControlInputs,
          input,
          layer,
          zoom = this._map.getZoom();

      for (var i = inputs.length - 1; i >= 0; i--) {
        input = inputs[i];
        layer = this._getLayer(input.layerId).layer;
        input.disabled = layer.options.minZoom !== undefined && zoom < layer.options.minZoom || layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom;
      }
    },
    _expandIfNotCollapsed: function () {
      if (this._map && !this.options.collapsed) {
        this.expand();
      }

      return this;
    },
    _expand: function () {
      // Backward compatibility, remove me in 1.1.
      return this.expand();
    },
    _collapse: function () {
      // Backward compatibility, remove me in 1.1.
      return this.collapse();
    }
  }); // @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
  // Creates a layers control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.

  var layers = function (baseLayers, overlays, options) {
    return new Layers(baseLayers, overlays, options);
  };
  /*
   * @class Control.Zoom
   * @aka L.Control.Zoom
   * @inherits Control
   *
   * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
   */


  var Zoom = Control.extend({
    // @section
    // @aka Control.Zoom options
    options: {
      position: 'topleft',
      // @option zoomInText: String = '+'
      // The text set on the 'zoom in' button.
      zoomInText: '+',
      // @option zoomInTitle: String = 'Zoom in'
      // The title set on the 'zoom in' button.
      zoomInTitle: 'Zoom in',
      // @option zoomOutText: String = '&#x2212;'
      // The text set on the 'zoom out' button.
      zoomOutText: '&#x2212;',
      // @option zoomOutTitle: String = 'Zoom out'
      // The title set on the 'zoom out' button.
      zoomOutTitle: 'Zoom out'
    },
    onAdd: function (map) {
      var zoomName = 'leaflet-control-zoom',
          container = create$1('div', zoomName + ' leaflet-bar'),
          options = this.options;
      this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + '-in', container, this._zoomIn);
      this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + '-out', container, this._zoomOut);

      this._updateDisabled();

      map.on('zoomend zoomlevelschange', this._updateDisabled, this);
      return container;
    },
    onRemove: function (map) {
      map.off('zoomend zoomlevelschange', this._updateDisabled, this);
    },
    disable: function () {
      this._disabled = true;

      this._updateDisabled();

      return this;
    },
    enable: function () {
      this._disabled = false;

      this._updateDisabled();

      return this;
    },
    _zoomIn: function (e) {
      if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
        this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
      }
    },
    _zoomOut: function (e) {
      if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
        this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
      }
    },
    _createButton: function (html, title, className, container, fn) {
      var link = create$1('a', className, container);
      link.innerHTML = html;
      link.href = '#';
      link.title = title;
      /*
       * Will force screen readers like VoiceOver to read this as "Zoom in - button"
       */

      link.setAttribute('role', 'button');
      link.setAttribute('aria-label', title);
      disableClickPropagation(link);
      on(link, 'click', stop);
      on(link, 'click', fn, this);
      on(link, 'click', this._refocusOnMap, this);
      return link;
    },
    _updateDisabled: function () {
      var map = this._map,
          className = 'leaflet-disabled';
      removeClass(this._zoomInButton, className);
      removeClass(this._zoomOutButton, className);

      if (this._disabled || map._zoom === map.getMinZoom()) {
        addClass(this._zoomOutButton, className);
      }

      if (this._disabled || map._zoom === map.getMaxZoom()) {
        addClass(this._zoomInButton, className);
      }
    }
  }); // @namespace Map
  // @section Control options
  // @option zoomControl: Boolean = true
  // Whether a [zoom control](#control-zoom) is added to the map by default.

  Map.mergeOptions({
    zoomControl: true
  });
  Map.addInitHook(function () {
    if (this.options.zoomControl) {
      // @section Controls
      // @property zoomControl: Control.Zoom
      // The default zoom control (only available if the
      // [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).
      this.zoomControl = new Zoom();
      this.addControl(this.zoomControl);
    }
  }); // @namespace Control.Zoom
  // @factory L.control.zoom(options: Control.Zoom options)
  // Creates a zoom control

  var zoom = function (options) {
    return new Zoom(options);
  };
  /*
   * @class Control.Scale
   * @aka L.Control.Scale
   * @inherits Control
   *
   * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
   *
   * @example
   *
   * ```js
   * L.control.scale().addTo(map);
   * ```
   */


  var Scale = Control.extend({
    // @section
    // @aka Control.Scale options
    options: {
      position: 'bottomleft',
      // @option maxWidth: Number = 100
      // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
      maxWidth: 100,
      // @option metric: Boolean = True
      // Whether to show the metric scale line (m/km).
      metric: true,
      // @option imperial: Boolean = True
      // Whether to show the imperial scale line (mi/ft).
      imperial: true // @option updateWhenIdle: Boolean = false
      // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).

    },
    onAdd: function (map) {
      var className = 'leaflet-control-scale',
          container = create$1('div', className),
          options = this.options;

      this._addScales(options, className + '-line', container);

      map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
      map.whenReady(this._update, this);
      return container;
    },
    onRemove: function (map) {
      map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
    },
    _addScales: function (options, className, container) {
      if (options.metric) {
        this._mScale = create$1('div', className, container);
      }

      if (options.imperial) {
        this._iScale = create$1('div', className, container);
      }
    },
    _update: function () {
      var map = this._map,
          y = map.getSize().y / 2;
      var maxMeters = map.distance(map.containerPointToLatLng([0, y]), map.containerPointToLatLng([this.options.maxWidth, y]));

      this._updateScales(maxMeters);
    },
    _updateScales: function (maxMeters) {
      if (this.options.metric && maxMeters) {
        this._updateMetric(maxMeters);
      }

      if (this.options.imperial && maxMeters) {
        this._updateImperial(maxMeters);
      }
    },
    _updateMetric: function (maxMeters) {
      var meters = this._getRoundNum(maxMeters),
          label = meters < 1000 ? meters + ' m' : meters / 1000 + ' km';

      this._updateScale(this._mScale, label, meters / maxMeters);
    },
    _updateImperial: function (maxMeters) {
      var maxFeet = maxMeters * 3.2808399,
          maxMiles,
          miles,
          feet;

      if (maxFeet > 5280) {
        maxMiles = maxFeet / 5280;
        miles = this._getRoundNum(maxMiles);

        this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);
      } else {
        feet = this._getRoundNum(maxFeet);

        this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
      }
    },
    _updateScale: function (scale, text, ratio) {
      scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
      scale.innerHTML = text;
    },
    _getRoundNum: function (num) {
      var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
          d = num / pow10;
      d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
      return pow10 * d;
    }
  }); // @factory L.control.scale(options?: Control.Scale options)
  // Creates an scale control with the given options.

  var scale = function (options) {
    return new Scale(options);
  };
  /*
   * @class Control.Attribution
   * @aka L.Control.Attribution
   * @inherits Control
   *
   * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
   */


  var Attribution = Control.extend({
    // @section
    // @aka Control.Attribution options
    options: {
      position: 'bottomright',
      // @option prefix: String = 'Leaflet'
      // The HTML text shown before the attributions. Pass `false` to disable.
      prefix: '<a href="https://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
    },
    initialize: function (options) {
      setOptions(this, options);
      this._attributions = {};
    },
    onAdd: function (map) {
      map.attributionControl = this;
      this._container = create$1('div', 'leaflet-control-attribution');
      disableClickPropagation(this._container); // TODO ugly, refactor

      for (var i in map._layers) {
        if (map._layers[i].getAttribution) {
          this.addAttribution(map._layers[i].getAttribution());
        }
      }

      this._update();

      return this._container;
    },
    // @method setPrefix(prefix: String): this
    // Sets the text before the attributions.
    setPrefix: function (prefix) {
      this.options.prefix = prefix;

      this._update();

      return this;
    },
    // @method addAttribution(text: String): this
    // Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
    addAttribution: function (text) {
      if (!text) {
        return this;
      }

      if (!this._attributions[text]) {
        this._attributions[text] = 0;
      }

      this._attributions[text]++;

      this._update();

      return this;
    },
    // @method removeAttribution(text: String): this
    // Removes an attribution text.
    removeAttribution: function (text) {
      if (!text) {
        return this;
      }

      if (this._attributions[text]) {
        this._attributions[text]--;

        this._update();
      }

      return this;
    },
    _update: function () {
      if (!this._map) {
        return;
      }

      var attribs = [];

      for (var i in this._attributions) {
        if (this._attributions[i]) {
          attribs.push(i);
        }
      }

      var prefixAndAttribs = [];

      if (this.options.prefix) {
        prefixAndAttribs.push(this.options.prefix);
      }

      if (attribs.length) {
        prefixAndAttribs.push(attribs.join(', '));
      }

      this._container.innerHTML = prefixAndAttribs.join(' | ');
    }
  }); // @namespace Map
  // @section Control options
  // @option attributionControl: Boolean = true
  // Whether a [attribution control](#control-attribution) is added to the map by default.

  Map.mergeOptions({
    attributionControl: true
  });
  Map.addInitHook(function () {
    if (this.options.attributionControl) {
      new Attribution().addTo(this);
    }
  }); // @namespace Control.Attribution
  // @factory L.control.attribution(options: Control.Attribution options)
  // Creates an attribution control.

  var attribution = function (options) {
    return new Attribution(options);
  };

  Control.Layers = Layers;
  Control.Zoom = Zoom;
  Control.Scale = Scale;
  Control.Attribution = Attribution;
  control.layers = layers;
  control.zoom = zoom;
  control.scale = scale;
  control.attribution = attribution;
  /*
  	L.Handler is a base class for handler classes that are used internally to inject
  	interaction features like dragging to classes like Map and Marker.
  */
  // @class Handler
  // @aka L.Handler
  // Abstract class for map interaction handlers

  var Handler = Class.extend({
    initialize: function (map) {
      this._map = map;
    },
    // @method enable(): this
    // Enables the handler
    enable: function () {
      if (this._enabled) {
        return this;
      }

      this._enabled = true;
      this.addHooks();
      return this;
    },
    // @method disable(): this
    // Disables the handler
    disable: function () {
      if (!this._enabled) {
        return this;
      }

      this._enabled = false;
      this.removeHooks();
      return this;
    },
    // @method enabled(): Boolean
    // Returns `true` if the handler is enabled
    enabled: function () {
      return !!this._enabled;
    } // @section Extension methods
    // Classes inheriting from `Handler` must implement the two following methods:
    // @method addHooks()
    // Called when the handler is enabled, should add event hooks.
    // @method removeHooks()
    // Called when the handler is disabled, should remove the event hooks added previously.

  }); // @section There is static function which can be called without instantiating L.Handler:
  // @function addTo(map: Map, name: String): this
  // Adds a new Handler to the given map with the given name.

  Handler.addTo = function (map, name) {
    map.addHandler(name, this);
    return this;
  };

  var Mixin = {
    Events: Events
  };
  /*
   * @class Draggable
   * @aka L.Draggable
   * @inherits Evented
   *
   * A class for making DOM elements draggable (including touch support).
   * Used internally for map and marker dragging. Only works for elements
   * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
   *
   * @example
   * ```js
   * var draggable = new L.Draggable(elementToDrag);
   * draggable.enable();
   * ```
   */

  var START = touch ? 'touchstart mousedown' : 'mousedown';
  var END = {
    mousedown: 'mouseup',
    touchstart: 'touchend',
    pointerdown: 'touchend',
    MSPointerDown: 'touchend'
  };
  var MOVE = {
    mousedown: 'mousemove',
    touchstart: 'touchmove',
    pointerdown: 'touchmove',
    MSPointerDown: 'touchmove'
  };
  var Draggable = Evented.extend({
    options: {
      // @section
      // @aka Draggable options
      // @option clickTolerance: Number = 3
      // The max number of pixels a user can shift the mouse pointer during a click
      // for it to be considered a valid click (as opposed to a mouse drag).
      clickTolerance: 3
    },
    // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
    // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
    initialize: function (element, dragStartTarget, preventOutline$$1, options) {
      setOptions(this, options);
      this._element = element;
      this._dragStartTarget = dragStartTarget || element;
      this._preventOutline = preventOutline$$1;
    },
    // @method enable()
    // Enables the dragging ability
    enable: function () {
      if (this._enabled) {
        return;
      }

      on(this._dragStartTarget, START, this._onDown, this);
      this._enabled = true;
    },
    // @method disable()
    // Disables the dragging ability
    disable: function () {
      if (!this._enabled) {
        return;
      } // If we're currently dragging this draggable,
      // disabling it counts as first ending the drag.


      if (Draggable._dragging === this) {
        this.finishDrag();
      }

      off(this._dragStartTarget, START, this._onDown, this);
      this._enabled = false;
      this._moved = false;
    },
    _onDown: function (e) {
      // Ignore simulated events, since we handle both touch and
      // mouse explicitly; otherwise we risk getting duplicates of
      // touch events, see #4315.
      // Also ignore the event if disabled; this happens in IE11
      // under some circumstances, see #3666.
      if (e._simulated || !this._enabled) {
        return;
      }

      this._moved = false;

      if (hasClass(this._element, 'leaflet-zoom-anim')) {
        return;
      }

      if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
        return;
      }

      Draggable._dragging = this; // Prevent dragging multiple objects at once.

      if (this._preventOutline) {
        preventOutline(this._element);
      }

      disableImageDrag();
      disableTextSelection();

      if (this._moving) {
        return;
      } // @event down: Event
      // Fired when a drag is about to start.


      this.fire('down');
      var first = e.touches ? e.touches[0] : e,
          sizedParent = getSizedParentNode(this._element);
      this._startPoint = new Point(first.clientX, first.clientY); // Cache the scale, so that we can continuously compensate for it during drag (_onMove).

      this._parentScale = getScale(sizedParent);
      on(document, MOVE[e.type], this._onMove, this);
      on(document, END[e.type], this._onUp, this);
    },
    _onMove: function (e) {
      // Ignore simulated events, since we handle both touch and
      // mouse explicitly; otherwise we risk getting duplicates of
      // touch events, see #4315.
      // Also ignore the event if disabled; this happens in IE11
      // under some circumstances, see #3666.
      if (e._simulated || !this._enabled) {
        return;
      }

      if (e.touches && e.touches.length > 1) {
        this._moved = true;
        return;
      }

      var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,
          offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);

      if (!offset.x && !offset.y) {
        return;
      }

      if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
        return;
      } // We assume that the parent container's position, border and scale do not change for the duration of the drag.
      // Therefore there is no need to account for the position and border (they are eliminated by the subtraction)
      // and we can use the cached value for the scale.


      offset.x /= this._parentScale.x;
      offset.y /= this._parentScale.y;
      preventDefault(e);

      if (!this._moved) {
        // @event dragstart: Event
        // Fired when a drag starts
        this.fire('dragstart');
        this._moved = true;
        this._startPos = getPosition(this._element).subtract(offset);
        addClass(document.body, 'leaflet-dragging');
        this._lastTarget = e.target || e.srcElement; // IE and Edge do not give the <use> element, so fetch it
        // if necessary

        if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
          this._lastTarget = this._lastTarget.correspondingUseElement;
        }

        addClass(this._lastTarget, 'leaflet-drag-target');
      }

      this._newPos = this._startPos.add(offset);
      this._moving = true;
      cancelAnimFrame(this._animRequest);
      this._lastEvent = e;
      this._animRequest = requestAnimFrame(this._updatePosition, this, true);
    },
    _updatePosition: function () {
      var e = {
        originalEvent: this._lastEvent
      }; // @event predrag: Event
      // Fired continuously during dragging *before* each corresponding
      // update of the element's position.

      this.fire('predrag', e);
      setPosition(this._element, this._newPos); // @event drag: Event
      // Fired continuously during dragging.

      this.fire('drag', e);
    },
    _onUp: function (e) {
      // Ignore simulated events, since we handle both touch and
      // mouse explicitly; otherwise we risk getting duplicates of
      // touch events, see #4315.
      // Also ignore the event if disabled; this happens in IE11
      // under some circumstances, see #3666.
      if (e._simulated || !this._enabled) {
        return;
      }

      this.finishDrag();
    },
    finishDrag: function () {
      removeClass(document.body, 'leaflet-dragging');

      if (this._lastTarget) {
        removeClass(this._lastTarget, 'leaflet-drag-target');
        this._lastTarget = null;
      }

      for (var i in MOVE) {
        off(document, MOVE[i], this._onMove, this);
        off(document, END[i], this._onUp, this);
      }

      enableImageDrag();
      enableTextSelection();

      if (this._moved && this._moving) {
        // ensure drag is not fired after dragend
        cancelAnimFrame(this._animRequest); // @event dragend: DragEndEvent
        // Fired when the drag ends.

        this.fire('dragend', {
          distance: this._newPos.distanceTo(this._startPos)
        });
      }

      this._moving = false;
      Draggable._dragging = false;
    }
  });
  /*
   * @namespace LineUtil
   *
   * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.
   */
  // Simplify polyline with vertex reduction and Douglas-Peucker simplification.
  // Improves rendering performance dramatically by lessening the number of points to draw.
  // @function simplify(points: Point[], tolerance: Number): Point[]
  // Dramatically reduces the number of points in a polyline while retaining
  // its shape and returns a new array of simplified points, using the
  // [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
  // Used for a huge performance boost when processing/displaying Leaflet polylines for
  // each zoom level and also reducing visual noise. tolerance affects the amount of
  // simplification (lesser value means higher quality but slower and with more points).
  // Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).

  function simplify(points, tolerance) {
    if (!tolerance || !points.length) {
      return points.slice();
    }

    var sqTolerance = tolerance * tolerance; // stage 1: vertex reduction

    points = _reducePoints(points, sqTolerance); // stage 2: Douglas-Peucker simplification

    points = _simplifyDP(points, sqTolerance);
    return points;
  } // @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
  // Returns the distance between point `p` and segment `p1` to `p2`.


  function pointToSegmentDistance(p, p1, p2) {
    return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
  } // @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
  // Returns the closest point from a point `p` on a segment `p1` to `p2`.


  function closestPointOnSegment(p, p1, p2) {
    return _sqClosestPointOnSegment(p, p1, p2);
  } // Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm


  function _simplifyDP(points, sqTolerance) {
    var len = points.length,
        ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
        markers = new ArrayConstructor(len);
    markers[0] = markers[len - 1] = 1;

    _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

    var i,
        newPoints = [];

    for (i = 0; i < len; i++) {
      if (markers[i]) {
        newPoints.push(points[i]);
      }
    }

    return newPoints;
  }

  function _simplifyDPStep(points, markers, sqTolerance, first, last) {
    var maxSqDist = 0,
        index,
        i,
        sqDist;

    for (i = first + 1; i <= last - 1; i++) {
      sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);

      if (sqDist > maxSqDist) {
        index = i;
        maxSqDist = sqDist;
      }
    }

    if (maxSqDist > sqTolerance) {
      markers[index] = 1;

      _simplifyDPStep(points, markers, sqTolerance, first, index);

      _simplifyDPStep(points, markers, sqTolerance, index, last);
    }
  } // reduce points that are too close to each other to a single point


  function _reducePoints(points, sqTolerance) {
    var reducedPoints = [points[0]];

    for (var i = 1, prev = 0, len = points.length; i < len; i++) {
      if (_sqDist(points[i], points[prev]) > sqTolerance) {
        reducedPoints.push(points[i]);
        prev = i;
      }
    }

    if (prev < len - 1) {
      reducedPoints.push(points[len - 1]);
    }

    return reducedPoints;
  }

  var _lastCode; // @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
  // Clips the segment a to b by rectangular bounds with the
  // [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
  // (modifying the segment points directly!). Used by Leaflet to only show polyline
  // points that are on the screen or near, increasing performance.


  function clipSegment(a, b, bounds, useLastCode, round) {
    var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
        codeB = _getBitCode(b, bounds),
        codeOut,
        p,
        newCode; // save 2nd code to avoid calculating it on the next segment


    _lastCode = codeB;

    while (true) {
      // if a,b is inside the clip window (trivial accept)
      if (!(codeA | codeB)) {
        return [a, b];
      } // if a,b is outside the clip window (trivial reject)


      if (codeA & codeB) {
        return false;
      } // other cases


      codeOut = codeA || codeB;
      p = _getEdgeIntersection(a, b, codeOut, bounds, round);
      newCode = _getBitCode(p, bounds);

      if (codeOut === codeA) {
        a = p;
        codeA = newCode;
      } else {
        b = p;
        codeB = newCode;
      }
    }
  }

  function _getEdgeIntersection(a, b, code, bounds, round) {
    var dx = b.x - a.x,
        dy = b.y - a.y,
        min = bounds.min,
        max = bounds.max,
        x,
        y;

    if (code & 8) {
      // top
      x = a.x + dx * (max.y - a.y) / dy;
      y = max.y;
    } else if (code & 4) {
      // bottom
      x = a.x + dx * (min.y - a.y) / dy;
      y = min.y;
    } else if (code & 2) {
      // right
      x = max.x;
      y = a.y + dy * (max.x - a.x) / dx;
    } else if (code & 1) {
      // left
      x = min.x;
      y = a.y + dy * (min.x - a.x) / dx;
    }

    return new Point(x, y, round);
  }

  function _getBitCode(p, bounds) {
    var code = 0;

    if (p.x < bounds.min.x) {
      // left
      code |= 1;
    } else if (p.x > bounds.max.x) {
      // right
      code |= 2;
    }

    if (p.y < bounds.min.y) {
      // bottom
      code |= 4;
    } else if (p.y > bounds.max.y) {
      // top
      code |= 8;
    }

    return code;
  } // square distance (to avoid unnecessary Math.sqrt calls)


  function _sqDist(p1, p2) {
    var dx = p2.x - p1.x,
        dy = p2.y - p1.y;
    return dx * dx + dy * dy;
  } // return closest point on segment or distance to that point


  function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
    var x = p1.x,
        y = p1.y,
        dx = p2.x - x,
        dy = p2.y - y,
        dot = dx * dx + dy * dy,
        t;

    if (dot > 0) {
      t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

      if (t > 1) {
        x = p2.x;
        y = p2.y;
      } else if (t > 0) {
        x += dx * t;
        y += dy * t;
      }
    }

    dx = p.x - x;
    dy = p.y - y;
    return sqDist ? dx * dx + dy * dy : new Point(x, y);
  } // @function isFlat(latlngs: LatLng[]): Boolean
  // Returns true if `latlngs` is a flat array, false is nested.


  function isFlat(latlngs) {
    return !isArray(latlngs[0]) || typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined';
  }

  function _flat(latlngs) {
    console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');
    return isFlat(latlngs);
  }

  var LineUtil = {
    simplify: simplify,
    pointToSegmentDistance: pointToSegmentDistance,
    closestPointOnSegment: closestPointOnSegment,
    clipSegment: clipSegment,
    _getEdgeIntersection: _getEdgeIntersection,
    _getBitCode: _getBitCode,
    _sqClosestPointOnSegment: _sqClosestPointOnSegment,
    isFlat: isFlat,
    _flat: _flat
  };
  /*
   * @namespace PolyUtil
   * Various utility functions for polygon geometries.
   */

  /* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
   * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
   * Used by Leaflet to only show polygon points that are on the screen or near, increasing
   * performance. Note that polygon points needs different algorithm for clipping
   * than polyline, so there's a separate method for it.
   */

  function clipPolygon(points, bounds, round) {
    var clippedPoints,
        edges = [1, 4, 2, 8],
        i,
        j,
        k,
        a,
        b,
        len,
        edge,
        p;

    for (i = 0, len = points.length; i < len; i++) {
      points[i]._code = _getBitCode(points[i], bounds);
    } // for each edge (left, bottom, right, top)


    for (k = 0; k < 4; k++) {
      edge = edges[k];
      clippedPoints = [];

      for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
        a = points[i];
        b = points[j]; // if a is inside the clip window

        if (!(a._code & edge)) {
          // if b is outside the clip window (a->b goes out of screen)
          if (b._code & edge) {
            p = _getEdgeIntersection(b, a, edge, bounds, round);
            p._code = _getBitCode(p, bounds);
            clippedPoints.push(p);
          }

          clippedPoints.push(a); // else if b is inside the clip window (a->b enters the screen)
        } else if (!(b._code & edge)) {
          p = _getEdgeIntersection(b, a, edge, bounds, round);
          p._code = _getBitCode(p, bounds);
          clippedPoints.push(p);
        }
      }

      points = clippedPoints;
    }

    return points;
  }

  var PolyUtil = {
    clipPolygon: clipPolygon
  };
  /*
   * @namespace Projection
   * @section
   * Leaflet comes with a set of already defined Projections out of the box:
   *
   * @projection L.Projection.LonLat
   *
   * Equirectangular, or Plate Carree projection — the most simple projection,
   * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
   * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
   * `EPSG:4326` and `Simple` CRS.
   */

  var LonLat = {
    project: function (latlng) {
      return new Point(latlng.lng, latlng.lat);
    },
    unproject: function (point) {
      return new LatLng(point.y, point.x);
    },
    bounds: new Bounds([-180, -90], [180, 90])
  };
  /*
   * @namespace Projection
   * @projection L.Projection.Mercator
   *
   * Elliptical Mercator projection — more complex than Spherical Mercator. Assumes that Earth is an ellipsoid. Used by the EPSG:3395 CRS.
   */

  var Mercator = {
    R: 6378137,
    R_MINOR: 6356752.314245179,
    bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),
    project: function (latlng) {
      var d = Math.PI / 180,
          r = this.R,
          y = latlng.lat * d,
          tmp = this.R_MINOR / r,
          e = Math.sqrt(1 - tmp * tmp),
          con = e * Math.sin(y);
      var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
      y = -r * Math.log(Math.max(ts, 1E-10));
      return new Point(latlng.lng * d * r, y);
    },
    unproject: function (point) {
      var d = 180 / Math.PI,
          r = this.R,
          tmp = this.R_MINOR / r,
          e = Math.sqrt(1 - tmp * tmp),
          ts = Math.exp(-point.y / r),
          phi = Math.PI / 2 - 2 * Math.atan(ts);

      for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
        con = e * Math.sin(phi);
        con = Math.pow((1 - con) / (1 + con), e / 2);
        dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
        phi += dphi;
      }

      return new LatLng(phi * d, point.x * d / r);
    }
  };
  /*
   * @class Projection
    * An object with methods for projecting geographical coordinates of the world onto
   * a flat surface (and back). See [Map projection](http://en.wikipedia.org/wiki/Map_projection).
    * @property bounds: Bounds
   * The bounds (specified in CRS units) where the projection is valid
    * @method project(latlng: LatLng): Point
   * Projects geographical coordinates into a 2D point.
   * Only accepts actual `L.LatLng` instances, not arrays.
    * @method unproject(point: Point): LatLng
   * The inverse of `project`. Projects a 2D point into a geographical location.
   * Only accepts actual `L.Point` instances, not arrays.
    * Note that the projection instances do not inherit from Leaflet's `Class` object,
   * and can't be instantiated. Also, new classes can't inherit from them,
   * and methods can't be added to them with the `include` function.
    */

  var index = {
    LonLat: LonLat,
    Mercator: Mercator,
    SphericalMercator: SphericalMercator
  };
  /*
   * @namespace CRS
   * @crs L.CRS.EPSG3395
   *
   * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
   */

  var EPSG3395 = extend({}, Earth, {
    code: 'EPSG:3395',
    projection: Mercator,
    transformation: function () {
      var scale = 0.5 / (Math.PI * Mercator.R);
      return toTransformation(scale, 0.5, -scale, 0.5);
    }()
  });
  /*
   * @namespace CRS
   * @crs L.CRS.EPSG4326
   *
   * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
   *
   * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
   * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
   * with this CRS, ensure that there are two 256x256 pixel tiles covering the
   * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
   * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
   */

  var EPSG4326 = extend({}, Earth, {
    code: 'EPSG:4326',
    projection: LonLat,
    transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
  });
  /*
   * @namespace CRS
   * @crs L.CRS.Simple
   *
   * A simple CRS that maps longitude and latitude into `x` and `y` directly.
   * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
   * axis should still be inverted (going from bottom to top). `distance()` returns
   * simple euclidean distance.
   */

  var Simple = extend({}, CRS, {
    projection: LonLat,
    transformation: toTransformation(1, 0, -1, 0),
    scale: function (zoom) {
      return Math.pow(2, zoom);
    },
    zoom: function (scale) {
      return Math.log(scale) / Math.LN2;
    },
    distance: function (latlng1, latlng2) {
      var dx = latlng2.lng - latlng1.lng,
          dy = latlng2.lat - latlng1.lat;
      return Math.sqrt(dx * dx + dy * dy);
    },
    infinite: true
  });
  CRS.Earth = Earth;
  CRS.EPSG3395 = EPSG3395;
  CRS.EPSG3857 = EPSG3857;
  CRS.EPSG900913 = EPSG900913;
  CRS.EPSG4326 = EPSG4326;
  CRS.Simple = Simple;
  /*
   * @class Layer
   * @inherits Evented
   * @aka L.Layer
   * @aka ILayer
   *
   * A set of methods from the Layer base class that all Leaflet layers use.
   * Inherits all methods, options and events from `L.Evented`.
   *
   * @example
   *
   * ```js
   * var layer = L.marker(latlng).addTo(map);
   * layer.addTo(map);
   * layer.remove();
   * ```
   *
   * @event add: Event
   * Fired after the layer is added to a map
   *
   * @event remove: Event
   * Fired after the layer is removed from a map
   */

  var Layer = Evented.extend({
    // Classes extending `L.Layer` will inherit the following options:
    options: {
      // @option pane: String = 'overlayPane'
      // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
      pane: 'overlayPane',
      // @option attribution: String = null
      // String to be shown in the attribution control, e.g. "© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
      attribution: null,
      bubblingMouseEvents: true
    },

    /* @section
     * Classes extending `L.Layer` will inherit the following methods:
     *
     * @method addTo(map: Map|LayerGroup): this
     * Adds the layer to the given map or layer group.
     */
    addTo: function (map) {
      map.addLayer(this);
      return this;
    },
    // @method remove: this
    // Removes the layer from the map it is currently active on.
    remove: function () {
      return this.removeFrom(this._map || this._mapToAdd);
    },
    // @method removeFrom(map: Map): this
    // Removes the layer from the given map
    //
    // @alternative
    // @method removeFrom(group: LayerGroup): this
    // Removes the layer from the given `LayerGroup`
    removeFrom: function (obj) {
      if (obj) {
        obj.removeLayer(this);
      }

      return this;
    },
    // @method getPane(name? : String): HTMLElement
    // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
    getPane: function (name) {
      return this._map.getPane(name ? this.options[name] || name : this.options.pane);
    },
    addInteractiveTarget: function (targetEl) {
      this._map._targets[stamp(targetEl)] = this;
      return this;
    },
    removeInteractiveTarget: function (targetEl) {
      delete this._map._targets[stamp(targetEl)];
      return this;
    },
    // @method getAttribution: String
    // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
    getAttribution: function () {
      return this.options.attribution;
    },
    _layerAdd: function (e) {
      var map = e.target; // check in case layer gets added and then removed before the map is ready

      if (!map.hasLayer(this)) {
        return;
      }

      this._map = map;
      this._zoomAnimated = map._zoomAnimated;

      if (this.getEvents) {
        var events = this.getEvents();
        map.on(events, this);
        this.once('remove', function () {
          map.off(events, this);
        }, this);
      }

      this.onAdd(map);

      if (this.getAttribution && map.attributionControl) {
        map.attributionControl.addAttribution(this.getAttribution());
      }

      this.fire('add');
      map.fire('layeradd', {
        layer: this
      });
    }
  });
  /* @section Extension methods
   * @uninheritable
   *
   * Every layer should extend from `L.Layer` and (re-)implement the following methods.
   *
   * @method onAdd(map: Map): this
   * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
   *
   * @method onRemove(map: Map): this
   * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
   *
   * @method getEvents(): Object
   * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
   *
   * @method getAttribution(): String
   * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
   *
   * @method beforeAdd(map: Map): this
   * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
   */

  /* @namespace Map
   * @section Layer events
   *
   * @event layeradd: LayerEvent
   * Fired when a new layer is added to the map.
   *
   * @event layerremove: LayerEvent
   * Fired when some layer is removed from the map
   *
   * @section Methods for Layers and Controls
   */

  Map.include({
    // @method addLayer(layer: Layer): this
    // Adds the given layer to the map
    addLayer: function (layer) {
      if (!layer._layerAdd) {
        throw new Error('The provided object is not a Layer.');
      }

      var id = stamp(layer);

      if (this._layers[id]) {
        return this;
      }

      this._layers[id] = layer;
      layer._mapToAdd = this;

      if (layer.beforeAdd) {
        layer.beforeAdd(this);
      }

      this.whenReady(layer._layerAdd, layer);
      return this;
    },
    // @method removeLayer(layer: Layer): this
    // Removes the given layer from the map.
    removeLayer: function (layer) {
      var id = stamp(layer);

      if (!this._layers[id]) {
        return this;
      }

      if (this._loaded) {
        layer.onRemove(this);
      }

      if (layer.getAttribution && this.attributionControl) {
        this.attributionControl.removeAttribution(layer.getAttribution());
      }

      delete this._layers[id];

      if (this._loaded) {
        this.fire('layerremove', {
          layer: layer
        });
        layer.fire('remove');
      }

      layer._map = layer._mapToAdd = null;
      return this;
    },
    // @method hasLayer(layer: Layer): Boolean
    // Returns `true` if the given layer is currently added to the map
    hasLayer: function (layer) {
      return !!layer && stamp(layer) in this._layers;
    },

    /* @method eachLayer(fn: Function, context?: Object): this
     * Iterates over the layers of the map, optionally specifying context of the iterator function.
     * ```
     * map.eachLayer(function(layer){
     *     layer.bindPopup('Hello');
     * });
     * ```
     */
    eachLayer: function (method, context) {
      for (var i in this._layers) {
        method.call(context, this._layers[i]);
      }

      return this;
    },
    _addLayers: function (layers) {
      layers = layers ? isArray(layers) ? layers : [layers] : [];

      for (var i = 0, len = layers.length; i < len; i++) {
        this.addLayer(layers[i]);
      }
    },
    _addZoomLimit: function (layer) {
      if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
        this._zoomBoundLayers[stamp(layer)] = layer;

        this._updateZoomLevels();
      }
    },
    _removeZoomLimit: function (layer) {
      var id = stamp(layer);

      if (this._zoomBoundLayers[id]) {
        delete this._zoomBoundLayers[id];

        this._updateZoomLevels();
      }
    },
    _updateZoomLevels: function () {
      var minZoom = Infinity,
          maxZoom = -Infinity,
          oldZoomSpan = this._getZoomSpan();

      for (var i in this._zoomBoundLayers) {
        var options = this._zoomBoundLayers[i].options;
        minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
        maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
      }

      this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
      this._layersMinZoom = minZoom === Infinity ? undefined : minZoom; // @section Map state change events
      // @event zoomlevelschange: Event
      // Fired when the number of zoomlevels on the map is changed due
      // to adding or removing a layer.

      if (oldZoomSpan !== this._getZoomSpan()) {
        this.fire('zoomlevelschange');
      }

      if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
        this.setZoom(this._layersMaxZoom);
      }

      if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
        this.setZoom(this._layersMinZoom);
      }
    }
  });
  /*
   * @class LayerGroup
   * @aka L.LayerGroup
   * @inherits Layer
   *
   * Used to group several layers and handle them as one. If you add it to the map,
   * any layers added or removed from the group will be added/removed on the map as
   * well. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * L.layerGroup([marker1, marker2])
   * 	.addLayer(polyline)
   * 	.addTo(map);
   * ```
   */

  var LayerGroup = Layer.extend({
    initialize: function (layers, options) {
      setOptions(this, options);
      this._layers = {};
      var i, len;

      if (layers) {
        for (i = 0, len = layers.length; i < len; i++) {
          this.addLayer(layers[i]);
        }
      }
    },
    // @method addLayer(layer: Layer): this
    // Adds the given layer to the group.
    addLayer: function (layer) {
      var id = this.getLayerId(layer);
      this._layers[id] = layer;

      if (this._map) {
        this._map.addLayer(layer);
      }

      return this;
    },
    // @method removeLayer(layer: Layer): this
    // Removes the given layer from the group.
    // @alternative
    // @method removeLayer(id: Number): this
    // Removes the layer with the given internal ID from the group.
    removeLayer: function (layer) {
      var id = layer in this._layers ? layer : this.getLayerId(layer);

      if (this._map && this._layers[id]) {
        this._map.removeLayer(this._layers[id]);
      }

      delete this._layers[id];
      return this;
    },
    // @method hasLayer(layer: Layer): Boolean
    // Returns `true` if the given layer is currently added to the group.
    // @alternative
    // @method hasLayer(id: Number): Boolean
    // Returns `true` if the given internal ID is currently added to the group.
    hasLayer: function (layer) {
      if (!layer) {
        return false;
      }

      var layerId = typeof layer === 'number' ? layer : this.getLayerId(layer);
      return layerId in this._layers;
    },
    // @method clearLayers(): this
    // Removes all the layers from the group.
    clearLayers: function () {
      return this.eachLayer(this.removeLayer, this);
    },
    // @method invoke(methodName: String, …): this
    // Calls `methodName` on every layer contained in this group, passing any
    // additional parameters. Has no effect if the layers contained do not
    // implement `methodName`.
    invoke: function (methodName) {
      var args = Array.prototype.slice.call(arguments, 1),
          i,
          layer;

      for (i in this._layers) {
        layer = this._layers[i];

        if (layer[methodName]) {
          layer[methodName].apply(layer, args);
        }
      }

      return this;
    },
    onAdd: function (map) {
      this.eachLayer(map.addLayer, map);
    },
    onRemove: function (map) {
      this.eachLayer(map.removeLayer, map);
    },
    // @method eachLayer(fn: Function, context?: Object): this
    // Iterates over the layers of the group, optionally specifying context of the iterator function.
    // ```js
    // group.eachLayer(function (layer) {
    // 	layer.bindPopup('Hello');
    // });
    // ```
    eachLayer: function (method, context) {
      for (var i in this._layers) {
        method.call(context, this._layers[i]);
      }

      return this;
    },
    // @method getLayer(id: Number): Layer
    // Returns the layer with the given internal ID.
    getLayer: function (id) {
      return this._layers[id];
    },
    // @method getLayers(): Layer[]
    // Returns an array of all the layers added to the group.
    getLayers: function () {
      var layers = [];
      this.eachLayer(layers.push, layers);
      return layers;
    },
    // @method setZIndex(zIndex: Number): this
    // Calls `setZIndex` on every layer contained in this group, passing the z-index.
    setZIndex: function (zIndex) {
      return this.invoke('setZIndex', zIndex);
    },
    // @method getLayerId(layer: Layer): Number
    // Returns the internal ID for a layer
    getLayerId: function (layer) {
      return stamp(layer);
    }
  }); // @factory L.layerGroup(layers?: Layer[], options?: Object)
  // Create a layer group, optionally given an initial set of layers and an `options` object.

  var layerGroup = function (layers, options) {
    return new LayerGroup(layers, options);
  };
  /*
   * @class FeatureGroup
   * @aka L.FeatureGroup
   * @inherits LayerGroup
   *
   * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
   *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
   *  * Events are propagated to the `FeatureGroup`, so if the group has an event
   * handler, it will handle events from any of the layers. This includes mouse events
   * and custom events.
   *  * Has `layeradd` and `layerremove` events
   *
   * @example
   *
   * ```js
   * L.featureGroup([marker1, marker2, polyline])
   * 	.bindPopup('Hello world!')
   * 	.on('click', function() { alert('Clicked on a member of the group!'); })
   * 	.addTo(map);
   * ```
   */


  var FeatureGroup = LayerGroup.extend({
    addLayer: function (layer) {
      if (this.hasLayer(layer)) {
        return this;
      }

      layer.addEventParent(this);
      LayerGroup.prototype.addLayer.call(this, layer); // @event layeradd: LayerEvent
      // Fired when a layer is added to this `FeatureGroup`

      return this.fire('layeradd', {
        layer: layer
      });
    },
    removeLayer: function (layer) {
      if (!this.hasLayer(layer)) {
        return this;
      }

      if (layer in this._layers) {
        layer = this._layers[layer];
      }

      layer.removeEventParent(this);
      LayerGroup.prototype.removeLayer.call(this, layer); // @event layerremove: LayerEvent
      // Fired when a layer is removed from this `FeatureGroup`

      return this.fire('layerremove', {
        layer: layer
      });
    },
    // @method setStyle(style: Path options): this
    // Sets the given path options to each layer of the group that has a `setStyle` method.
    setStyle: function (style) {
      return this.invoke('setStyle', style);
    },
    // @method bringToFront(): this
    // Brings the layer group to the top of all other layers
    bringToFront: function () {
      return this.invoke('bringToFront');
    },
    // @method bringToBack(): this
    // Brings the layer group to the back of all other layers
    bringToBack: function () {
      return this.invoke('bringToBack');
    },
    // @method getBounds(): LatLngBounds
    // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
    getBounds: function () {
      var bounds = new LatLngBounds();

      for (var id in this._layers) {
        var layer = this._layers[id];
        bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
      }

      return bounds;
    }
  }); // @factory L.featureGroup(layers?: Layer[], options?: Object)
  // Create a feature group, optionally given an initial set of layers and an `options` object.

  var featureGroup = function (layers, options) {
    return new FeatureGroup(layers, options);
  };
  /*
   * @class Icon
   * @aka L.Icon
   *
   * Represents an icon to provide when creating a marker.
   *
   * @example
   *
   * ```js
   * var myIcon = L.icon({
   *     iconUrl: 'my-icon.png',
   *     iconRetinaUrl: 'my-icon@2x.png',
   *     iconSize: [38, 95],
   *     iconAnchor: [22, 94],
   *     popupAnchor: [-3, -76],
   *     shadowUrl: 'my-icon-shadow.png',
   *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
   *     shadowSize: [68, 95],
   *     shadowAnchor: [22, 94]
   * });
   *
   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
   * ```
   *
   * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
   *
   */


  var Icon = Class.extend({
    /* @section
     * @aka Icon options
     *
     * @option iconUrl: String = null
     * **(required)** The URL to the icon image (absolute or relative to your script path).
     *
     * @option iconRetinaUrl: String = null
     * The URL to a retina sized version of the icon image (absolute or relative to your
     * script path). Used for Retina screen devices.
     *
     * @option iconSize: Point = null
     * Size of the icon image in pixels.
     *
     * @option iconAnchor: Point = null
     * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
     * will be aligned so that this point is at the marker's geographical location. Centered
     * by default if size is specified, also can be set in CSS with negative margins.
     *
     * @option popupAnchor: Point = [0, 0]
     * The coordinates of the point from which popups will "open", relative to the icon anchor.
     *
     * @option tooltipAnchor: Point = [0, 0]
     * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
     *
     * @option shadowUrl: String = null
     * The URL to the icon shadow image. If not specified, no shadow image will be created.
     *
     * @option shadowRetinaUrl: String = null
     *
     * @option shadowSize: Point = null
     * Size of the shadow image in pixels.
     *
     * @option shadowAnchor: Point = null
     * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
     * as iconAnchor if not specified).
     *
     * @option className: String = ''
     * A custom class name to assign to both icon and shadow images. Empty by default.
     */
    options: {
      popupAnchor: [0, 0],
      tooltipAnchor: [0, 0]
    },
    initialize: function (options) {
      setOptions(this, options);
    },
    // @method createIcon(oldIcon?: HTMLElement): HTMLElement
    // Called internally when the icon has to be shown, returns a `<img>` HTML element
    // styled according to the options.
    createIcon: function (oldIcon) {
      return this._createIcon('icon', oldIcon);
    },
    // @method createShadow(oldIcon?: HTMLElement): HTMLElement
    // As `createIcon`, but for the shadow beneath it.
    createShadow: function (oldIcon) {
      return this._createIcon('shadow', oldIcon);
    },
    _createIcon: function (name, oldIcon) {
      var src = this._getIconUrl(name);

      if (!src) {
        if (name === 'icon') {
          throw new Error('iconUrl not set in Icon options (see the docs).');
        }

        return null;
      }

      var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);

      this._setIconStyles(img, name);

      return img;
    },
    _setIconStyles: function (img, name) {
      var options = this.options;
      var sizeOption = options[name + 'Size'];

      if (typeof sizeOption === 'number') {
        sizeOption = [sizeOption, sizeOption];
      }

      var size = toPoint(sizeOption),
          anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
      img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

      if (anchor) {
        img.style.marginLeft = -anchor.x + 'px';
        img.style.marginTop = -anchor.y + 'px';
      }

      if (size) {
        img.style.width = size.x + 'px';
        img.style.height = size.y + 'px';
      }
    },
    _createImg: function (src, el) {
      el = el || document.createElement('img');
      el.src = src;
      return el;
    },
    _getIconUrl: function (name) {
      return retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
    }
  }); // @factory L.icon(options: Icon options)
  // Creates an icon instance with the given options.

  function icon(options) {
    return new Icon(options);
  }
  /*
   * @miniclass Icon.Default (Icon)
   * @aka L.Icon.Default
   * @section
   *
   * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
   * no icon is specified. Points to the blue marker image distributed with Leaflet
   * releases.
   *
   * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
   * (which is a set of `Icon options`).
   *
   * If you want to _completely_ replace the default icon, override the
   * `L.Marker.prototype.options.icon` with your own icon instead.
   */


  var IconDefault = Icon.extend({
    options: {
      iconUrl: 'marker-icon.png',
      iconRetinaUrl: 'marker-icon-2x.png',
      shadowUrl: 'marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      tooltipAnchor: [16, -28],
      shadowSize: [41, 41]
    },
    _getIconUrl: function (name) {
      if (!IconDefault.imagePath) {
        // Deprecated, backwards-compatibility only
        IconDefault.imagePath = this._detectIconPath();
      } // @option imagePath: String
      // `Icon.Default` will try to auto-detect the location of the
      // blue icon images. If you are placing these images in a non-standard
      // way, set this option to point to the right path.


      return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
    },
    _detectIconPath: function () {
      var el = create$1('div', 'leaflet-default-icon-path', document.body);
      var path = getStyle(el, 'background-image') || getStyle(el, 'backgroundImage'); // IE8

      document.body.removeChild(el);

      if (path === null || path.indexOf('url') !== 0) {
        path = '';
      } else {
        path = path.replace(/^url\(["']?/, '').replace(/marker-icon\.png["']?\)$/, '');
      }

      return path;
    }
  });
  /*
   * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
   */

  /* @namespace Marker
   * @section Interaction handlers
   *
   * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
   *
   * ```js
   * marker.dragging.disable();
   * ```
   *
   * @property dragging: Handler
   * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
   */

  var MarkerDrag = Handler.extend({
    initialize: function (marker) {
      this._marker = marker;
    },
    addHooks: function () {
      var icon = this._marker._icon;

      if (!this._draggable) {
        this._draggable = new Draggable(icon, icon, true);
      }

      this._draggable.on({
        dragstart: this._onDragStart,
        predrag: this._onPreDrag,
        drag: this._onDrag,
        dragend: this._onDragEnd
      }, this).enable();

      addClass(icon, 'leaflet-marker-draggable');
    },
    removeHooks: function () {
      this._draggable.off({
        dragstart: this._onDragStart,
        predrag: this._onPreDrag,
        drag: this._onDrag,
        dragend: this._onDragEnd
      }, this).disable();

      if (this._marker._icon) {
        removeClass(this._marker._icon, 'leaflet-marker-draggable');
      }
    },
    moved: function () {
      return this._draggable && this._draggable._moved;
    },
    _adjustPan: function (e) {
      var marker = this._marker,
          map = marker._map,
          speed = this._marker.options.autoPanSpeed,
          padding = this._marker.options.autoPanPadding,
          iconPos = getPosition(marker._icon),
          bounds = map.getPixelBounds(),
          origin = map.getPixelOrigin();
      var panBounds = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));

      if (!panBounds.contains(iconPos)) {
        // Compute incremental movement
        var movement = toPoint((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);
        map.panBy(movement, {
          animate: false
        });

        this._draggable._newPos._add(movement);

        this._draggable._startPos._add(movement);

        setPosition(marker._icon, this._draggable._newPos);

        this._onDrag(e);

        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
      }
    },
    _onDragStart: function () {
      // @section Dragging events
      // @event dragstart: Event
      // Fired when the user starts dragging the marker.
      // @event movestart: Event
      // Fired when the marker starts moving (because of dragging).
      this._oldLatLng = this._marker.getLatLng(); // When using ES6 imports it could not be set when `Popup` was not imported as well

      this._marker.closePopup && this._marker.closePopup();

      this._marker.fire('movestart').fire('dragstart');
    },
    _onPreDrag: function (e) {
      if (this._marker.options.autoPan) {
        cancelAnimFrame(this._panRequest);
        this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
      }
    },
    _onDrag: function (e) {
      var marker = this._marker,
          shadow = marker._shadow,
          iconPos = getPosition(marker._icon),
          latlng = marker._map.layerPointToLatLng(iconPos); // update shadow position


      if (shadow) {
        setPosition(shadow, iconPos);
      }

      marker._latlng = latlng;
      e.latlng = latlng;
      e.oldLatLng = this._oldLatLng; // @event drag: Event
      // Fired repeatedly while the user drags the marker.

      marker.fire('move', e).fire('drag', e);
    },
    _onDragEnd: function (e) {
      // @event dragend: DragEndEvent
      // Fired when the user stops dragging the marker.
      cancelAnimFrame(this._panRequest); // @event moveend: Event
      // Fired when the marker stops moving (because of dragging).

      delete this._oldLatLng;

      this._marker.fire('moveend').fire('dragend', e);
    }
  });
  /*
   * @class Marker
   * @inherits Interactive layer
   * @aka L.Marker
   * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * L.marker([50.5, 30.5]).addTo(map);
   * ```
   */

  var Marker = Layer.extend({
    // @section
    // @aka Marker options
    options: {
      // @option icon: Icon = *
      // Icon instance to use for rendering the marker.
      // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
      // If not specified, a common instance of `L.Icon.Default` is used.
      icon: new IconDefault(),
      // Option inherited from "Interactive layer" abstract class
      interactive: true,
      // @option keyboard: Boolean = true
      // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
      keyboard: true,
      // @option title: String = ''
      // Text for the browser tooltip that appear on marker hover (no tooltip by default).
      title: '',
      // @option alt: String = ''
      // Text for the `alt` attribute of the icon image (useful for accessibility).
      alt: '',
      // @option zIndexOffset: Number = 0
      // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
      zIndexOffset: 0,
      // @option opacity: Number = 1.0
      // The opacity of the marker.
      opacity: 1,
      // @option riseOnHover: Boolean = false
      // If `true`, the marker will get on top of others when you hover the mouse over it.
      riseOnHover: false,
      // @option riseOffset: Number = 250
      // The z-index offset used for the `riseOnHover` feature.
      riseOffset: 250,
      // @option pane: String = 'markerPane'
      // `Map pane` where the markers icon will be added.
      pane: 'markerPane',
      // @option shadowPane: String = 'shadowPane'
      // `Map pane` where the markers shadow will be added.
      shadowPane: 'shadowPane',
      // @option bubblingMouseEvents: Boolean = false
      // When `true`, a mouse event on this marker will trigger the same event on the map
      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
      bubblingMouseEvents: false,
      // @section Draggable marker options
      // @option draggable: Boolean = false
      // Whether the marker is draggable with mouse/touch or not.
      draggable: false,
      // @option autoPan: Boolean = false
      // Whether to pan the map when dragging this marker near its edge or not.
      autoPan: false,
      // @option autoPanPadding: Point = Point(50, 50)
      // Distance (in pixels to the left/right and to the top/bottom) of the
      // map edge to start panning the map.
      autoPanPadding: [50, 50],
      // @option autoPanSpeed: Number = 10
      // Number of pixels the map should pan by.
      autoPanSpeed: 10
    },

    /* @section
     *
     * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
     */
    initialize: function (latlng, options) {
      setOptions(this, options);
      this._latlng = toLatLng(latlng);
    },
    onAdd: function (map) {
      this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

      if (this._zoomAnimated) {
        map.on('zoomanim', this._animateZoom, this);
      }

      this._initIcon();

      this.update();
    },
    onRemove: function (map) {
      if (this.dragging && this.dragging.enabled()) {
        this.options.draggable = true;
        this.dragging.removeHooks();
      }

      delete this.dragging;

      if (this._zoomAnimated) {
        map.off('zoomanim', this._animateZoom, this);
      }

      this._removeIcon();

      this._removeShadow();
    },
    getEvents: function () {
      return {
        zoom: this.update,
        viewreset: this.update
      };
    },
    // @method getLatLng: LatLng
    // Returns the current geographical position of the marker.
    getLatLng: function () {
      return this._latlng;
    },
    // @method setLatLng(latlng: LatLng): this
    // Changes the marker position to the given point.
    setLatLng: function (latlng) {
      var oldLatLng = this._latlng;
      this._latlng = toLatLng(latlng);
      this.update(); // @event move: Event
      // Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.

      return this.fire('move', {
        oldLatLng: oldLatLng,
        latlng: this._latlng
      });
    },
    // @method setZIndexOffset(offset: Number): this
    // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
    setZIndexOffset: function (offset) {
      this.options.zIndexOffset = offset;
      return this.update();
    },
    // @method getIcon: Icon
    // Returns the current icon used by the marker
    getIcon: function () {
      return this.options.icon;
    },
    // @method setIcon(icon: Icon): this
    // Changes the marker icon.
    setIcon: function (icon) {
      this.options.icon = icon;

      if (this._map) {
        this._initIcon();

        this.update();
      }

      if (this._popup) {
        this.bindPopup(this._popup, this._popup.options);
      }

      return this;
    },
    getElement: function () {
      return this._icon;
    },
    update: function () {
      if (this._icon && this._map) {
        var pos = this._map.latLngToLayerPoint(this._latlng).round();

        this._setPos(pos);
      }

      return this;
    },
    _initIcon: function () {
      var options = this.options,
          classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');
      var icon = options.icon.createIcon(this._icon),
          addIcon = false; // if we're not reusing the icon, remove the old one and init new one

      if (icon !== this._icon) {
        if (this._icon) {
          this._removeIcon();
        }

        addIcon = true;

        if (options.title) {
          icon.title = options.title;
        }

        if (icon.tagName === 'IMG') {
          icon.alt = options.alt || '';
        }
      }

      addClass(icon, classToAdd);

      if (options.keyboard) {
        icon.tabIndex = '0';
      }

      this._icon = icon;

      if (options.riseOnHover) {
        this.on({
          mouseover: this._bringToFront,
          mouseout: this._resetZIndex
        });
      }

      var newShadow = options.icon.createShadow(this._shadow),
          addShadow = false;

      if (newShadow !== this._shadow) {
        this._removeShadow();

        addShadow = true;
      }

      if (newShadow) {
        addClass(newShadow, classToAdd);
        newShadow.alt = '';
      }

      this._shadow = newShadow;

      if (options.opacity < 1) {
        this._updateOpacity();
      }

      if (addIcon) {
        this.getPane().appendChild(this._icon);
      }

      this._initInteraction();

      if (newShadow && addShadow) {
        this.getPane(options.shadowPane).appendChild(this._shadow);
      }
    },
    _removeIcon: function () {
      if (this.options.riseOnHover) {
        this.off({
          mouseover: this._bringToFront,
          mouseout: this._resetZIndex
        });
      }

      remove(this._icon);
      this.removeInteractiveTarget(this._icon);
      this._icon = null;
    },
    _removeShadow: function () {
      if (this._shadow) {
        remove(this._shadow);
      }

      this._shadow = null;
    },
    _setPos: function (pos) {
      if (this._icon) {
        setPosition(this._icon, pos);
      }

      if (this._shadow) {
        setPosition(this._shadow, pos);
      }

      this._zIndex = pos.y + this.options.zIndexOffset;

      this._resetZIndex();
    },
    _updateZIndex: function (offset) {
      if (this._icon) {
        this._icon.style.zIndex = this._zIndex + offset;
      }
    },
    _animateZoom: function (opt) {
      var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

      this._setPos(pos);
    },
    _initInteraction: function () {
      if (!this.options.interactive) {
        return;
      }

      addClass(this._icon, 'leaflet-interactive');
      this.addInteractiveTarget(this._icon);

      if (MarkerDrag) {
        var draggable = this.options.draggable;

        if (this.dragging) {
          draggable = this.dragging.enabled();
          this.dragging.disable();
        }

        this.dragging = new MarkerDrag(this);

        if (draggable) {
          this.dragging.enable();
        }
      }
    },
    // @method setOpacity(opacity: Number): this
    // Changes the opacity of the marker.
    setOpacity: function (opacity) {
      this.options.opacity = opacity;

      if (this._map) {
        this._updateOpacity();
      }

      return this;
    },
    _updateOpacity: function () {
      var opacity = this.options.opacity;

      if (this._icon) {
        setOpacity(this._icon, opacity);
      }

      if (this._shadow) {
        setOpacity(this._shadow, opacity);
      }
    },
    _bringToFront: function () {
      this._updateZIndex(this.options.riseOffset);
    },
    _resetZIndex: function () {
      this._updateZIndex(0);
    },
    _getPopupAnchor: function () {
      return this.options.icon.options.popupAnchor;
    },
    _getTooltipAnchor: function () {
      return this.options.icon.options.tooltipAnchor;
    }
  }); // factory L.marker(latlng: LatLng, options? : Marker options)
  // @factory L.marker(latlng: LatLng, options? : Marker options)
  // Instantiates a Marker object given a geographical point and optionally an options object.

  function marker(latlng, options) {
    return new Marker(latlng, options);
  }
  /*
   * @class Path
   * @aka L.Path
   * @inherits Interactive layer
   *
   * An abstract class that contains options and constants shared between vector
   * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
   */


  var Path = Layer.extend({
    // @section
    // @aka Path options
    options: {
      // @option stroke: Boolean = true
      // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
      stroke: true,
      // @option color: String = '#3388ff'
      // Stroke color
      color: '#3388ff',
      // @option weight: Number = 3
      // Stroke width in pixels
      weight: 3,
      // @option opacity: Number = 1.0
      // Stroke opacity
      opacity: 1,
      // @option lineCap: String= 'round'
      // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
      lineCap: 'round',
      // @option lineJoin: String = 'round'
      // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
      lineJoin: 'round',
      // @option dashArray: String = null
      // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
      dashArray: null,
      // @option dashOffset: String = null
      // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
      dashOffset: null,
      // @option fill: Boolean = depends
      // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
      fill: false,
      // @option fillColor: String = *
      // Fill color. Defaults to the value of the [`color`](#path-color) option
      fillColor: null,
      // @option fillOpacity: Number = 0.2
      // Fill opacity.
      fillOpacity: 0.2,
      // @option fillRule: String = 'evenodd'
      // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
      fillRule: 'evenodd',
      // className: '',
      // Option inherited from "Interactive layer" abstract class
      interactive: true,
      // @option bubblingMouseEvents: Boolean = true
      // When `true`, a mouse event on this path will trigger the same event on the map
      // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
      bubblingMouseEvents: true
    },
    beforeAdd: function (map) {
      // Renderer is set here because we need to call renderer.getEvents
      // before this.getEvents.
      this._renderer = map.getRenderer(this);
    },
    onAdd: function () {
      this._renderer._initPath(this);

      this._reset();

      this._renderer._addPath(this);
    },
    onRemove: function () {
      this._renderer._removePath(this);
    },
    // @method redraw(): this
    // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
    redraw: function () {
      if (this._map) {
        this._renderer._updatePath(this);
      }

      return this;
    },
    // @method setStyle(style: Path options): this
    // Changes the appearance of a Path based on the options in the `Path options` object.
    setStyle: function (style) {
      setOptions(this, style);

      if (this._renderer) {
        this._renderer._updateStyle(this);

        if (this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, 'weight')) {
          this._updateBounds();
        }
      }

      return this;
    },
    // @method bringToFront(): this
    // Brings the layer to the top of all path layers.
    bringToFront: function () {
      if (this._renderer) {
        this._renderer._bringToFront(this);
      }

      return this;
    },
    // @method bringToBack(): this
    // Brings the layer to the bottom of all path layers.
    bringToBack: function () {
      if (this._renderer) {
        this._renderer._bringToBack(this);
      }

      return this;
    },
    getElement: function () {
      return this._path;
    },
    _reset: function () {
      // defined in child classes
      this._project();

      this._update();
    },
    _clickTolerance: function () {
      // used when doing hit detection for Canvas layers
      return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;
    }
  });
  /*
   * @class CircleMarker
   * @aka L.CircleMarker
   * @inherits Path
   *
   * A circle of a fixed size with radius specified in pixels. Extends `Path`.
   */

  var CircleMarker = Path.extend({
    // @section
    // @aka CircleMarker options
    options: {
      fill: true,
      // @option radius: Number = 10
      // Radius of the circle marker, in pixels
      radius: 10
    },
    initialize: function (latlng, options) {
      setOptions(this, options);
      this._latlng = toLatLng(latlng);
      this._radius = this.options.radius;
    },
    // @method setLatLng(latLng: LatLng): this
    // Sets the position of a circle marker to a new location.
    setLatLng: function (latlng) {
      var oldLatLng = this._latlng;
      this._latlng = toLatLng(latlng);
      this.redraw(); // @event move: Event
      // Fired when the marker is moved via [`setLatLng`](#circlemarker-setlatlng). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.

      return this.fire('move', {
        oldLatLng: oldLatLng,
        latlng: this._latlng
      });
    },
    // @method getLatLng(): LatLng
    // Returns the current geographical position of the circle marker
    getLatLng: function () {
      return this._latlng;
    },
    // @method setRadius(radius: Number): this
    // Sets the radius of a circle marker. Units are in pixels.
    setRadius: function (radius) {
      this.options.radius = this._radius = radius;
      return this.redraw();
    },
    // @method getRadius(): Number
    // Returns the current radius of the circle
    getRadius: function () {
      return this._radius;
    },
    setStyle: function (options) {
      var radius = options && options.radius || this._radius;
      Path.prototype.setStyle.call(this, options);
      this.setRadius(radius);
      return this;
    },
    _project: function () {
      this._point = this._map.latLngToLayerPoint(this._latlng);

      this._updateBounds();
    },
    _updateBounds: function () {
      var r = this._radius,
          r2 = this._radiusY || r,
          w = this._clickTolerance(),
          p = [r + w, r2 + w];

      this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
    },
    _update: function () {
      if (this._map) {
        this._updatePath();
      }
    },
    _updatePath: function () {
      this._renderer._updateCircle(this);
    },
    _empty: function () {
      return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
    },
    // Needed by the `Canvas` renderer for interactivity
    _containsPoint: function (p) {
      return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
    }
  }); // @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
  // Instantiates a circle marker object given a geographical point, and an optional options object.

  function circleMarker(latlng, options) {
    return new CircleMarker(latlng, options);
  }
  /*
   * @class Circle
   * @aka L.Circle
   * @inherits CircleMarker
   *
   * A class for drawing circle overlays on a map. Extends `CircleMarker`.
   *
   * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
   *
   * @example
   *
   * ```js
   * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
   * ```
   */


  var Circle = CircleMarker.extend({
    initialize: function (latlng, options, legacyOptions) {
      if (typeof options === 'number') {
        // Backwards compatibility with 0.7.x factory (latlng, radius, options?)
        options = extend({}, legacyOptions, {
          radius: options
        });
      }

      setOptions(this, options);
      this._latlng = toLatLng(latlng);

      if (isNaN(this.options.radius)) {
        throw new Error('Circle radius cannot be NaN');
      } // @section
      // @aka Circle options
      // @option radius: Number; Radius of the circle, in meters.


      this._mRadius = this.options.radius;
    },
    // @method setRadius(radius: Number): this
    // Sets the radius of a circle. Units are in meters.
    setRadius: function (radius) {
      this._mRadius = radius;
      return this.redraw();
    },
    // @method getRadius(): Number
    // Returns the current radius of a circle. Units are in meters.
    getRadius: function () {
      return this._mRadius;
    },
    // @method getBounds(): LatLngBounds
    // Returns the `LatLngBounds` of the path.
    getBounds: function () {
      var half = [this._radius, this._radiusY || this._radius];
      return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));
    },
    setStyle: Path.prototype.setStyle,
    _project: function () {
      var lng = this._latlng.lng,
          lat = this._latlng.lat,
          map = this._map,
          crs = map.options.crs;

      if (crs.distance === Earth.distance) {
        var d = Math.PI / 180,
            latR = this._mRadius / Earth.R / d,
            top = map.project([lat + latR, lng]),
            bottom = map.project([lat - latR, lng]),
            p = top.add(bottom).divideBy(2),
            lat2 = map.unproject(p).lat,
            lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

        if (isNaN(lngR) || lngR === 0) {
          lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
        }

        this._point = p.subtract(map.getPixelOrigin());
        this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
        this._radiusY = p.y - top.y;
      } else {
        var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
        this._point = map.latLngToLayerPoint(this._latlng);
        this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
      }

      this._updateBounds();
    }
  }); // @factory L.circle(latlng: LatLng, options?: Circle options)
  // Instantiates a circle object given a geographical point, and an options object
  // which contains the circle radius.
  // @alternative
  // @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
  // Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
  // Do not use in new applications or plugins.

  function circle(latlng, options, legacyOptions) {
    return new Circle(latlng, options, legacyOptions);
  }
  /*
   * @class Polyline
   * @aka L.Polyline
   * @inherits Path
   *
   * A class for drawing polyline overlays on a map. Extends `Path`.
   *
   * @example
   *
   * ```js
   * // create a red polyline from an array of LatLng points
   * var latlngs = [
   * 	[45.51, -122.68],
   * 	[37.77, -122.43],
   * 	[34.04, -118.2]
   * ];
   *
   * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
   *
   * // zoom the map to the polyline
   * map.fitBounds(polyline.getBounds());
   * ```
   *
   * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
   *
   * ```js
   * // create a red polyline from an array of arrays of LatLng points
   * var latlngs = [
   * 	[[45.51, -122.68],
   * 	 [37.77, -122.43],
   * 	 [34.04, -118.2]],
   * 	[[40.78, -73.91],
   * 	 [41.83, -87.62],
   * 	 [32.76, -96.72]]
   * ];
   * ```
   */


  var Polyline = Path.extend({
    // @section
    // @aka Polyline options
    options: {
      // @option smoothFactor: Number = 1.0
      // How much to simplify the polyline on each zoom level. More means
      // better performance and smoother look, and less means more accurate representation.
      smoothFactor: 1.0,
      // @option noClip: Boolean = false
      // Disable polyline clipping.
      noClip: false
    },
    initialize: function (latlngs, options) {
      setOptions(this, options);

      this._setLatLngs(latlngs);
    },
    // @method getLatLngs(): LatLng[]
    // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
    getLatLngs: function () {
      return this._latlngs;
    },
    // @method setLatLngs(latlngs: LatLng[]): this
    // Replaces all the points in the polyline with the given array of geographical points.
    setLatLngs: function (latlngs) {
      this._setLatLngs(latlngs);

      return this.redraw();
    },
    // @method isEmpty(): Boolean
    // Returns `true` if the Polyline has no LatLngs.
    isEmpty: function () {
      return !this._latlngs.length;
    },
    // @method closestLayerPoint(p: Point): Point
    // Returns the point closest to `p` on the Polyline.
    closestLayerPoint: function (p) {
      var minDistance = Infinity,
          minPoint = null,
          closest = _sqClosestPointOnSegment,
          p1,
          p2;

      for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
        var points = this._parts[j];

        for (var i = 1, len = points.length; i < len; i++) {
          p1 = points[i - 1];
          p2 = points[i];
          var sqDist = closest(p, p1, p2, true);

          if (sqDist < minDistance) {
            minDistance = sqDist;
            minPoint = closest(p, p1, p2);
          }
        }
      }

      if (minPoint) {
        minPoint.distance = Math.sqrt(minDistance);
      }

      return minPoint;
    },
    // @method getCenter(): LatLng
    // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
    getCenter: function () {
      // throws error when not yet added to map as this center calculation requires projected coordinates
      if (!this._map) {
        throw new Error('Must add layer to map before using getCenter()');
      }

      var i,
          halfDist,
          segDist,
          dist,
          p1,
          p2,
          ratio,
          points = this._rings[0],
          len = points.length;

      if (!len) {
        return null;
      } // polyline centroid algorithm; only uses the first ring if there are multiple


      for (i = 0, halfDist = 0; i < len - 1; i++) {
        halfDist += points[i].distanceTo(points[i + 1]) / 2;
      } // The line is so small in the current view that all points are on the same pixel.


      if (halfDist === 0) {
        return this._map.layerPointToLatLng(points[0]);
      }

      for (i = 0, dist = 0; i < len - 1; i++) {
        p1 = points[i];
        p2 = points[i + 1];
        segDist = p1.distanceTo(p2);
        dist += segDist;

        if (dist > halfDist) {
          ratio = (dist - halfDist) / segDist;
          return this._map.layerPointToLatLng([p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y)]);
        }
      }
    },
    // @method getBounds(): LatLngBounds
    // Returns the `LatLngBounds` of the path.
    getBounds: function () {
      return this._bounds;
    },
    // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
    // Adds a given point to the polyline. By default, adds to the first ring of
    // the polyline in case of a multi-polyline, but can be overridden by passing
    // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
    addLatLng: function (latlng, latlngs) {
      latlngs = latlngs || this._defaultShape();
      latlng = toLatLng(latlng);
      latlngs.push(latlng);

      this._bounds.extend(latlng);

      return this.redraw();
    },
    _setLatLngs: function (latlngs) {
      this._bounds = new LatLngBounds();
      this._latlngs = this._convertLatLngs(latlngs);
    },
    _defaultShape: function () {
      return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
    },
    // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
    _convertLatLngs: function (latlngs) {
      var result = [],
          flat = isFlat(latlngs);

      for (var i = 0, len = latlngs.length; i < len; i++) {
        if (flat) {
          result[i] = toLatLng(latlngs[i]);

          this._bounds.extend(result[i]);
        } else {
          result[i] = this._convertLatLngs(latlngs[i]);
        }
      }

      return result;
    },
    _project: function () {
      var pxBounds = new Bounds();
      this._rings = [];

      this._projectLatlngs(this._latlngs, this._rings, pxBounds);

      if (this._bounds.isValid() && pxBounds.isValid()) {
        this._rawPxBounds = pxBounds;

        this._updateBounds();
      }
    },
    _updateBounds: function () {
      var w = this._clickTolerance(),
          p = new Point(w, w);

      this._pxBounds = new Bounds([this._rawPxBounds.min.subtract(p), this._rawPxBounds.max.add(p)]);
    },
    // recursively turns latlngs into a set of rings with projected coordinates
    _projectLatlngs: function (latlngs, result, projectedBounds) {
      var flat = latlngs[0] instanceof LatLng,
          len = latlngs.length,
          i,
          ring;

      if (flat) {
        ring = [];

        for (i = 0; i < len; i++) {
          ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
          projectedBounds.extend(ring[i]);
        }

        result.push(ring);
      } else {
        for (i = 0; i < len; i++) {
          this._projectLatlngs(latlngs[i], result, projectedBounds);
        }
      }
    },
    // clip polyline by renderer bounds so that we have less to render for performance
    _clipPoints: function () {
      var bounds = this._renderer._bounds;
      this._parts = [];

      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
        return;
      }

      if (this.options.noClip) {
        this._parts = this._rings;
        return;
      }

      var parts = this._parts,
          i,
          j,
          k,
          len,
          len2,
          segment,
          points;

      for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
        points = this._rings[i];

        for (j = 0, len2 = points.length; j < len2 - 1; j++) {
          segment = clipSegment(points[j], points[j + 1], bounds, j, true);

          if (!segment) {
            continue;
          }

          parts[k] = parts[k] || [];
          parts[k].push(segment[0]); // if segment goes out of screen, or it's the last one, it's the end of the line part

          if (segment[1] !== points[j + 1] || j === len2 - 2) {
            parts[k].push(segment[1]);
            k++;
          }
        }
      }
    },
    // simplify each clipped part of the polyline for performance
    _simplifyPoints: function () {
      var parts = this._parts,
          tolerance = this.options.smoothFactor;

      for (var i = 0, len = parts.length; i < len; i++) {
        parts[i] = simplify(parts[i], tolerance);
      }
    },
    _update: function () {
      if (!this._map) {
        return;
      }

      this._clipPoints();

      this._simplifyPoints();

      this._updatePath();
    },
    _updatePath: function () {
      this._renderer._updatePoly(this);
    },
    // Needed by the `Canvas` renderer for interactivity
    _containsPoint: function (p, closed) {
      var i,
          j,
          k,
          len,
          len2,
          part,
          w = this._clickTolerance();

      if (!this._pxBounds || !this._pxBounds.contains(p)) {
        return false;
      } // hit detection for polylines


      for (i = 0, len = this._parts.length; i < len; i++) {
        part = this._parts[i];

        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
          if (!closed && j === 0) {
            continue;
          }

          if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
            return true;
          }
        }
      }

      return false;
    }
  }); // @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
  // Instantiates a polyline object given an array of geographical points and
  // optionally an options object. You can create a `Polyline` object with
  // multiple separate lines (`MultiPolyline`) by passing an array of arrays
  // of geographic points.

  function polyline(latlngs, options) {
    return new Polyline(latlngs, options);
  } // Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.


  Polyline._flat = _flat;
  /*
   * @class Polygon
   * @aka L.Polygon
   * @inherits Polyline
   *
   * A class for drawing polygon overlays on a map. Extends `Polyline`.
   *
   * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.
   *
   *
   * @example
   *
   * ```js
   * // create a red polygon from an array of LatLng points
   * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
   *
   * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
   *
   * // zoom the map to the polygon
   * map.fitBounds(polygon.getBounds());
   * ```
   *
   * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
   *
   * ```js
   * var latlngs = [
   *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
   *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
   * ];
   * ```
   *
   * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
   *
   * ```js
   * var latlngs = [
   *   [ // first polygon
   *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
   *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
   *   ],
   *   [ // second polygon
   *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
   *   ]
   * ];
   * ```
   */

  var Polygon = Polyline.extend({
    options: {
      fill: true
    },
    isEmpty: function () {
      return !this._latlngs.length || !this._latlngs[0].length;
    },
    getCenter: function () {
      // throws error when not yet added to map as this center calculation requires projected coordinates
      if (!this._map) {
        throw new Error('Must add layer to map before using getCenter()');
      }

      var i,
          j,
          p1,
          p2,
          f,
          area,
          x,
          y,
          center,
          points = this._rings[0],
          len = points.length;

      if (!len) {
        return null;
      } // polygon centroid algorithm; only uses the first ring if there are multiple


      area = x = y = 0;

      for (i = 0, j = len - 1; i < len; j = i++) {
        p1 = points[i];
        p2 = points[j];
        f = p1.y * p2.x - p2.y * p1.x;
        x += (p1.x + p2.x) * f;
        y += (p1.y + p2.y) * f;
        area += f * 3;
      }

      if (area === 0) {
        // Polygon is so small that all points are on same pixel.
        center = points[0];
      } else {
        center = [x / area, y / area];
      }

      return this._map.layerPointToLatLng(center);
    },
    _convertLatLngs: function (latlngs) {
      var result = Polyline.prototype._convertLatLngs.call(this, latlngs),
          len = result.length; // remove last point if it equals first one


      if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
        result.pop();
      }

      return result;
    },
    _setLatLngs: function (latlngs) {
      Polyline.prototype._setLatLngs.call(this, latlngs);

      if (isFlat(this._latlngs)) {
        this._latlngs = [this._latlngs];
      }
    },
    _defaultShape: function () {
      return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
    },
    _clipPoints: function () {
      // polygons need a different clipping algorithm so we redefine that
      var bounds = this._renderer._bounds,
          w = this.options.weight,
          p = new Point(w, w); // increase clip padding by stroke width to avoid stroke on clip edges

      bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));
      this._parts = [];

      if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
        return;
      }

      if (this.options.noClip) {
        this._parts = this._rings;
        return;
      }

      for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
        clipped = clipPolygon(this._rings[i], bounds, true);

        if (clipped.length) {
          this._parts.push(clipped);
        }
      }
    },
    _updatePath: function () {
      this._renderer._updatePoly(this, true);
    },
    // Needed by the `Canvas` renderer for interactivity
    _containsPoint: function (p) {
      var inside = false,
          part,
          p1,
          p2,
          i,
          j,
          k,
          len,
          len2;

      if (!this._pxBounds || !this._pxBounds.contains(p)) {
        return false;
      } // ray casting algorithm for detecting if point is in polygon


      for (i = 0, len = this._parts.length; i < len; i++) {
        part = this._parts[i];

        for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
          p1 = part[j];
          p2 = part[k];

          if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
            inside = !inside;
          }
        }
      } // also check if it's on polygon stroke


      return inside || Polyline.prototype._containsPoint.call(this, p, true);
    }
  }); // @factory L.polygon(latlngs: LatLng[], options?: Polyline options)

  function polygon(latlngs, options) {
    return new Polygon(latlngs, options);
  }
  /*
   * @class GeoJSON
   * @aka L.GeoJSON
   * @inherits FeatureGroup
   *
   * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
   * GeoJSON data and display it on the map. Extends `FeatureGroup`.
   *
   * @example
   *
   * ```js
   * L.geoJSON(data, {
   * 	style: function (feature) {
   * 		return {color: feature.properties.color};
   * 	}
   * }).bindPopup(function (layer) {
   * 	return layer.feature.properties.description;
   * }).addTo(map);
   * ```
   */


  var GeoJSON = FeatureGroup.extend({
    /* @section
     * @aka GeoJSON options
     *
     * @option pointToLayer: Function = *
     * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
     * called when data is added, passing the GeoJSON point feature and its `LatLng`.
     * The default is to spawn a default `Marker`:
     * ```js
     * function(geoJsonPoint, latlng) {
     * 	return L.marker(latlng);
     * }
     * ```
     *
     * @option style: Function = *
     * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
     * called internally when data is added.
     * The default value is to not override any defaults:
     * ```js
     * function (geoJsonFeature) {
     * 	return {}
     * }
     * ```
     *
     * @option onEachFeature: Function = *
     * A `Function` that will be called once for each created `Feature`, after it has
     * been created and styled. Useful for attaching events and popups to features.
     * The default is to do nothing with the newly created layers:
     * ```js
     * function (feature, layer) {}
     * ```
     *
     * @option filter: Function = *
     * A `Function` that will be used to decide whether to include a feature or not.
     * The default is to include all features:
     * ```js
     * function (geoJsonFeature) {
     * 	return true;
     * }
     * ```
     * Note: dynamically changing the `filter` option will have effect only on newly
     * added data. It will _not_ re-evaluate already included features.
     *
     * @option coordsToLatLng: Function = *
     * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
     * The default is the `coordsToLatLng` static method.
     *
     * @option markersInheritOptions: Boolean = false
     * Whether default Markers for "Point" type Features inherit from group options.
     */
    initialize: function (geojson, options) {
      setOptions(this, options);
      this._layers = {};

      if (geojson) {
        this.addData(geojson);
      }
    },
    // @method addData( <GeoJSON> data ): this
    // Adds a GeoJSON object to the layer.
    addData: function (geojson) {
      var features = isArray(geojson) ? geojson : geojson.features,
          i,
          len,
          feature;

      if (features) {
        for (i = 0, len = features.length; i < len; i++) {
          // only add this if geometry or geometries are set and not null
          feature = features[i];

          if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
            this.addData(feature);
          }
        }

        return this;
      }

      var options = this.options;

      if (options.filter && !options.filter(geojson)) {
        return this;
      }

      var layer = geometryToLayer(geojson, options);

      if (!layer) {
        return this;
      }

      layer.feature = asFeature(geojson);
      layer.defaultOptions = layer.options;
      this.resetStyle(layer);

      if (options.onEachFeature) {
        options.onEachFeature(geojson, layer);
      }

      return this.addLayer(layer);
    },
    // @method resetStyle( <Path> layer? ): this
    // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
    // If `layer` is omitted, the style of all features in the current layer is reset.
    resetStyle: function (layer) {
      if (layer === undefined) {
        return this.eachLayer(this.resetStyle, this);
      } // reset any custom styles


      layer.options = extend({}, layer.defaultOptions);

      this._setLayerStyle(layer, this.options.style);

      return this;
    },
    // @method setStyle( <Function> style ): this
    // Changes styles of GeoJSON vector layers with the given style function.
    setStyle: function (style) {
      return this.eachLayer(function (layer) {
        this._setLayerStyle(layer, style);
      }, this);
    },
    _setLayerStyle: function (layer, style) {
      if (layer.setStyle) {
        if (typeof style === 'function') {
          style = style(layer.feature);
        }

        layer.setStyle(style);
      }
    }
  }); // @section
  // There are several static functions which can be called without instantiating L.GeoJSON:
  // @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
  // Creates a `Layer` from a given GeoJSON feature. Can use a custom
  // [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
  // functions if provided as options.

  function geometryToLayer(geojson, options) {
    var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
        coords = geometry ? geometry.coordinates : null,
        layers = [],
        pointToLayer = options && options.pointToLayer,
        _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,
        latlng,
        latlngs,
        i,
        len;

    if (!coords && !geometry) {
      return null;
    }

    switch (geometry.type) {
      case 'Point':
        latlng = _coordsToLatLng(coords);
        return _pointToLayer(pointToLayer, geojson, latlng, options);

      case 'MultiPoint':
        for (i = 0, len = coords.length; i < len; i++) {
          latlng = _coordsToLatLng(coords[i]);
          layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));
        }

        return new FeatureGroup(layers);

      case 'LineString':
      case 'MultiLineString':
        latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);
        return new Polyline(latlngs, options);

      case 'Polygon':
      case 'MultiPolygon':
        latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);
        return new Polygon(latlngs, options);

      case 'GeometryCollection':
        for (i = 0, len = geometry.geometries.length; i < len; i++) {
          var layer = geometryToLayer({
            geometry: geometry.geometries[i],
            type: 'Feature',
            properties: geojson.properties
          }, options);

          if (layer) {
            layers.push(layer);
          }
        }

        return new FeatureGroup(layers);

      default:
        throw new Error('Invalid GeoJSON object.');
    }
  }

  function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
    return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);
  } // @function coordsToLatLng(coords: Array): LatLng
  // Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
  // or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.


  function coordsToLatLng(coords) {
    return new LatLng(coords[1], coords[0], coords[2]);
  } // @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
  // Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
  // `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
  // Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.


  function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
    var latlngs = [];

    for (var i = 0, len = coords.length, latlng; i < len; i++) {
      latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);
      latlngs.push(latlng);
    }

    return latlngs;
  } // @function latLngToCoords(latlng: LatLng, precision?: Number): Array
  // Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)


  function latLngToCoords(latlng, precision) {
    precision = typeof precision === 'number' ? precision : 6;
    return latlng.alt !== undefined ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
  } // @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
  // Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
  // `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.


  function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
    var coords = [];

    for (var i = 0, len = latlngs.length; i < len; i++) {
      coords.push(levelsDeep ? latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
    }

    if (!levelsDeep && closed) {
      coords.push(coords[0]);
    }

    return coords;
  }

  function getFeature(layer, newGeometry) {
    return layer.feature ? extend({}, layer.feature, {
      geometry: newGeometry
    }) : asFeature(newGeometry);
  } // @function asFeature(geojson: Object): Object
  // Normalize GeoJSON geometries/features into GeoJSON features.


  function asFeature(geojson) {
    if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
      return geojson;
    }

    return {
      type: 'Feature',
      properties: {},
      geometry: geojson
    };
  }

  var PointToGeoJSON = {
    toGeoJSON: function (precision) {
      return getFeature(this, {
        type: 'Point',
        coordinates: latLngToCoords(this.getLatLng(), precision)
      });
    }
  }; // @namespace Marker
  // @section Other methods
  // @method toGeoJSON(precision?: Number): Object
  // `precision` is the number of decimal places for coordinates.
  // The default value is 6 places.
  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).

  Marker.include(PointToGeoJSON); // @namespace CircleMarker
  // @method toGeoJSON(precision?: Number): Object
  // `precision` is the number of decimal places for coordinates.
  // The default value is 6 places.
  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).

  Circle.include(PointToGeoJSON);
  CircleMarker.include(PointToGeoJSON); // @namespace Polyline
  // @method toGeoJSON(precision?: Number): Object
  // `precision` is the number of decimal places for coordinates.
  // The default value is 6 places.
  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).

  Polyline.include({
    toGeoJSON: function (precision) {
      var multi = !isFlat(this._latlngs);
      var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
      return getFeature(this, {
        type: (multi ? 'Multi' : '') + 'LineString',
        coordinates: coords
      });
    }
  }); // @namespace Polygon
  // @method toGeoJSON(precision?: Number): Object
  // `precision` is the number of decimal places for coordinates.
  // The default value is 6 places.
  // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).

  Polygon.include({
    toGeoJSON: function (precision) {
      var holes = !isFlat(this._latlngs),
          multi = holes && !isFlat(this._latlngs[0]);
      var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);

      if (!holes) {
        coords = [coords];
      }

      return getFeature(this, {
        type: (multi ? 'Multi' : '') + 'Polygon',
        coordinates: coords
      });
    }
  }); // @namespace LayerGroup

  LayerGroup.include({
    toMultiPoint: function (precision) {
      var coords = [];
      this.eachLayer(function (layer) {
        coords.push(layer.toGeoJSON(precision).geometry.coordinates);
      });
      return getFeature(this, {
        type: 'MultiPoint',
        coordinates: coords
      });
    },
    // @method toGeoJSON(precision?: Number): Object
    // `precision` is the number of decimal places for coordinates.
    // The default value is 6 places.
    // Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
    toGeoJSON: function (precision) {
      var type = this.feature && this.feature.geometry && this.feature.geometry.type;

      if (type === 'MultiPoint') {
        return this.toMultiPoint(precision);
      }

      var isGeometryCollection = type === 'GeometryCollection',
          jsons = [];
      this.eachLayer(function (layer) {
        if (layer.toGeoJSON) {
          var json = layer.toGeoJSON(precision);

          if (isGeometryCollection) {
            jsons.push(json.geometry);
          } else {
            var feature = asFeature(json); // Squash nested feature collections

            if (feature.type === 'FeatureCollection') {
              jsons.push.apply(jsons, feature.features);
            } else {
              jsons.push(feature);
            }
          }
        }
      });

      if (isGeometryCollection) {
        return getFeature(this, {
          geometries: jsons,
          type: 'GeometryCollection'
        });
      }

      return {
        type: 'FeatureCollection',
        features: jsons
      };
    }
  }); // @namespace GeoJSON
  // @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
  // Creates a GeoJSON layer. Optionally accepts an object in
  // [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map
  // (you can alternatively add it later with `addData` method) and an `options` object.

  function geoJSON(geojson, options) {
    return new GeoJSON(geojson, options);
  } // Backward compatibility.


  var geoJson = geoJSON;
  /*
   * @class ImageOverlay
   * @aka L.ImageOverlay
   * @inherits Interactive layer
   *
   * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
   *
   * @example
   *
   * ```js
   * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
   * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
   * L.imageOverlay(imageUrl, imageBounds).addTo(map);
   * ```
   */

  var ImageOverlay = Layer.extend({
    // @section
    // @aka ImageOverlay options
    options: {
      // @option opacity: Number = 1.0
      // The opacity of the image overlay.
      opacity: 1,
      // @option alt: String = ''
      // Text for the `alt` attribute of the image (useful for accessibility).
      alt: '',
      // @option interactive: Boolean = false
      // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
      interactive: false,
      // @option crossOrigin: Boolean|String = false
      // Whether the crossOrigin attribute will be added to the image.
      // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
      crossOrigin: false,
      // @option errorOverlayUrl: String = ''
      // URL to the overlay image to show in place of the overlay that failed to load.
      errorOverlayUrl: '',
      // @option zIndex: Number = 1
      // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
      zIndex: 1,
      // @option className: String = ''
      // A custom class name to assign to the image. Empty by default.
      className: ''
    },
    initialize: function (url, bounds, options) {
      // (String, LatLngBounds, Object)
      this._url = url;
      this._bounds = toLatLngBounds(bounds);
      setOptions(this, options);
    },
    onAdd: function () {
      if (!this._image) {
        this._initImage();

        if (this.options.opacity < 1) {
          this._updateOpacity();
        }
      }

      if (this.options.interactive) {
        addClass(this._image, 'leaflet-interactive');
        this.addInteractiveTarget(this._image);
      }

      this.getPane().appendChild(this._image);

      this._reset();
    },
    onRemove: function () {
      remove(this._image);

      if (this.options.interactive) {
        this.removeInteractiveTarget(this._image);
      }
    },
    // @method setOpacity(opacity: Number): this
    // Sets the opacity of the overlay.
    setOpacity: function (opacity) {
      this.options.opacity = opacity;

      if (this._image) {
        this._updateOpacity();
      }

      return this;
    },
    setStyle: function (styleOpts) {
      if (styleOpts.opacity) {
        this.setOpacity(styleOpts.opacity);
      }

      return this;
    },
    // @method bringToFront(): this
    // Brings the layer to the top of all overlays.
    bringToFront: function () {
      if (this._map) {
        toFront(this._image);
      }

      return this;
    },
    // @method bringToBack(): this
    // Brings the layer to the bottom of all overlays.
    bringToBack: function () {
      if (this._map) {
        toBack(this._image);
      }

      return this;
    },
    // @method setUrl(url: String): this
    // Changes the URL of the image.
    setUrl: function (url) {
      this._url = url;

      if (this._image) {
        this._image.src = url;
      }

      return this;
    },
    // @method setBounds(bounds: LatLngBounds): this
    // Update the bounds that this ImageOverlay covers
    setBounds: function (bounds) {
      this._bounds = toLatLngBounds(bounds);

      if (this._map) {
        this._reset();
      }

      return this;
    },
    getEvents: function () {
      var events = {
        zoom: this._reset,
        viewreset: this._reset
      };

      if (this._zoomAnimated) {
        events.zoomanim = this._animateZoom;
      }

      return events;
    },
    // @method setZIndex(value: Number): this
    // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
    setZIndex: function (value) {
      this.options.zIndex = value;

      this._updateZIndex();

      return this;
    },
    // @method getBounds(): LatLngBounds
    // Get the bounds that this ImageOverlay covers
    getBounds: function () {
      return this._bounds;
    },
    // @method getElement(): HTMLElement
    // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
    // used by this overlay.
    getElement: function () {
      return this._image;
    },
    _initImage: function () {
      var wasElementSupplied = this._url.tagName === 'IMG';
      var img = this._image = wasElementSupplied ? this._url : create$1('img');
      addClass(img, 'leaflet-image-layer');

      if (this._zoomAnimated) {
        addClass(img, 'leaflet-zoom-animated');
      }

      if (this.options.className) {
        addClass(img, this.options.className);
      }

      img.onselectstart = falseFn;
      img.onmousemove = falseFn; // @event load: Event
      // Fired when the ImageOverlay layer has loaded its image

      img.onload = bind(this.fire, this, 'load');
      img.onerror = bind(this._overlayOnError, this, 'error');

      if (this.options.crossOrigin || this.options.crossOrigin === '') {
        img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
      }

      if (this.options.zIndex) {
        this._updateZIndex();
      }

      if (wasElementSupplied) {
        this._url = img.src;
        return;
      }

      img.src = this._url;
      img.alt = this.options.alt;
    },
    _animateZoom: function (e) {
      var scale = this._map.getZoomScale(e.zoom),
          offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

      setTransform(this._image, offset, scale);
    },
    _reset: function () {
      var image = this._image,
          bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
          size = bounds.getSize();
      setPosition(image, bounds.min);
      image.style.width = size.x + 'px';
      image.style.height = size.y + 'px';
    },
    _updateOpacity: function () {
      setOpacity(this._image, this.options.opacity);
    },
    _updateZIndex: function () {
      if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {
        this._image.style.zIndex = this.options.zIndex;
      }
    },
    _overlayOnError: function () {
      // @event error: Event
      // Fired when the ImageOverlay layer fails to load its image
      this.fire('error');
      var errorUrl = this.options.errorOverlayUrl;

      if (errorUrl && this._url !== errorUrl) {
        this._url = errorUrl;
        this._image.src = errorUrl;
      }
    }
  }); // @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
  // Instantiates an image overlay object given the URL of the image and the
  // geographical bounds it is tied to.

  var imageOverlay = function (url, bounds, options) {
    return new ImageOverlay(url, bounds, options);
  };
  /*
   * @class VideoOverlay
   * @aka L.VideoOverlay
   * @inherits ImageOverlay
   *
   * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.
   *
   * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)
   * HTML5 element.
   *
   * @example
   *
   * ```js
   * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
   * 	videoBounds = [[ 32, -130], [ 13, -100]];
   * L.videoOverlay(videoUrl, videoBounds ).addTo(map);
   * ```
   */


  var VideoOverlay = ImageOverlay.extend({
    // @section
    // @aka VideoOverlay options
    options: {
      // @option autoplay: Boolean = true
      // Whether the video starts playing automatically when loaded.
      autoplay: true,
      // @option loop: Boolean = true
      // Whether the video will loop back to the beginning when played.
      loop: true,
      // @option keepAspectRatio: Boolean = true
      // Whether the video will save aspect ratio after the projection.
      // Relevant for supported browsers. Browser compatibility- https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit
      keepAspectRatio: true,
      // @option muted: Boolean = false
      // Whether the video starts on mute when loaded.
      muted: false
    },
    _initImage: function () {
      var wasElementSupplied = this._url.tagName === 'VIDEO';
      var vid = this._image = wasElementSupplied ? this._url : create$1('video');
      addClass(vid, 'leaflet-image-layer');

      if (this._zoomAnimated) {
        addClass(vid, 'leaflet-zoom-animated');
      }

      if (this.options.className) {
        addClass(vid, this.options.className);
      }

      vid.onselectstart = falseFn;
      vid.onmousemove = falseFn; // @event load: Event
      // Fired when the video has finished loading the first frame

      vid.onloadeddata = bind(this.fire, this, 'load');

      if (wasElementSupplied) {
        var sourceElements = vid.getElementsByTagName('source');
        var sources = [];

        for (var j = 0; j < sourceElements.length; j++) {
          sources.push(sourceElements[j].src);
        }

        this._url = sourceElements.length > 0 ? sources : [vid.src];
        return;
      }

      if (!isArray(this._url)) {
        this._url = [this._url];
      }

      if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, 'objectFit')) {
        vid.style['objectFit'] = 'fill';
      }

      vid.autoplay = !!this.options.autoplay;
      vid.loop = !!this.options.loop;
      vid.muted = !!this.options.muted;

      for (var i = 0; i < this._url.length; i++) {
        var source = create$1('source');
        source.src = this._url[i];
        vid.appendChild(source);
      }
    } // @method getElement(): HTMLVideoElement
    // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
    // used by this overlay.

  }); // @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)
  // Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the
  // geographical bounds it is tied to.

  function videoOverlay(video, bounds, options) {
    return new VideoOverlay(video, bounds, options);
  }
  /*
   * @class SVGOverlay
   * @aka L.SVGOverlay
   * @inherits ImageOverlay
   *
   * Used to load, display and provide DOM access to an SVG file over specific bounds of the map. Extends `ImageOverlay`.
   *
   * An SVG overlay uses the [`<svg>`](https://developer.mozilla.org/docs/Web/SVG/Element/svg) element.
   *
   * @example
   *
   * ```js
   * var svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
   * svgElement.setAttribute('xmlns', "http://www.w3.org/2000/svg");
   * svgElement.setAttribute('viewBox', "0 0 200 200");
   * svgElement.innerHTML = '<rect width="200" height="200"/><rect x="75" y="23" width="50" height="50" style="fill:red"/><rect x="75" y="123" width="50" height="50" style="fill:#0013ff"/>';
   * var svgElementBounds = [ [ 32, -130 ], [ 13, -100 ] ];
   * L.svgOverlay(svgElement, svgElementBounds).addTo(map);
   * ```
   */


  var SVGOverlay = ImageOverlay.extend({
    _initImage: function () {
      var el = this._image = this._url;
      addClass(el, 'leaflet-image-layer');

      if (this._zoomAnimated) {
        addClass(el, 'leaflet-zoom-animated');
      }

      if (this.options.className) {
        addClass(el, this.options.className);
      }

      el.onselectstart = falseFn;
      el.onmousemove = falseFn;
    } // @method getElement(): SVGElement
    // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
    // used by this overlay.

  }); // @factory L.svgOverlay(svg: String|SVGElement, bounds: LatLngBounds, options?: SVGOverlay options)
  // Instantiates an image overlay object given an SVG element and the geographical bounds it is tied to.
  // A viewBox attribute is required on the SVG element to zoom in and out properly.

  function svgOverlay(el, bounds, options) {
    return new SVGOverlay(el, bounds, options);
  }
  /*
   * @class DivOverlay
   * @inherits Layer
   * @aka L.DivOverlay
   * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
   */
  // @namespace DivOverlay


  var DivOverlay = Layer.extend({
    // @section
    // @aka DivOverlay options
    options: {
      // @option offset: Point = Point(0, 7)
      // The offset of the popup position. Useful to control the anchor
      // of the popup when opening it on some overlays.
      offset: [0, 7],
      // @option className: String = ''
      // A custom CSS class name to assign to the popup.
      className: '',
      // @option pane: String = 'popupPane'
      // `Map pane` where the popup will be added.
      pane: 'popupPane'
    },
    initialize: function (options, source) {
      setOptions(this, options);
      this._source = source;
    },
    onAdd: function (map) {
      this._zoomAnimated = map._zoomAnimated;

      if (!this._container) {
        this._initLayout();
      }

      if (map._fadeAnimated) {
        setOpacity(this._container, 0);
      }

      clearTimeout(this._removeTimeout);
      this.getPane().appendChild(this._container);
      this.update();

      if (map._fadeAnimated) {
        setOpacity(this._container, 1);
      }

      this.bringToFront();
    },
    onRemove: function (map) {
      if (map._fadeAnimated) {
        setOpacity(this._container, 0);
        this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);
      } else {
        remove(this._container);
      }
    },
    // @namespace Popup
    // @method getLatLng: LatLng
    // Returns the geographical point of popup.
    getLatLng: function () {
      return this._latlng;
    },
    // @method setLatLng(latlng: LatLng): this
    // Sets the geographical point where the popup will open.
    setLatLng: function (latlng) {
      this._latlng = toLatLng(latlng);

      if (this._map) {
        this._updatePosition();

        this._adjustPan();
      }

      return this;
    },
    // @method getContent: String|HTMLElement
    // Returns the content of the popup.
    getContent: function () {
      return this._content;
    },
    // @method setContent(htmlContent: String|HTMLElement|Function): this
    // Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
    setContent: function (content) {
      this._content = content;
      this.update();
      return this;
    },
    // @method getElement: String|HTMLElement
    // Returns the HTML container of the popup.
    getElement: function () {
      return this._container;
    },
    // @method update: null
    // Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
    update: function () {
      if (!this._map) {
        return;
      }

      this._container.style.visibility = 'hidden';

      this._updateContent();

      this._updateLayout();

      this._updatePosition();

      this._container.style.visibility = '';

      this._adjustPan();
    },
    getEvents: function () {
      var events = {
        zoom: this._updatePosition,
        viewreset: this._updatePosition
      };

      if (this._zoomAnimated) {
        events.zoomanim = this._animateZoom;
      }

      return events;
    },
    // @method isOpen: Boolean
    // Returns `true` when the popup is visible on the map.
    isOpen: function () {
      return !!this._map && this._map.hasLayer(this);
    },
    // @method bringToFront: this
    // Brings this popup in front of other popups (in the same map pane).
    bringToFront: function () {
      if (this._map) {
        toFront(this._container);
      }

      return this;
    },
    // @method bringToBack: this
    // Brings this popup to the back of other popups (in the same map pane).
    bringToBack: function () {
      if (this._map) {
        toBack(this._container);
      }

      return this;
    },
    _prepareOpen: function (parent, layer, latlng) {
      if (!(layer instanceof Layer)) {
        latlng = layer;
        layer = parent;
      }

      if (layer instanceof FeatureGroup) {
        for (var id in parent._layers) {
          layer = parent._layers[id];
          break;
        }
      }

      if (!latlng) {
        if (layer.getCenter) {
          latlng = layer.getCenter();
        } else if (layer.getLatLng) {
          latlng = layer.getLatLng();
        } else {
          throw new Error('Unable to get source layer LatLng.');
        }
      } // set overlay source to this layer


      this._source = layer; // update the overlay (content, layout, ect...)

      this.update();
      return latlng;
    },
    _updateContent: function () {
      if (!this._content) {
        return;
      }

      var node = this._contentNode;
      var content = typeof this._content === 'function' ? this._content(this._source || this) : this._content;

      if (typeof content === 'string') {
        node.innerHTML = content;
      } else {
        while (node.hasChildNodes()) {
          node.removeChild(node.firstChild);
        }

        node.appendChild(content);
      }

      this.fire('contentupdate');
    },
    _updatePosition: function () {
      if (!this._map) {
        return;
      }

      var pos = this._map.latLngToLayerPoint(this._latlng),
          offset = toPoint(this.options.offset),
          anchor = this._getAnchor();

      if (this._zoomAnimated) {
        setPosition(this._container, pos.add(anchor));
      } else {
        offset = offset.add(pos).add(anchor);
      }

      var bottom = this._containerBottom = -offset.y,
          left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x; // bottom position the popup in case the height of the popup changes (images loading etc)

      this._container.style.bottom = bottom + 'px';
      this._container.style.left = left + 'px';
    },
    _getAnchor: function () {
      return [0, 0];
    }
  });
  /*
   * @class Popup
   * @inherits DivOverlay
   * @aka L.Popup
   * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
   * open popups while making sure that only one popup is open at one time
   * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
   *
   * @example
   *
   * If you want to just bind a popup to marker click and then open it, it's really easy:
   *
   * ```js
   * marker.bindPopup(popupContent).openPopup();
   * ```
   * Path overlays like polylines also have a `bindPopup` method.
   * Here's a more complicated way to open a popup on a map:
   *
   * ```js
   * var popup = L.popup()
   * 	.setLatLng(latlng)
   * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
   * 	.openOn(map);
   * ```
   */
  // @namespace Popup

  var Popup = DivOverlay.extend({
    // @section
    // @aka Popup options
    options: {
      // @option maxWidth: Number = 300
      // Max width of the popup, in pixels.
      maxWidth: 300,
      // @option minWidth: Number = 50
      // Min width of the popup, in pixels.
      minWidth: 50,
      // @option maxHeight: Number = null
      // If set, creates a scrollable container of the given height
      // inside a popup if its content exceeds it.
      maxHeight: null,
      // @option autoPan: Boolean = true
      // Set it to `false` if you don't want the map to do panning animation
      // to fit the opened popup.
      autoPan: true,
      // @option autoPanPaddingTopLeft: Point = null
      // The margin between the popup and the top left corner of the map
      // view after autopanning was performed.
      autoPanPaddingTopLeft: null,
      // @option autoPanPaddingBottomRight: Point = null
      // The margin between the popup and the bottom right corner of the map
      // view after autopanning was performed.
      autoPanPaddingBottomRight: null,
      // @option autoPanPadding: Point = Point(5, 5)
      // Equivalent of setting both top left and bottom right autopan padding to the same value.
      autoPanPadding: [5, 5],
      // @option keepInView: Boolean = false
      // Set it to `true` if you want to prevent users from panning the popup
      // off of the screen while it is open.
      keepInView: false,
      // @option closeButton: Boolean = true
      // Controls the presence of a close button in the popup.
      closeButton: true,
      // @option autoClose: Boolean = true
      // Set it to `false` if you want to override the default behavior of
      // the popup closing when another popup is opened.
      autoClose: true,
      // @option closeOnEscapeKey: Boolean = true
      // Set it to `false` if you want to override the default behavior of
      // the ESC key for closing of the popup.
      closeOnEscapeKey: true,
      // @option closeOnClick: Boolean = *
      // Set it if you want to override the default behavior of the popup closing when user clicks
      // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
      // @option className: String = ''
      // A custom CSS class name to assign to the popup.
      className: ''
    },
    // @namespace Popup
    // @method openOn(map: Map): this
    // Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
    openOn: function (map) {
      map.openPopup(this);
      return this;
    },
    onAdd: function (map) {
      DivOverlay.prototype.onAdd.call(this, map); // @namespace Map
      // @section Popup events
      // @event popupopen: PopupEvent
      // Fired when a popup is opened in the map

      map.fire('popupopen', {
        popup: this
      });

      if (this._source) {
        // @namespace Layer
        // @section Popup events
        // @event popupopen: PopupEvent
        // Fired when a popup bound to this layer is opened
        this._source.fire('popupopen', {
          popup: this
        }, true); // For non-path layers, we toggle the popup when clicking
        // again the layer, so prevent the map to reopen it.


        if (!(this._source instanceof Path)) {
          this._source.on('preclick', stopPropagation);
        }
      }
    },
    onRemove: function (map) {
      DivOverlay.prototype.onRemove.call(this, map); // @namespace Map
      // @section Popup events
      // @event popupclose: PopupEvent
      // Fired when a popup in the map is closed

      map.fire('popupclose', {
        popup: this
      });

      if (this._source) {
        // @namespace Layer
        // @section Popup events
        // @event popupclose: PopupEvent
        // Fired when a popup bound to this layer is closed
        this._source.fire('popupclose', {
          popup: this
        }, true);

        if (!(this._source instanceof Path)) {
          this._source.off('preclick', stopPropagation);
        }
      }
    },
    getEvents: function () {
      var events = DivOverlay.prototype.getEvents.call(this);

      if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
        events.preclick = this._close;
      }

      if (this.options.keepInView) {
        events.moveend = this._adjustPan;
      }

      return events;
    },
    _close: function () {
      if (this._map) {
        this._map.closePopup(this);
      }
    },
    _initLayout: function () {
      var prefix = 'leaflet-popup',
          container = this._container = create$1('div', prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-animated');
      var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);
      this._contentNode = create$1('div', prefix + '-content', wrapper);
      disableClickPropagation(container);
      disableScrollPropagation(this._contentNode);
      on(container, 'contextmenu', stopPropagation);
      this._tipContainer = create$1('div', prefix + '-tip-container', container);
      this._tip = create$1('div', prefix + '-tip', this._tipContainer);

      if (this.options.closeButton) {
        var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);
        closeButton.href = '#close';
        closeButton.innerHTML = '&#215;';
        on(closeButton, 'click', this._onCloseButtonClick, this);
      }
    },
    _updateLayout: function () {
      var container = this._contentNode,
          style = container.style;
      style.width = '';
      style.whiteSpace = 'nowrap';
      var width = container.offsetWidth;
      width = Math.min(width, this.options.maxWidth);
      width = Math.max(width, this.options.minWidth);
      style.width = width + 1 + 'px';
      style.whiteSpace = '';
      style.height = '';
      var height = container.offsetHeight,
          maxHeight = this.options.maxHeight,
          scrolledClass = 'leaflet-popup-scrolled';

      if (maxHeight && height > maxHeight) {
        style.height = maxHeight + 'px';
        addClass(container, scrolledClass);
      } else {
        removeClass(container, scrolledClass);
      }

      this._containerWidth = this._container.offsetWidth;
    },
    _animateZoom: function (e) {
      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
          anchor = this._getAnchor();

      setPosition(this._container, pos.add(anchor));
    },
    _adjustPan: function () {
      if (!this.options.autoPan) {
        return;
      }

      if (this._map._panAnim) {
        this._map._panAnim.stop();
      }

      var map = this._map,
          marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,
          containerHeight = this._container.offsetHeight + marginBottom,
          containerWidth = this._containerWidth,
          layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);

      layerPos._add(getPosition(this._container));

      var containerPos = map.layerPointToContainerPoint(layerPos),
          padding = toPoint(this.options.autoPanPadding),
          paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),
          paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),
          size = map.getSize(),
          dx = 0,
          dy = 0;

      if (containerPos.x + containerWidth + paddingBR.x > size.x) {
        // right
        dx = containerPos.x + containerWidth - size.x + paddingBR.x;
      }

      if (containerPos.x - dx - paddingTL.x < 0) {
        // left
        dx = containerPos.x - paddingTL.x;
      }

      if (containerPos.y + containerHeight + paddingBR.y > size.y) {
        // bottom
        dy = containerPos.y + containerHeight - size.y + paddingBR.y;
      }

      if (containerPos.y - dy - paddingTL.y < 0) {
        // top
        dy = containerPos.y - paddingTL.y;
      } // @namespace Map
      // @section Popup events
      // @event autopanstart: Event
      // Fired when the map starts autopanning when opening a popup.


      if (dx || dy) {
        map.fire('autopanstart').panBy([dx, dy]);
      }
    },
    _onCloseButtonClick: function (e) {
      this._close();

      stop(e);
    },
    _getAnchor: function () {
      // Where should we anchor the popup on the source layer?
      return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
    }
  }); // @namespace Popup
  // @factory L.popup(options?: Popup options, source?: Layer)
  // Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.

  var popup = function (options, source) {
    return new Popup(options, source);
  };
  /* @namespace Map
   * @section Interaction Options
   * @option closePopupOnClick: Boolean = true
   * Set it to `false` if you don't want popups to close when user clicks the map.
   */


  Map.mergeOptions({
    closePopupOnClick: true
  }); // @namespace Map
  // @section Methods for Layers and Controls

  Map.include({
    // @method openPopup(popup: Popup): this
    // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
    // @alternative
    // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
    // Creates a popup with the specified content and options and opens it in the given point on a map.
    openPopup: function (popup, latlng, options) {
      if (!(popup instanceof Popup)) {
        popup = new Popup(options).setContent(popup);
      }

      if (latlng) {
        popup.setLatLng(latlng);
      }

      if (this.hasLayer(popup)) {
        return this;
      }

      if (this._popup && this._popup.options.autoClose) {
        this.closePopup();
      }

      this._popup = popup;
      return this.addLayer(popup);
    },
    // @method closePopup(popup?: Popup): this
    // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
    closePopup: function (popup) {
      if (!popup || popup === this._popup) {
        popup = this._popup;
        this._popup = null;
      }

      if (popup) {
        this.removeLayer(popup);
      }

      return this;
    }
  });
  /*
   * @namespace Layer
   * @section Popup methods example
   *
   * All layers share a set of methods convenient for binding popups to it.
   *
   * ```js
   * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
   * layer.openPopup();
   * layer.closePopup();
   * ```
   *
   * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
   */
  // @section Popup methods

  Layer.include({
    // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
    // Binds a popup to the layer with the passed `content` and sets up the
    // necessary event listeners. If a `Function` is passed it will receive
    // the layer as the first argument and should return a `String` or `HTMLElement`.
    bindPopup: function (content, options) {
      if (content instanceof Popup) {
        setOptions(content, options);
        this._popup = content;
        content._source = this;
      } else {
        if (!this._popup || options) {
          this._popup = new Popup(options, this);
        }

        this._popup.setContent(content);
      }

      if (!this._popupHandlersAdded) {
        this.on({
          click: this._openPopup,
          keypress: this._onKeyPress,
          remove: this.closePopup,
          move: this._movePopup
        });
        this._popupHandlersAdded = true;
      }

      return this;
    },
    // @method unbindPopup(): this
    // Removes the popup previously bound with `bindPopup`.
    unbindPopup: function () {
      if (this._popup) {
        this.off({
          click: this._openPopup,
          keypress: this._onKeyPress,
          remove: this.closePopup,
          move: this._movePopup
        });
        this._popupHandlersAdded = false;
        this._popup = null;
      }

      return this;
    },
    // @method openPopup(latlng?: LatLng): this
    // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
    openPopup: function (layer, latlng) {
      if (this._popup && this._map) {
        latlng = this._popup._prepareOpen(this, layer, latlng); // open the popup on the map

        this._map.openPopup(this._popup, latlng);
      }

      return this;
    },
    // @method closePopup(): this
    // Closes the popup bound to this layer if it is open.
    closePopup: function () {
      if (this._popup) {
        this._popup._close();
      }

      return this;
    },
    // @method togglePopup(): this
    // Opens or closes the popup bound to this layer depending on its current state.
    togglePopup: function (target) {
      if (this._popup) {
        if (this._popup._map) {
          this.closePopup();
        } else {
          this.openPopup(target);
        }
      }

      return this;
    },
    // @method isPopupOpen(): boolean
    // Returns `true` if the popup bound to this layer is currently open.
    isPopupOpen: function () {
      return this._popup ? this._popup.isOpen() : false;
    },
    // @method setPopupContent(content: String|HTMLElement|Popup): this
    // Sets the content of the popup bound to this layer.
    setPopupContent: function (content) {
      if (this._popup) {
        this._popup.setContent(content);
      }

      return this;
    },
    // @method getPopup(): Popup
    // Returns the popup bound to this layer.
    getPopup: function () {
      return this._popup;
    },
    _openPopup: function (e) {
      var layer = e.layer || e.target;

      if (!this._popup) {
        return;
      }

      if (!this._map) {
        return;
      } // prevent map click


      stop(e); // if this inherits from Path its a vector and we can just
      // open the popup at the new location

      if (layer instanceof Path) {
        this.openPopup(e.layer || e.target, e.latlng);
        return;
      } // otherwise treat it like a marker and figure out
      // if we should toggle it open/closed


      if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
        this.closePopup();
      } else {
        this.openPopup(layer, e.latlng);
      }
    },
    _movePopup: function (e) {
      this._popup.setLatLng(e.latlng);
    },
    _onKeyPress: function (e) {
      if (e.originalEvent.keyCode === 13) {
        this._openPopup(e);
      }
    }
  });
  /*
   * @class Tooltip
   * @inherits DivOverlay
   * @aka L.Tooltip
   * Used to display small texts on top of map layers.
   *
   * @example
   *
   * ```js
   * marker.bindTooltip("my tooltip text").openTooltip();
   * ```
   * Note about tooltip offset. Leaflet takes two options in consideration
   * for computing tooltip offsetting:
   * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
   *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
   *   move it to the bottom. Negatives will move to the left and top.
   * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
   *   should adapt this value if you use a custom icon.
   */
  // @namespace Tooltip

  var Tooltip = DivOverlay.extend({
    // @section
    // @aka Tooltip options
    options: {
      // @option pane: String = 'tooltipPane'
      // `Map pane` where the tooltip will be added.
      pane: 'tooltipPane',
      // @option offset: Point = Point(0, 0)
      // Optional offset of the tooltip position.
      offset: [0, 0],
      // @option direction: String = 'auto'
      // Direction where to open the tooltip. Possible values are: `right`, `left`,
      // `top`, `bottom`, `center`, `auto`.
      // `auto` will dynamically switch between `right` and `left` according to the tooltip
      // position on the map.
      direction: 'auto',
      // @option permanent: Boolean = false
      // Whether to open the tooltip permanently or only on mouseover.
      permanent: false,
      // @option sticky: Boolean = false
      // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
      sticky: false,
      // @option interactive: Boolean = false
      // If true, the tooltip will listen to the feature events.
      interactive: false,
      // @option opacity: Number = 0.9
      // Tooltip container opacity.
      opacity: 0.9
    },
    onAdd: function (map) {
      DivOverlay.prototype.onAdd.call(this, map);
      this.setOpacity(this.options.opacity); // @namespace Map
      // @section Tooltip events
      // @event tooltipopen: TooltipEvent
      // Fired when a tooltip is opened in the map.

      map.fire('tooltipopen', {
        tooltip: this
      });

      if (this._source) {
        // @namespace Layer
        // @section Tooltip events
        // @event tooltipopen: TooltipEvent
        // Fired when a tooltip bound to this layer is opened.
        this._source.fire('tooltipopen', {
          tooltip: this
        }, true);
      }
    },
    onRemove: function (map) {
      DivOverlay.prototype.onRemove.call(this, map); // @namespace Map
      // @section Tooltip events
      // @event tooltipclose: TooltipEvent
      // Fired when a tooltip in the map is closed.

      map.fire('tooltipclose', {
        tooltip: this
      });

      if (this._source) {
        // @namespace Layer
        // @section Tooltip events
        // @event tooltipclose: TooltipEvent
        // Fired when a tooltip bound to this layer is closed.
        this._source.fire('tooltipclose', {
          tooltip: this
        }, true);
      }
    },
    getEvents: function () {
      var events = DivOverlay.prototype.getEvents.call(this);

      if (touch && !this.options.permanent) {
        events.preclick = this._close;
      }

      return events;
    },
    _close: function () {
      if (this._map) {
        this._map.closeTooltip(this);
      }
    },
    _initLayout: function () {
      var prefix = 'leaflet-tooltip',
          className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');
      this._contentNode = this._container = create$1('div', className);
    },
    _updateLayout: function () {},
    _adjustPan: function () {},
    _setPosition: function (pos) {
      var subX,
          subY,
          map = this._map,
          container = this._container,
          centerPoint = map.latLngToContainerPoint(map.getCenter()),
          tooltipPoint = map.layerPointToContainerPoint(pos),
          direction = this.options.direction,
          tooltipWidth = container.offsetWidth,
          tooltipHeight = container.offsetHeight,
          offset = toPoint(this.options.offset),
          anchor = this._getAnchor();

      if (direction === 'top') {
        subX = tooltipWidth / 2;
        subY = tooltipHeight;
      } else if (direction === 'bottom') {
        subX = tooltipWidth / 2;
        subY = 0;
      } else if (direction === 'center') {
        subX = tooltipWidth / 2;
        subY = tooltipHeight / 2;
      } else if (direction === 'right') {
        subX = 0;
        subY = tooltipHeight / 2;
      } else if (direction === 'left') {
        subX = tooltipWidth;
        subY = tooltipHeight / 2;
      } else if (tooltipPoint.x < centerPoint.x) {
        direction = 'right';
        subX = 0;
        subY = tooltipHeight / 2;
      } else {
        direction = 'left';
        subX = tooltipWidth + (offset.x + anchor.x) * 2;
        subY = tooltipHeight / 2;
      }

      pos = pos.subtract(toPoint(subX, subY, true)).add(offset).add(anchor);
      removeClass(container, 'leaflet-tooltip-right');
      removeClass(container, 'leaflet-tooltip-left');
      removeClass(container, 'leaflet-tooltip-top');
      removeClass(container, 'leaflet-tooltip-bottom');
      addClass(container, 'leaflet-tooltip-' + direction);
      setPosition(container, pos);
    },
    _updatePosition: function () {
      var pos = this._map.latLngToLayerPoint(this._latlng);

      this._setPosition(pos);
    },
    setOpacity: function (opacity) {
      this.options.opacity = opacity;

      if (this._container) {
        setOpacity(this._container, opacity);
      }
    },
    _animateZoom: function (e) {
      var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);

      this._setPosition(pos);
    },
    _getAnchor: function () {
      // Where should we anchor the tooltip on the source layer?
      return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
    }
  }); // @namespace Tooltip
  // @factory L.tooltip(options?: Tooltip options, source?: Layer)
  // Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.

  var tooltip = function (options, source) {
    return new Tooltip(options, source);
  }; // @namespace Map
  // @section Methods for Layers and Controls


  Map.include({
    // @method openTooltip(tooltip: Tooltip): this
    // Opens the specified tooltip.
    // @alternative
    // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
    // Creates a tooltip with the specified content and options and open it.
    openTooltip: function (tooltip, latlng, options) {
      if (!(tooltip instanceof Tooltip)) {
        tooltip = new Tooltip(options).setContent(tooltip);
      }

      if (latlng) {
        tooltip.setLatLng(latlng);
      }

      if (this.hasLayer(tooltip)) {
        return this;
      }

      return this.addLayer(tooltip);
    },
    // @method closeTooltip(tooltip?: Tooltip): this
    // Closes the tooltip given as parameter.
    closeTooltip: function (tooltip) {
      if (tooltip) {
        this.removeLayer(tooltip);
      }

      return this;
    }
  });
  /*
   * @namespace Layer
   * @section Tooltip methods example
   *
   * All layers share a set of methods convenient for binding tooltips to it.
   *
   * ```js
   * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
   * layer.openTooltip();
   * layer.closeTooltip();
   * ```
   */
  // @section Tooltip methods

  Layer.include({
    // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
    // Binds a tooltip to the layer with the passed `content` and sets up the
    // necessary event listeners. If a `Function` is passed it will receive
    // the layer as the first argument and should return a `String` or `HTMLElement`.
    bindTooltip: function (content, options) {
      if (content instanceof Tooltip) {
        setOptions(content, options);
        this._tooltip = content;
        content._source = this;
      } else {
        if (!this._tooltip || options) {
          this._tooltip = new Tooltip(options, this);
        }

        this._tooltip.setContent(content);
      }

      this._initTooltipInteractions();

      if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
        this.openTooltip();
      }

      return this;
    },
    // @method unbindTooltip(): this
    // Removes the tooltip previously bound with `bindTooltip`.
    unbindTooltip: function () {
      if (this._tooltip) {
        this._initTooltipInteractions(true);

        this.closeTooltip();
        this._tooltip = null;
      }

      return this;
    },
    _initTooltipInteractions: function (remove$$1) {
      if (!remove$$1 && this._tooltipHandlersAdded) {
        return;
      }

      var onOff = remove$$1 ? 'off' : 'on',
          events = {
        remove: this.closeTooltip,
        move: this._moveTooltip
      };

      if (!this._tooltip.options.permanent) {
        events.mouseover = this._openTooltip;
        events.mouseout = this.closeTooltip;

        if (this._tooltip.options.sticky) {
          events.mousemove = this._moveTooltip;
        }

        if (touch) {
          events.click = this._openTooltip;
        }
      } else {
        events.add = this._openTooltip;
      }

      this[onOff](events);
      this._tooltipHandlersAdded = !remove$$1;
    },
    // @method openTooltip(latlng?: LatLng): this
    // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
    openTooltip: function (layer, latlng) {
      if (this._tooltip && this._map) {
        latlng = this._tooltip._prepareOpen(this, layer, latlng); // open the tooltip on the map

        this._map.openTooltip(this._tooltip, latlng); // Tooltip container may not be defined if not permanent and never
        // opened.


        if (this._tooltip.options.interactive && this._tooltip._container) {
          addClass(this._tooltip._container, 'leaflet-clickable');
          this.addInteractiveTarget(this._tooltip._container);
        }
      }

      return this;
    },
    // @method closeTooltip(): this
    // Closes the tooltip bound to this layer if it is open.
    closeTooltip: function () {
      if (this._tooltip) {
        this._tooltip._close();

        if (this._tooltip.options.interactive && this._tooltip._container) {
          removeClass(this._tooltip._container, 'leaflet-clickable');
          this.removeInteractiveTarget(this._tooltip._container);
        }
      }

      return this;
    },
    // @method toggleTooltip(): this
    // Opens or closes the tooltip bound to this layer depending on its current state.
    toggleTooltip: function (target) {
      if (this._tooltip) {
        if (this._tooltip._map) {
          this.closeTooltip();
        } else {
          this.openTooltip(target);
        }
      }

      return this;
    },
    // @method isTooltipOpen(): boolean
    // Returns `true` if the tooltip bound to this layer is currently open.
    isTooltipOpen: function () {
      return this._tooltip.isOpen();
    },
    // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
    // Sets the content of the tooltip bound to this layer.
    setTooltipContent: function (content) {
      if (this._tooltip) {
        this._tooltip.setContent(content);
      }

      return this;
    },
    // @method getTooltip(): Tooltip
    // Returns the tooltip bound to this layer.
    getTooltip: function () {
      return this._tooltip;
    },
    _openTooltip: function (e) {
      var layer = e.layer || e.target;

      if (!this._tooltip || !this._map) {
        return;
      }

      this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
    },
    _moveTooltip: function (e) {
      var latlng = e.latlng,
          containerPoint,
          layerPoint;

      if (this._tooltip.options.sticky && e.originalEvent) {
        containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
        layerPoint = this._map.containerPointToLayerPoint(containerPoint);
        latlng = this._map.layerPointToLatLng(layerPoint);
      }

      this._tooltip.setLatLng(latlng);
    }
  });
  /*
   * @class DivIcon
   * @aka L.DivIcon
   * @inherits Icon
   *
   * Represents a lightweight icon for markers that uses a simple `<div>`
   * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
   *
   * @example
   * ```js
   * var myIcon = L.divIcon({className: 'my-div-icon'});
   * // you can set .my-div-icon styles in CSS
   *
   * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
   * ```
   *
   * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
   */

  var DivIcon = Icon.extend({
    options: {
      // @section
      // @aka DivIcon options
      iconSize: [12, 12],
      // also can be set through CSS
      // iconAnchor: (Point),
      // popupAnchor: (Point),
      // @option html: String|HTMLElement = ''
      // Custom HTML code to put inside the div element, empty by default. Alternatively,
      // an instance of `HTMLElement`.
      html: false,
      // @option bgPos: Point = [0, 0]
      // Optional relative position of the background, in pixels
      bgPos: null,
      className: 'leaflet-div-icon'
    },
    createIcon: function (oldIcon) {
      var div = oldIcon && oldIcon.tagName === 'DIV' ? oldIcon : document.createElement('div'),
          options = this.options;

      if (options.html instanceof Element) {
        empty(div);
        div.appendChild(options.html);
      } else {
        div.innerHTML = options.html !== false ? options.html : '';
      }

      if (options.bgPos) {
        var bgPos = toPoint(options.bgPos);
        div.style.backgroundPosition = -bgPos.x + 'px ' + -bgPos.y + 'px';
      }

      this._setIconStyles(div, 'icon');

      return div;
    },
    createShadow: function () {
      return null;
    }
  }); // @factory L.divIcon(options: DivIcon options)
  // Creates a `DivIcon` instance with the given options.

  function divIcon(options) {
    return new DivIcon(options);
  }

  Icon.Default = IconDefault;
  /*
   * @class GridLayer
   * @inherits Layer
   * @aka L.GridLayer
   *
   * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
   * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
   *
   *
   * @section Synchronous usage
   * @example
   *
   * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
   *
   * ```js
   * var CanvasLayer = L.GridLayer.extend({
   *     createTile: function(coords){
   *         // create a <canvas> element for drawing
   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
   *
   *         // setup tile width and height according to the options
   *         var size = this.getTileSize();
   *         tile.width = size.x;
   *         tile.height = size.y;
   *
   *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
   *         var ctx = tile.getContext('2d');
   *
   *         // return the tile so it can be rendered on screen
   *         return tile;
   *     }
   * });
   * ```
   *
   * @section Asynchronous usage
   * @example
   *
   * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
   *
   * ```js
   * var CanvasLayer = L.GridLayer.extend({
   *     createTile: function(coords, done){
   *         var error;
   *
   *         // create a <canvas> element for drawing
   *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
   *
   *         // setup tile width and height according to the options
   *         var size = this.getTileSize();
   *         tile.width = size.x;
   *         tile.height = size.y;
   *
   *         // draw something asynchronously and pass the tile to the done() callback
   *         setTimeout(function() {
   *             done(error, tile);
   *         }, 1000);
   *
   *         return tile;
   *     }
   * });
   * ```
   *
   * @section
   */

  var GridLayer = Layer.extend({
    // @section
    // @aka GridLayer options
    options: {
      // @option tileSize: Number|Point = 256
      // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
      tileSize: 256,
      // @option opacity: Number = 1.0
      // Opacity of the tiles. Can be used in the `createTile()` function.
      opacity: 1,
      // @option updateWhenIdle: Boolean = (depends)
      // Load new tiles only when panning ends.
      // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
      // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
      // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
      updateWhenIdle: mobile,
      // @option updateWhenZooming: Boolean = true
      // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
      updateWhenZooming: true,
      // @option updateInterval: Number = 200
      // Tiles will not update more than once every `updateInterval` milliseconds when panning.
      updateInterval: 200,
      // @option zIndex: Number = 1
      // The explicit zIndex of the tile layer.
      zIndex: 1,
      // @option bounds: LatLngBounds = undefined
      // If set, tiles will only be loaded inside the set `LatLngBounds`.
      bounds: null,
      // @option minZoom: Number = 0
      // The minimum zoom level down to which this layer will be displayed (inclusive).
      minZoom: 0,
      // @option maxZoom: Number = undefined
      // The maximum zoom level up to which this layer will be displayed (inclusive).
      maxZoom: undefined,
      // @option maxNativeZoom: Number = undefined
      // Maximum zoom number the tile source has available. If it is specified,
      // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
      // from `maxNativeZoom` level and auto-scaled.
      maxNativeZoom: undefined,
      // @option minNativeZoom: Number = undefined
      // Minimum zoom number the tile source has available. If it is specified,
      // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
      // from `minNativeZoom` level and auto-scaled.
      minNativeZoom: undefined,
      // @option noWrap: Boolean = false
      // Whether the layer is wrapped around the antimeridian. If `true`, the
      // GridLayer will only be displayed once at low zoom levels. Has no
      // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
      // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
      // tiles outside the CRS limits.
      noWrap: false,
      // @option pane: String = 'tilePane'
      // `Map pane` where the grid layer will be added.
      pane: 'tilePane',
      // @option className: String = ''
      // A custom class name to assign to the tile layer. Empty by default.
      className: '',
      // @option keepBuffer: Number = 2
      // When panning the map, keep this many rows and columns of tiles before unloading them.
      keepBuffer: 2
    },
    initialize: function (options) {
      setOptions(this, options);
    },
    onAdd: function () {
      this._initContainer();

      this._levels = {};
      this._tiles = {};

      this._resetView();

      this._update();
    },
    beforeAdd: function (map) {
      map._addZoomLimit(this);
    },
    onRemove: function (map) {
      this._removeAllTiles();

      remove(this._container);

      map._removeZoomLimit(this);

      this._container = null;
      this._tileZoom = undefined;
    },
    // @method bringToFront: this
    // Brings the tile layer to the top of all tile layers.
    bringToFront: function () {
      if (this._map) {
        toFront(this._container);

        this._setAutoZIndex(Math.max);
      }

      return this;
    },
    // @method bringToBack: this
    // Brings the tile layer to the bottom of all tile layers.
    bringToBack: function () {
      if (this._map) {
        toBack(this._container);

        this._setAutoZIndex(Math.min);
      }

      return this;
    },
    // @method getContainer: HTMLElement
    // Returns the HTML element that contains the tiles for this layer.
    getContainer: function () {
      return this._container;
    },
    // @method setOpacity(opacity: Number): this
    // Changes the [opacity](#gridlayer-opacity) of the grid layer.
    setOpacity: function (opacity) {
      this.options.opacity = opacity;

      this._updateOpacity();

      return this;
    },
    // @method setZIndex(zIndex: Number): this
    // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
    setZIndex: function (zIndex) {
      this.options.zIndex = zIndex;

      this._updateZIndex();

      return this;
    },
    // @method isLoading: Boolean
    // Returns `true` if any tile in the grid layer has not finished loading.
    isLoading: function () {
      return this._loading;
    },
    // @method redraw: this
    // Causes the layer to clear all the tiles and request them again.
    redraw: function () {
      if (this._map) {
        this._removeAllTiles();

        this._update();
      }

      return this;
    },
    getEvents: function () {
      var events = {
        viewprereset: this._invalidateAll,
        viewreset: this._resetView,
        zoom: this._resetView,
        moveend: this._onMoveEnd
      };

      if (!this.options.updateWhenIdle) {
        // update tiles on move, but not more often than once per given interval
        if (!this._onMove) {
          this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
        }

        events.move = this._onMove;
      }

      if (this._zoomAnimated) {
        events.zoomanim = this._animateZoom;
      }

      return events;
    },
    // @section Extension methods
    // Layers extending `GridLayer` shall reimplement the following method.
    // @method createTile(coords: Object, done?: Function): HTMLElement
    // Called only internally, must be overridden by classes extending `GridLayer`.
    // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
    // is specified, it must be called when the tile has finished loading and drawing.
    createTile: function () {
      return document.createElement('div');
    },
    // @section
    // @method getTileSize: Point
    // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
    getTileSize: function () {
      var s = this.options.tileSize;
      return s instanceof Point ? s : new Point(s, s);
    },
    _updateZIndex: function () {
      if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
        this._container.style.zIndex = this.options.zIndex;
      }
    },
    _setAutoZIndex: function (compare) {
      // go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)
      var layers = this.getPane().children,
          edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

      for (var i = 0, len = layers.length, zIndex; i < len; i++) {
        zIndex = layers[i].style.zIndex;

        if (layers[i] !== this._container && zIndex) {
          edgeZIndex = compare(edgeZIndex, +zIndex);
        }
      }

      if (isFinite(edgeZIndex)) {
        this.options.zIndex = edgeZIndex + compare(-1, 1);

        this._updateZIndex();
      }
    },
    _updateOpacity: function () {
      if (!this._map) {
        return;
      } // IE doesn't inherit filter opacity properly, so we're forced to set it on tiles


      if (ielt9) {
        return;
      }

      setOpacity(this._container, this.options.opacity);
      var now = +new Date(),
          nextFrame = false,
          willPrune = false;

      for (var key in this._tiles) {
        var tile = this._tiles[key];

        if (!tile.current || !tile.loaded) {
          continue;
        }

        var fade = Math.min(1, (now - tile.loaded) / 200);
        setOpacity(tile.el, fade);

        if (fade < 1) {
          nextFrame = true;
        } else {
          if (tile.active) {
            willPrune = true;
          } else {
            this._onOpaqueTile(tile);
          }

          tile.active = true;
        }
      }

      if (willPrune && !this._noPrune) {
        this._pruneTiles();
      }

      if (nextFrame) {
        cancelAnimFrame(this._fadeFrame);
        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
      }
    },
    _onOpaqueTile: falseFn,
    _initContainer: function () {
      if (this._container) {
        return;
      }

      this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));

      this._updateZIndex();

      if (this.options.opacity < 1) {
        this._updateOpacity();
      }

      this.getPane().appendChild(this._container);
    },
    _updateLevels: function () {
      var zoom = this._tileZoom,
          maxZoom = this.options.maxZoom;

      if (zoom === undefined) {
        return undefined;
      }

      for (var z in this._levels) {
        z = Number(z);

        if (this._levels[z].el.children.length || z === zoom) {
          this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);

          this._onUpdateLevel(z);
        } else {
          remove(this._levels[z].el);

          this._removeTilesAtZoom(z);

          this._onRemoveLevel(z);

          delete this._levels[z];
        }
      }

      var level = this._levels[zoom],
          map = this._map;

      if (!level) {
        level = this._levels[zoom] = {};
        level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
        level.el.style.zIndex = maxZoom;
        level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
        level.zoom = zoom;

        this._setZoomTransform(level, map.getCenter(), map.getZoom()); // force the browser to consider the newly added element for transition


        falseFn(level.el.offsetWidth);

        this._onCreateLevel(level);
      }

      this._level = level;
      return level;
    },
    _onUpdateLevel: falseFn,
    _onRemoveLevel: falseFn,
    _onCreateLevel: falseFn,
    _pruneTiles: function () {
      if (!this._map) {
        return;
      }

      var key, tile;

      var zoom = this._map.getZoom();

      if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
        this._removeAllTiles();

        return;
      }

      for (key in this._tiles) {
        tile = this._tiles[key];
        tile.retain = tile.current;
      }

      for (key in this._tiles) {
        tile = this._tiles[key];

        if (tile.current && !tile.active) {
          var coords = tile.coords;

          if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
            this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
          }
        }
      }

      for (key in this._tiles) {
        if (!this._tiles[key].retain) {
          this._removeTile(key);
        }
      }
    },
    _removeTilesAtZoom: function (zoom) {
      for (var key in this._tiles) {
        if (this._tiles[key].coords.z !== zoom) {
          continue;
        }

        this._removeTile(key);
      }
    },
    _removeAllTiles: function () {
      for (var key in this._tiles) {
        this._removeTile(key);
      }
    },
    _invalidateAll: function () {
      for (var z in this._levels) {
        remove(this._levels[z].el);

        this._onRemoveLevel(Number(z));

        delete this._levels[z];
      }

      this._removeAllTiles();

      this._tileZoom = undefined;
    },
    _retainParent: function (x, y, z, minZoom) {
      var x2 = Math.floor(x / 2),
          y2 = Math.floor(y / 2),
          z2 = z - 1,
          coords2 = new Point(+x2, +y2);
      coords2.z = +z2;

      var key = this._tileCoordsToKey(coords2),
          tile = this._tiles[key];

      if (tile && tile.active) {
        tile.retain = true;
        return true;
      } else if (tile && tile.loaded) {
        tile.retain = true;
      }

      if (z2 > minZoom) {
        return this._retainParent(x2, y2, z2, minZoom);
      }

      return false;
    },
    _retainChildren: function (x, y, z, maxZoom) {
      for (var i = 2 * x; i < 2 * x + 2; i++) {
        for (var j = 2 * y; j < 2 * y + 2; j++) {
          var coords = new Point(i, j);
          coords.z = z + 1;

          var key = this._tileCoordsToKey(coords),
              tile = this._tiles[key];

          if (tile && tile.active) {
            tile.retain = true;
            continue;
          } else if (tile && tile.loaded) {
            tile.retain = true;
          }

          if (z + 1 < maxZoom) {
            this._retainChildren(i, j, z + 1, maxZoom);
          }
        }
      }
    },
    _resetView: function (e) {
      var animating = e && (e.pinch || e.flyTo);

      this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
    },
    _animateZoom: function (e) {
      this._setView(e.center, e.zoom, true, e.noUpdate);
    },
    _clampZoom: function (zoom) {
      var options = this.options;

      if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
        return options.minNativeZoom;
      }

      if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
        return options.maxNativeZoom;
      }

      return zoom;
    },
    _setView: function (center, zoom, noPrune, noUpdate) {
      var tileZoom = Math.round(zoom);

      if (this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom || this.options.minZoom !== undefined && tileZoom < this.options.minZoom) {
        tileZoom = undefined;
      } else {
        tileZoom = this._clampZoom(tileZoom);
      }

      var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;

      if (!noUpdate || tileZoomChanged) {
        this._tileZoom = tileZoom;

        if (this._abortLoading) {
          this._abortLoading();
        }

        this._updateLevels();

        this._resetGrid();

        if (tileZoom !== undefined) {
          this._update(center);
        }

        if (!noPrune) {
          this._pruneTiles();
        } // Flag to prevent _updateOpacity from pruning tiles during
        // a zoom anim or a pinch gesture


        this._noPrune = !!noPrune;
      }

      this._setZoomTransforms(center, zoom);
    },
    _setZoomTransforms: function (center, zoom) {
      for (var i in this._levels) {
        this._setZoomTransform(this._levels[i], center, zoom);
      }
    },
    _setZoomTransform: function (level, center, zoom) {
      var scale = this._map.getZoomScale(zoom, level.zoom),
          translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();

      if (any3d) {
        setTransform(level.el, translate, scale);
      } else {
        setPosition(level.el, translate);
      }
    },
    _resetGrid: function () {
      var map = this._map,
          crs = map.options.crs,
          tileSize = this._tileSize = this.getTileSize(),
          tileZoom = this._tileZoom;

      var bounds = this._map.getPixelWorldBounds(this._tileZoom);

      if (bounds) {
        this._globalTileRange = this._pxBoundsToTileRange(bounds);
      }

      this._wrapX = crs.wrapLng && !this.options.noWrap && [Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x), Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)];
      this._wrapY = crs.wrapLat && !this.options.noWrap && [Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x), Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)];
    },
    _onMoveEnd: function () {
      if (!this._map || this._map._animatingZoom) {
        return;
      }

      this._update();
    },
    _getTiledPixelBounds: function (center) {
      var map = this._map,
          mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
          scale = map.getZoomScale(mapZoom, this._tileZoom),
          pixelCenter = map.project(center, this._tileZoom).floor(),
          halfSize = map.getSize().divideBy(scale * 2);
      return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
    },
    // Private method to load tiles in the grid's active zoom level according to map bounds
    _update: function (center) {
      var map = this._map;

      if (!map) {
        return;
      }

      var zoom = this._clampZoom(map.getZoom());

      if (center === undefined) {
        center = map.getCenter();
      }

      if (this._tileZoom === undefined) {
        return;
      } // if out of minzoom/maxzoom


      var pixelBounds = this._getTiledPixelBounds(center),
          tileRange = this._pxBoundsToTileRange(pixelBounds),
          tileCenter = tileRange.getCenter(),
          queue = [],
          margin = this.options.keepBuffer,
          noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin])); // Sanity check: panic if the tile range contains Infinity somewhere.


      if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
        throw new Error('Attempted to load an infinite number of tiles');
      }

      for (var key in this._tiles) {
        var c = this._tiles[key].coords;

        if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
          this._tiles[key].current = false;
        }
      } // _update just loads more tiles. If the tile zoom level differs too much
      // from the map's, let _setView reset levels and prune old tiles.


      if (Math.abs(zoom - this._tileZoom) > 1) {
        this._setView(center, zoom);

        return;
      } // create a queue of coordinates to load tiles from


      for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
        for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
          var coords = new Point(i, j);
          coords.z = this._tileZoom;

          if (!this._isValidTile(coords)) {
            continue;
          }

          var tile = this._tiles[this._tileCoordsToKey(coords)];

          if (tile) {
            tile.current = true;
          } else {
            queue.push(coords);
          }
        }
      } // sort tile queue to load tiles in order of their distance to center


      queue.sort(function (a, b) {
        return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
      });

      if (queue.length !== 0) {
        // if it's the first batch of tiles to load
        if (!this._loading) {
          this._loading = true; // @event loading: Event
          // Fired when the grid layer starts loading tiles.

          this.fire('loading');
        } // create DOM fragment to append tiles in one batch


        var fragment = document.createDocumentFragment();

        for (i = 0; i < queue.length; i++) {
          this._addTile(queue[i], fragment);
        }

        this._level.el.appendChild(fragment);
      }
    },
    _isValidTile: function (coords) {
      var crs = this._map.options.crs;

      if (!crs.infinite) {
        // don't load tile if it's out of bounds and not wrapped
        var bounds = this._globalTileRange;

        if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
          return false;
        }
      }

      if (!this.options.bounds) {
        return true;
      } // don't load tile if it doesn't intersect the bounds in options


      var tileBounds = this._tileCoordsToBounds(coords);

      return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
    },
    _keyToBounds: function (key) {
      return this._tileCoordsToBounds(this._keyToTileCoords(key));
    },
    _tileCoordsToNwSe: function (coords) {
      var map = this._map,
          tileSize = this.getTileSize(),
          nwPoint = coords.scaleBy(tileSize),
          sePoint = nwPoint.add(tileSize),
          nw = map.unproject(nwPoint, coords.z),
          se = map.unproject(sePoint, coords.z);
      return [nw, se];
    },
    // converts tile coordinates to its geographical bounds
    _tileCoordsToBounds: function (coords) {
      var bp = this._tileCoordsToNwSe(coords),
          bounds = new LatLngBounds(bp[0], bp[1]);

      if (!this.options.noWrap) {
        bounds = this._map.wrapLatLngBounds(bounds);
      }

      return bounds;
    },
    // converts tile coordinates to key for the tile cache
    _tileCoordsToKey: function (coords) {
      return coords.x + ':' + coords.y + ':' + coords.z;
    },
    // converts tile cache key to coordinates
    _keyToTileCoords: function (key) {
      var k = key.split(':'),
          coords = new Point(+k[0], +k[1]);
      coords.z = +k[2];
      return coords;
    },
    _removeTile: function (key) {
      var tile = this._tiles[key];

      if (!tile) {
        return;
      }

      remove(tile.el);
      delete this._tiles[key]; // @event tileunload: TileEvent
      // Fired when a tile is removed (e.g. when a tile goes off the screen).

      this.fire('tileunload', {
        tile: tile.el,
        coords: this._keyToTileCoords(key)
      });
    },
    _initTile: function (tile) {
      addClass(tile, 'leaflet-tile');
      var tileSize = this.getTileSize();
      tile.style.width = tileSize.x + 'px';
      tile.style.height = tileSize.y + 'px';
      tile.onselectstart = falseFn;
      tile.onmousemove = falseFn; // update opacity on tiles in IE7-8 because of filter inheritance problems

      if (ielt9 && this.options.opacity < 1) {
        setOpacity(tile, this.options.opacity);
      } // without this hack, tiles disappear after zoom on Chrome for Android
      // https://github.com/Leaflet/Leaflet/issues/2078


      if (android && !android23) {
        tile.style.WebkitBackfaceVisibility = 'hidden';
      }
    },
    _addTile: function (coords, container) {
      var tilePos = this._getTilePos(coords),
          key = this._tileCoordsToKey(coords);

      var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));

      this._initTile(tile); // if createTile is defined with a second argument ("done" callback),
      // we know that tile is async and will be ready later; otherwise


      if (this.createTile.length < 2) {
        // mark tile as ready, but delay one frame for opacity animation to happen
        requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
      }

      setPosition(tile, tilePos); // save tile in cache

      this._tiles[key] = {
        el: tile,
        coords: coords,
        current: true
      };
      container.appendChild(tile); // @event tileloadstart: TileEvent
      // Fired when a tile is requested and starts loading.

      this.fire('tileloadstart', {
        tile: tile,
        coords: coords
      });
    },
    _tileReady: function (coords, err, tile) {
      if (err) {
        // @event tileerror: TileErrorEvent
        // Fired when there is an error loading a tile.
        this.fire('tileerror', {
          error: err,
          tile: tile,
          coords: coords
        });
      }

      var key = this._tileCoordsToKey(coords);

      tile = this._tiles[key];

      if (!tile) {
        return;
      }

      tile.loaded = +new Date();

      if (this._map._fadeAnimated) {
        setOpacity(tile.el, 0);
        cancelAnimFrame(this._fadeFrame);
        this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
      } else {
        tile.active = true;

        this._pruneTiles();
      }

      if (!err) {
        addClass(tile.el, 'leaflet-tile-loaded'); // @event tileload: TileEvent
        // Fired when a tile loads.

        this.fire('tileload', {
          tile: tile.el,
          coords: coords
        });
      }

      if (this._noTilesToLoad()) {
        this._loading = false; // @event load: Event
        // Fired when the grid layer loaded all visible tiles.

        this.fire('load');

        if (ielt9 || !this._map._fadeAnimated) {
          requestAnimFrame(this._pruneTiles, this);
        } else {
          // Wait a bit more than 0.2 secs (the duration of the tile fade-in)
          // to trigger a pruning.
          setTimeout(bind(this._pruneTiles, this), 250);
        }
      }
    },
    _getTilePos: function (coords) {
      return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
    },
    _wrapCoords: function (coords) {
      var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
      newCoords.z = coords.z;
      return newCoords;
    },
    _pxBoundsToTileRange: function (bounds) {
      var tileSize = this.getTileSize();
      return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
    },
    _noTilesToLoad: function () {
      for (var key in this._tiles) {
        if (!this._tiles[key].loaded) {
          return false;
        }
      }

      return true;
    }
  }); // @factory L.gridLayer(options?: GridLayer options)
  // Creates a new instance of GridLayer with the supplied options.

  function gridLayer(options) {
    return new GridLayer(options);
  }
  /*
   * @class TileLayer
   * @inherits GridLayer
   * @aka L.TileLayer
   * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.
   *
   * @example
   *
   * ```js
   * L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>'}).addTo(map);
   * ```
   *
   * @section URL template
   * @example
   *
   * A string of the following form:
   *
   * ```
   * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
   * ```
   *
   * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
   *
   * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
   *
   * ```
   * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
   * ```
   */


  var TileLayer = GridLayer.extend({
    // @section
    // @aka TileLayer options
    options: {
      // @option minZoom: Number = 0
      // The minimum zoom level down to which this layer will be displayed (inclusive).
      minZoom: 0,
      // @option maxZoom: Number = 18
      // The maximum zoom level up to which this layer will be displayed (inclusive).
      maxZoom: 18,
      // @option subdomains: String|String[] = 'abc'
      // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
      subdomains: 'abc',
      // @option errorTileUrl: String = ''
      // URL to the tile image to show in place of the tile that failed to load.
      errorTileUrl: '',
      // @option zoomOffset: Number = 0
      // The zoom number used in tile URLs will be offset with this value.
      zoomOffset: 0,
      // @option tms: Boolean = false
      // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
      tms: false,
      // @option zoomReverse: Boolean = false
      // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
      zoomReverse: false,
      // @option detectRetina: Boolean = false
      // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
      detectRetina: false,
      // @option crossOrigin: Boolean|String = false
      // Whether the crossOrigin attribute will be added to the tiles.
      // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
      // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
      crossOrigin: false
    },
    initialize: function (url, options) {
      this._url = url;
      options = setOptions(this, options); // detecting retina displays, adjusting tileSize and zoom levels

      if (options.detectRetina && retina && options.maxZoom > 0) {
        options.tileSize = Math.floor(options.tileSize / 2);

        if (!options.zoomReverse) {
          options.zoomOffset++;
          options.maxZoom--;
        } else {
          options.zoomOffset--;
          options.minZoom++;
        }

        options.minZoom = Math.max(0, options.minZoom);
      }

      if (typeof options.subdomains === 'string') {
        options.subdomains = options.subdomains.split('');
      } // for https://github.com/Leaflet/Leaflet/issues/137


      if (!android) {
        this.on('tileunload', this._onTileRemove);
      }
    },
    // @method setUrl(url: String, noRedraw?: Boolean): this
    // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
    // If the URL does not change, the layer will not be redrawn unless
    // the noRedraw parameter is set to false.
    setUrl: function (url, noRedraw) {
      if (this._url === url && noRedraw === undefined) {
        noRedraw = true;
      }

      this._url = url;

      if (!noRedraw) {
        this.redraw();
      }

      return this;
    },
    // @method createTile(coords: Object, done?: Function): HTMLElement
    // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
    // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
    // callback is called when the tile has been loaded.
    createTile: function (coords, done) {
      var tile = document.createElement('img');
      on(tile, 'load', bind(this._tileOnLoad, this, done, tile));
      on(tile, 'error', bind(this._tileOnError, this, done, tile));

      if (this.options.crossOrigin || this.options.crossOrigin === '') {
        tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
      }
      /*
       Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
       http://www.w3.org/TR/WCAG20-TECHS/H67
      */


      tile.alt = '';
      /*
       Set role="presentation" to force screen readers to ignore this
       https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
      */

      tile.setAttribute('role', 'presentation');
      tile.src = this.getTileUrl(coords);
      return tile;
    },
    // @section Extension methods
    // @uninheritable
    // Layers extending `TileLayer` might reimplement the following method.
    // @method getTileUrl(coords: Object): String
    // Called only internally, returns the URL for a tile given its coordinates.
    // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
    getTileUrl: function (coords) {
      var data = {
        r: retina ? '@2x' : '',
        s: this._getSubdomain(coords),
        x: coords.x,
        y: coords.y,
        z: this._getZoomForUrl()
      };

      if (this._map && !this._map.options.crs.infinite) {
        var invertedY = this._globalTileRange.max.y - coords.y;

        if (this.options.tms) {
          data['y'] = invertedY;
        }

        data['-y'] = invertedY;
      }

      return template(this._url, extend(data, this.options));
    },
    _tileOnLoad: function (done, tile) {
      // For https://github.com/Leaflet/Leaflet/issues/3332
      if (ielt9) {
        setTimeout(bind(done, this, null, tile), 0);
      } else {
        done(null, tile);
      }
    },
    _tileOnError: function (done, tile, e) {
      var errorUrl = this.options.errorTileUrl;

      if (errorUrl && tile.getAttribute('src') !== errorUrl) {
        tile.src = errorUrl;
      }

      done(e, tile);
    },
    _onTileRemove: function (e) {
      e.tile.onload = null;
    },
    _getZoomForUrl: function () {
      var zoom = this._tileZoom,
          maxZoom = this.options.maxZoom,
          zoomReverse = this.options.zoomReverse,
          zoomOffset = this.options.zoomOffset;

      if (zoomReverse) {
        zoom = maxZoom - zoom;
      }

      return zoom + zoomOffset;
    },
    _getSubdomain: function (tilePoint) {
      var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
      return this.options.subdomains[index];
    },
    // stops loading all tiles in the background layer
    _abortLoading: function () {
      var i, tile;

      for (i in this._tiles) {
        if (this._tiles[i].coords.z !== this._tileZoom) {
          tile = this._tiles[i].el;
          tile.onload = falseFn;
          tile.onerror = falseFn;

          if (!tile.complete) {
            tile.src = emptyImageUrl;
            remove(tile);
            delete this._tiles[i];
          }
        }
      }
    },
    _removeTile: function (key) {
      var tile = this._tiles[key];

      if (!tile) {
        return;
      } // Cancels any pending http requests associated with the tile
      // unless we're on Android's stock browser,
      // see https://github.com/Leaflet/Leaflet/issues/137


      if (!androidStock) {
        tile.el.setAttribute('src', emptyImageUrl);
      }

      return GridLayer.prototype._removeTile.call(this, key);
    },
    _tileReady: function (coords, err, tile) {
      if (!this._map || tile && tile.getAttribute('src') === emptyImageUrl) {
        return;
      }

      return GridLayer.prototype._tileReady.call(this, coords, err, tile);
    }
  }); // @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
  // Instantiates a tile layer object given a `URL template` and optionally an options object.

  function tileLayer(url, options) {
    return new TileLayer(url, options);
  }
  /*
   * @class TileLayer.WMS
   * @inherits TileLayer
   * @aka L.TileLayer.WMS
   * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
   *
   * @example
   *
   * ```js
   * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
   * 	layers: 'nexrad-n0r-900913',
   * 	format: 'image/png',
   * 	transparent: true,
   * 	attribution: "Weather data © 2012 IEM Nexrad"
   * });
   * ```
   */


  var TileLayerWMS = TileLayer.extend({
    // @section
    // @aka TileLayer.WMS options
    // If any custom options not documented here are used, they will be sent to the
    // WMS server as extra parameters in each request URL. This can be useful for
    // [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
    defaultWmsParams: {
      service: 'WMS',
      request: 'GetMap',
      // @option layers: String = ''
      // **(required)** Comma-separated list of WMS layers to show.
      layers: '',
      // @option styles: String = ''
      // Comma-separated list of WMS styles.
      styles: '',
      // @option format: String = 'image/jpeg'
      // WMS image format (use `'image/png'` for layers with transparency).
      format: 'image/jpeg',
      // @option transparent: Boolean = false
      // If `true`, the WMS service will return images with transparency.
      transparent: false,
      // @option version: String = '1.1.1'
      // Version of the WMS service to use
      version: '1.1.1'
    },
    options: {
      // @option crs: CRS = null
      // Coordinate Reference System to use for the WMS requests, defaults to
      // map CRS. Don't change this if you're not sure what it means.
      crs: null,
      // @option uppercase: Boolean = false
      // If `true`, WMS request parameter keys will be uppercase.
      uppercase: false
    },
    initialize: function (url, options) {
      this._url = url;
      var wmsParams = extend({}, this.defaultWmsParams); // all keys that are not TileLayer options go to WMS params

      for (var i in options) {
        if (!(i in this.options)) {
          wmsParams[i] = options[i];
        }
      }

      options = setOptions(this, options);
      var realRetina = options.detectRetina && retina ? 2 : 1;
      var tileSize = this.getTileSize();
      wmsParams.width = tileSize.x * realRetina;
      wmsParams.height = tileSize.y * realRetina;
      this.wmsParams = wmsParams;
    },
    onAdd: function (map) {
      this._crs = this.options.crs || map.options.crs;
      this._wmsVersion = parseFloat(this.wmsParams.version);
      var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
      this.wmsParams[projectionKey] = this._crs.code;
      TileLayer.prototype.onAdd.call(this, map);
    },
    getTileUrl: function (coords) {
      var tileBounds = this._tileCoordsToNwSe(coords),
          crs = this._crs,
          bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),
          min = bounds.min,
          max = bounds.max,
          bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(','),
          url = TileLayer.prototype.getTileUrl.call(this, coords);

      return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
    },
    // @method setParams(params: Object, noRedraw?: Boolean): this
    // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
    setParams: function (params, noRedraw) {
      extend(this.wmsParams, params);

      if (!noRedraw) {
        this.redraw();
      }

      return this;
    }
  }); // @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
  // Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.

  function tileLayerWMS(url, options) {
    return new TileLayerWMS(url, options);
  }

  TileLayer.WMS = TileLayerWMS;
  tileLayer.wms = tileLayerWMS;
  /*
   * @class Renderer
   * @inherits Layer
   * @aka L.Renderer
   *
   * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
   * DOM container of the renderer, its bounds, and its zoom animation.
   *
   * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
   * itself can be added or removed to the map. All paths use a renderer, which can
   * be implicit (the map will decide the type of renderer and use it automatically)
   * or explicit (using the [`renderer`](#path-renderer) option of the path).
   *
   * Do not use this class directly, use `SVG` and `Canvas` instead.
   *
   * @event update: Event
   * Fired when the renderer updates its bounds, center and zoom, for example when
   * its map has moved
   */

  var Renderer = Layer.extend({
    // @section
    // @aka Renderer options
    options: {
      // @option padding: Number = 0.1
      // How much to extend the clip area around the map view (relative to its size)
      // e.g. 0.1 would be 10% of map view in each direction
      padding: 0.1,
      // @option tolerance: Number = 0
      // How much to extend click tolerance round a path/object on the map
      tolerance: 0
    },
    initialize: function (options) {
      setOptions(this, options);
      stamp(this);
      this._layers = this._layers || {};
    },
    onAdd: function () {
      if (!this._container) {
        this._initContainer(); // defined by renderer implementations


        if (this._zoomAnimated) {
          addClass(this._container, 'leaflet-zoom-animated');
        }
      }

      this.getPane().appendChild(this._container);

      this._update();

      this.on('update', this._updatePaths, this);
    },
    onRemove: function () {
      this.off('update', this._updatePaths, this);

      this._destroyContainer();
    },
    getEvents: function () {
      var events = {
        viewreset: this._reset,
        zoom: this._onZoom,
        moveend: this._update,
        zoomend: this._onZoomEnd
      };

      if (this._zoomAnimated) {
        events.zoomanim = this._onAnimZoom;
      }

      return events;
    },
    _onAnimZoom: function (ev) {
      this._updateTransform(ev.center, ev.zoom);
    },
    _onZoom: function () {
      this._updateTransform(this._map.getCenter(), this._map.getZoom());
    },
    _updateTransform: function (center, zoom) {
      var scale = this._map.getZoomScale(zoom, this._zoom),
          position = getPosition(this._container),
          viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
          currentCenterPoint = this._map.project(this._center, zoom),
          destCenterPoint = this._map.project(center, zoom),
          centerOffset = destCenterPoint.subtract(currentCenterPoint),
          topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

      if (any3d) {
        setTransform(this._container, topLeftOffset, scale);
      } else {
        setPosition(this._container, topLeftOffset);
      }
    },
    _reset: function () {
      this._update();

      this._updateTransform(this._center, this._zoom);

      for (var id in this._layers) {
        this._layers[id]._reset();
      }
    },
    _onZoomEnd: function () {
      for (var id in this._layers) {
        this._layers[id]._project();
      }
    },
    _updatePaths: function () {
      for (var id in this._layers) {
        this._layers[id]._update();
      }
    },
    _update: function () {
      // Update pixel bounds of renderer container (for positioning/sizing/clipping later)
      // Subclasses are responsible of firing the 'update' event.
      var p = this.options.padding,
          size = this._map.getSize(),
          min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

      this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());
      this._center = this._map.getCenter();
      this._zoom = this._map.getZoom();
    }
  });
  /*
   * @class Canvas
   * @inherits Renderer
   * @aka L.Canvas
   *
   * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
   * Inherits `Renderer`.
   *
   * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
   * available in all web browsers, notably IE8, and overlapping geometries might
   * not display properly in some edge cases.
   *
   * @example
   *
   * Use Canvas by default for all paths in the map:
   *
   * ```js
   * var map = L.map('map', {
   * 	renderer: L.canvas()
   * });
   * ```
   *
   * Use a Canvas renderer with extra padding for specific vector geometries:
   *
   * ```js
   * var map = L.map('map');
   * var myRenderer = L.canvas({ padding: 0.5 });
   * var line = L.polyline( coordinates, { renderer: myRenderer } );
   * var circle = L.circle( center, { renderer: myRenderer } );
   * ```
   */

  var Canvas = Renderer.extend({
    getEvents: function () {
      var events = Renderer.prototype.getEvents.call(this);
      events.viewprereset = this._onViewPreReset;
      return events;
    },
    _onViewPreReset: function () {
      // Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
      this._postponeUpdatePaths = true;
    },
    onAdd: function () {
      Renderer.prototype.onAdd.call(this); // Redraw vectors since canvas is cleared upon removal,
      // in case of removing the renderer itself from the map.

      this._draw();
    },
    _initContainer: function () {
      var container = this._container = document.createElement('canvas');
      on(container, 'mousemove', this._onMouseMove, this);
      on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);
      on(container, 'mouseout', this._handleMouseOut, this);
      this._ctx = container.getContext('2d');
    },
    _destroyContainer: function () {
      cancelAnimFrame(this._redrawRequest);
      delete this._ctx;
      remove(this._container);
      off(this._container);
      delete this._container;
    },
    _updatePaths: function () {
      if (this._postponeUpdatePaths) {
        return;
      }

      var layer;
      this._redrawBounds = null;

      for (var id in this._layers) {
        layer = this._layers[id];

        layer._update();
      }

      this._redraw();
    },
    _update: function () {
      if (this._map._animatingZoom && this._bounds) {
        return;
      }

      Renderer.prototype._update.call(this);

      var b = this._bounds,
          container = this._container,
          size = b.getSize(),
          m = retina ? 2 : 1;
      setPosition(container, b.min); // set canvas size (also clearing it); use double size on retina

      container.width = m * size.x;
      container.height = m * size.y;
      container.style.width = size.x + 'px';
      container.style.height = size.y + 'px';

      if (retina) {
        this._ctx.scale(2, 2);
      } // translate so we use the same path coordinates after canvas element moves


      this._ctx.translate(-b.min.x, -b.min.y); // Tell paths to redraw themselves


      this.fire('update');
    },
    _reset: function () {
      Renderer.prototype._reset.call(this);

      if (this._postponeUpdatePaths) {
        this._postponeUpdatePaths = false;

        this._updatePaths();
      }
    },
    _initPath: function (layer) {
      this._updateDashArray(layer);

      this._layers[stamp(layer)] = layer;
      var order = layer._order = {
        layer: layer,
        prev: this._drawLast,
        next: null
      };

      if (this._drawLast) {
        this._drawLast.next = order;
      }

      this._drawLast = order;
      this._drawFirst = this._drawFirst || this._drawLast;
    },
    _addPath: function (layer) {
      this._requestRedraw(layer);
    },
    _removePath: function (layer) {
      var order = layer._order;
      var next = order.next;
      var prev = order.prev;

      if (next) {
        next.prev = prev;
      } else {
        this._drawLast = prev;
      }

      if (prev) {
        prev.next = next;
      } else {
        this._drawFirst = next;
      }

      delete layer._order;
      delete this._layers[stamp(layer)];

      this._requestRedraw(layer);
    },
    _updatePath: function (layer) {
      // Redraw the union of the layer's old pixel
      // bounds and the new pixel bounds.
      this._extendRedrawBounds(layer);

      layer._project();

      layer._update(); // The redraw will extend the redraw bounds
      // with the new pixel bounds.


      this._requestRedraw(layer);
    },
    _updateStyle: function (layer) {
      this._updateDashArray(layer);

      this._requestRedraw(layer);
    },
    _updateDashArray: function (layer) {
      if (typeof layer.options.dashArray === 'string') {
        var parts = layer.options.dashArray.split(/[, ]+/),
            dashArray = [],
            dashValue,
            i;

        for (i = 0; i < parts.length; i++) {
          dashValue = Number(parts[i]); // Ignore dash array containing invalid lengths

          if (isNaN(dashValue)) {
            return;
          }

          dashArray.push(dashValue);
        }

        layer.options._dashArray = dashArray;
      } else {
        layer.options._dashArray = layer.options.dashArray;
      }
    },
    _requestRedraw: function (layer) {
      if (!this._map) {
        return;
      }

      this._extendRedrawBounds(layer);

      this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
    },
    _extendRedrawBounds: function (layer) {
      if (layer._pxBounds) {
        var padding = (layer.options.weight || 0) + 1;
        this._redrawBounds = this._redrawBounds || new Bounds();

        this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));

        this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
      }
    },
    _redraw: function () {
      this._redrawRequest = null;

      if (this._redrawBounds) {
        this._redrawBounds.min._floor();

        this._redrawBounds.max._ceil();
      }

      this._clear(); // clear layers in redraw bounds


      this._draw(); // draw layers


      this._redrawBounds = null;
    },
    _clear: function () {
      var bounds = this._redrawBounds;

      if (bounds) {
        var size = bounds.getSize();

        this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
      } else {
        this._ctx.save();

        this._ctx.setTransform(1, 0, 0, 1, 0, 0);

        this._ctx.clearRect(0, 0, this._container.width, this._container.height);

        this._ctx.restore();
      }
    },
    _draw: function () {
      var layer,
          bounds = this._redrawBounds;

      this._ctx.save();

      if (bounds) {
        var size = bounds.getSize();

        this._ctx.beginPath();

        this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);

        this._ctx.clip();
      }

      this._drawing = true;

      for (var order = this._drawFirst; order; order = order.next) {
        layer = order.layer;

        if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
          layer._updatePath();
        }
      }

      this._drawing = false;

      this._ctx.restore(); // Restore state before clipping.

    },
    _updatePoly: function (layer, closed) {
      if (!this._drawing) {
        return;
      }

      var i,
          j,
          len2,
          p,
          parts = layer._parts,
          len = parts.length,
          ctx = this._ctx;

      if (!len) {
        return;
      }

      ctx.beginPath();

      for (i = 0; i < len; i++) {
        for (j = 0, len2 = parts[i].length; j < len2; j++) {
          p = parts[i][j];
          ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
        }

        if (closed) {
          ctx.closePath();
        }
      }

      this._fillStroke(ctx, layer); // TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature

    },
    _updateCircle: function (layer) {
      if (!this._drawing || layer._empty()) {
        return;
      }

      var p = layer._point,
          ctx = this._ctx,
          r = Math.max(Math.round(layer._radius), 1),
          s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;

      if (s !== 1) {
        ctx.save();
        ctx.scale(1, s);
      }

      ctx.beginPath();
      ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

      if (s !== 1) {
        ctx.restore();
      }

      this._fillStroke(ctx, layer);
    },
    _fillStroke: function (ctx, layer) {
      var options = layer.options;

      if (options.fill) {
        ctx.globalAlpha = options.fillOpacity;
        ctx.fillStyle = options.fillColor || options.color;
        ctx.fill(options.fillRule || 'evenodd');
      }

      if (options.stroke && options.weight !== 0) {
        if (ctx.setLineDash) {
          ctx.setLineDash(layer.options && layer.options._dashArray || []);
        }

        ctx.globalAlpha = options.opacity;
        ctx.lineWidth = options.weight;
        ctx.strokeStyle = options.color;
        ctx.lineCap = options.lineCap;
        ctx.lineJoin = options.lineJoin;
        ctx.stroke();
      }
    },
    // Canvas obviously doesn't have mouse events for individual drawn objects,
    // so we emulate that by calculating what's under the mouse on mousemove/click manually
    _onClick: function (e) {
      var point = this._map.mouseEventToLayerPoint(e),
          layer,
          clickedLayer;

      for (var order = this._drawFirst; order; order = order.next) {
        layer = order.layer;

        if (layer.options.interactive && layer._containsPoint(point)) {
          if (!(e.type === 'click' || e.type !== 'preclick') || !this._map._draggableMoved(layer)) {
            clickedLayer = layer;
          }
        }
      }

      if (clickedLayer) {
        fakeStop(e);

        this._fireEvent([clickedLayer], e);
      }
    },
    _onMouseMove: function (e) {
      if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
        return;
      }

      var point = this._map.mouseEventToLayerPoint(e);

      this._handleMouseHover(e, point);
    },
    _handleMouseOut: function (e) {
      var layer = this._hoveredLayer;

      if (layer) {
        // if we're leaving the layer, fire mouseout
        removeClass(this._container, 'leaflet-interactive');

        this._fireEvent([layer], e, 'mouseout');

        this._hoveredLayer = null;
        this._mouseHoverThrottled = false;
      }
    },
    _handleMouseHover: function (e, point) {
      if (this._mouseHoverThrottled) {
        return;
      }

      var layer, candidateHoveredLayer;

      for (var order = this._drawFirst; order; order = order.next) {
        layer = order.layer;

        if (layer.options.interactive && layer._containsPoint(point)) {
          candidateHoveredLayer = layer;
        }
      }

      if (candidateHoveredLayer !== this._hoveredLayer) {
        this._handleMouseOut(e);

        if (candidateHoveredLayer) {
          addClass(this._container, 'leaflet-interactive'); // change cursor

          this._fireEvent([candidateHoveredLayer], e, 'mouseover');

          this._hoveredLayer = candidateHoveredLayer;
        }
      }

      if (this._hoveredLayer) {
        this._fireEvent([this._hoveredLayer], e);
      }

      this._mouseHoverThrottled = true;
      setTimeout(bind(function () {
        this._mouseHoverThrottled = false;
      }, this), 32);
    },
    _fireEvent: function (layers, e, type) {
      this._map._fireDOMEvent(e, type || e.type, layers);
    },
    _bringToFront: function (layer) {
      var order = layer._order;

      if (!order) {
        return;
      }

      var next = order.next;
      var prev = order.prev;

      if (next) {
        next.prev = prev;
      } else {
        // Already last
        return;
      }

      if (prev) {
        prev.next = next;
      } else if (next) {
        // Update first entry unless this is the
        // single entry
        this._drawFirst = next;
      }

      order.prev = this._drawLast;
      this._drawLast.next = order;
      order.next = null;
      this._drawLast = order;

      this._requestRedraw(layer);
    },
    _bringToBack: function (layer) {
      var order = layer._order;

      if (!order) {
        return;
      }

      var next = order.next;
      var prev = order.prev;

      if (prev) {
        prev.next = next;
      } else {
        // Already first
        return;
      }

      if (next) {
        next.prev = prev;
      } else if (prev) {
        // Update last entry unless this is the
        // single entry
        this._drawLast = prev;
      }

      order.prev = null;
      order.next = this._drawFirst;
      this._drawFirst.prev = order;
      this._drawFirst = order;

      this._requestRedraw(layer);
    }
  }); // @factory L.canvas(options?: Renderer options)
  // Creates a Canvas renderer with the given options.

  function canvas$1(options) {
    return canvas ? new Canvas(options) : null;
  }
  /*
   * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
   */


  var vmlCreate = function () {
    try {
      document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
      return function (name) {
        return document.createElement('<lvml:' + name + ' class="lvml">');
      };
    } catch (e) {
      return function (name) {
        return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
      };
    }
  }();
  /*
   * @class SVG
   *
   *
   * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
   * with old versions of Internet Explorer.
   */
  // mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences


  var vmlMixin = {
    _initContainer: function () {
      this._container = create$1('div', 'leaflet-vml-container');
    },
    _update: function () {
      if (this._map._animatingZoom) {
        return;
      }

      Renderer.prototype._update.call(this);

      this.fire('update');
    },
    _initPath: function (layer) {
      var container = layer._container = vmlCreate('shape');
      addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));
      container.coordsize = '1 1';
      layer._path = vmlCreate('path');
      container.appendChild(layer._path);

      this._updateStyle(layer);

      this._layers[stamp(layer)] = layer;
    },
    _addPath: function (layer) {
      var container = layer._container;

      this._container.appendChild(container);

      if (layer.options.interactive) {
        layer.addInteractiveTarget(container);
      }
    },
    _removePath: function (layer) {
      var container = layer._container;
      remove(container);
      layer.removeInteractiveTarget(container);
      delete this._layers[stamp(layer)];
    },
    _updateStyle: function (layer) {
      var stroke = layer._stroke,
          fill = layer._fill,
          options = layer.options,
          container = layer._container;
      container.stroked = !!options.stroke;
      container.filled = !!options.fill;

      if (options.stroke) {
        if (!stroke) {
          stroke = layer._stroke = vmlCreate('stroke');
        }

        container.appendChild(stroke);
        stroke.weight = options.weight + 'px';
        stroke.color = options.color;
        stroke.opacity = options.opacity;

        if (options.dashArray) {
          stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(' ') : options.dashArray.replace(/( *, *)/g, ' ');
        } else {
          stroke.dashStyle = '';
        }

        stroke.endcap = options.lineCap.replace('butt', 'flat');
        stroke.joinstyle = options.lineJoin;
      } else if (stroke) {
        container.removeChild(stroke);
        layer._stroke = null;
      }

      if (options.fill) {
        if (!fill) {
          fill = layer._fill = vmlCreate('fill');
        }

        container.appendChild(fill);
        fill.color = options.fillColor || options.color;
        fill.opacity = options.fillOpacity;
      } else if (fill) {
        container.removeChild(fill);
        layer._fill = null;
      }
    },
    _updateCircle: function (layer) {
      var p = layer._point.round(),
          r = Math.round(layer._radius),
          r2 = Math.round(layer._radiusY || r);

      this._setPath(layer, layer._empty() ? 'M0 0' : 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + 65535 * 360);
    },
    _setPath: function (layer, path) {
      layer._path.v = path;
    },
    _bringToFront: function (layer) {
      toFront(layer._container);
    },
    _bringToBack: function (layer) {
      toBack(layer._container);
    }
  };
  var create$2 = vml ? vmlCreate : svgCreate;
  /*
   * @class SVG
   * @inherits Renderer
   * @aka L.SVG
   *
   * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
   * Inherits `Renderer`.
   *
   * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
   * available in all web browsers, notably Android 2.x and 3.x.
   *
   * Although SVG is not available on IE7 and IE8, these browsers support
   * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
   * (a now deprecated technology), and the SVG renderer will fall back to VML in
   * this case.
   *
   * @example
   *
   * Use SVG by default for all paths in the map:
   *
   * ```js
   * var map = L.map('map', {
   * 	renderer: L.svg()
   * });
   * ```
   *
   * Use a SVG renderer with extra padding for specific vector geometries:
   *
   * ```js
   * var map = L.map('map');
   * var myRenderer = L.svg({ padding: 0.5 });
   * var line = L.polyline( coordinates, { renderer: myRenderer } );
   * var circle = L.circle( center, { renderer: myRenderer } );
   * ```
   */

  var SVG = Renderer.extend({
    getEvents: function () {
      var events = Renderer.prototype.getEvents.call(this);
      events.zoomstart = this._onZoomStart;
      return events;
    },
    _initContainer: function () {
      this._container = create$2('svg'); // makes it possible to click through svg root; we'll reset it back in individual paths

      this._container.setAttribute('pointer-events', 'none');

      this._rootGroup = create$2('g');

      this._container.appendChild(this._rootGroup);
    },
    _destroyContainer: function () {
      remove(this._container);
      off(this._container);
      delete this._container;
      delete this._rootGroup;
      delete this._svgSize;
    },
    _onZoomStart: function () {
      // Drag-then-pinch interactions might mess up the center and zoom.
      // In this case, the easiest way to prevent this is re-do the renderer
      //   bounds and padding when the zooming starts.
      this._update();
    },
    _update: function () {
      if (this._map._animatingZoom && this._bounds) {
        return;
      }

      Renderer.prototype._update.call(this);

      var b = this._bounds,
          size = b.getSize(),
          container = this._container; // set size of svg-container if changed

      if (!this._svgSize || !this._svgSize.equals(size)) {
        this._svgSize = size;
        container.setAttribute('width', size.x);
        container.setAttribute('height', size.y);
      } // movement: update container viewBox so that we don't have to change coordinates of individual layers


      setPosition(container, b.min);
      container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));
      this.fire('update');
    },
    // methods below are called by vector layers implementations
    _initPath: function (layer) {
      var path = layer._path = create$2('path'); // @namespace Path
      // @option className: String = null
      // Custom class name set on an element. Only for SVG renderer.

      if (layer.options.className) {
        addClass(path, layer.options.className);
      }

      if (layer.options.interactive) {
        addClass(path, 'leaflet-interactive');
      }

      this._updateStyle(layer);

      this._layers[stamp(layer)] = layer;
    },
    _addPath: function (layer) {
      if (!this._rootGroup) {
        this._initContainer();
      }

      this._rootGroup.appendChild(layer._path);

      layer.addInteractiveTarget(layer._path);
    },
    _removePath: function (layer) {
      remove(layer._path);
      layer.removeInteractiveTarget(layer._path);
      delete this._layers[stamp(layer)];
    },
    _updatePath: function (layer) {
      layer._project();

      layer._update();
    },
    _updateStyle: function (layer) {
      var path = layer._path,
          options = layer.options;

      if (!path) {
        return;
      }

      if (options.stroke) {
        path.setAttribute('stroke', options.color);
        path.setAttribute('stroke-opacity', options.opacity);
        path.setAttribute('stroke-width', options.weight);
        path.setAttribute('stroke-linecap', options.lineCap);
        path.setAttribute('stroke-linejoin', options.lineJoin);

        if (options.dashArray) {
          path.setAttribute('stroke-dasharray', options.dashArray);
        } else {
          path.removeAttribute('stroke-dasharray');
        }

        if (options.dashOffset) {
          path.setAttribute('stroke-dashoffset', options.dashOffset);
        } else {
          path.removeAttribute('stroke-dashoffset');
        }
      } else {
        path.setAttribute('stroke', 'none');
      }

      if (options.fill) {
        path.setAttribute('fill', options.fillColor || options.color);
        path.setAttribute('fill-opacity', options.fillOpacity);
        path.setAttribute('fill-rule', options.fillRule || 'evenodd');
      } else {
        path.setAttribute('fill', 'none');
      }
    },
    _updatePoly: function (layer, closed) {
      this._setPath(layer, pointsToPath(layer._parts, closed));
    },
    _updateCircle: function (layer) {
      var p = layer._point,
          r = Math.max(Math.round(layer._radius), 1),
          r2 = Math.max(Math.round(layer._radiusY), 1) || r,
          arc = 'a' + r + ',' + r2 + ' 0 1,0 '; // drawing a circle with two half-arcs

      var d = layer._empty() ? 'M0 0' : 'M' + (p.x - r) + ',' + p.y + arc + r * 2 + ',0 ' + arc + -r * 2 + ',0 ';

      this._setPath(layer, d);
    },
    _setPath: function (layer, path) {
      layer._path.setAttribute('d', path);
    },
    // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
    _bringToFront: function (layer) {
      toFront(layer._path);
    },
    _bringToBack: function (layer) {
      toBack(layer._path);
    }
  });

  if (vml) {
    SVG.include(vmlMixin);
  } // @namespace SVG
  // @factory L.svg(options?: Renderer options)
  // Creates a SVG renderer with the given options.


  function svg$1(options) {
    return svg || vml ? new SVG(options) : null;
  }

  Map.include({
    // @namespace Map; @method getRenderer(layer: Path): Renderer
    // Returns the instance of `Renderer` that should be used to render the given
    // `Path`. It will ensure that the `renderer` options of the map and paths
    // are respected, and that the renderers do exist on the map.
    getRenderer: function (layer) {
      // @namespace Path; @option renderer: Renderer
      // Use this specific instance of `Renderer` for this path. Takes
      // precedence over the map's [default renderer](#map-renderer).
      var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

      if (!renderer) {
        renderer = this._renderer = this._createRenderer();
      }

      if (!this.hasLayer(renderer)) {
        this.addLayer(renderer);
      }

      return renderer;
    },
    _getPaneRenderer: function (name) {
      if (name === 'overlayPane' || name === undefined) {
        return false;
      }

      var renderer = this._paneRenderers[name];

      if (renderer === undefined) {
        renderer = this._createRenderer({
          pane: name
        });
        this._paneRenderers[name] = renderer;
      }

      return renderer;
    },
    _createRenderer: function (options) {
      // @namespace Map; @option preferCanvas: Boolean = false
      // Whether `Path`s should be rendered on a `Canvas` renderer.
      // By default, all `Path`s are rendered in a `SVG` renderer.
      return this.options.preferCanvas && canvas$1(options) || svg$1(options);
    }
  });
  /*
   * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
   */

  /*
   * @class Rectangle
   * @aka L.Rectangle
   * @inherits Polygon
   *
   * A class for drawing rectangle overlays on a map. Extends `Polygon`.
   *
   * @example
   *
   * ```js
   * // define rectangle geographical bounds
   * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
   *
   * // create an orange rectangle
   * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
   *
   * // zoom the map to the rectangle bounds
   * map.fitBounds(bounds);
   * ```
   *
   */

  var Rectangle = Polygon.extend({
    initialize: function (latLngBounds, options) {
      Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
    },
    // @method setBounds(latLngBounds: LatLngBounds): this
    // Redraws the rectangle with the passed bounds.
    setBounds: function (latLngBounds) {
      return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
    },
    _boundsToLatLngs: function (latLngBounds) {
      latLngBounds = toLatLngBounds(latLngBounds);
      return [latLngBounds.getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast()];
    }
  }); // @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)

  function rectangle(latLngBounds, options) {
    return new Rectangle(latLngBounds, options);
  }

  SVG.create = create$2;
  SVG.pointsToPath = pointsToPath;
  GeoJSON.geometryToLayer = geometryToLayer;
  GeoJSON.coordsToLatLng = coordsToLatLng;
  GeoJSON.coordsToLatLngs = coordsToLatLngs;
  GeoJSON.latLngToCoords = latLngToCoords;
  GeoJSON.latLngsToCoords = latLngsToCoords;
  GeoJSON.getFeature = getFeature;
  GeoJSON.asFeature = asFeature;
  /*
   * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
   * (zoom to a selected bounding box), enabled by default.
   */
  // @namespace Map
  // @section Interaction Options

  Map.mergeOptions({
    // @option boxZoom: Boolean = true
    // Whether the map can be zoomed to a rectangular area specified by
    // dragging the mouse while pressing the shift key.
    boxZoom: true
  });
  var BoxZoom = Handler.extend({
    initialize: function (map) {
      this._map = map;
      this._container = map._container;
      this._pane = map._panes.overlayPane;
      this._resetStateTimeout = 0;
      map.on('unload', this._destroy, this);
    },
    addHooks: function () {
      on(this._container, 'mousedown', this._onMouseDown, this);
    },
    removeHooks: function () {
      off(this._container, 'mousedown', this._onMouseDown, this);
    },
    moved: function () {
      return this._moved;
    },
    _destroy: function () {
      remove(this._pane);
      delete this._pane;
    },
    _resetState: function () {
      this._resetStateTimeout = 0;
      this._moved = false;
    },
    _clearDeferredResetState: function () {
      if (this._resetStateTimeout !== 0) {
        clearTimeout(this._resetStateTimeout);
        this._resetStateTimeout = 0;
      }
    },
    _onMouseDown: function (e) {
      if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
        return false;
      } // Clear the deferred resetState if it hasn't executed yet, otherwise it
      // will interrupt the interaction and orphan a box element in the container.


      this._clearDeferredResetState();

      this._resetState();

      disableTextSelection();
      disableImageDrag();
      this._startPoint = this._map.mouseEventToContainerPoint(e);
      on(document, {
        contextmenu: stop,
        mousemove: this._onMouseMove,
        mouseup: this._onMouseUp,
        keydown: this._onKeyDown
      }, this);
    },
    _onMouseMove: function (e) {
      if (!this._moved) {
        this._moved = true;
        this._box = create$1('div', 'leaflet-zoom-box', this._container);
        addClass(this._container, 'leaflet-crosshair');

        this._map.fire('boxzoomstart');
      }

      this._point = this._map.mouseEventToContainerPoint(e);
      var bounds = new Bounds(this._point, this._startPoint),
          size = bounds.getSize();
      setPosition(this._box, bounds.min);
      this._box.style.width = size.x + 'px';
      this._box.style.height = size.y + 'px';
    },
    _finish: function () {
      if (this._moved) {
        remove(this._box);
        removeClass(this._container, 'leaflet-crosshair');
      }

      enableTextSelection();
      enableImageDrag();
      off(document, {
        contextmenu: stop,
        mousemove: this._onMouseMove,
        mouseup: this._onMouseUp,
        keydown: this._onKeyDown
      }, this);
    },
    _onMouseUp: function (e) {
      if (e.which !== 1 && e.button !== 1) {
        return;
      }

      this._finish();

      if (!this._moved) {
        return;
      } // Postpone to next JS tick so internal click event handling
      // still see it as "moved".


      this._clearDeferredResetState();

      this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);
      var bounds = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));

      this._map.fitBounds(bounds).fire('boxzoomend', {
        boxZoomBounds: bounds
      });
    },
    _onKeyDown: function (e) {
      if (e.keyCode === 27) {
        this._finish();
      }
    }
  }); // @section Handlers
  // @property boxZoom: Handler
  // Box (shift-drag with mouse) zoom handler.

  Map.addInitHook('addHandler', 'boxZoom', BoxZoom);
  /*
   * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
   */
  // @namespace Map
  // @section Interaction Options

  Map.mergeOptions({
    // @option doubleClickZoom: Boolean|String = true
    // Whether the map can be zoomed in by double clicking on it and
    // zoomed out by double clicking while holding shift. If passed
    // `'center'`, double-click zoom will zoom to the center of the
    //  view regardless of where the mouse was.
    doubleClickZoom: true
  });
  var DoubleClickZoom = Handler.extend({
    addHooks: function () {
      this._map.on('dblclick', this._onDoubleClick, this);
    },
    removeHooks: function () {
      this._map.off('dblclick', this._onDoubleClick, this);
    },
    _onDoubleClick: function (e) {
      var map = this._map,
          oldZoom = map.getZoom(),
          delta = map.options.zoomDelta,
          zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

      if (map.options.doubleClickZoom === 'center') {
        map.setZoom(zoom);
      } else {
        map.setZoomAround(e.containerPoint, zoom);
      }
    }
  }); // @section Handlers
  //
  // Map properties include interaction handlers that allow you to control
  // interaction behavior in runtime, enabling or disabling certain features such
  // as dragging or touch zoom (see `Handler` methods). For example:
  //
  // ```js
  // map.doubleClickZoom.disable();
  // ```
  //
  // @property doubleClickZoom: Handler
  // Double click zoom handler.

  Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);
  /*
   * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
   */
  // @namespace Map
  // @section Interaction Options

  Map.mergeOptions({
    // @option dragging: Boolean = true
    // Whether the map be draggable with mouse/touch or not.
    dragging: true,
    // @section Panning Inertia Options
    // @option inertia: Boolean = *
    // If enabled, panning of the map will have an inertia effect where
    // the map builds momentum while dragging and continues moving in
    // the same direction for some time. Feels especially nice on touch
    // devices. Enabled by default unless running on old Android devices.
    inertia: !android23,
    // @option inertiaDeceleration: Number = 3000
    // The rate with which the inertial movement slows down, in pixels/second².
    inertiaDeceleration: 3400,
    // px/s^2
    // @option inertiaMaxSpeed: Number = Infinity
    // Max speed of the inertial movement, in pixels/second.
    inertiaMaxSpeed: Infinity,
    // px/s
    // @option easeLinearity: Number = 0.2
    easeLinearity: 0.2,
    // TODO refactor, move to CRS
    // @option worldCopyJump: Boolean = false
    // With this option enabled, the map tracks when you pan to another "copy"
    // of the world and seamlessly jumps to the original one so that all overlays
    // like markers and vector layers are still visible.
    worldCopyJump: false,
    // @option maxBoundsViscosity: Number = 0.0
    // If `maxBounds` is set, this option will control how solid the bounds
    // are when dragging the map around. The default value of `0.0` allows the
    // user to drag outside the bounds at normal speed, higher values will
    // slow down map dragging outside bounds, and `1.0` makes the bounds fully
    // solid, preventing the user from dragging outside the bounds.
    maxBoundsViscosity: 0.0
  });
  var Drag = Handler.extend({
    addHooks: function () {
      if (!this._draggable) {
        var map = this._map;
        this._draggable = new Draggable(map._mapPane, map._container);

        this._draggable.on({
          dragstart: this._onDragStart,
          drag: this._onDrag,
          dragend: this._onDragEnd
        }, this);

        this._draggable.on('predrag', this._onPreDragLimit, this);

        if (map.options.worldCopyJump) {
          this._draggable.on('predrag', this._onPreDragWrap, this);

          map.on('zoomend', this._onZoomEnd, this);
          map.whenReady(this._onZoomEnd, this);
        }
      }

      addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');

      this._draggable.enable();

      this._positions = [];
      this._times = [];
    },
    removeHooks: function () {
      removeClass(this._map._container, 'leaflet-grab');
      removeClass(this._map._container, 'leaflet-touch-drag');

      this._draggable.disable();
    },
    moved: function () {
      return this._draggable && this._draggable._moved;
    },
    moving: function () {
      return this._draggable && this._draggable._moving;
    },
    _onDragStart: function () {
      var map = this._map;

      map._stop();

      if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
        var bounds = toLatLngBounds(this._map.options.maxBounds);
        this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize()));
        this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
      } else {
        this._offsetLimit = null;
      }

      map.fire('movestart').fire('dragstart');

      if (map.options.inertia) {
        this._positions = [];
        this._times = [];
      }
    },
    _onDrag: function (e) {
      if (this._map.options.inertia) {
        var time = this._lastTime = +new Date(),
            pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

        this._positions.push(pos);

        this._times.push(time);

        this._prunePositions(time);
      }

      this._map.fire('move', e).fire('drag', e);
    },
    _prunePositions: function (time) {
      while (this._positions.length > 1 && time - this._times[0] > 50) {
        this._positions.shift();

        this._times.shift();
      }
    },
    _onZoomEnd: function () {
      var pxCenter = this._map.getSize().divideBy(2),
          pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

      this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
      this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
    },
    _viscousLimit: function (value, threshold) {
      return value - (value - threshold) * this._viscosity;
    },
    _onPreDragLimit: function () {
      if (!this._viscosity || !this._offsetLimit) {
        return;
      }

      var offset = this._draggable._newPos.subtract(this._draggable._startPos);

      var limit = this._offsetLimit;

      if (offset.x < limit.min.x) {
        offset.x = this._viscousLimit(offset.x, limit.min.x);
      }

      if (offset.y < limit.min.y) {
        offset.y = this._viscousLimit(offset.y, limit.min.y);
      }

      if (offset.x > limit.max.x) {
        offset.x = this._viscousLimit(offset.x, limit.max.x);
      }

      if (offset.y > limit.max.y) {
        offset.y = this._viscousLimit(offset.y, limit.max.y);
      }

      this._draggable._newPos = this._draggable._startPos.add(offset);
    },
    _onPreDragWrap: function () {
      // TODO refactor to be able to adjust map pane position after zoom
      var worldWidth = this._worldWidth,
          halfWidth = Math.round(worldWidth / 2),
          dx = this._initialWorldOffset,
          x = this._draggable._newPos.x,
          newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
          newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
          newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
      this._draggable._absPos = this._draggable._newPos.clone();
      this._draggable._newPos.x = newX;
    },
    _onDragEnd: function (e) {
      var map = this._map,
          options = map.options,
          noInertia = !options.inertia || this._times.length < 2;
      map.fire('dragend', e);

      if (noInertia) {
        map.fire('moveend');
      } else {
        this._prunePositions(+new Date());

        var direction = this._lastPos.subtract(this._positions[0]),
            duration = (this._lastTime - this._times[0]) / 1000,
            ease = options.easeLinearity,
            speedVector = direction.multiplyBy(ease / duration),
            speed = speedVector.distanceTo([0, 0]),
            limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
            limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),
            decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
            offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

        if (!offset.x && !offset.y) {
          map.fire('moveend');
        } else {
          offset = map._limitOffset(offset, map.options.maxBounds);
          requestAnimFrame(function () {
            map.panBy(offset, {
              duration: decelerationDuration,
              easeLinearity: ease,
              noMoveStart: true,
              animate: true
            });
          });
        }
      }
    }
  }); // @section Handlers
  // @property dragging: Handler
  // Map dragging handler (by both mouse and touch).

  Map.addInitHook('addHandler', 'dragging', Drag);
  /*
   * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
   */
  // @namespace Map
  // @section Keyboard Navigation Options

  Map.mergeOptions({
    // @option keyboard: Boolean = true
    // Makes the map focusable and allows users to navigate the map with keyboard
    // arrows and `+`/`-` keys.
    keyboard: true,
    // @option keyboardPanDelta: Number = 80
    // Amount of pixels to pan when pressing an arrow key.
    keyboardPanDelta: 80
  });
  var Keyboard = Handler.extend({
    keyCodes: {
      left: [37],
      right: [39],
      down: [40],
      up: [38],
      zoomIn: [187, 107, 61, 171],
      zoomOut: [189, 109, 54, 173]
    },
    initialize: function (map) {
      this._map = map;

      this._setPanDelta(map.options.keyboardPanDelta);

      this._setZoomDelta(map.options.zoomDelta);
    },
    addHooks: function () {
      var container = this._map._container; // make the container focusable by tabbing

      if (container.tabIndex <= 0) {
        container.tabIndex = '0';
      }

      on(container, {
        focus: this._onFocus,
        blur: this._onBlur,
        mousedown: this._onMouseDown
      }, this);

      this._map.on({
        focus: this._addHooks,
        blur: this._removeHooks
      }, this);
    },
    removeHooks: function () {
      this._removeHooks();

      off(this._map._container, {
        focus: this._onFocus,
        blur: this._onBlur,
        mousedown: this._onMouseDown
      }, this);

      this._map.off({
        focus: this._addHooks,
        blur: this._removeHooks
      }, this);
    },
    _onMouseDown: function () {
      if (this._focused) {
        return;
      }

      var body = document.body,
          docEl = document.documentElement,
          top = body.scrollTop || docEl.scrollTop,
          left = body.scrollLeft || docEl.scrollLeft;

      this._map._container.focus();

      window.scrollTo(left, top);
    },
    _onFocus: function () {
      this._focused = true;

      this._map.fire('focus');
    },
    _onBlur: function () {
      this._focused = false;

      this._map.fire('blur');
    },
    _setPanDelta: function (panDelta) {
      var keys = this._panKeys = {},
          codes = this.keyCodes,
          i,
          len;

      for (i = 0, len = codes.left.length; i < len; i++) {
        keys[codes.left[i]] = [-1 * panDelta, 0];
      }

      for (i = 0, len = codes.right.length; i < len; i++) {
        keys[codes.right[i]] = [panDelta, 0];
      }

      for (i = 0, len = codes.down.length; i < len; i++) {
        keys[codes.down[i]] = [0, panDelta];
      }

      for (i = 0, len = codes.up.length; i < len; i++) {
        keys[codes.up[i]] = [0, -1 * panDelta];
      }
    },
    _setZoomDelta: function (zoomDelta) {
      var keys = this._zoomKeys = {},
          codes = this.keyCodes,
          i,
          len;

      for (i = 0, len = codes.zoomIn.length; i < len; i++) {
        keys[codes.zoomIn[i]] = zoomDelta;
      }

      for (i = 0, len = codes.zoomOut.length; i < len; i++) {
        keys[codes.zoomOut[i]] = -zoomDelta;
      }
    },
    _addHooks: function () {
      on(document, 'keydown', this._onKeyDown, this);
    },
    _removeHooks: function () {
      off(document, 'keydown', this._onKeyDown, this);
    },
    _onKeyDown: function (e) {
      if (e.altKey || e.ctrlKey || e.metaKey) {
        return;
      }

      var key = e.keyCode,
          map = this._map,
          offset;

      if (key in this._panKeys) {
        if (!map._panAnim || !map._panAnim._inProgress) {
          offset = this._panKeys[key];

          if (e.shiftKey) {
            offset = toPoint(offset).multiplyBy(3);
          }

          map.panBy(offset);

          if (map.options.maxBounds) {
            map.panInsideBounds(map.options.maxBounds);
          }
        }
      } else if (key in this._zoomKeys) {
        map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
      } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
        map.closePopup();
      } else {
        return;
      }

      stop(e);
    }
  }); // @section Handlers
  // @section Handlers
  // @property keyboard: Handler
  // Keyboard navigation handler.

  Map.addInitHook('addHandler', 'keyboard', Keyboard);
  /*
   * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
   */
  // @namespace Map
  // @section Interaction Options

  Map.mergeOptions({
    // @section Mouse wheel options
    // @option scrollWheelZoom: Boolean|String = true
    // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
    // it will zoom to the center of the view regardless of where the mouse was.
    scrollWheelZoom: true,
    // @option wheelDebounceTime: Number = 40
    // Limits the rate at which a wheel can fire (in milliseconds). By default
    // user can't zoom via wheel more often than once per 40 ms.
    wheelDebounceTime: 40,
    // @option wheelPxPerZoomLevel: Number = 60
    // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
    // mean a change of one full zoom level. Smaller values will make wheel-zooming
    // faster (and vice versa).
    wheelPxPerZoomLevel: 60
  });
  var ScrollWheelZoom = Handler.extend({
    addHooks: function () {
      on(this._map._container, 'wheel', this._onWheelScroll, this);
      this._delta = 0;
    },
    removeHooks: function () {
      off(this._map._container, 'wheel', this._onWheelScroll, this);
    },
    _onWheelScroll: function (e) {
      var delta = getWheelDelta(e);
      var debounce = this._map.options.wheelDebounceTime;
      this._delta += delta;
      this._lastMousePos = this._map.mouseEventToContainerPoint(e);

      if (!this._startTime) {
        this._startTime = +new Date();
      }

      var left = Math.max(debounce - (+new Date() - this._startTime), 0);
      clearTimeout(this._timer);
      this._timer = setTimeout(bind(this._performZoom, this), left);
      stop(e);
    },
    _performZoom: function () {
      var map = this._map,
          zoom = map.getZoom(),
          snap = this._map.options.zoomSnap || 0;

      map._stop(); // stop panning and fly animations if any
      // map the delta with a sigmoid function to -4..4 range leaning on -1..1


      var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
          d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
          d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
          delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;
      this._delta = 0;
      this._startTime = null;

      if (!delta) {
        return;
      }

      if (map.options.scrollWheelZoom === 'center') {
        map.setZoom(zoom + delta);
      } else {
        map.setZoomAround(this._lastMousePos, zoom + delta);
      }
    }
  }); // @section Handlers
  // @property scrollWheelZoom: Handler
  // Scroll wheel zoom handler.

  Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);
  /*
   * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
   */
  // @namespace Map
  // @section Interaction Options

  Map.mergeOptions({
    // @section Touch interaction options
    // @option tap: Boolean = true
    // Enables mobile hacks for supporting instant taps (fixing 200ms click
    // delay on iOS/Android) and touch holds (fired as `contextmenu` events).
    tap: true,
    // @option tapTolerance: Number = 15
    // The max number of pixels a user can shift his finger during touch
    // for it to be considered a valid tap.
    tapTolerance: 15
  });
  var Tap = Handler.extend({
    addHooks: function () {
      on(this._map._container, 'touchstart', this._onDown, this);
    },
    removeHooks: function () {
      off(this._map._container, 'touchstart', this._onDown, this);
    },
    _onDown: function (e) {
      if (!e.touches) {
        return;
      }

      preventDefault(e);
      this._fireClick = true; // don't simulate click or track longpress if more than 1 touch

      if (e.touches.length > 1) {
        this._fireClick = false;
        clearTimeout(this._holdTimeout);
        return;
      }

      var first = e.touches[0],
          el = first.target;
      this._startPos = this._newPos = new Point(first.clientX, first.clientY); // if touching a link, highlight it

      if (el.tagName && el.tagName.toLowerCase() === 'a') {
        addClass(el, 'leaflet-active');
      } // simulate long hold but setting a timeout


      this._holdTimeout = setTimeout(bind(function () {
        if (this._isTapValid()) {
          this._fireClick = false;

          this._onUp();

          this._simulateEvent('contextmenu', first);
        }
      }, this), 1000);

      this._simulateEvent('mousedown', first);

      on(document, {
        touchmove: this._onMove,
        touchend: this._onUp
      }, this);
    },
    _onUp: function (e) {
      clearTimeout(this._holdTimeout);
      off(document, {
        touchmove: this._onMove,
        touchend: this._onUp
      }, this);

      if (this._fireClick && e && e.changedTouches) {
        var first = e.changedTouches[0],
            el = first.target;

        if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
          removeClass(el, 'leaflet-active');
        }

        this._simulateEvent('mouseup', first); // simulate click if the touch didn't move too much


        if (this._isTapValid()) {
          this._simulateEvent('click', first);
        }
      }
    },
    _isTapValid: function () {
      return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
    },
    _onMove: function (e) {
      var first = e.touches[0];
      this._newPos = new Point(first.clientX, first.clientY);

      this._simulateEvent('mousemove', first);
    },
    _simulateEvent: function (type, e) {
      var simulatedEvent = document.createEvent('MouseEvents');
      simulatedEvent._simulated = true;
      e.target._simulatedClick = true;
      simulatedEvent.initMouseEvent(type, true, true, window, 1, e.screenX, e.screenY, e.clientX, e.clientY, false, false, false, false, 0, null);
      e.target.dispatchEvent(simulatedEvent);
    }
  }); // @section Handlers
  // @property tap: Handler
  // Mobile touch hacks (quick tap and touch hold) handler.

  if (touch && (!pointer || safari)) {
    Map.addInitHook('addHandler', 'tap', Tap);
  }
  /*
   * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
   */
  // @namespace Map
  // @section Interaction Options


  Map.mergeOptions({
    // @section Touch interaction options
    // @option touchZoom: Boolean|String = *
    // Whether the map can be zoomed by touch-dragging with two fingers. If
    // passed `'center'`, it will zoom to the center of the view regardless of
    // where the touch events (fingers) were. Enabled for touch-capable web
    // browsers except for old Androids.
    touchZoom: touch && !android23,
    // @option bounceAtZoomLimits: Boolean = true
    // Set it to false if you don't want the map to zoom beyond min/max zoom
    // and then bounce back when pinch-zooming.
    bounceAtZoomLimits: true
  });
  var TouchZoom = Handler.extend({
    addHooks: function () {
      addClass(this._map._container, 'leaflet-touch-zoom');
      on(this._map._container, 'touchstart', this._onTouchStart, this);
    },
    removeHooks: function () {
      removeClass(this._map._container, 'leaflet-touch-zoom');
      off(this._map._container, 'touchstart', this._onTouchStart, this);
    },
    _onTouchStart: function (e) {
      var map = this._map;

      if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {
        return;
      }

      var p1 = map.mouseEventToContainerPoint(e.touches[0]),
          p2 = map.mouseEventToContainerPoint(e.touches[1]);
      this._centerPoint = map.getSize()._divideBy(2);
      this._startLatLng = map.containerPointToLatLng(this._centerPoint);

      if (map.options.touchZoom !== 'center') {
        this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
      }

      this._startDist = p1.distanceTo(p2);
      this._startZoom = map.getZoom();
      this._moved = false;
      this._zooming = true;

      map._stop();

      on(document, 'touchmove', this._onTouchMove, this);
      on(document, 'touchend', this._onTouchEnd, this);
      preventDefault(e);
    },
    _onTouchMove: function (e) {
      if (!e.touches || e.touches.length !== 2 || !this._zooming) {
        return;
      }

      var map = this._map,
          p1 = map.mouseEventToContainerPoint(e.touches[0]),
          p2 = map.mouseEventToContainerPoint(e.touches[1]),
          scale = p1.distanceTo(p2) / this._startDist;

      this._zoom = map.getScaleZoom(scale, this._startZoom);

      if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1)) {
        this._zoom = map._limitZoom(this._zoom);
      }

      if (map.options.touchZoom === 'center') {
        this._center = this._startLatLng;

        if (scale === 1) {
          return;
        }
      } else {
        // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
        var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);

        if (scale === 1 && delta.x === 0 && delta.y === 0) {
          return;
        }

        this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
      }

      if (!this._moved) {
        map._moveStart(true, false);

        this._moved = true;
      }

      cancelAnimFrame(this._animRequest);
      var moveFn = bind(map._move, map, this._center, this._zoom, {
        pinch: true,
        round: false
      });
      this._animRequest = requestAnimFrame(moveFn, this, true);
      preventDefault(e);
    },
    _onTouchEnd: function () {
      if (!this._moved || !this._zooming) {
        this._zooming = false;
        return;
      }

      this._zooming = false;
      cancelAnimFrame(this._animRequest);
      off(document, 'touchmove', this._onTouchMove, this);
      off(document, 'touchend', this._onTouchEnd, this); // Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.

      if (this._map.options.zoomAnimation) {
        this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
      } else {
        this._map._resetView(this._center, this._map._limitZoom(this._zoom));
      }
    }
  }); // @section Handlers
  // @property touchZoom: Handler
  // Touch zoom handler.

  Map.addInitHook('addHandler', 'touchZoom', TouchZoom);
  Map.BoxZoom = BoxZoom;
  Map.DoubleClickZoom = DoubleClickZoom;
  Map.Drag = Drag;
  Map.Keyboard = Keyboard;
  Map.ScrollWheelZoom = ScrollWheelZoom;
  Map.Tap = Tap;
  Map.TouchZoom = TouchZoom;
  exports.version = version;
  exports.Control = Control;
  exports.control = control;
  exports.Browser = Browser;
  exports.Evented = Evented;
  exports.Mixin = Mixin;
  exports.Util = Util;
  exports.Class = Class;
  exports.Handler = Handler;
  exports.extend = extend;
  exports.bind = bind;
  exports.stamp = stamp;
  exports.setOptions = setOptions;
  exports.DomEvent = DomEvent;
  exports.DomUtil = DomUtil;
  exports.PosAnimation = PosAnimation;
  exports.Draggable = Draggable;
  exports.LineUtil = LineUtil;
  exports.PolyUtil = PolyUtil;
  exports.Point = Point;
  exports.point = toPoint;
  exports.Bounds = Bounds;
  exports.bounds = toBounds;
  exports.Transformation = Transformation;
  exports.transformation = toTransformation;
  exports.Projection = index;
  exports.LatLng = LatLng;
  exports.latLng = toLatLng;
  exports.LatLngBounds = LatLngBounds;
  exports.latLngBounds = toLatLngBounds;
  exports.CRS = CRS;
  exports.GeoJSON = GeoJSON;
  exports.geoJSON = geoJSON;
  exports.geoJson = geoJson;
  exports.Layer = Layer;
  exports.LayerGroup = LayerGroup;
  exports.layerGroup = layerGroup;
  exports.FeatureGroup = FeatureGroup;
  exports.featureGroup = featureGroup;
  exports.ImageOverlay = ImageOverlay;
  exports.imageOverlay = imageOverlay;
  exports.VideoOverlay = VideoOverlay;
  exports.videoOverlay = videoOverlay;
  exports.SVGOverlay = SVGOverlay;
  exports.svgOverlay = svgOverlay;
  exports.DivOverlay = DivOverlay;
  exports.Popup = Popup;
  exports.popup = popup;
  exports.Tooltip = Tooltip;
  exports.tooltip = tooltip;
  exports.Icon = Icon;
  exports.icon = icon;
  exports.DivIcon = DivIcon;
  exports.divIcon = divIcon;
  exports.Marker = Marker;
  exports.marker = marker;
  exports.TileLayer = TileLayer;
  exports.tileLayer = tileLayer;
  exports.GridLayer = GridLayer;
  exports.gridLayer = gridLayer;
  exports.SVG = SVG;
  exports.svg = svg$1;
  exports.Renderer = Renderer;
  exports.Canvas = Canvas;
  exports.canvas = canvas$1;
  exports.Path = Path;
  exports.CircleMarker = CircleMarker;
  exports.circleMarker = circleMarker;
  exports.Circle = Circle;
  exports.circle = circle;
  exports.Polyline = Polyline;
  exports.polyline = polyline;
  exports.Polygon = Polygon;
  exports.polygon = polygon;
  exports.Rectangle = Rectangle;
  exports.rectangle = rectangle;
  exports.Map = Map;
  exports.map = createMap;
  var oldL = window.L;

  exports.noConflict = function () {
    window.L = oldL;
    return this;
  }; // Always export us to window global (see #2364)


  window.L = exports;
});

},{}],30:[function(require,module,exports){
function lerp(v0, v1, t) {
    return v0*(1-t)+v1*t
}
module.exports = lerp
},{}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function BinarySearchIndex(values) {
  this.values = [].concat(values || []);
}

BinarySearchIndex.prototype.query = function (value) {
  var index = this.getIndex(value);
  return this.values[index];
};

BinarySearchIndex.prototype.getIndex = function getIndex(value) {
  if (this.dirty) {
    this.sort();
  }

  var minIndex = 0;
  var maxIndex = this.values.length - 1;
  var currentIndex;
  var currentElement;

  while (minIndex <= maxIndex) {
    currentIndex = (minIndex + maxIndex) / 2 | 0;
    currentElement = this.values[Math.round(currentIndex)];

    if (+currentElement.value < +value) {
      minIndex = currentIndex + 1;
    } else if (+currentElement.value > +value) {
      maxIndex = currentIndex - 1;
    } else {
      return currentIndex;
    }
  }

  return Math.abs(~maxIndex);
};

BinarySearchIndex.prototype.between = function between(start, end) {
  var startIndex = this.getIndex(start);
  var endIndex = this.getIndex(end);

  if (startIndex === 0 && endIndex === 0) {
    return [];
  }

  while (this.values[startIndex - 1] && this.values[startIndex - 1].value === start) {
    startIndex--;
  }

  while (this.values[endIndex + 1] && this.values[endIndex + 1].value === end) {
    endIndex++;
  }

  if (this.values[endIndex] && this.values[endIndex].value === end && this.values[endIndex + 1]) {
    endIndex++;
  }

  return this.values.slice(startIndex, endIndex);
};

BinarySearchIndex.prototype.insert = function insert(item) {
  this.values.splice(this.getIndex(item.value), 0, item);
  return this;
};

BinarySearchIndex.prototype.bulkAdd = function bulkAdd(items, sort) {
  this.values = this.values.concat([].concat(items || []));

  if (sort) {
    this.sort();
  } else {
    this.dirty = true;
  }

  return this;
};

BinarySearchIndex.prototype.sort = function sort() {
  this.values.sort(function (a, b) {
    return +b.value - +a.value;
  }).reverse();
  this.dirty = false;
  return this;
};

var _default = BinarySearchIndex;
exports.default = _default;

},{}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _visNetwork = require("./vis-network");

Object.keys(_visNetwork).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _visNetwork[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _visNetwork[key];
    }
  });
});

},{"./vis-network":33}],33:[function(require,module,exports){
(function (global){(function (){
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.Network=Network;exports.parseGephiNetwork=parseGephi;exports.parseDOTNetwork=exports.networkOptions=exports.networkGephiParser=exports.networkDOTParser=exports.data=exports.Queue=exports.NetworkImages=exports.DataView=exports.DataSet=void 0;/**
 * vis-network
 * https://visjs.github.io/vis-network/
 *
 * A dynamic, browser-based visualization library.
 *
 * @version 9.0.5
 * @date    2021-07-24T16:11:14.383Z
 *
 * @copyright (c) 2011-2017 Almende B.V, http://almende.com
 * @copyright (c) 2017-2019 visjs contributors, https://github.com/visjs
 *
 * @license
 * vis.js is dual licensed under both
 *
 *   1. The Apache 2.0 License
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *   and
 *
 *   2. The MIT License
 *      http://opensource.org/licenses/MIT
 *
 * vis.js may be distributed under either license.
 */var commonjsGlobal=typeof globalThis!=='undefined'?globalThis:typeof window!=='undefined'?window:typeof global!=='undefined'?global:typeof self!=='undefined'?self:{};function createCommonjsModule(fn){var module={exports:{}};return fn(module,module.exports),module.exports;}var check=function(it){return it&&it.Math==Math&&it;};// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global$1=// eslint-disable-next-line es/no-global-this -- safe
check(typeof globalThis=='object'&&globalThis)||check(typeof window=='object'&&window)||// eslint-disable-next-line no-restricted-globals -- safe
check(typeof self=='object'&&self)||check(typeof commonjsGlobal=='object'&&commonjsGlobal)||// eslint-disable-next-line no-new-func -- fallback
function(){return this;}()||Function('return this')();var fails=function(exec){try{return!!exec();}catch(error){return true;}};var descriptors=!fails(function(){// eslint-disable-next-line es/no-object-defineproperty -- required for testing
return Object.defineProperty({},1,{get:function(){return 7;}})[1]!=7;});var $propertyIsEnumerable$1={}.propertyIsEnumerable;// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor$5=Object.getOwnPropertyDescriptor;// Nashorn ~ JDK8 bug
var NASHORN_BUG=getOwnPropertyDescriptor$5&&!$propertyIsEnumerable$1.call({1:2},1);// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
var f$6=NASHORN_BUG?function propertyIsEnumerable(V){var descriptor=getOwnPropertyDescriptor$5(this,V);return!!descriptor&&descriptor.enumerable;}:$propertyIsEnumerable$1;var objectPropertyIsEnumerable={f:f$6};var createPropertyDescriptor=function(bitmap,value){return{enumerable:!(bitmap&1),configurable:!(bitmap&2),writable:!(bitmap&4),value:value};};var toString$1={}.toString;var classofRaw=function(it){return toString$1.call(it).slice(8,-1);};var split=''.split;// fallback for non-array-like ES3 and non-enumerable old V8 strings
var indexedObject=fails(function(){// throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
// eslint-disable-next-line no-prototype-builtins -- safe
return!Object('z').propertyIsEnumerable(0);})?function(it){return classofRaw(it)=='String'?split.call(it,''):Object(it);}:Object;// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
var requireObjectCoercible=function(it){if(it==undefined)throw TypeError("Can't call method on "+it);return it;};var toIndexedObject=function(it){return indexedObject(requireObjectCoercible(it));};var isObject$1=function(it){return typeof it==='object'?it!==null:typeof it==='function';};// https://tc39.es/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var toPrimitive=function(input,PREFERRED_STRING){if(!isObject$1(input))return input;var fn,val;if(PREFERRED_STRING&&typeof(fn=input.toString)=='function'&&!isObject$1(val=fn.call(input)))return val;if(typeof(fn=input.valueOf)=='function'&&!isObject$1(val=fn.call(input)))return val;if(!PREFERRED_STRING&&typeof(fn=input.toString)=='function'&&!isObject$1(val=fn.call(input)))return val;throw TypeError("Can't convert object to primitive value");};// https://tc39.es/ecma262/#sec-toobject
var toObject=function(argument){return Object(requireObjectCoercible(argument));};var hasOwnProperty={}.hasOwnProperty;var has$1=Object.hasOwn||function hasOwn(it,key){return hasOwnProperty.call(toObject(it),key);};var document$1=global$1.document;// typeof document.createElement is 'object' in old IE
var EXISTS=isObject$1(document$1)&&isObject$1(document$1.createElement);var documentCreateElement=function(it){return EXISTS?document$1.createElement(it):{};};var ie8DomDefine=!descriptors&&!fails(function(){// eslint-disable-next-line es/no-object-defineproperty -- requied for testing
return Object.defineProperty(documentCreateElement('div'),'a',{get:function(){return 7;}}).a!=7;});var $getOwnPropertyDescriptor$1=Object.getOwnPropertyDescriptor;// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
var f$5=descriptors?$getOwnPropertyDescriptor$1:function getOwnPropertyDescriptor(O,P){O=toIndexedObject(O);P=toPrimitive(P,true);if(ie8DomDefine)try{return $getOwnPropertyDescriptor$1(O,P);}catch(error){/* empty */}if(has$1(O,P))return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O,P),O[P]);};var objectGetOwnPropertyDescriptor={f:f$5};var replacement=/#|\.prototype\./;var isForced=function(feature,detection){var value=data[normalize(feature)];return value==POLYFILL?true:value==NATIVE?false:typeof detection=='function'?fails(detection):!!detection;};var normalize=isForced.normalize=function(string){return String(string).replace(replacement,'.').toLowerCase();};var data=isForced.data={};var NATIVE=isForced.NATIVE='N';var POLYFILL=isForced.POLYFILL='P';var isForced_1=isForced;var path={};var aFunction$1=function(it){if(typeof it!='function'){throw TypeError(String(it)+' is not a function');}return it;};var functionBindContext=function(fn,that,length){aFunction$1(fn);if(that===undefined)return fn;switch(length){case 0:return function(){return fn.call(that);};case 1:return function(a){return fn.call(that,a);};case 2:return function(a,b){return fn.call(that,a,b);};case 3:return function(a,b,c){return fn.call(that,a,b,c);};}return function(){return fn.apply(that,arguments);};};var anObject=function(it){if(!isObject$1(it)){throw TypeError(String(it)+' is not an object');}return it;};var $defineProperty$1=Object.defineProperty;// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
var f$4=descriptors?$defineProperty$1:function defineProperty(O,P,Attributes){anObject(O);P=toPrimitive(P,true);anObject(Attributes);if(ie8DomDefine)try{return $defineProperty$1(O,P,Attributes);}catch(error){/* empty */}if('get'in Attributes||'set'in Attributes)throw TypeError('Accessors not supported');if('value'in Attributes)O[P]=Attributes.value;return O;};var objectDefineProperty={f:f$4};var createNonEnumerableProperty=descriptors?function(object,key,value){return objectDefineProperty.f(object,key,createPropertyDescriptor(1,value));}:function(object,key,value){object[key]=value;return object;};var getOwnPropertyDescriptor$4=objectGetOwnPropertyDescriptor.f;var wrapConstructor=function(NativeConstructor){var Wrapper=function(a,b,c){if(this instanceof NativeConstructor){switch(arguments.length){case 0:return new NativeConstructor();case 1:return new NativeConstructor(a);case 2:return new NativeConstructor(a,b);}return new NativeConstructor(a,b,c);}return NativeConstructor.apply(this,arguments);};Wrapper.prototype=NativeConstructor.prototype;return Wrapper;};/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/var _export=function(options,source){var TARGET=options.target;var GLOBAL=options.global;var STATIC=options.stat;var PROTO=options.proto;var nativeSource=GLOBAL?global$1:STATIC?global$1[TARGET]:(global$1[TARGET]||{}).prototype;var target=GLOBAL?path:path[TARGET]||(path[TARGET]={});var targetPrototype=target.prototype;var FORCED,USE_NATIVE,VIRTUAL_PROTOTYPE;var key,sourceProperty,targetProperty,nativeProperty,resultProperty,descriptor;for(key in source){FORCED=isForced_1(GLOBAL?key:TARGET+(STATIC?'.':'#')+key,options.forced);// contains in native
USE_NATIVE=!FORCED&&nativeSource&&has$1(nativeSource,key);targetProperty=target[key];if(USE_NATIVE)if(options.noTargetGet){descriptor=getOwnPropertyDescriptor$4(nativeSource,key);nativeProperty=descriptor&&descriptor.value;}else nativeProperty=nativeSource[key];// export native or implementation
sourceProperty=USE_NATIVE&&nativeProperty?nativeProperty:source[key];if(USE_NATIVE&&typeof targetProperty===typeof sourceProperty)continue;// bind timers to global for call from export context
if(options.bind&&USE_NATIVE)resultProperty=functionBindContext(sourceProperty,global$1);// wrap global constructors for prevent changs in this version
else if(options.wrap&&USE_NATIVE)resultProperty=wrapConstructor(sourceProperty);// make static versions for prototype methods
else if(PROTO&&typeof sourceProperty=='function')resultProperty=functionBindContext(Function.call,sourceProperty);// default case
else resultProperty=sourceProperty;// add a flag to not completely full polyfills
if(options.sham||sourceProperty&&sourceProperty.sham||targetProperty&&targetProperty.sham){createNonEnumerableProperty(resultProperty,'sham',true);}target[key]=resultProperty;if(PROTO){VIRTUAL_PROTOTYPE=TARGET+'Prototype';if(!has$1(path,VIRTUAL_PROTOTYPE)){createNonEnumerableProperty(path,VIRTUAL_PROTOTYPE,{});}// export virtual prototype methods
path[VIRTUAL_PROTOTYPE][key]=sourceProperty;// export real prototype methods
if(options.real&&targetPrototype&&!targetPrototype[key]){createNonEnumerableProperty(targetPrototype,key,sourceProperty);}}}};var ceil=Math.ceil;var floor$1=Math.floor;// `ToInteger` abstract operation
// https://tc39.es/ecma262/#sec-tointeger
var toInteger=function(argument){return isNaN(argument=+argument)?0:(argument>0?floor$1:ceil)(argument);};var min$2=Math.min;// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
var toLength=function(argument){return argument>0?min$2(toInteger(argument),0x1FFFFFFFFFFFFF):0;// 2 ** 53 - 1 == 9007199254740991
};var max$2=Math.max;var min$1=Math.min;// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
var toAbsoluteIndex=function(index,length){var integer=toInteger(index);return integer<0?max$2(integer+length,0):min$1(integer,length);};var createMethod$5=function(IS_INCLUDES){return function($this,el,fromIndex){var O=toIndexedObject($this);var length=toLength(O.length);var index=toAbsoluteIndex(fromIndex,length);var value;// Array#includes uses SameValueZero equality algorithm
// eslint-disable-next-line no-self-compare -- NaN check
if(IS_INCLUDES&&el!=el)while(length>index){value=O[index++];// eslint-disable-next-line no-self-compare -- NaN check
if(value!=value)return true;// Array#indexOf ignores holes, Array#includes - not
}else for(;length>index;index++){if((IS_INCLUDES||index in O)&&O[index]===el)return IS_INCLUDES||index||0;}return!IS_INCLUDES&&-1;};};var arrayIncludes={// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
includes:createMethod$5(true),// `Array.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-array.prototype.indexof
indexOf:createMethod$5(false)};var hiddenKeys$1={};var indexOf$3=arrayIncludes.indexOf;var objectKeysInternal=function(object,names){var O=toIndexedObject(object);var i=0;var result=[];var key;for(key in O)!has$1(hiddenKeys$1,key)&&has$1(O,key)&&result.push(key);// Don't enum bug & hidden keys
while(names.length>i)if(has$1(O,key=names[i++])){~indexOf$3(result,key)||result.push(key);}return result;};// IE8- don't enum bug keys
var enumBugKeys=['constructor','hasOwnProperty','isPrototypeOf','propertyIsEnumerable','toLocaleString','toString','valueOf'];// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
var objectKeys=Object.keys||function keys(O){return objectKeysInternal(O,enumBugKeys);};// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
var f$3=Object.getOwnPropertySymbols;var objectGetOwnPropertySymbols={f:f$3};var $assign=Object.assign;// eslint-disable-next-line es/no-object-defineproperty -- required for testing
var defineProperty$8=Object.defineProperty;// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
var objectAssign=!$assign||fails(function(){// should have correct order of operations (Edge bug)
if(descriptors&&$assign({b:1},$assign(defineProperty$8({},'a',{enumerable:true,get:function(){defineProperty$8(this,'b',{value:3,enumerable:false});}}),{b:2})).b!==1)return true;// should work with symbols and should have deterministic property order (V8 bug)
var A={};var B={};// eslint-disable-next-line es/no-symbol -- safe
var symbol=Symbol();var alphabet='abcdefghijklmnopqrst';A[symbol]=7;alphabet.split('').forEach(function(chr){B[chr]=chr;});return $assign({},A)[symbol]!=7||objectKeys($assign({},B)).join('')!=alphabet;})?function assign(target,source){// eslint-disable-line no-unused-vars -- required for `.length`
var T=toObject(target);var argumentsLength=arguments.length;var index=1;var getOwnPropertySymbols=objectGetOwnPropertySymbols.f;var propertyIsEnumerable=objectPropertyIsEnumerable.f;while(argumentsLength>index){var S=indexedObject(arguments[index++]);var keys=getOwnPropertySymbols?objectKeys(S).concat(getOwnPropertySymbols(S)):objectKeys(S);var length=keys.length;var j=0;var key;while(length>j){key=keys[j++];if(!descriptors||propertyIsEnumerable.call(S,key))T[key]=S[key];}}return T;}:$assign;// https://tc39.es/ecma262/#sec-object.assign
// eslint-disable-next-line es/no-object-assign -- required for testing
_export({target:'Object',stat:true,forced:Object.assign!==objectAssign},{assign:objectAssign});var assign$4=path.Object.assign;var assign$3=assign$4;var assign$2=assign$3;var slice$6=[].slice;var factories={};var construct$3=function(C,argsLength,args){if(!(argsLength in factories)){for(var list=[],i=0;i<argsLength;i++)list[i]='a['+i+']';// eslint-disable-next-line no-new-func -- we have no proper alternatives, IE8- only
factories[argsLength]=Function('C,a','return new C('+list.join(',')+')');}return factories[argsLength](C,args);};// `Function.prototype.bind` method implementation
// https://tc39.es/ecma262/#sec-function.prototype.bind
var functionBind=Function.bind||function bind(that/* , ...args */){var fn=aFunction$1(this);var partArgs=slice$6.call(arguments,1);var boundFunction=function bound(){var args=partArgs.concat(slice$6.call(arguments));return this instanceof boundFunction?construct$3(fn,args.length,args):fn.apply(that,args);};if(isObject$1(fn.prototype))boundFunction.prototype=fn.prototype;return boundFunction;};// https://tc39.es/ecma262/#sec-function.prototype.bind
_export({target:'Function',proto:true},{bind:functionBind});var entryVirtual=function(CONSTRUCTOR){return path[CONSTRUCTOR+'Prototype'];};var bind$2=entryVirtual('Function').bind;var FunctionPrototype=Function.prototype;var bind_1=function(it){var own=it.bind;return it===FunctionPrototype||it instanceof Function&&own===FunctionPrototype.bind?bind$2:own;};var bind$1=bind_1;var bind=bind$1;/**
 * Draw a circle.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - The radius of the circle.
 */function drawCircle(ctx,x,y,r){ctx.beginPath();ctx.arc(x,y,r,0,2*Math.PI,false);ctx.closePath();}/**
 * Draw a square.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - Half of the width and height of the square.
 */function drawSquare(ctx,x,y,r){ctx.beginPath();ctx.rect(x-r,y-r,r*2,r*2);ctx.closePath();}/**
 * Draw an equilateral triangle standing on a side.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - Half of the length of the sides.
 *
 * @remarks
 * http://en.wikipedia.org/wiki/Equilateral_triangle
 */function drawTriangle(ctx,x,y,r){ctx.beginPath();// the change in radius and the offset is here to center the shape
r*=1.15;y+=0.275*r;var s=r*2;var s2=s/2;var ir=Math.sqrt(3)/6*s;// radius of inner circle
var h=Math.sqrt(s*s-s2*s2);// height
ctx.moveTo(x,y-(h-ir));ctx.lineTo(x+s2,y+ir);ctx.lineTo(x-s2,y+ir);ctx.lineTo(x,y-(h-ir));ctx.closePath();}/**
 * Draw an equilateral triangle standing on a vertex.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - Half of the length of the sides.
 *
 * @remarks
 * http://en.wikipedia.org/wiki/Equilateral_triangle
 */function drawTriangleDown(ctx,x,y,r){ctx.beginPath();// the change in radius and the offset is here to center the shape
r*=1.15;y-=0.275*r;var s=r*2;var s2=s/2;var ir=Math.sqrt(3)/6*s;// radius of inner circle
var h=Math.sqrt(s*s-s2*s2);// height
ctx.moveTo(x,y+(h-ir));ctx.lineTo(x+s2,y-ir);ctx.lineTo(x-s2,y-ir);ctx.lineTo(x,y+(h-ir));ctx.closePath();}/**
 * Draw a star.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - The outer radius of the star.
 */function drawStar(ctx,x,y,r){// http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/
ctx.beginPath();// the change in radius and the offset is here to center the shape
r*=0.82;y+=0.1*r;for(var n=0;n<10;n++){var radius=n%2===0?r*1.3:r*0.5;ctx.lineTo(x+radius*Math.sin(n*2*Math.PI/10),y-radius*Math.cos(n*2*Math.PI/10));}ctx.closePath();}/**
 * Draw a diamond.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - Half of the width and height of the diamond.
 *
 * @remarks
 * http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/
 */function drawDiamond(ctx,x,y,r){ctx.beginPath();ctx.lineTo(x,y+r);ctx.lineTo(x+r,y);ctx.lineTo(x,y-r);ctx.lineTo(x-r,y);ctx.closePath();}/**
 * Draw a rectangle with rounded corners.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param w - The width of the rectangle.
 * @param h - The height of the rectangle.
 * @param r - The radius of the corners.
 *
 * @remarks
 * http://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas
 */function drawRoundRect(ctx,x,y,w,h,r){var r2d=Math.PI/180;if(w-2*r<0){r=w/2;}//ensure that the radius isn't too large for x
if(h-2*r<0){r=h/2;}//ensure that the radius isn't too large for y
ctx.beginPath();ctx.moveTo(x+r,y);ctx.lineTo(x+w-r,y);ctx.arc(x+w-r,y+r,r,r2d*270,r2d*360,false);ctx.lineTo(x+w,y+h-r);ctx.arc(x+w-r,y+h-r,r,0,r2d*90,false);ctx.lineTo(x+r,y+h);ctx.arc(x+r,y+h-r,r,r2d*90,r2d*180,false);ctx.lineTo(x,y+r);ctx.arc(x+r,y+r,r,r2d*180,r2d*270,false);ctx.closePath();}/**
 * Draw an ellipse.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param w - The width of the ellipse.
 * @param h - The height of the ellipse.
 *
 * @remarks
 * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
 *
 * Postfix '_vis' added to discern it from standard method ellipse().
 */function drawEllipse(ctx,x,y,w,h){var kappa=0.5522848,ox=w/2*kappa,// control point offset horizontal
oy=h/2*kappa,// control point offset vertical
xe=x+w,// x-end
ye=y+h,// y-end
xm=x+w/2,// x-middle
ym=y+h/2;// y-middle
ctx.beginPath();ctx.moveTo(x,ym);ctx.bezierCurveTo(x,ym-oy,xm-ox,y,xm,y);ctx.bezierCurveTo(xm+ox,y,xe,ym-oy,xe,ym);ctx.bezierCurveTo(xe,ym+oy,xm+ox,ye,xm,ye);ctx.bezierCurveTo(xm-ox,ye,x,ym+oy,x,ym);ctx.closePath();}/**
 * Draw an isometric cylinder.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param w - The width of the database.
 * @param h - The height of the database.
 *
 * @remarks
 * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
 */function drawDatabase(ctx,x,y,w,h){var f=1/3;var wEllipse=w;var hEllipse=h*f;var kappa=0.5522848,ox=wEllipse/2*kappa,// control point offset horizontal
oy=hEllipse/2*kappa,// control point offset vertical
xe=x+wEllipse,// x-end
ye=y+hEllipse,// y-end
xm=x+wEllipse/2,// x-middle
ym=y+hEllipse/2,// y-middle
ymb=y+(h-hEllipse/2),// y-midlle, bottom ellipse
yeb=y+h;// y-end, bottom ellipse
ctx.beginPath();ctx.moveTo(xe,ym);ctx.bezierCurveTo(xe,ym+oy,xm+ox,ye,xm,ye);ctx.bezierCurveTo(xm-ox,ye,x,ym+oy,x,ym);ctx.bezierCurveTo(x,ym-oy,xm-ox,y,xm,y);ctx.bezierCurveTo(xm+ox,y,xe,ym-oy,xe,ym);ctx.lineTo(xe,ymb);ctx.bezierCurveTo(xe,ymb+oy,xm+ox,yeb,xm,yeb);ctx.bezierCurveTo(xm-ox,yeb,x,ymb+oy,x,ymb);ctx.lineTo(x,ym);}/**
 * Draw a dashed line.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The start position on the x axis.
 * @param y - The start position on the y axis.
 * @param x2 - The end position on the x axis.
 * @param y2 - The end position on the y axis.
 * @param pattern - List of lengths starting with line and then alternating between space and line.
 *
 * @author David Jordan
 * @remarks
 * date 2012-08-08
 * http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas
 */function drawDashedLine(ctx,x,y,x2,y2,pattern){ctx.beginPath();ctx.moveTo(x,y);var patternLength=pattern.length;var dx=x2-x;var dy=y2-y;var slope=dy/dx;var distRemaining=Math.sqrt(dx*dx+dy*dy);var patternIndex=0;var draw=true;var xStep=0;var dashLength=+pattern[0];while(distRemaining>=0.1){dashLength=+pattern[patternIndex++%patternLength];if(dashLength>distRemaining){dashLength=distRemaining;}xStep=Math.sqrt(dashLength*dashLength/(1+slope*slope));xStep=dx<0?-xStep:xStep;x+=xStep;y+=slope*xStep;if(draw===true){ctx.lineTo(x,y);}else{ctx.moveTo(x,y);}distRemaining-=dashLength;draw=!draw;}}/**
 * Draw a hexagon.
 *
 * @param ctx - The context this shape will be rendered to.
 * @param x - The position of the center on the x axis.
 * @param y - The position of the center on the y axis.
 * @param r - The radius of the hexagon.
 */function drawHexagon(ctx,x,y,r){ctx.beginPath();var sides=6;var a=Math.PI*2/sides;ctx.moveTo(x+r,y);for(var i=1;i<sides;i++){ctx.lineTo(x+r*Math.cos(a*i),y+r*Math.sin(a*i));}ctx.closePath();}var shapeMap={circle:drawCircle,dashedLine:drawDashedLine,database:drawDatabase,diamond:drawDiamond,ellipse:drawEllipse,ellipse_vis:drawEllipse,hexagon:drawHexagon,roundRect:drawRoundRect,square:drawSquare,star:drawStar,triangle:drawTriangle,triangleDown:drawTriangleDown};/**
 * Returns either custom or native drawing function base on supplied name.
 *
 * @param name - The name of the function. Either the name of a
 * CanvasRenderingContext2D property or an export from shapes.ts without the
 * draw prefix.
 *
 * @returns The function that can be used for rendering. In case of native
 * CanvasRenderingContext2D function the API is normalized to
 * `(ctx: CanvasRenderingContext2D, ...originalArgs) => void`.
 */function getShape(name){if(Object.prototype.hasOwnProperty.call(shapeMap,name)){return shapeMap[name];}else{return function(ctx){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}CanvasRenderingContext2D.prototype[name].call(ctx,args);};}}function styleInject(css,ref){if(ref===void 0)ref={};var insertAt=ref.insertAt;if(!css||typeof document==='undefined'){return;}var head=document.head||document.getElementsByTagName('head')[0];var style=document.createElement('style');style.type='text/css';if(insertAt==='top'){if(head.firstChild){head.insertBefore(style,head.firstChild);}else{head.appendChild(style);}}else{head.appendChild(style);}if(style.styleSheet){style.styleSheet.cssText=css;}else{style.appendChild(document.createTextNode(css));}}var css_248z$6=".vis-overlay {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n\n  /* Must be displayed above for example selected Timeline items */\n  z-index: 10;\n}\n\n.vis-active {\n  box-shadow: 0 0 10px #86d5f8;\n}\n";styleInject(css_248z$6);var css_248z$5="/* override some bootstrap styles screwing up the timelines css */\n\n.vis [class*=\"span\"] {\n  min-height: 0;\n  width: auto;\n}\n";styleInject(css_248z$5);var css_248z$4="div.vis-color-picker {\n  position: absolute;\n  top: 0px;\n  left: 30px;\n  margin-top: -140px;\n  margin-left: 30px;\n  width: 310px;\n  height: 444px;\n  z-index: 1;\n  padding: 10px;\n  border-radius: 15px;\n  background-color: #ffffff;\n  display: none;\n  box-shadow: rgba(0, 0, 0, 0.5) 0px 0px 10px 0px;\n}\n\ndiv.vis-color-picker div.vis-arrow {\n  position: absolute;\n  top: 147px;\n  left: 5px;\n}\n\ndiv.vis-color-picker div.vis-arrow::after,\ndiv.vis-color-picker div.vis-arrow::before {\n  right: 100%;\n  top: 50%;\n  border: solid transparent;\n  content: \" \";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\ndiv.vis-color-picker div.vis-arrow:after {\n  border-color: rgba(255, 255, 255, 0);\n  border-right-color: #ffffff;\n  border-width: 30px;\n  margin-top: -30px;\n}\n\ndiv.vis-color-picker div.vis-color {\n  position: absolute;\n  width: 289px;\n  height: 289px;\n  cursor: pointer;\n}\n\ndiv.vis-color-picker div.vis-brightness {\n  position: absolute;\n  top: 313px;\n}\n\ndiv.vis-color-picker div.vis-opacity {\n  position: absolute;\n  top: 350px;\n}\n\ndiv.vis-color-picker div.vis-selector {\n  position: absolute;\n  top: 137px;\n  left: 137px;\n  width: 15px;\n  height: 15px;\n  border-radius: 15px;\n  border: 1px solid #ffffff;\n  background: #4c4c4c; /* Old browsers */\n  background: -moz-linear-gradient(\n    top,\n    #4c4c4c 0%,\n    #595959 12%,\n    #666666 25%,\n    #474747 39%,\n    #2c2c2c 50%,\n    #000000 51%,\n    #111111 60%,\n    #2b2b2b 76%,\n    #1c1c1c 91%,\n    #131313 100%\n  ); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #4c4c4c),\n    color-stop(12%, #595959),\n    color-stop(25%, #666666),\n    color-stop(39%, #474747),\n    color-stop(50%, #2c2c2c),\n    color-stop(51%, #000000),\n    color-stop(60%, #111111),\n    color-stop(76%, #2b2b2b),\n    color-stop(91%, #1c1c1c),\n    color-stop(100%, #131313)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #4c4c4c 0%,\n    #595959 12%,\n    #666666 25%,\n    #474747 39%,\n    #2c2c2c 50%,\n    #000000 51%,\n    #111111 60%,\n    #2b2b2b 76%,\n    #1c1c1c 91%,\n    #131313 100%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #4c4c4c 0%,\n    #595959 12%,\n    #666666 25%,\n    #474747 39%,\n    #2c2c2c 50%,\n    #000000 51%,\n    #111111 60%,\n    #2b2b2b 76%,\n    #1c1c1c 91%,\n    #131313 100%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(\n    top,\n    #4c4c4c 0%,\n    #595959 12%,\n    #666666 25%,\n    #474747 39%,\n    #2c2c2c 50%,\n    #000000 51%,\n    #111111 60%,\n    #2b2b2b 76%,\n    #1c1c1c 91%,\n    #131313 100%\n  ); /* IE10+ */\n  background: linear-gradient(\n    to bottom,\n    #4c4c4c 0%,\n    #595959 12%,\n    #666666 25%,\n    #474747 39%,\n    #2c2c2c 50%,\n    #000000 51%,\n    #111111 60%,\n    #2b2b2b 76%,\n    #1c1c1c 91%,\n    #131313 100%\n  ); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#4c4c4c', endColorstr='#131313',GradientType=0 ); /* IE6-9 */\n}\n\ndiv.vis-color-picker div.vis-new-color {\n  position: absolute;\n  width: 140px;\n  height: 20px;\n  border: 1px solid rgba(0, 0, 0, 0.1);\n  border-radius: 5px;\n  top: 380px;\n  left: 159px;\n  text-align: right;\n  padding-right: 2px;\n  font-size: 10px;\n  color: rgba(0, 0, 0, 0.4);\n  vertical-align: middle;\n  line-height: 20px;\n}\n\ndiv.vis-color-picker div.vis-initial-color {\n  position: absolute;\n  width: 140px;\n  height: 20px;\n  border: 1px solid rgba(0, 0, 0, 0.1);\n  border-radius: 5px;\n  top: 380px;\n  left: 10px;\n  text-align: left;\n  padding-left: 2px;\n  font-size: 10px;\n  color: rgba(0, 0, 0, 0.4);\n  vertical-align: middle;\n  line-height: 20px;\n}\n\ndiv.vis-color-picker div.vis-label {\n  position: absolute;\n  width: 300px;\n  left: 10px;\n}\n\ndiv.vis-color-picker div.vis-label.vis-brightness {\n  top: 300px;\n}\n\ndiv.vis-color-picker div.vis-label.vis-opacity {\n  top: 338px;\n}\n\ndiv.vis-color-picker div.vis-button {\n  position: absolute;\n  width: 68px;\n  height: 25px;\n  border-radius: 10px;\n  vertical-align: middle;\n  text-align: center;\n  line-height: 25px;\n  top: 410px;\n  border: 2px solid #d9d9d9;\n  background-color: #f7f7f7;\n  cursor: pointer;\n}\n\ndiv.vis-color-picker div.vis-button.vis-cancel {\n  /*border:2px solid #ff4e33;*/\n  /*background-color: #ff7761;*/\n  left: 5px;\n}\ndiv.vis-color-picker div.vis-button.vis-load {\n  /*border:2px solid #a153e6;*/\n  /*background-color: #cb8dff;*/\n  left: 82px;\n}\ndiv.vis-color-picker div.vis-button.vis-apply {\n  /*border:2px solid #4588e6;*/\n  /*background-color: #82b6ff;*/\n  left: 159px;\n}\ndiv.vis-color-picker div.vis-button.vis-save {\n  /*border:2px solid #45e655;*/\n  /*background-color: #6dff7c;*/\n  left: 236px;\n}\n\ndiv.vis-color-picker input.vis-range {\n  width: 290px;\n  height: 20px;\n}\n\n/* TODO: is this redundant?\ndiv.vis-color-picker input.vis-range-brightness {\n  width: 289px !important;\n}\n\n\ndiv.vis-color-picker input.vis-saturation-range {\n  width: 289px !important;\n}*/\n";styleInject(css_248z$4);var css_248z$3="div.vis-configuration {\n  position: relative;\n  display: block;\n  float: left;\n  font-size: 12px;\n}\n\ndiv.vis-configuration-wrapper {\n  display: block;\n  width: 700px;\n}\n\ndiv.vis-configuration-wrapper::after {\n  clear: both;\n  content: \"\";\n  display: block;\n}\n\ndiv.vis-configuration.vis-config-option-container {\n  display: block;\n  width: 495px;\n  background-color: #ffffff;\n  border: 2px solid #f7f8fa;\n  border-radius: 4px;\n  margin-top: 20px;\n  left: 10px;\n  padding-left: 5px;\n}\n\ndiv.vis-configuration.vis-config-button {\n  display: block;\n  width: 495px;\n  height: 25px;\n  vertical-align: middle;\n  line-height: 25px;\n  background-color: #f7f8fa;\n  border: 2px solid #ceced0;\n  border-radius: 4px;\n  margin-top: 20px;\n  left: 10px;\n  padding-left: 5px;\n  cursor: pointer;\n  margin-bottom: 30px;\n}\n\ndiv.vis-configuration.vis-config-button.hover {\n  background-color: #4588e6;\n  border: 2px solid #214373;\n  color: #ffffff;\n}\n\ndiv.vis-configuration.vis-config-item {\n  display: block;\n  float: left;\n  width: 495px;\n  height: 25px;\n  vertical-align: middle;\n  line-height: 25px;\n}\n\ndiv.vis-configuration.vis-config-item.vis-config-s2 {\n  left: 10px;\n  background-color: #f7f8fa;\n  padding-left: 5px;\n  border-radius: 3px;\n}\ndiv.vis-configuration.vis-config-item.vis-config-s3 {\n  left: 20px;\n  background-color: #e4e9f0;\n  padding-left: 5px;\n  border-radius: 3px;\n}\ndiv.vis-configuration.vis-config-item.vis-config-s4 {\n  left: 30px;\n  background-color: #cfd8e6;\n  padding-left: 5px;\n  border-radius: 3px;\n}\n\ndiv.vis-configuration.vis-config-header {\n  font-size: 18px;\n  font-weight: bold;\n}\n\ndiv.vis-configuration.vis-config-label {\n  width: 120px;\n  height: 25px;\n  line-height: 25px;\n}\n\ndiv.vis-configuration.vis-config-label.vis-config-s3 {\n  width: 110px;\n}\ndiv.vis-configuration.vis-config-label.vis-config-s4 {\n  width: 100px;\n}\n\ndiv.vis-configuration.vis-config-colorBlock {\n  top: 1px;\n  width: 30px;\n  height: 19px;\n  border: 1px solid #444444;\n  border-radius: 2px;\n  padding: 0px;\n  margin: 0px;\n  cursor: pointer;\n}\n\ninput.vis-configuration.vis-config-checkbox {\n  left: -5px;\n}\n\ninput.vis-configuration.vis-config-rangeinput {\n  position: relative;\n  top: -5px;\n  width: 60px;\n  /*height:13px;*/\n  padding: 1px;\n  margin: 0;\n  pointer-events: none;\n}\n\ninput.vis-configuration.vis-config-range {\n  /*removes default webkit styles*/\n  -webkit-appearance: none;\n\n  /*fix for FF unable to apply focus style bug */\n  border: 0px solid white;\n  background-color: rgba(0, 0, 0, 0);\n\n  /*required for proper track sizing in FF*/\n  width: 300px;\n  height: 20px;\n}\ninput.vis-configuration.vis-config-range::-webkit-slider-runnable-track {\n  width: 300px;\n  height: 5px;\n  background: #dedede; /* Old browsers */\n  background: -moz-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #dedede),\n    color-stop(99%, #c8c8c8)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #dedede 0%,\n    #c8c8c8 99%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #dedede 0%,\n    #c8c8c8 99%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* IE10+ */\n  background: linear-gradient(to bottom, #dedede 0%, #c8c8c8 99%); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#dedede', endColorstr='#c8c8c8',GradientType=0 ); /* IE6-9 */\n\n  border: 1px solid #999999;\n  box-shadow: #aaaaaa 0px 0px 3px 0px;\n  border-radius: 3px;\n}\ninput.vis-configuration.vis-config-range::-webkit-slider-thumb {\n  -webkit-appearance: none;\n  border: 1px solid #14334b;\n  height: 17px;\n  width: 17px;\n  border-radius: 50%;\n  background: #3876c2; /* Old browsers */\n  background: -moz-linear-gradient(top, #3876c2 0%, #385380 100%); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #3876c2),\n    color-stop(100%, #385380)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #3876c2 0%,\n    #385380 100%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #3876c2 0%,\n    #385380 100%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(top, #3876c2 0%, #385380 100%); /* IE10+ */\n  background: linear-gradient(to bottom, #3876c2 0%, #385380 100%); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#3876c2', endColorstr='#385380',GradientType=0 ); /* IE6-9 */\n  box-shadow: #111927 0px 0px 1px 0px;\n  margin-top: -7px;\n}\ninput.vis-configuration.vis-config-range:focus {\n  outline: none;\n}\ninput.vis-configuration.vis-config-range:focus::-webkit-slider-runnable-track {\n  background: #9d9d9d; /* Old browsers */\n  background: -moz-linear-gradient(top, #9d9d9d 0%, #c8c8c8 99%); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #9d9d9d),\n    color-stop(99%, #c8c8c8)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #9d9d9d 0%,\n    #c8c8c8 99%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #9d9d9d 0%,\n    #c8c8c8 99%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(top, #9d9d9d 0%, #c8c8c8 99%); /* IE10+ */\n  background: linear-gradient(to bottom, #9d9d9d 0%, #c8c8c8 99%); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#9d9d9d', endColorstr='#c8c8c8',GradientType=0 ); /* IE6-9 */\n}\n\ninput.vis-configuration.vis-config-range::-moz-range-track {\n  width: 300px;\n  height: 10px;\n  background: #dedede; /* Old browsers */\n  background: -moz-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #dedede),\n    color-stop(99%, #c8c8c8)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #dedede 0%,\n    #c8c8c8 99%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #dedede 0%,\n    #c8c8c8 99%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(top, #dedede 0%, #c8c8c8 99%); /* IE10+ */\n  background: linear-gradient(to bottom, #dedede 0%, #c8c8c8 99%); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#dedede', endColorstr='#c8c8c8',GradientType=0 ); /* IE6-9 */\n\n  border: 1px solid #999999;\n  box-shadow: #aaaaaa 0px 0px 3px 0px;\n  border-radius: 3px;\n}\ninput.vis-configuration.vis-config-range::-moz-range-thumb {\n  border: none;\n  height: 16px;\n  width: 16px;\n\n  border-radius: 50%;\n  background: #385380;\n}\n\n/*hide the outline behind the border*/\ninput.vis-configuration.vis-config-range:-moz-focusring {\n  outline: 1px solid white;\n  outline-offset: -1px;\n}\n\ninput.vis-configuration.vis-config-range::-ms-track {\n  width: 300px;\n  height: 5px;\n\n  /*remove bg colour from the track, we'll use ms-fill-lower and ms-fill-upper instead */\n  background: transparent;\n\n  /*leave room for the larger thumb to overflow with a transparent border */\n  border-color: transparent;\n  border-width: 6px 0;\n\n  /*remove default tick marks*/\n  color: transparent;\n}\ninput.vis-configuration.vis-config-range::-ms-fill-lower {\n  background: #777;\n  border-radius: 10px;\n}\ninput.vis-configuration.vis-config-range::-ms-fill-upper {\n  background: #ddd;\n  border-radius: 10px;\n}\ninput.vis-configuration.vis-config-range::-ms-thumb {\n  border: none;\n  height: 16px;\n  width: 16px;\n  border-radius: 50%;\n  background: #385380;\n}\ninput.vis-configuration.vis-config-range:focus::-ms-fill-lower {\n  background: #888;\n}\ninput.vis-configuration.vis-config-range:focus::-ms-fill-upper {\n  background: #ccc;\n}\n\n.vis-configuration-popup {\n  position: absolute;\n  background: rgba(57, 76, 89, 0.85);\n  border: 2px solid #f2faff;\n  line-height: 30px;\n  height: 30px;\n  width: 150px;\n  text-align: center;\n  color: #ffffff;\n  font-size: 14px;\n  border-radius: 4px;\n  -webkit-transition: opacity 0.3s ease-in-out;\n  -moz-transition: opacity 0.3s ease-in-out;\n  transition: opacity 0.3s ease-in-out;\n}\n.vis-configuration-popup:after,\n.vis-configuration-popup:before {\n  left: 100%;\n  top: 50%;\n  border: solid transparent;\n  content: \" \";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.vis-configuration-popup:after {\n  border-color: rgba(136, 183, 213, 0);\n  border-left-color: rgba(57, 76, 89, 0.85);\n  border-width: 8px;\n  margin-top: -8px;\n}\n.vis-configuration-popup:before {\n  border-color: rgba(194, 225, 245, 0);\n  border-left-color: #f2faff;\n  border-width: 12px;\n  margin-top: -12px;\n}\n";styleInject(css_248z$3);var css_248z$2="div.vis-tooltip {\n  position: absolute;\n  visibility: hidden;\n  padding: 5px;\n  white-space: nowrap;\n\n  font-family: verdana;\n  font-size: 14px;\n  color: #000000;\n  background-color: #f5f4ed;\n\n  -moz-border-radius: 3px;\n  -webkit-border-radius: 3px;\n  border-radius: 3px;\n  border: 1px solid #808074;\n\n  box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);\n  pointer-events: none;\n\n  z-index: 5;\n}\n";styleInject(css_248z$2);var componentEmitter=createCommonjsModule(function(module){/**
   * Expose `Emitter`.
   */{module.exports=Emitter;}/**
   * Initialize a new `Emitter`.
   *
   * @api public
   */function Emitter(obj){if(obj)return mixin(obj);}/**
   * Mixin the emitter properties.
   *
   * @param {Object} obj
   * @return {Object}
   * @api private
   */function mixin(obj){for(var key in Emitter.prototype){obj[key]=Emitter.prototype[key];}return obj;}/**
   * Listen on the given `event` with `fn`.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */Emitter.prototype.on=Emitter.prototype.addEventListener=function(event,fn){this._callbacks=this._callbacks||{};(this._callbacks['$'+event]=this._callbacks['$'+event]||[]).push(fn);return this;};/**
   * Adds an `event` listener that will be invoked a single
   * time then automatically removed.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */Emitter.prototype.once=function(event,fn){function on(){this.off(event,on);fn.apply(this,arguments);}on.fn=fn;this.on(event,on);return this;};/**
   * Remove the given callback for `event` or all
   * registered callbacks.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */Emitter.prototype.off=Emitter.prototype.removeListener=Emitter.prototype.removeAllListeners=Emitter.prototype.removeEventListener=function(event,fn){this._callbacks=this._callbacks||{};// all
if(0==arguments.length){this._callbacks={};return this;}// specific event
var callbacks=this._callbacks['$'+event];if(!callbacks)return this;// remove all handlers
if(1==arguments.length){delete this._callbacks['$'+event];return this;}// remove specific handler
var cb;for(var i=0;i<callbacks.length;i++){cb=callbacks[i];if(cb===fn||cb.fn===fn){callbacks.splice(i,1);break;}}// Remove event specific arrays for event types that no
// one is subscribed for to avoid memory leak.
if(callbacks.length===0){delete this._callbacks['$'+event];}return this;};/**
   * Emit `event` with the given args.
   *
   * @param {String} event
   * @param {Mixed} ...
   * @return {Emitter}
   */Emitter.prototype.emit=function(event){this._callbacks=this._callbacks||{};var args=new Array(arguments.length-1),callbacks=this._callbacks['$'+event];for(var i=1;i<arguments.length;i++){args[i-1]=arguments[i];}if(callbacks){callbacks=callbacks.slice(0);for(var i=0,len=callbacks.length;i<len;++i){callbacks[i].apply(this,args);}}return this;};/**
   * Return array of callbacks for `event`.
   *
   * @param {String} event
   * @return {Array}
   * @api public
   */Emitter.prototype.listeners=function(event){this._callbacks=this._callbacks||{};return this._callbacks['$'+event]||[];};/**
   * Check if this emitter has `event` handlers.
   *
   * @param {String} event
   * @return {Boolean}
   * @api public
   */Emitter.prototype.hasListeners=function(event){return!!this.listeners(event).length;};});var createMethod$4=function(CONVERT_TO_STRING){return function($this,pos){var S=String(requireObjectCoercible($this));var position=toInteger(pos);var size=S.length;var first,second;if(position<0||position>=size)return CONVERT_TO_STRING?'':undefined;first=S.charCodeAt(position);return first<0xD800||first>0xDBFF||position+1===size||(second=S.charCodeAt(position+1))<0xDC00||second>0xDFFF?CONVERT_TO_STRING?S.charAt(position):first:CONVERT_TO_STRING?S.slice(position,position+2):(first-0xD800<<10)+(second-0xDC00)+0x10000;};};var stringMultibyte={// `String.prototype.codePointAt` method
// https://tc39.es/ecma262/#sec-string.prototype.codepointat
codeAt:createMethod$4(false),// `String.prototype.at` method
// https://github.com/mathiasbynens/String.prototype.at
charAt:createMethod$4(true)};var setGlobal=function(key,value){try{createNonEnumerableProperty(global$1,key,value);}catch(error){global$1[key]=value;}return value;};var SHARED='__core-js_shared__';var store$1=global$1[SHARED]||setGlobal(SHARED,{});var sharedStore=store$1;var functionToString=Function.toString;// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if(typeof sharedStore.inspectSource!='function'){sharedStore.inspectSource=function(it){return functionToString.call(it);};}var inspectSource=sharedStore.inspectSource;var WeakMap$1=global$1.WeakMap;var nativeWeakMap=typeof WeakMap$1==='function'&&/native code/.test(inspectSource(WeakMap$1));var shared=createCommonjsModule(function(module){(module.exports=function(key,value){return sharedStore[key]||(sharedStore[key]=value!==undefined?value:{});})('versions',[]).push({version:'3.15.2',mode:'pure',copyright:'© 2021 Denis Pushkarev (zloirock.ru)'});});var id$1=0;var postfix=Math.random();var uid=function(key){return'Symbol('+String(key===undefined?'':key)+')_'+(++id$1+postfix).toString(36);};var keys$6=shared('keys');var sharedKey=function(key){return keys$6[key]||(keys$6[key]=uid(key));};var OBJECT_ALREADY_INITIALIZED='Object already initialized';var WeakMap=global$1.WeakMap;var set$3,get$4,has;var enforce=function(it){return has(it)?get$4(it):set$3(it,{});};var getterFor=function(TYPE){return function(it){var state;if(!isObject$1(it)||(state=get$4(it)).type!==TYPE){throw TypeError('Incompatible receiver, '+TYPE+' required');}return state;};};if(nativeWeakMap||sharedStore.state){var store=sharedStore.state||(sharedStore.state=new WeakMap());var wmget=store.get;var wmhas=store.has;var wmset=store.set;set$3=function(it,metadata){if(wmhas.call(store,it))throw new TypeError(OBJECT_ALREADY_INITIALIZED);metadata.facade=it;wmset.call(store,it,metadata);return metadata;};get$4=function(it){return wmget.call(store,it)||{};};has=function(it){return wmhas.call(store,it);};}else{var STATE=sharedKey('state');hiddenKeys$1[STATE]=true;set$3=function(it,metadata){if(has$1(it,STATE))throw new TypeError(OBJECT_ALREADY_INITIALIZED);metadata.facade=it;createNonEnumerableProperty(it,STATE,metadata);return metadata;};get$4=function(it){return has$1(it,STATE)?it[STATE]:{};};has=function(it){return has$1(it,STATE);};}var internalState={set:set$3,get:get$4,has:has,enforce:enforce,getterFor:getterFor};var correctPrototypeGetter=!fails(function(){function F(){/* empty */}F.prototype.constructor=null;// eslint-disable-next-line es/no-object-getprototypeof -- required for testing
return Object.getPrototypeOf(new F())!==F.prototype;});var IE_PROTO$1=sharedKey('IE_PROTO');var ObjectPrototype$1=Object.prototype;// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
var objectGetPrototypeOf=correctPrototypeGetter?Object.getPrototypeOf:function(O){O=toObject(O);if(has$1(O,IE_PROTO$1))return O[IE_PROTO$1];if(typeof O.constructor=='function'&&O instanceof O.constructor){return O.constructor.prototype;}return O instanceof Object?ObjectPrototype$1:null;};var aFunction=function(variable){return typeof variable=='function'?variable:undefined;};var getBuiltIn=function(namespace,method){return arguments.length<2?aFunction(path[namespace])||aFunction(global$1[namespace]):path[namespace]&&path[namespace][method]||global$1[namespace]&&global$1[namespace][method];};var engineUserAgent=getBuiltIn('navigator','userAgent')||'';var process=global$1.process;var versions=process&&process.versions;var v8=versions&&versions.v8;var match,version;if(v8){match=v8.split('.');version=match[0]<4?1:match[0]+match[1];}else if(engineUserAgent){match=engineUserAgent.match(/Edge\/(\d+)/);if(!match||match[1]>=74){match=engineUserAgent.match(/Chrome\/(\d+)/);if(match)version=match[1];}}var engineV8Version=version&&+version;/* eslint-disable es/no-symbol -- required for testing */var nativeSymbol=!!Object.getOwnPropertySymbols&&!fails(function(){var symbol=Symbol();// Chrome 38 Symbol has incorrect toString conversion
// `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
return!String(symbol)||!(Object(symbol)instanceof Symbol)||// Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
!Symbol.sham&&engineV8Version&&engineV8Version<41;});/* eslint-disable es/no-symbol -- required for testing */var useSymbolAsUid=nativeSymbol&&!Symbol.sham&&typeof Symbol.iterator=='symbol';var WellKnownSymbolsStore$1=shared('wks');var Symbol$1=global$1.Symbol;var createWellKnownSymbol=useSymbolAsUid?Symbol$1:Symbol$1&&Symbol$1.withoutSetter||uid;var wellKnownSymbol=function(name){if(!has$1(WellKnownSymbolsStore$1,name)||!(nativeSymbol||typeof WellKnownSymbolsStore$1[name]=='string')){if(nativeSymbol&&has$1(Symbol$1,name)){WellKnownSymbolsStore$1[name]=Symbol$1[name];}else{WellKnownSymbolsStore$1[name]=createWellKnownSymbol('Symbol.'+name);}}return WellKnownSymbolsStore$1[name];};var ITERATOR$4=wellKnownSymbol('iterator');var BUGGY_SAFARI_ITERATORS$1=false;var returnThis$2=function(){return this;};// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype$2,PrototypeOfArrayIteratorPrototype,arrayIterator;/* eslint-disable es/no-array-prototype-keys -- safe */if([].keys){arrayIterator=[].keys();// Safari 8 has buggy iterators w/o `next`
if(!('next'in arrayIterator))BUGGY_SAFARI_ITERATORS$1=true;else{PrototypeOfArrayIteratorPrototype=objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));if(PrototypeOfArrayIteratorPrototype!==Object.prototype)IteratorPrototype$2=PrototypeOfArrayIteratorPrototype;}}var NEW_ITERATOR_PROTOTYPE=IteratorPrototype$2==undefined||fails(function(){var test={};// FF44- legacy iterators case
return IteratorPrototype$2[ITERATOR$4].call(test)!==test;});if(NEW_ITERATOR_PROTOTYPE)IteratorPrototype$2={};// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if(NEW_ITERATOR_PROTOTYPE&&!has$1(IteratorPrototype$2,ITERATOR$4)){createNonEnumerableProperty(IteratorPrototype$2,ITERATOR$4,returnThis$2);}var iteratorsCore={IteratorPrototype:IteratorPrototype$2,BUGGY_SAFARI_ITERATORS:BUGGY_SAFARI_ITERATORS$1};// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
var objectDefineProperties=descriptors?Object.defineProperties:function defineProperties(O,Properties){anObject(O);var keys=objectKeys(Properties);var length=keys.length;var index=0;var key;while(length>index)objectDefineProperty.f(O,key=keys[index++],Properties[key]);return O;};var html=getBuiltIn('document','documentElement');var GT='>';var LT='<';var PROTOTYPE$1='prototype';var SCRIPT='script';var IE_PROTO=sharedKey('IE_PROTO');var EmptyConstructor=function(){/* empty */};var scriptTag=function(content){return LT+SCRIPT+GT+content+LT+'/'+SCRIPT+GT;};// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX=function(activeXDocument){activeXDocument.write(scriptTag(''));activeXDocument.close();var temp=activeXDocument.parentWindow.Object;activeXDocument=null;// avoid memory leak
return temp;};// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame=function(){// Thrash, waste and sodomy: IE GC bug
var iframe=documentCreateElement('iframe');var JS='java'+SCRIPT+':';var iframeDocument;iframe.style.display='none';html.appendChild(iframe);// https://github.com/zloirock/core-js/issues/475
iframe.src=String(JS);iframeDocument=iframe.contentWindow.document;iframeDocument.open();iframeDocument.write(scriptTag('document.F=Object'));iframeDocument.close();return iframeDocument.F;};// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;var NullProtoObject=function(){try{/* global ActiveXObject -- old IE */activeXDocument=document.domain&&new ActiveXObject('htmlfile');}catch(error){/* ignore */}NullProtoObject=activeXDocument?NullProtoObjectViaActiveX(activeXDocument):NullProtoObjectViaIFrame();var length=enumBugKeys.length;while(length--)delete NullProtoObject[PROTOTYPE$1][enumBugKeys[length]];return NullProtoObject();};hiddenKeys$1[IE_PROTO]=true;// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
var objectCreate=Object.create||function create(O,Properties){var result;if(O!==null){EmptyConstructor[PROTOTYPE$1]=anObject(O);result=new EmptyConstructor();EmptyConstructor[PROTOTYPE$1]=null;// add "__proto__" for Object.getPrototypeOf polyfill
result[IE_PROTO]=O;}else result=NullProtoObject();return Properties===undefined?result:objectDefineProperties(result,Properties);};var TO_STRING_TAG$3=wellKnownSymbol('toStringTag');var test$2={};test$2[TO_STRING_TAG$3]='z';var toStringTagSupport=String(test$2)==='[object z]';var TO_STRING_TAG$2=wellKnownSymbol('toStringTag');// ES3 wrong here
var CORRECT_ARGUMENTS=classofRaw(function(){return arguments;}())=='Arguments';// fallback for IE11 Script Access Denied error
var tryGet=function(it,key){try{return it[key];}catch(error){/* empty */}};// getting tag from ES6+ `Object.prototype.toString`
var classof=toStringTagSupport?classofRaw:function(it){var O,tag,result;return it===undefined?'Undefined':it===null?'Null'// @@toStringTag case
:typeof(tag=tryGet(O=Object(it),TO_STRING_TAG$2))=='string'?tag// builtinTag case
:CORRECT_ARGUMENTS?classofRaw(O)// ES3 arguments fallback
:(result=classofRaw(O))=='Object'&&typeof O.callee=='function'?'Arguments':result;};// https://tc39.es/ecma262/#sec-object.prototype.tostring
var objectToString=toStringTagSupport?{}.toString:function toString(){return'[object '+classof(this)+']';};var defineProperty$7=objectDefineProperty.f;var TO_STRING_TAG$1=wellKnownSymbol('toStringTag');var setToStringTag=function(it,TAG,STATIC,SET_METHOD){if(it){var target=STATIC?it:it.prototype;if(!has$1(target,TO_STRING_TAG$1)){defineProperty$7(target,TO_STRING_TAG$1,{configurable:true,value:TAG});}if(SET_METHOD&&!toStringTagSupport){createNonEnumerableProperty(target,'toString',objectToString);}}};var iterators={};var IteratorPrototype$1=iteratorsCore.IteratorPrototype;var returnThis$1=function(){return this;};var createIteratorConstructor=function(IteratorConstructor,NAME,next){var TO_STRING_TAG=NAME+' Iterator';IteratorConstructor.prototype=objectCreate(IteratorPrototype$1,{next:createPropertyDescriptor(1,next)});setToStringTag(IteratorConstructor,TO_STRING_TAG,false,true);iterators[TO_STRING_TAG]=returnThis$1;return IteratorConstructor;};var aPossiblePrototype=function(it){if(!isObject$1(it)&&it!==null){throw TypeError("Can't set "+String(it)+' as a prototype');}return it;};/* eslint-disable no-proto -- safe */ // https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
var objectSetPrototypeOf=Object.setPrototypeOf||('__proto__'in{}?function(){var CORRECT_SETTER=false;var test={};var setter;try{// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
setter=Object.getOwnPropertyDescriptor(Object.prototype,'__proto__').set;setter.call(test,[]);CORRECT_SETTER=test instanceof Array;}catch(error){/* empty */}return function setPrototypeOf(O,proto){anObject(O);aPossiblePrototype(proto);if(CORRECT_SETTER)setter.call(O,proto);else O.__proto__=proto;return O;};}():undefined);var redefine=function(target,key,value,options){if(options&&options.enumerable)target[key]=value;else createNonEnumerableProperty(target,key,value);};var IteratorPrototype=iteratorsCore.IteratorPrototype;var BUGGY_SAFARI_ITERATORS=iteratorsCore.BUGGY_SAFARI_ITERATORS;var ITERATOR$3=wellKnownSymbol('iterator');var KEYS='keys';var VALUES='values';var ENTRIES='entries';var returnThis=function(){return this;};var defineIterator=function(Iterable,NAME,IteratorConstructor,next,DEFAULT,IS_SET,FORCED){createIteratorConstructor(IteratorConstructor,NAME,next);var getIterationMethod=function(KIND){if(KIND===DEFAULT&&defaultIterator)return defaultIterator;if(!BUGGY_SAFARI_ITERATORS&&KIND in IterablePrototype)return IterablePrototype[KIND];switch(KIND){case KEYS:return function keys(){return new IteratorConstructor(this,KIND);};case VALUES:return function values(){return new IteratorConstructor(this,KIND);};case ENTRIES:return function entries(){return new IteratorConstructor(this,KIND);};}return function(){return new IteratorConstructor(this);};};var TO_STRING_TAG=NAME+' Iterator';var INCORRECT_VALUES_NAME=false;var IterablePrototype=Iterable.prototype;var nativeIterator=IterablePrototype[ITERATOR$3]||IterablePrototype['@@iterator']||DEFAULT&&IterablePrototype[DEFAULT];var defaultIterator=!BUGGY_SAFARI_ITERATORS&&nativeIterator||getIterationMethod(DEFAULT);var anyNativeIterator=NAME=='Array'?IterablePrototype.entries||nativeIterator:nativeIterator;var CurrentIteratorPrototype,methods,KEY;// fix native
if(anyNativeIterator){CurrentIteratorPrototype=objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));if(IteratorPrototype!==Object.prototype&&CurrentIteratorPrototype.next){setToStringTag(CurrentIteratorPrototype,TO_STRING_TAG,true,true);iterators[TO_STRING_TAG]=returnThis;}}// fix Array.prototype.{ values, @@iterator }.name in V8 / FF
if(DEFAULT==VALUES&&nativeIterator&&nativeIterator.name!==VALUES){INCORRECT_VALUES_NAME=true;defaultIterator=function values(){return nativeIterator.call(this);};}// define iterator
if(FORCED&&IterablePrototype[ITERATOR$3]!==defaultIterator){createNonEnumerableProperty(IterablePrototype,ITERATOR$3,defaultIterator);}iterators[NAME]=defaultIterator;// export additional methods
if(DEFAULT){methods={values:getIterationMethod(VALUES),keys:IS_SET?defaultIterator:getIterationMethod(KEYS),entries:getIterationMethod(ENTRIES)};if(FORCED)for(KEY in methods){if(BUGGY_SAFARI_ITERATORS||INCORRECT_VALUES_NAME||!(KEY in IterablePrototype)){redefine(IterablePrototype,KEY,methods[KEY]);}}else _export({target:NAME,proto:true,forced:BUGGY_SAFARI_ITERATORS||INCORRECT_VALUES_NAME},methods);}return methods;};var charAt=stringMultibyte.charAt;var STRING_ITERATOR='String Iterator';var setInternalState$5=internalState.set;var getInternalState$2=internalState.getterFor(STRING_ITERATOR);// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String,'String',function(iterated){setInternalState$5(this,{type:STRING_ITERATOR,string:String(iterated),index:0});// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
},function next(){var state=getInternalState$2(this);var string=state.string;var index=state.index;var point;if(index>=string.length)return{value:undefined,done:true};point=charAt(string,index);state.index+=point.length;return{value:point,done:false};});var iteratorClose=function(iterator){var returnMethod=iterator['return'];if(returnMethod!==undefined){return anObject(returnMethod.call(iterator)).value;}};var callWithSafeIterationClosing=function(iterator,fn,value,ENTRIES){try{return ENTRIES?fn(anObject(value)[0],value[1]):fn(value);}catch(error){iteratorClose(iterator);throw error;}};var ITERATOR$2=wellKnownSymbol('iterator');var ArrayPrototype$i=Array.prototype;// check on default Array iterator
var isArrayIteratorMethod=function(it){return it!==undefined&&(iterators.Array===it||ArrayPrototype$i[ITERATOR$2]===it);};var createProperty=function(object,key,value){var propertyKey=toPrimitive(key);if(propertyKey in object)objectDefineProperty.f(object,propertyKey,createPropertyDescriptor(0,value));else object[propertyKey]=value;};var ITERATOR$1=wellKnownSymbol('iterator');var getIteratorMethod$1=function(it){if(it!=undefined)return it[ITERATOR$1]||it['@@iterator']||iterators[classof(it)];};// https://tc39.es/ecma262/#sec-array.from
var arrayFrom=function from(arrayLike/* , mapfn = undefined, thisArg = undefined */){var O=toObject(arrayLike);var C=typeof this=='function'?this:Array;var argumentsLength=arguments.length;var mapfn=argumentsLength>1?arguments[1]:undefined;var mapping=mapfn!==undefined;var iteratorMethod=getIteratorMethod$1(O);var index=0;var length,result,step,iterator,next,value;if(mapping)mapfn=functionBindContext(mapfn,argumentsLength>2?arguments[2]:undefined,2);// if the target is not iterable or it's an array with the default iterator - use a simple case
if(iteratorMethod!=undefined&&!(C==Array&&isArrayIteratorMethod(iteratorMethod))){iterator=iteratorMethod.call(O);next=iterator.next;result=new C();for(;!(step=next.call(iterator)).done;index++){value=mapping?callWithSafeIterationClosing(iterator,mapfn,[step.value,index],true):step.value;createProperty(result,index,value);}}else{length=toLength(O.length);result=new C(length);for(;length>index;index++){value=mapping?mapfn(O[index],index):O[index];createProperty(result,index,value);}}result.length=index;return result;};var ITERATOR=wellKnownSymbol('iterator');var SAFE_CLOSING=false;try{var called=0;var iteratorWithReturn={next:function(){return{done:!!called++};},'return':function(){SAFE_CLOSING=true;}};iteratorWithReturn[ITERATOR]=function(){return this;};// eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
Array.from(iteratorWithReturn,function(){throw 2;});}catch(error){/* empty */}var checkCorrectnessOfIteration=function(exec,SKIP_CLOSING){if(!SKIP_CLOSING&&!SAFE_CLOSING)return false;var ITERATION_SUPPORT=false;try{var object={};object[ITERATOR]=function(){return{next:function(){return{done:ITERATION_SUPPORT=true};}};};exec(object);}catch(error){/* empty */}return ITERATION_SUPPORT;};var INCORRECT_ITERATION=!checkCorrectnessOfIteration(function(iterable){// eslint-disable-next-line es/no-array-from -- required for testing
Array.from(iterable);});// `Array.from` method
// https://tc39.es/ecma262/#sec-array.from
_export({target:'Array',stat:true,forced:INCORRECT_ITERATION},{from:arrayFrom});var from$4=path.Array.from;var from$3=from$4;var from$2=from$3;var ARRAY_ITERATOR='Array Iterator';var setInternalState$4=internalState.set;var getInternalState$1=internalState.getterFor(ARRAY_ITERATOR);// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
defineIterator(Array,'Array',function(iterated,kind){setInternalState$4(this,{type:ARRAY_ITERATOR,target:toIndexedObject(iterated),// target
index:0,// next index
kind:kind// kind
});// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
},function(){var state=getInternalState$1(this);var target=state.target;var kind=state.kind;var index=state.index++;if(!target||index>=target.length){state.target=undefined;return{value:undefined,done:true};}if(kind=='keys')return{value:index,done:false};if(kind=='values')return{value:target[index],done:false};return{value:[index,target[index]],done:false};},'values');// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
iterators.Arguments=iterators.Array;// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
var domIterables={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0};var TO_STRING_TAG=wellKnownSymbol('toStringTag');for(var COLLECTION_NAME in domIterables){var Collection=global$1[COLLECTION_NAME];var CollectionPrototype=Collection&&Collection.prototype;if(CollectionPrototype&&classof(CollectionPrototype)!==TO_STRING_TAG){createNonEnumerableProperty(CollectionPrototype,TO_STRING_TAG,COLLECTION_NAME);}iterators[COLLECTION_NAME]=iterators.Array;}var getIteratorMethod_1=getIteratorMethod$1;var getIteratorMethod=getIteratorMethod_1;// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
var isArray$5=Array.isArray||function isArray(arg){return classofRaw(arg)=='Array';};var hiddenKeys=enumBugKeys.concat('length','prototype');// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
var f$2=Object.getOwnPropertyNames||function getOwnPropertyNames(O){return objectKeysInternal(O,hiddenKeys);};var objectGetOwnPropertyNames={f:f$2};/* eslint-disable es/no-object-getownpropertynames -- safe */var $getOwnPropertyNames$1=objectGetOwnPropertyNames.f;var toString={}.toString;var windowNames=typeof window=='object'&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];var getWindowNames=function(it){try{return $getOwnPropertyNames$1(it);}catch(error){return windowNames.slice();}};// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var f$1=function getOwnPropertyNames(it){return windowNames&&toString.call(it)=='[object Window]'?getWindowNames(it):$getOwnPropertyNames$1(toIndexedObject(it));};var objectGetOwnPropertyNamesExternal={f:f$1};var f=wellKnownSymbol;var wellKnownSymbolWrapped={f:f};var defineProperty$6=objectDefineProperty.f;var defineWellKnownSymbol=function(NAME){var Symbol=path.Symbol||(path.Symbol={});if(!has$1(Symbol,NAME))defineProperty$6(Symbol,NAME,{value:wellKnownSymbolWrapped.f(NAME)});};var SPECIES$3=wellKnownSymbol('species');// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
var arraySpeciesCreate=function(originalArray,length){var C;if(isArray$5(originalArray)){C=originalArray.constructor;// cross-realm fallback
if(typeof C=='function'&&(C===Array||isArray$5(C.prototype)))C=undefined;else if(isObject$1(C)){C=C[SPECIES$3];if(C===null)C=undefined;}}return new(C===undefined?Array:C)(length===0?0:length);};var push=[].push;// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation
var createMethod$3=function(TYPE){var IS_MAP=TYPE==1;var IS_FILTER=TYPE==2;var IS_SOME=TYPE==3;var IS_EVERY=TYPE==4;var IS_FIND_INDEX=TYPE==6;var IS_FILTER_OUT=TYPE==7;var NO_HOLES=TYPE==5||IS_FIND_INDEX;return function($this,callbackfn,that,specificCreate){var O=toObject($this);var self=indexedObject(O);var boundFunction=functionBindContext(callbackfn,that,3);var length=toLength(self.length);var index=0;var create=specificCreate||arraySpeciesCreate;var target=IS_MAP?create($this,length):IS_FILTER||IS_FILTER_OUT?create($this,0):undefined;var value,result;for(;length>index;index++)if(NO_HOLES||index in self){value=self[index];result=boundFunction(value,index,O);if(TYPE){if(IS_MAP)target[index]=result;// map
else if(result)switch(TYPE){case 3:return true;// some
case 5:return value;// find
case 6:return index;// findIndex
case 2:push.call(target,value);// filter
}else switch(TYPE){case 4:return false;// every
case 7:push.call(target,value);// filterOut
}}}return IS_FIND_INDEX?-1:IS_SOME||IS_EVERY?IS_EVERY:target;};};var arrayIteration={// `Array.prototype.forEach` method
// https://tc39.es/ecma262/#sec-array.prototype.foreach
forEach:createMethod$3(0),// `Array.prototype.map` method
// https://tc39.es/ecma262/#sec-array.prototype.map
map:createMethod$3(1),// `Array.prototype.filter` method
// https://tc39.es/ecma262/#sec-array.prototype.filter
filter:createMethod$3(2),// `Array.prototype.some` method
// https://tc39.es/ecma262/#sec-array.prototype.some
some:createMethod$3(3),// `Array.prototype.every` method
// https://tc39.es/ecma262/#sec-array.prototype.every
every:createMethod$3(4),// `Array.prototype.find` method
// https://tc39.es/ecma262/#sec-array.prototype.find
find:createMethod$3(5),// `Array.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-array.prototype.findIndex
findIndex:createMethod$3(6),// `Array.prototype.filterOut` method
// https://github.com/tc39/proposal-array-filtering
filterOut:createMethod$3(7)};var $forEach$1=arrayIteration.forEach;var HIDDEN=sharedKey('hidden');var SYMBOL='Symbol';var PROTOTYPE='prototype';var TO_PRIMITIVE=wellKnownSymbol('toPrimitive');var setInternalState$3=internalState.set;var getInternalState=internalState.getterFor(SYMBOL);var ObjectPrototype=Object[PROTOTYPE];var $Symbol=global$1.Symbol;var $stringify$1=getBuiltIn('JSON','stringify');var nativeGetOwnPropertyDescriptor$1=objectGetOwnPropertyDescriptor.f;var nativeDefineProperty=objectDefineProperty.f;var nativeGetOwnPropertyNames=objectGetOwnPropertyNamesExternal.f;var nativePropertyIsEnumerable=objectPropertyIsEnumerable.f;var AllSymbols=shared('symbols');var ObjectPrototypeSymbols=shared('op-symbols');var StringToSymbolRegistry=shared('string-to-symbol-registry');var SymbolToStringRegistry=shared('symbol-to-string-registry');var WellKnownSymbolsStore=shared('wks');var QObject=global$1.QObject;// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER=!QObject||!QObject[PROTOTYPE]||!QObject[PROTOTYPE].findChild;// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor=descriptors&&fails(function(){return objectCreate(nativeDefineProperty({},'a',{get:function(){return nativeDefineProperty(this,'a',{value:7}).a;}})).a!=7;})?function(O,P,Attributes){var ObjectPrototypeDescriptor=nativeGetOwnPropertyDescriptor$1(ObjectPrototype,P);if(ObjectPrototypeDescriptor)delete ObjectPrototype[P];nativeDefineProperty(O,P,Attributes);if(ObjectPrototypeDescriptor&&O!==ObjectPrototype){nativeDefineProperty(ObjectPrototype,P,ObjectPrototypeDescriptor);}}:nativeDefineProperty;var wrap$1=function(tag,description){var symbol=AllSymbols[tag]=objectCreate($Symbol[PROTOTYPE]);setInternalState$3(symbol,{type:SYMBOL,tag:tag,description:description});if(!descriptors)symbol.description=description;return symbol;};var isSymbol=useSymbolAsUid?function(it){return typeof it=='symbol';}:function(it){return Object(it)instanceof $Symbol;};var $defineProperty=function defineProperty(O,P,Attributes){if(O===ObjectPrototype)$defineProperty(ObjectPrototypeSymbols,P,Attributes);anObject(O);var key=toPrimitive(P,true);anObject(Attributes);if(has$1(AllSymbols,key)){if(!Attributes.enumerable){if(!has$1(O,HIDDEN))nativeDefineProperty(O,HIDDEN,createPropertyDescriptor(1,{}));O[HIDDEN][key]=true;}else{if(has$1(O,HIDDEN)&&O[HIDDEN][key])O[HIDDEN][key]=false;Attributes=objectCreate(Attributes,{enumerable:createPropertyDescriptor(0,false)});}return setSymbolDescriptor(O,key,Attributes);}return nativeDefineProperty(O,key,Attributes);};var $defineProperties=function defineProperties(O,Properties){anObject(O);var properties=toIndexedObject(Properties);var keys=objectKeys(properties).concat($getOwnPropertySymbols(properties));$forEach$1(keys,function(key){if(!descriptors||$propertyIsEnumerable.call(properties,key))$defineProperty(O,key,properties[key]);});return O;};var $create=function create(O,Properties){return Properties===undefined?objectCreate(O):$defineProperties(objectCreate(O),Properties);};var $propertyIsEnumerable=function propertyIsEnumerable(V){var P=toPrimitive(V,true);var enumerable=nativePropertyIsEnumerable.call(this,P);if(this===ObjectPrototype&&has$1(AllSymbols,P)&&!has$1(ObjectPrototypeSymbols,P))return false;return enumerable||!has$1(this,P)||!has$1(AllSymbols,P)||has$1(this,HIDDEN)&&this[HIDDEN][P]?enumerable:true;};var $getOwnPropertyDescriptor=function getOwnPropertyDescriptor(O,P){var it=toIndexedObject(O);var key=toPrimitive(P,true);if(it===ObjectPrototype&&has$1(AllSymbols,key)&&!has$1(ObjectPrototypeSymbols,key))return;var descriptor=nativeGetOwnPropertyDescriptor$1(it,key);if(descriptor&&has$1(AllSymbols,key)&&!(has$1(it,HIDDEN)&&it[HIDDEN][key])){descriptor.enumerable=true;}return descriptor;};var $getOwnPropertyNames=function getOwnPropertyNames(O){var names=nativeGetOwnPropertyNames(toIndexedObject(O));var result=[];$forEach$1(names,function(key){if(!has$1(AllSymbols,key)&&!has$1(hiddenKeys$1,key))result.push(key);});return result;};var $getOwnPropertySymbols=function getOwnPropertySymbols(O){var IS_OBJECT_PROTOTYPE=O===ObjectPrototype;var names=nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE?ObjectPrototypeSymbols:toIndexedObject(O));var result=[];$forEach$1(names,function(key){if(has$1(AllSymbols,key)&&(!IS_OBJECT_PROTOTYPE||has$1(ObjectPrototype,key))){result.push(AllSymbols[key]);}});return result;};// `Symbol` constructor
// https://tc39.es/ecma262/#sec-symbol-constructor
if(!nativeSymbol){$Symbol=function Symbol(){if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor');var description=!arguments.length||arguments[0]===undefined?undefined:String(arguments[0]);var tag=uid(description);var setter=function(value){if(this===ObjectPrototype)setter.call(ObjectPrototypeSymbols,value);if(has$1(this,HIDDEN)&&has$1(this[HIDDEN],tag))this[HIDDEN][tag]=false;setSymbolDescriptor(this,tag,createPropertyDescriptor(1,value));};if(descriptors&&USE_SETTER)setSymbolDescriptor(ObjectPrototype,tag,{configurable:true,set:setter});return wrap$1(tag,description);};redefine($Symbol[PROTOTYPE],'toString',function toString(){return getInternalState(this).tag;});redefine($Symbol,'withoutSetter',function(description){return wrap$1(uid(description),description);});objectPropertyIsEnumerable.f=$propertyIsEnumerable;objectDefineProperty.f=$defineProperty;objectGetOwnPropertyDescriptor.f=$getOwnPropertyDescriptor;objectGetOwnPropertyNames.f=objectGetOwnPropertyNamesExternal.f=$getOwnPropertyNames;objectGetOwnPropertySymbols.f=$getOwnPropertySymbols;wellKnownSymbolWrapped.f=function(name){return wrap$1(wellKnownSymbol(name),name);};if(descriptors){// https://github.com/tc39/proposal-Symbol-description
nativeDefineProperty($Symbol[PROTOTYPE],'description',{configurable:true,get:function description(){return getInternalState(this).description;}});}}_export({global:true,wrap:true,forced:!nativeSymbol,sham:!nativeSymbol},{Symbol:$Symbol});$forEach$1(objectKeys(WellKnownSymbolsStore),function(name){defineWellKnownSymbol(name);});_export({target:SYMBOL,stat:true,forced:!nativeSymbol},{// `Symbol.for` method
// https://tc39.es/ecma262/#sec-symbol.for
'for':function(key){var string=String(key);if(has$1(StringToSymbolRegistry,string))return StringToSymbolRegistry[string];var symbol=$Symbol(string);StringToSymbolRegistry[string]=symbol;SymbolToStringRegistry[symbol]=string;return symbol;},// `Symbol.keyFor` method
// https://tc39.es/ecma262/#sec-symbol.keyfor
keyFor:function keyFor(sym){if(!isSymbol(sym))throw TypeError(sym+' is not a symbol');if(has$1(SymbolToStringRegistry,sym))return SymbolToStringRegistry[sym];},useSetter:function(){USE_SETTER=true;},useSimple:function(){USE_SETTER=false;}});_export({target:'Object',stat:true,forced:!nativeSymbol,sham:!descriptors},{// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
create:$create,// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
defineProperty:$defineProperty,// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
defineProperties:$defineProperties,// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
getOwnPropertyDescriptor:$getOwnPropertyDescriptor});_export({target:'Object',stat:true,forced:!nativeSymbol},{// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
getOwnPropertyNames:$getOwnPropertyNames,// `Object.getOwnPropertySymbols` method
// https://tc39.es/ecma262/#sec-object.getownpropertysymbols
getOwnPropertySymbols:$getOwnPropertySymbols});// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
_export({target:'Object',stat:true,forced:fails(function(){objectGetOwnPropertySymbols.f(1);})},{getOwnPropertySymbols:function getOwnPropertySymbols(it){return objectGetOwnPropertySymbols.f(toObject(it));}});// `JSON.stringify` method behavior with symbols
// https://tc39.es/ecma262/#sec-json.stringify
if($stringify$1){var FORCED_JSON_STRINGIFY=!nativeSymbol||fails(function(){var symbol=$Symbol();// MS Edge converts symbol values to JSON as {}
return $stringify$1([symbol])!='[null]'// WebKit converts symbol values to JSON as null
||$stringify$1({a:symbol})!='{}'// V8 throws on boxed symbols
||$stringify$1(Object(symbol))!='{}';});_export({target:'JSON',stat:true,forced:FORCED_JSON_STRINGIFY},{// eslint-disable-next-line no-unused-vars -- required for `.length`
stringify:function stringify(it,replacer,space){var args=[it];var index=1;var $replacer;while(arguments.length>index)args.push(arguments[index++]);$replacer=replacer;if(!isObject$1(replacer)&&it===undefined||isSymbol(it))return;// IE8 returns string on undefined
if(!isArray$5(replacer))replacer=function(key,value){if(typeof $replacer=='function')value=$replacer.call(this,key,value);if(!isSymbol(value))return value;};args[1]=replacer;return $stringify$1.apply(null,args);}});}// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
if(!$Symbol[PROTOTYPE][TO_PRIMITIVE]){createNonEnumerableProperty($Symbol[PROTOTYPE],TO_PRIMITIVE,$Symbol[PROTOTYPE].valueOf);}// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol,SYMBOL);hiddenKeys$1[HIDDEN]=true;var getOwnPropertySymbols$2=path.Object.getOwnPropertySymbols;var getOwnPropertySymbols$1=getOwnPropertySymbols$2;var getOwnPropertySymbols=getOwnPropertySymbols$1;var nativeGetOwnPropertyDescriptor=objectGetOwnPropertyDescriptor.f;var FAILS_ON_PRIMITIVES$3=fails(function(){nativeGetOwnPropertyDescriptor(1);});var FORCED$6=!descriptors||FAILS_ON_PRIMITIVES$3;// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
_export({target:'Object',stat:true,forced:FORCED$6,sham:!descriptors},{getOwnPropertyDescriptor:function getOwnPropertyDescriptor(it,key){return nativeGetOwnPropertyDescriptor(toIndexedObject(it),key);}});var getOwnPropertyDescriptor_1=createCommonjsModule(function(module){var Object=path.Object;var getOwnPropertyDescriptor=module.exports=function getOwnPropertyDescriptor(it,key){return Object.getOwnPropertyDescriptor(it,key);};if(Object.getOwnPropertyDescriptor.sham)getOwnPropertyDescriptor.sham=true;});var getOwnPropertyDescriptor$3=getOwnPropertyDescriptor_1;var getOwnPropertyDescriptor$2=getOwnPropertyDescriptor$3;var ownKeys$8=getBuiltIn('Reflect','ownKeys')||function ownKeys(it){var keys=objectGetOwnPropertyNames.f(anObject(it));var getOwnPropertySymbols=objectGetOwnPropertySymbols.f;return getOwnPropertySymbols?keys.concat(getOwnPropertySymbols(it)):keys;};// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
_export({target:'Object',stat:true,sham:!descriptors},{getOwnPropertyDescriptors:function getOwnPropertyDescriptors(object){var O=toIndexedObject(object);var getOwnPropertyDescriptor=objectGetOwnPropertyDescriptor.f;var keys=ownKeys$8(O);var result={};var index=0;var key,descriptor;while(keys.length>index){descriptor=getOwnPropertyDescriptor(O,key=keys[index++]);if(descriptor!==undefined)createProperty(result,key,descriptor);}return result;}});var getOwnPropertyDescriptors$2=path.Object.getOwnPropertyDescriptors;var getOwnPropertyDescriptors$1=getOwnPropertyDescriptors$2;var getOwnPropertyDescriptors=getOwnPropertyDescriptors$1;// https://tc39.es/ecma262/#sec-object.defineproperties
_export({target:'Object',stat:true,forced:!descriptors,sham:!descriptors},{defineProperties:objectDefineProperties});var defineProperties_1=createCommonjsModule(function(module){var Object=path.Object;var defineProperties=module.exports=function defineProperties(T,D){return Object.defineProperties(T,D);};if(Object.defineProperties.sham)defineProperties.sham=true;});var defineProperties$1=defineProperties_1;var defineProperties=defineProperties$1;// https://tc39.es/ecma262/#sec-object.defineproperty
_export({target:'Object',stat:true,forced:!descriptors,sham:!descriptors},{defineProperty:objectDefineProperty.f});var defineProperty_1=createCommonjsModule(function(module){var Object=path.Object;var defineProperty=module.exports=function defineProperty(it,key,desc){return Object.defineProperty(it,key,desc);};if(Object.defineProperty.sham)defineProperty.sham=true;});var defineProperty$5=defineProperty_1;var defineProperty$4=defineProperty$5;function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var defineProperty$3=defineProperty_1;var defineProperty$2=defineProperty$3;function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;defineProperty$2(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}function _defineProperty(obj,key,value){if(key in obj){defineProperty$2(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}// https://tc39.es/ecma262/#sec-array.isarray
_export({target:'Array',stat:true},{isArray:isArray$5});var isArray$4=path.Array.isArray;var isArray$3=isArray$4;var isArray$2=isArray$3;function _arrayWithHoles(arr){if(isArray$2(arr))return arr;}var SPECIES$2=wellKnownSymbol('species');var arrayMethodHasSpeciesSupport=function(METHOD_NAME){// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/677
return engineV8Version>=51||!fails(function(){var array=[];var constructor=array.constructor={};constructor[SPECIES$2]=function(){return{foo:1};};return array[METHOD_NAME](Boolean).foo!==1;});};var IS_CONCAT_SPREADABLE=wellKnownSymbol('isConcatSpreadable');var MAX_SAFE_INTEGER$1=0x1FFFFFFFFFFFFF;var MAXIMUM_ALLOWED_INDEX_EXCEEDED='Maximum allowed index exceeded';// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT=engineV8Version>=51||!fails(function(){var array=[];array[IS_CONCAT_SPREADABLE]=false;return array.concat()[0]!==array;});var SPECIES_SUPPORT=arrayMethodHasSpeciesSupport('concat');var isConcatSpreadable=function(O){if(!isObject$1(O))return false;var spreadable=O[IS_CONCAT_SPREADABLE];return spreadable!==undefined?!!spreadable:isArray$5(O);};var FORCED$5=!IS_CONCAT_SPREADABLE_SUPPORT||!SPECIES_SUPPORT;// `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
_export({target:'Array',proto:true,forced:FORCED$5},{// eslint-disable-next-line no-unused-vars -- required for `.length`
concat:function concat(arg){var O=toObject(this);var A=arraySpeciesCreate(O,0);var n=0;var i,k,length,len,E;for(i=-1,length=arguments.length;i<length;i++){E=i===-1?O:arguments[i];if(isConcatSpreadable(E)){len=toLength(E.length);if(n+len>MAX_SAFE_INTEGER$1)throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);for(k=0;k<len;k++,n++)if(k in E)createProperty(A,n,E[k]);}else{if(n>=MAX_SAFE_INTEGER$1)throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);createProperty(A,n++,E);}}A.length=n;return A;}});// https://tc39.es/ecma262/#sec-symbol.asynciterator
defineWellKnownSymbol('asyncIterator');// https://tc39.es/ecma262/#sec-symbol.hasinstance
defineWellKnownSymbol('hasInstance');// https://tc39.es/ecma262/#sec-symbol.isconcatspreadable
defineWellKnownSymbol('isConcatSpreadable');// https://tc39.es/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');// https://tc39.es/ecma262/#sec-symbol.match
defineWellKnownSymbol('match');// https://tc39.es/ecma262/#sec-symbol.matchall
defineWellKnownSymbol('matchAll');// https://tc39.es/ecma262/#sec-symbol.replace
defineWellKnownSymbol('replace');// https://tc39.es/ecma262/#sec-symbol.search
defineWellKnownSymbol('search');// https://tc39.es/ecma262/#sec-symbol.species
defineWellKnownSymbol('species');// https://tc39.es/ecma262/#sec-symbol.split
defineWellKnownSymbol('split');// https://tc39.es/ecma262/#sec-symbol.toprimitive
defineWellKnownSymbol('toPrimitive');// https://tc39.es/ecma262/#sec-symbol.tostringtag
defineWellKnownSymbol('toStringTag');// https://tc39.es/ecma262/#sec-symbol.unscopables
defineWellKnownSymbol('unscopables');// https://tc39.es/ecma262/#sec-json-@@tostringtag
setToStringTag(global$1.JSON,'JSON',true);var symbol$4=path.Symbol;// https://github.com/tc39/proposal-using-statement
defineWellKnownSymbol('asyncDispose');// https://github.com/tc39/proposal-using-statement
defineWellKnownSymbol('dispose');// https://github.com/tc39/proposal-pattern-matching
defineWellKnownSymbol('matcher');// https://github.com/tc39/proposal-decorators
defineWellKnownSymbol('metadata');// https://github.com/tc39/proposal-observable
defineWellKnownSymbol('observable');// `Symbol.patternMatch` well-known symbol
// https://github.com/tc39/proposal-pattern-matching
defineWellKnownSymbol('patternMatch');defineWellKnownSymbol('replaceAll');// TODO: Remove from `core-js@4`
var symbol$3=symbol$4;var symbol$2=symbol$3;function _iterableToArrayLimit(arr,i){var _i=arr==null?null:typeof symbol$2!=="undefined"&&getIteratorMethod(arr)||arr["@@iterator"];if(_i==null)return;var _arr=[];var _n=true;var _d=false;var _s,_e;try{for(_i=_i.call(arr);!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"]!=null)_i["return"]();}finally{if(_d)throw _e;}}return _arr;}var HAS_SPECIES_SUPPORT$3=arrayMethodHasSpeciesSupport('slice');var SPECIES$1=wellKnownSymbol('species');var nativeSlice=[].slice;var max$1=Math.max;// `Array.prototype.slice` method
// https://tc39.es/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
_export({target:'Array',proto:true,forced:!HAS_SPECIES_SUPPORT$3},{slice:function slice(start,end){var O=toIndexedObject(this);var length=toLength(O.length);var k=toAbsoluteIndex(start,length);var fin=toAbsoluteIndex(end===undefined?length:end,length);// inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
var Constructor,result,n;if(isArray$5(O)){Constructor=O.constructor;// cross-realm fallback
if(typeof Constructor=='function'&&(Constructor===Array||isArray$5(Constructor.prototype))){Constructor=undefined;}else if(isObject$1(Constructor)){Constructor=Constructor[SPECIES$1];if(Constructor===null)Constructor=undefined;}if(Constructor===Array||Constructor===undefined){return nativeSlice.call(O,k,fin);}}result=new(Constructor===undefined?Array:Constructor)(max$1(fin-k,0));for(n=0;k<fin;k++,n++)if(k in O)createProperty(result,n,O[k]);result.length=n;return result;}});var slice$5=entryVirtual('Array').slice;var ArrayPrototype$h=Array.prototype;var slice_1=function(it){var own=it.slice;return it===ArrayPrototype$h||it instanceof Array&&own===ArrayPrototype$h.slice?slice$5:own;};var slice$4=slice_1;var slice$3=slice$4;var from$1=from$4;var from=from$1;function _arrayLikeToArray$9(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}function _unsupportedIterableToArray$9(o,minLen){var _context;if(!o)return;if(typeof o==="string")return _arrayLikeToArray$9(o,minLen);var n=slice$3(_context=Object.prototype.toString.call(o)).call(_context,8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return from(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray$9(o,minLen);}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _slicedToArray(arr,i){return _arrayWithHoles(arr)||_iterableToArrayLimit(arr,i)||_unsupportedIterableToArray$9(arr,i)||_nonIterableRest();}var iterator$4=wellKnownSymbolWrapped.f('iterator');var iterator$3=iterator$4;var iterator$2=iterator$3;function _typeof(obj){"@babel/helpers - typeof";if(typeof symbol$2==="function"&&typeof iterator$2==="symbol"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof symbol$2==="function"&&obj.constructor===symbol$2&&obj!==symbol$2.prototype?"symbol":typeof obj;};}return _typeof(obj);}function _arrayWithoutHoles(arr){if(isArray$2(arr))return _arrayLikeToArray$9(arr);}function _iterableToArray(iter){if(typeof symbol$2!=="undefined"&&getIteratorMethod(iter)!=null||iter["@@iterator"]!=null)return from(iter);}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _toConsumableArray(arr){return _arrayWithoutHoles(arr)||_iterableToArray(arr)||_unsupportedIterableToArray$9(arr)||_nonIterableSpread();}var symbol$1=symbol$4;var symbol=symbol$1;var concat$2=entryVirtual('Array').concat;var ArrayPrototype$g=Array.prototype;var concat_1=function(it){var own=it.concat;return it===ArrayPrototype$g||it instanceof Array&&own===ArrayPrototype$g.concat?concat$2:own;};var concat$1=concat_1;var concat=concat$1;var slice$2=slice_1;var slice$1=slice$2;// https://tc39.es/ecma262/#sec-reflect.ownkeys
_export({target:'Reflect',stat:true},{ownKeys:ownKeys$8});var ownKeys$7=path.Reflect.ownKeys;var ownKeys$6=ownKeys$7;var ownKeys$5=ownKeys$6;var isArray$1=isArray$4;var isArray=isArray$1;var $map=arrayIteration.map;var HAS_SPECIES_SUPPORT$2=arrayMethodHasSpeciesSupport('map');// `Array.prototype.map` method
// https://tc39.es/ecma262/#sec-array.prototype.map
// with adding support of @@species
_export({target:'Array',proto:true,forced:!HAS_SPECIES_SUPPORT$2},{map:function map(callbackfn/* , thisArg */){return $map(this,callbackfn,arguments.length>1?arguments[1]:undefined);}});var map$5=entryVirtual('Array').map;var ArrayPrototype$f=Array.prototype;var map_1=function(it){var own=it.map;return it===ArrayPrototype$f||it instanceof Array&&own===ArrayPrototype$f.map?map$5:own;};var map$4=map_1;var map$3=map$4;var FAILS_ON_PRIMITIVES$2=fails(function(){objectKeys(1);});// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
_export({target:'Object',stat:true,forced:FAILS_ON_PRIMITIVES$2},{keys:function keys(it){return objectKeys(toObject(it));}});var keys$5=path.Object.keys;var keys$4=keys$5;var keys$3=keys$4;// https://tc39.es/ecma262/#sec-date.now
_export({target:'Date',stat:true},{now:function now(){return new Date().getTime();}});var now$3=path.Date.now;var now$2=now$3;var now$1=now$2;var arrayMethodIsStrict=function(METHOD_NAME,argument){var method=[][METHOD_NAME];return!!method&&fails(function(){// eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing
method.call(null,argument||function(){throw 1;},1);});};var $forEach=arrayIteration.forEach;var STRICT_METHOD$5=arrayMethodIsStrict('forEach');// `Array.prototype.forEach` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.foreach
var arrayForEach=!STRICT_METHOD$5?function forEach(callbackfn/* , thisArg */){return $forEach(this,callbackfn,arguments.length>1?arguments[1]:undefined);// eslint-disable-next-line es/no-array-prototype-foreach -- safe
}:[].forEach;// https://tc39.es/ecma262/#sec-array.prototype.foreach
// eslint-disable-next-line es/no-array-prototype-foreach -- safe
_export({target:'Array',proto:true,forced:[].forEach!=arrayForEach},{forEach:arrayForEach});var forEach$4=entryVirtual('Array').forEach;var forEach$3=forEach$4;var ArrayPrototype$e=Array.prototype;var DOMIterables$3={DOMTokenList:true,NodeList:true};var forEach_1=function(it){var own=it.forEach;return it===ArrayPrototype$e||it instanceof Array&&own===ArrayPrototype$e.forEach// eslint-disable-next-line no-prototype-builtins -- safe
||DOMIterables$3.hasOwnProperty(classof(it))?forEach$3:own;};var forEach$2=forEach_1;var nativeReverse=[].reverse;var test$1=[1,2];// `Array.prototype.reverse` method
// https://tc39.es/ecma262/#sec-array.prototype.reverse
// fix for Safari 12.0 bug
// https://bugs.webkit.org/show_bug.cgi?id=188794
_export({target:'Array',proto:true,forced:String(test$1)===String(test$1.reverse())},{reverse:function reverse(){// eslint-disable-next-line no-self-assign -- dirty hack
if(isArray$5(this))this.length=this.length;return nativeReverse.call(this);}});var reverse$2=entryVirtual('Array').reverse;var ArrayPrototype$d=Array.prototype;var reverse_1=function(it){var own=it.reverse;return it===ArrayPrototype$d||it instanceof Array&&own===ArrayPrototype$d.reverse?reverse$2:own;};var reverse$1=reverse_1;var reverse=reverse$1;var HAS_SPECIES_SUPPORT$1=arrayMethodHasSpeciesSupport('splice');var max=Math.max;var min=Math.min;var MAX_SAFE_INTEGER=0x1FFFFFFFFFFFFF;var MAXIMUM_ALLOWED_LENGTH_EXCEEDED='Maximum allowed length exceeded';// `Array.prototype.splice` method
// https://tc39.es/ecma262/#sec-array.prototype.splice
// with adding support of @@species
_export({target:'Array',proto:true,forced:!HAS_SPECIES_SUPPORT$1},{splice:function splice(start,deleteCount/* , ...items */){var O=toObject(this);var len=toLength(O.length);var actualStart=toAbsoluteIndex(start,len);var argumentsLength=arguments.length;var insertCount,actualDeleteCount,A,k,from,to;if(argumentsLength===0){insertCount=actualDeleteCount=0;}else if(argumentsLength===1){insertCount=0;actualDeleteCount=len-actualStart;}else{insertCount=argumentsLength-2;actualDeleteCount=min(max(toInteger(deleteCount),0),len-actualStart);}if(len+insertCount-actualDeleteCount>MAX_SAFE_INTEGER){throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);}A=arraySpeciesCreate(O,actualDeleteCount);for(k=0;k<actualDeleteCount;k++){from=actualStart+k;if(from in O)createProperty(A,k,O[from]);}A.length=actualDeleteCount;if(insertCount<actualDeleteCount){for(k=actualStart;k<len-actualDeleteCount;k++){from=k+actualDeleteCount;to=k+insertCount;if(from in O)O[to]=O[from];else delete O[to];}for(k=len;k>len-actualDeleteCount+insertCount;k--)delete O[k-1];}else if(insertCount>actualDeleteCount){for(k=len-actualDeleteCount;k>actualStart;k--){from=k+actualDeleteCount-1;to=k+insertCount-1;if(from in O)O[to]=O[from];else delete O[to];}}for(k=0;k<insertCount;k++){O[k+actualStart]=arguments[k+2];}O.length=len-actualDeleteCount+insertCount;return A;}});var splice$2=entryVirtual('Array').splice;var ArrayPrototype$c=Array.prototype;var splice_1=function(it){var own=it.splice;return it===ArrayPrototype$c||it instanceof Array&&own===ArrayPrototype$c.splice?splice$2:own;};var splice$1=splice_1;var splice=splice$1;var $includes=arrayIncludes.includes;// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
_export({target:'Array',proto:true},{includes:function includes(el/* , fromIndex = 0 */){return $includes(this,el,arguments.length>1?arguments[1]:undefined);}});// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
var includes$4=entryVirtual('Array').includes;var MATCH$1=wellKnownSymbol('match');// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
var isRegexp=function(it){var isRegExp;return isObject$1(it)&&((isRegExp=it[MATCH$1])!==undefined?!!isRegExp:classofRaw(it)=='RegExp');};var notARegexp=function(it){if(isRegexp(it)){throw TypeError("The method doesn't accept regular expressions");}return it;};var MATCH=wellKnownSymbol('match');var correctIsRegexpLogic=function(METHOD_NAME){var regexp=/./;try{'/./'[METHOD_NAME](regexp);}catch(error1){try{regexp[MATCH]=false;return'/./'[METHOD_NAME](regexp);}catch(error2){/* empty */}}return false;};// https://tc39.es/ecma262/#sec-string.prototype.includes
_export({target:'String',proto:true,forced:!correctIsRegexpLogic('includes')},{includes:function includes(searchString/* , position = 0 */){return!!~String(requireObjectCoercible(this)).indexOf(notARegexp(searchString),arguments.length>1?arguments[1]:undefined);}});var includes$3=entryVirtual('String').includes;var ArrayPrototype$b=Array.prototype;var StringPrototype=String.prototype;var includes$2=function(it){var own=it.includes;if(it===ArrayPrototype$b||it instanceof Array&&own===ArrayPrototype$b.includes)return includes$4;if(typeof it==='string'||it===StringPrototype||it instanceof String&&own===StringPrototype.includes){return includes$3;}return own;};var includes$1=includes$2;var includes=includes$1;var FAILS_ON_PRIMITIVES$1=fails(function(){objectGetPrototypeOf(1);});// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
_export({target:'Object',stat:true,forced:FAILS_ON_PRIMITIVES$1,sham:!correctPrototypeGetter},{getPrototypeOf:function getPrototypeOf(it){return objectGetPrototypeOf(toObject(it));}});var getPrototypeOf$4=path.Object.getPrototypeOf;var getPrototypeOf$3=getPrototypeOf$4;var getPrototypeOf$2=getPrototypeOf$3;var $filter=arrayIteration.filter;var HAS_SPECIES_SUPPORT=arrayMethodHasSpeciesSupport('filter');// `Array.prototype.filter` method
// https://tc39.es/ecma262/#sec-array.prototype.filter
// with adding support of @@species
_export({target:'Array',proto:true,forced:!HAS_SPECIES_SUPPORT},{filter:function filter(callbackfn/* , thisArg */){return $filter(this,callbackfn,arguments.length>1?arguments[1]:undefined);}});var filter$2=entryVirtual('Array').filter;var ArrayPrototype$a=Array.prototype;var filter_1=function(it){var own=it.filter;return it===ArrayPrototype$a||it instanceof Array&&own===ArrayPrototype$a.filter?filter$2:own;};var filter$1=filter_1;var filter=filter$1;var propertyIsEnumerable=objectPropertyIsEnumerable.f;// `Object.{ entries, values }` methods implementation
var createMethod$2=function(TO_ENTRIES){return function(it){var O=toIndexedObject(it);var keys=objectKeys(O);var length=keys.length;var i=0;var result=[];var key;while(length>i){key=keys[i++];if(!descriptors||propertyIsEnumerable.call(O,key)){result.push(TO_ENTRIES?[key,O[key]]:O[key]);}}return result;};};var objectToArray={// `Object.entries` method
// https://tc39.es/ecma262/#sec-object.entries
entries:createMethod$2(true),// `Object.values` method
// https://tc39.es/ecma262/#sec-object.values
values:createMethod$2(false)};var $values=objectToArray.values;// `Object.values` method
// https://tc39.es/ecma262/#sec-object.values
_export({target:'Object',stat:true},{values:function values(O){return $values(O);}});path.Object.values;// a string of all valid unicode whitespaces
var whitespaces='\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002'+'\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';var whitespace='['+whitespaces+']';var ltrim=RegExp('^'+whitespace+whitespace+'*');var rtrim=RegExp(whitespace+whitespace+'*$');// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod$1=function(TYPE){return function($this){var string=String(requireObjectCoercible($this));if(TYPE&1)string=string.replace(ltrim,'');if(TYPE&2)string=string.replace(rtrim,'');return string;};};var stringTrim={// `String.prototype.{ trimLeft, trimStart }` methods
// https://tc39.es/ecma262/#sec-string.prototype.trimstart
start:createMethod$1(1),// `String.prototype.{ trimRight, trimEnd }` methods
// https://tc39.es/ecma262/#sec-string.prototype.trimend
end:createMethod$1(2),// `String.prototype.trim` method
// https://tc39.es/ecma262/#sec-string.prototype.trim
trim:createMethod$1(3)};var trim$1=stringTrim.trim;var $parseInt=global$1.parseInt;var hex=/^[+-]?0[Xx]/;var FORCED$4=$parseInt(whitespaces+'08')!==8||$parseInt(whitespaces+'0x16')!==22;// `parseInt` method
// https://tc39.es/ecma262/#sec-parseint-string-radix
var numberParseInt=FORCED$4?function parseInt(string,radix){var S=trim$1(String(string));return $parseInt(S,radix>>>0||(hex.test(S)?16:10));}:$parseInt;// https://tc39.es/ecma262/#sec-parseint-string-radix
_export({global:true,forced:parseInt!=numberParseInt},{parseInt:numberParseInt});var _parseInt$2=path.parseInt;var _parseInt$1=_parseInt$2;var _parseInt=_parseInt$1;/* eslint-disable es/no-array-prototype-indexof -- required for testing */var $indexOf=arrayIncludes.indexOf;var nativeIndexOf=[].indexOf;var NEGATIVE_ZERO=!!nativeIndexOf&&1/[1].indexOf(1,-0)<0;var STRICT_METHOD$4=arrayMethodIsStrict('indexOf');// `Array.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-array.prototype.indexof
_export({target:'Array',proto:true,forced:NEGATIVE_ZERO||!STRICT_METHOD$4},{indexOf:function indexOf(searchElement/* , fromIndex = 0 */){return NEGATIVE_ZERO// convert -0 to +0
?nativeIndexOf.apply(this,arguments)||0:$indexOf(this,searchElement,arguments.length>1?arguments[1]:undefined);}});var indexOf$2=entryVirtual('Array').indexOf;var ArrayPrototype$9=Array.prototype;var indexOf_1=function(it){var own=it.indexOf;return it===ArrayPrototype$9||it instanceof Array&&own===ArrayPrototype$9.indexOf?indexOf$2:own;};var indexOf$1=indexOf_1;var indexOf=indexOf$1;var non='\u200B\u0085\u180E';// check that a method works with the correct list
// of whitespaces and has a correct name
var stringTrimForced=function(METHOD_NAME){return fails(function(){return!!whitespaces[METHOD_NAME]()||non[METHOD_NAME]()!=non||whitespaces[METHOD_NAME].name!==METHOD_NAME;});};var $trim=stringTrim.trim;// `String.prototype.trim` method
// https://tc39.es/ecma262/#sec-string.prototype.trim
_export({target:'String',proto:true,forced:stringTrimForced('trim')},{trim:function trim(){return $trim(this);}});entryVirtual('String').trim;// https://tc39.es/ecma262/#sec-object.create
_export({target:'Object',stat:true,sham:!descriptors},{create:objectCreate});var Object$2=path.Object;var create$4=function create(P,D){return Object$2.create(P,D);};var create$3=create$4;var create$2=create$3;var $stringify=getBuiltIn('JSON','stringify');var re=/[\uD800-\uDFFF]/g;var low=/^[\uD800-\uDBFF]$/;var hi=/^[\uDC00-\uDFFF]$/;var fix=function(match,offset,string){var prev=string.charAt(offset-1);var next=string.charAt(offset+1);if(low.test(match)&&!hi.test(next)||hi.test(match)&&!low.test(prev)){return'\\u'+match.charCodeAt(0).toString(16);}return match;};var FORCED$3=fails(function(){return $stringify('\uDF06\uD834')!=='"\\udf06\\ud834"'||$stringify('\uDEAD')!=='"\\udead"';});if($stringify){// `JSON.stringify` method
// https://tc39.es/ecma262/#sec-json.stringify
// https://github.com/tc39/proposal-well-formed-stringify
_export({target:'JSON',stat:true,forced:FORCED$3},{// eslint-disable-next-line no-unused-vars -- required for `.length`
stringify:function stringify(it,replacer,space){var result=$stringify.apply(null,arguments);return typeof result=='string'?result.replace(re,fix):result;}});}if(!path.JSON)path.JSON={stringify:JSON.stringify};// eslint-disable-next-line no-unused-vars -- required for `.length`
var stringify$3=function stringify(it,replacer,space){return path.JSON.stringify.apply(null,arguments);};var stringify$2=stringify$3;var stringify$1=stringify$2;var slice=[].slice;var MSIE=/MSIE .\./.test(engineUserAgent);// <- dirty ie9- check
var wrap=function(scheduler){return function(handler,timeout/* , ...arguments */){var boundArgs=arguments.length>2;var args=boundArgs?slice.call(arguments,2):undefined;return scheduler(boundArgs?function(){// eslint-disable-next-line no-new-func -- spec requirement
(typeof handler=='function'?handler:Function(handler)).apply(this,args);}:handler,timeout);};};// ie9- setTimeout & setInterval additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
_export({global:true,bind:true,forced:MSIE},{// `setTimeout` method
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
setTimeout:wrap(global$1.setTimeout),// `setInterval` method
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
setInterval:wrap(global$1.setInterval)});var setTimeout$2=path.setTimeout;var setTimeout$1=setTimeout$2;// https://tc39.es/ecma262/#sec-array.prototype.fill
var arrayFill=function fill(value/* , start = 0, end = @length */){var O=toObject(this);var length=toLength(O.length);var argumentsLength=arguments.length;var index=toAbsoluteIndex(argumentsLength>1?arguments[1]:undefined,length);var end=argumentsLength>2?arguments[2]:undefined;var endPos=end===undefined?length:toAbsoluteIndex(end,length);while(endPos>index)O[index++]=value;return O;};// https://tc39.es/ecma262/#sec-array.prototype.fill
_export({target:'Array',proto:true},{fill:arrayFill});// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
var fill$2=entryVirtual('Array').fill;var ArrayPrototype$8=Array.prototype;var fill_1=function(it){var own=it.fill;return it===ArrayPrototype$8||it instanceof Array&&own===ArrayPrototype$8.fill?fill$2:own;};var fill$1=fill_1;var fill=fill$1;/*! Hammer.JS - v2.0.17-rc - 2019-12-16
 * http://naver.github.io/egjs
 *
 * Forked By Naver egjs
 * Copyright (c) hammerjs
 * Licensed under the MIT license */function _extends(){_extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};return _extends.apply(this,arguments);}function _inheritsLoose(subClass,superClass){subClass.prototype=Object.create(superClass.prototype);subClass.prototype.constructor=subClass;subClass.__proto__=superClass;}function _assertThisInitialized$1(self){if(self===void 0){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}/**
 * @private
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */var assign;if(typeof Object.assign!=='function'){assign=function assign(target){if(target===undefined||target===null){throw new TypeError('Cannot convert undefined or null to object');}var output=Object(target);for(var index=1;index<arguments.length;index++){var source=arguments[index];if(source!==undefined&&source!==null){for(var nextKey in source){if(source.hasOwnProperty(nextKey)){output[nextKey]=source[nextKey];}}}}return output;};}else{assign=Object.assign;}var assign$1=assign;var VENDOR_PREFIXES=['','webkit','Moz','MS','ms','o'];var TEST_ELEMENT=typeof document==="undefined"?{style:{}}:document.createElement('div');var TYPE_FUNCTION='function';var round=Math.round,abs$1=Math.abs;var now=Date.now;/**
 * @private
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */function prefixed(obj,property){var prefix;var prop;var camelProp=property[0].toUpperCase()+property.slice(1);var i=0;while(i<VENDOR_PREFIXES.length){prefix=VENDOR_PREFIXES[i];prop=prefix?prefix+camelProp:property;if(prop in obj){return prop;}i++;}return undefined;}/* eslint-disable no-new-func, no-nested-ternary */var win;if(typeof window==="undefined"){// window is undefined in node.js
win={};}else{win=window;}var PREFIXED_TOUCH_ACTION=prefixed(TEST_ELEMENT.style,'touchAction');var NATIVE_TOUCH_ACTION=PREFIXED_TOUCH_ACTION!==undefined;function getTouchActionProps(){if(!NATIVE_TOUCH_ACTION){return false;}var touchMap={};var cssSupports=win.CSS&&win.CSS.supports;['auto','manipulation','pan-y','pan-x','pan-x pan-y','none'].forEach(function(val){// If css.supports is not supported but there is native touch-action assume it supports
// all values. This is the case for IE 10 and 11.
return touchMap[val]=cssSupports?win.CSS.supports('touch-action',val):true;});return touchMap;}var TOUCH_ACTION_COMPUTE='compute';var TOUCH_ACTION_AUTO='auto';var TOUCH_ACTION_MANIPULATION='manipulation';// not implemented
var TOUCH_ACTION_NONE='none';var TOUCH_ACTION_PAN_X='pan-x';var TOUCH_ACTION_PAN_Y='pan-y';var TOUCH_ACTION_MAP=getTouchActionProps();var MOBILE_REGEX=/mobile|tablet|ip(ad|hone|od)|android/i;var SUPPORT_TOUCH=('ontouchstart'in win);var SUPPORT_POINTER_EVENTS=prefixed(win,'PointerEvent')!==undefined;var SUPPORT_ONLY_TOUCH=SUPPORT_TOUCH&&MOBILE_REGEX.test(navigator.userAgent);var INPUT_TYPE_TOUCH='touch';var INPUT_TYPE_PEN='pen';var INPUT_TYPE_MOUSE='mouse';var INPUT_TYPE_KINECT='kinect';var COMPUTE_INTERVAL=25;var INPUT_START=1;var INPUT_MOVE=2;var INPUT_END=4;var INPUT_CANCEL=8;var DIRECTION_NONE=1;var DIRECTION_LEFT=2;var DIRECTION_RIGHT=4;var DIRECTION_UP=8;var DIRECTION_DOWN=16;var DIRECTION_HORIZONTAL=DIRECTION_LEFT|DIRECTION_RIGHT;var DIRECTION_VERTICAL=DIRECTION_UP|DIRECTION_DOWN;var DIRECTION_ALL=DIRECTION_HORIZONTAL|DIRECTION_VERTICAL;var PROPS_XY=['x','y'];var PROPS_CLIENT_XY=['clientX','clientY'];/**
 * @private
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */function each(obj,iterator,context){var i;if(!obj){return;}if(obj.forEach){obj.forEach(iterator,context);}else if(obj.length!==undefined){i=0;while(i<obj.length){iterator.call(context,obj[i],i,obj);i++;}}else{for(i in obj){obj.hasOwnProperty(i)&&iterator.call(context,obj[i],i,obj);}}}/**
 * @private
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */function boolOrFn(val,args){if(typeof val===TYPE_FUNCTION){return val.apply(args?args[0]||undefined:undefined,args);}return val;}/**
 * @private
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */function inStr(str,find){return str.indexOf(find)>-1;}/**
 * @private
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */function cleanTouchActions(actions){// none
if(inStr(actions,TOUCH_ACTION_NONE)){return TOUCH_ACTION_NONE;}var hasPanX=inStr(actions,TOUCH_ACTION_PAN_X);var hasPanY=inStr(actions,TOUCH_ACTION_PAN_Y);// if both pan-x and pan-y are set (different recognizers
// for different directions, e.g. horizontal pan but vertical swipe?)
// we need none (as otherwise with pan-x pan-y combined none of these
// recognizers will work, since the browser would handle all panning
if(hasPanX&&hasPanY){return TOUCH_ACTION_NONE;}// pan-x OR pan-y
if(hasPanX||hasPanY){return hasPanX?TOUCH_ACTION_PAN_X:TOUCH_ACTION_PAN_Y;}// manipulation
if(inStr(actions,TOUCH_ACTION_MANIPULATION)){return TOUCH_ACTION_MANIPULATION;}return TOUCH_ACTION_AUTO;}/**
 * @private
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */var TouchAction=/*#__PURE__*/function(){function TouchAction(manager,value){this.manager=manager;this.set(value);}/**
   * @private
   * set the touchAction value on the element or enable the polyfill
   * @param {String} value
   */var _proto=TouchAction.prototype;_proto.set=function set(value){// find out the touch-action by the event handlers
if(value===TOUCH_ACTION_COMPUTE){value=this.compute();}if(NATIVE_TOUCH_ACTION&&this.manager.element.style&&TOUCH_ACTION_MAP[value]){this.manager.element.style[PREFIXED_TOUCH_ACTION]=value;}this.actions=value.toLowerCase().trim();};/**
   * @private
   * just re-set the touchAction value
   */_proto.update=function update(){this.set(this.manager.options.touchAction);};/**
   * @private
   * compute the value for the touchAction property based on the recognizer's settings
   * @returns {String} value
   */_proto.compute=function compute(){var actions=[];each(this.manager.recognizers,function(recognizer){if(boolOrFn(recognizer.options.enable,[recognizer])){actions=actions.concat(recognizer.getTouchAction());}});return cleanTouchActions(actions.join(' '));};/**
   * @private
   * this method is called on each input cycle and provides the preventing of the browser behavior
   * @param {Object} input
   */_proto.preventDefaults=function preventDefaults(input){var srcEvent=input.srcEvent;var direction=input.offsetDirection;// if the touch action did prevented once this session
if(this.manager.session.prevented){srcEvent.preventDefault();return;}var actions=this.actions;var hasNone=inStr(actions,TOUCH_ACTION_NONE)&&!TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];var hasPanY=inStr(actions,TOUCH_ACTION_PAN_Y)&&!TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];var hasPanX=inStr(actions,TOUCH_ACTION_PAN_X)&&!TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];if(hasNone){// do not prevent defaults if this is a tap gesture
var isTapPointer=input.pointers.length===1;var isTapMovement=input.distance<2;var isTapTouchTime=input.deltaTime<250;if(isTapPointer&&isTapMovement&&isTapTouchTime){return;}}if(hasPanX&&hasPanY){// `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
return;}if(hasNone||hasPanY&&direction&DIRECTION_HORIZONTAL||hasPanX&&direction&DIRECTION_VERTICAL){return this.preventSrc(srcEvent);}};/**
   * @private
   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
   * @param {Object} srcEvent
   */_proto.preventSrc=function preventSrc(srcEvent){this.manager.session.prevented=true;srcEvent.preventDefault();};return TouchAction;}();/**
 * @private
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */function hasParent(node,parent){while(node){if(node===parent){return true;}node=node.parentNode;}return false;}/**
 * @private
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */function getCenter(pointers){var pointersLength=pointers.length;// no need to loop when only one touch
if(pointersLength===1){return{x:round(pointers[0].clientX),y:round(pointers[0].clientY)};}var x=0;var y=0;var i=0;while(i<pointersLength){x+=pointers[i].clientX;y+=pointers[i].clientY;i++;}return{x:round(x/pointersLength),y:round(y/pointersLength)};}/**
 * @private
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */function simpleCloneInputData(input){// make a simple copy of the pointers because we will get a reference if we don't
// we only need clientXY for the calculations
var pointers=[];var i=0;while(i<input.pointers.length){pointers[i]={clientX:round(input.pointers[i].clientX),clientY:round(input.pointers[i].clientY)};i++;}return{timeStamp:now(),pointers:pointers,center:getCenter(pointers),deltaX:input.deltaX,deltaY:input.deltaY};}/**
 * @private
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */function getDistance(p1,p2,props){if(!props){props=PROPS_XY;}var x=p2[props[0]]-p1[props[0]];var y=p2[props[1]]-p1[props[1]];return Math.sqrt(x*x+y*y);}/**
 * @private
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */function getAngle(p1,p2,props){if(!props){props=PROPS_XY;}var x=p2[props[0]]-p1[props[0]];var y=p2[props[1]]-p1[props[1]];return Math.atan2(y,x)*180/Math.PI;}/**
 * @private
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */function getDirection(x,y){if(x===y){return DIRECTION_NONE;}if(abs$1(x)>=abs$1(y)){return x<0?DIRECTION_LEFT:DIRECTION_RIGHT;}return y<0?DIRECTION_UP:DIRECTION_DOWN;}function computeDeltaXY(session,input){var center=input.center;// let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;
// jscs throwing error on defalut destructured values and without defaults tests fail
var offset=session.offsetDelta||{};var prevDelta=session.prevDelta||{};var prevInput=session.prevInput||{};if(input.eventType===INPUT_START||prevInput.eventType===INPUT_END){prevDelta=session.prevDelta={x:prevInput.deltaX||0,y:prevInput.deltaY||0};offset=session.offsetDelta={x:center.x,y:center.y};}input.deltaX=prevDelta.x+(center.x-offset.x);input.deltaY=prevDelta.y+(center.y-offset.y);}/**
 * @private
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */function getVelocity(deltaTime,x,y){return{x:x/deltaTime||0,y:y/deltaTime||0};}/**
 * @private
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */function getScale(start,end){return getDistance(end[0],end[1],PROPS_CLIENT_XY)/getDistance(start[0],start[1],PROPS_CLIENT_XY);}/**
 * @private
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */function getRotation(start,end){return getAngle(end[1],end[0],PROPS_CLIENT_XY)+getAngle(start[1],start[0],PROPS_CLIENT_XY);}/**
 * @private
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */function computeIntervalInputData(session,input){var last=session.lastInterval||input;var deltaTime=input.timeStamp-last.timeStamp;var velocity;var velocityX;var velocityY;var direction;if(input.eventType!==INPUT_CANCEL&&(deltaTime>COMPUTE_INTERVAL||last.velocity===undefined)){var deltaX=input.deltaX-last.deltaX;var deltaY=input.deltaY-last.deltaY;var v=getVelocity(deltaTime,deltaX,deltaY);velocityX=v.x;velocityY=v.y;velocity=abs$1(v.x)>abs$1(v.y)?v.x:v.y;direction=getDirection(deltaX,deltaY);session.lastInterval=input;}else{// use latest velocity info if it doesn't overtake a minimum period
velocity=last.velocity;velocityX=last.velocityX;velocityY=last.velocityY;direction=last.direction;}input.velocity=velocity;input.velocityX=velocityX;input.velocityY=velocityY;input.direction=direction;}/**
* @private
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */function computeInputData(manager,input){var session=manager.session;var pointers=input.pointers;var pointersLength=pointers.length;// store the first input to calculate the distance and direction
if(!session.firstInput){session.firstInput=simpleCloneInputData(input);}// to compute scale and rotation we need to store the multiple touches
if(pointersLength>1&&!session.firstMultiple){session.firstMultiple=simpleCloneInputData(input);}else if(pointersLength===1){session.firstMultiple=false;}var firstInput=session.firstInput,firstMultiple=session.firstMultiple;var offsetCenter=firstMultiple?firstMultiple.center:firstInput.center;var center=input.center=getCenter(pointers);input.timeStamp=now();input.deltaTime=input.timeStamp-firstInput.timeStamp;input.angle=getAngle(offsetCenter,center);input.distance=getDistance(offsetCenter,center);computeDeltaXY(session,input);input.offsetDirection=getDirection(input.deltaX,input.deltaY);var overallVelocity=getVelocity(input.deltaTime,input.deltaX,input.deltaY);input.overallVelocityX=overallVelocity.x;input.overallVelocityY=overallVelocity.y;input.overallVelocity=abs$1(overallVelocity.x)>abs$1(overallVelocity.y)?overallVelocity.x:overallVelocity.y;input.scale=firstMultiple?getScale(firstMultiple.pointers,pointers):1;input.rotation=firstMultiple?getRotation(firstMultiple.pointers,pointers):0;input.maxPointers=!session.prevInput?input.pointers.length:input.pointers.length>session.prevInput.maxPointers?input.pointers.length:session.prevInput.maxPointers;computeIntervalInputData(session,input);// find the correct target
var target=manager.element;var srcEvent=input.srcEvent;var srcEventTarget;if(srcEvent.composedPath){srcEventTarget=srcEvent.composedPath()[0];}else if(srcEvent.path){srcEventTarget=srcEvent.path[0];}else{srcEventTarget=srcEvent.target;}if(hasParent(srcEventTarget,target)){target=srcEventTarget;}input.target=target;}/**
 * @private
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */function inputHandler(manager,eventType,input){var pointersLen=input.pointers.length;var changedPointersLen=input.changedPointers.length;var isFirst=eventType&INPUT_START&&pointersLen-changedPointersLen===0;var isFinal=eventType&(INPUT_END|INPUT_CANCEL)&&pointersLen-changedPointersLen===0;input.isFirst=!!isFirst;input.isFinal=!!isFinal;if(isFirst){manager.session={};}// source event is the normalized value of the domEvents
// like 'touchstart, mouseup, pointerdown'
input.eventType=eventType;// compute scale, rotation etc
computeInputData(manager,input);// emit secret event
manager.emit('hammer.input',input);manager.recognize(input);manager.session.prevInput=input;}/**
 * @private
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */function splitStr(str){return str.trim().split(/\s+/g);}/**
 * @private
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */function addEventListeners(target,types,handler){each(splitStr(types),function(type){target.addEventListener(type,handler,false);});}/**
 * @private
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */function removeEventListeners(target,types,handler){each(splitStr(types),function(type){target.removeEventListener(type,handler,false);});}/**
 * @private
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */function getWindowForElement(element){var doc=element.ownerDocument||element;return doc.defaultView||doc.parentWindow||window;}/**
 * @private
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */var Input=/*#__PURE__*/function(){function Input(manager,callback){var self=this;this.manager=manager;this.callback=callback;this.element=manager.element;this.target=manager.options.inputTarget;// smaller wrapper around the handler, for the scope and the enabled state of the manager,
// so when disabled the input events are completely bypassed.
this.domHandler=function(ev){if(boolOrFn(manager.options.enable,[manager])){self.handler(ev);}};this.init();}/**
   * @private
   * should handle the inputEvent data and trigger the callback
   * @virtual
   */var _proto=Input.prototype;_proto.handler=function handler(){};/**
   * @private
   * bind the events
   */_proto.init=function init(){this.evEl&&addEventListeners(this.element,this.evEl,this.domHandler);this.evTarget&&addEventListeners(this.target,this.evTarget,this.domHandler);this.evWin&&addEventListeners(getWindowForElement(this.element),this.evWin,this.domHandler);};/**
   * @private
   * unbind the events
   */_proto.destroy=function destroy(){this.evEl&&removeEventListeners(this.element,this.evEl,this.domHandler);this.evTarget&&removeEventListeners(this.target,this.evTarget,this.domHandler);this.evWin&&removeEventListeners(getWindowForElement(this.element),this.evWin,this.domHandler);};return Input;}();/**
 * @private
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */function inArray(src,find,findByKey){if(src.indexOf&&!findByKey){return src.indexOf(find);}else{var i=0;while(i<src.length){if(findByKey&&src[i][findByKey]==find||!findByKey&&src[i]===find){// do not use === here, test fails
return i;}i++;}return-1;}}var POINTER_INPUT_MAP={pointerdown:INPUT_START,pointermove:INPUT_MOVE,pointerup:INPUT_END,pointercancel:INPUT_CANCEL,pointerout:INPUT_CANCEL};// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM={2:INPUT_TYPE_TOUCH,3:INPUT_TYPE_PEN,4:INPUT_TYPE_MOUSE,5:INPUT_TYPE_KINECT// see https://twitter.com/jacobrossi/status/480596438489890816
};var POINTER_ELEMENT_EVENTS='pointerdown';var POINTER_WINDOW_EVENTS='pointermove pointerup pointercancel';// IE10 has prefixed support, and case-sensitive
if(win.MSPointerEvent&&!win.PointerEvent){POINTER_ELEMENT_EVENTS='MSPointerDown';POINTER_WINDOW_EVENTS='MSPointerMove MSPointerUp MSPointerCancel';}/**
 * @private
 * Pointer events input
 * @constructor
 * @extends Input
 */var PointerEventInput=/*#__PURE__*/function(_Input){_inheritsLoose(PointerEventInput,_Input);function PointerEventInput(){var _this;var proto=PointerEventInput.prototype;proto.evEl=POINTER_ELEMENT_EVENTS;proto.evWin=POINTER_WINDOW_EVENTS;_this=_Input.apply(this,arguments)||this;_this.store=_this.manager.session.pointerEvents=[];return _this;}/**
   * @private
   * handle mouse events
   * @param {Object} ev
   */var _proto=PointerEventInput.prototype;_proto.handler=function handler(ev){var store=this.store;var removePointer=false;var eventTypeNormalized=ev.type.toLowerCase().replace('ms','');var eventType=POINTER_INPUT_MAP[eventTypeNormalized];var pointerType=IE10_POINTER_TYPE_ENUM[ev.pointerType]||ev.pointerType;var isTouch=pointerType===INPUT_TYPE_TOUCH;// get index of the event in the store
var storeIndex=inArray(store,ev.pointerId,'pointerId');// start and mouse must be down
if(eventType&INPUT_START&&(ev.button===0||isTouch)){if(storeIndex<0){store.push(ev);storeIndex=store.length-1;}}else if(eventType&(INPUT_END|INPUT_CANCEL)){removePointer=true;}// it not found, so the pointer hasn't been down (so it's probably a hover)
if(storeIndex<0){return;}// update the event in the store
store[storeIndex]=ev;this.callback(this.manager,eventType,{pointers:store,changedPointers:[ev],pointerType:pointerType,srcEvent:ev});if(removePointer){// remove from the store
store.splice(storeIndex,1);}};return PointerEventInput;}(Input);/**
 * @private
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */function toArray(obj){return Array.prototype.slice.call(obj,0);}/**
 * @private
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */function uniqueArray(src,key,sort){var results=[];var values=[];var i=0;while(i<src.length){var val=key?src[i][key]:src[i];if(inArray(values,val)<0){results.push(src[i]);}values[i]=val;i++;}if(sort){if(!key){results=results.sort();}else{results=results.sort(function(a,b){return a[key]>b[key];});}}return results;}var TOUCH_INPUT_MAP={touchstart:INPUT_START,touchmove:INPUT_MOVE,touchend:INPUT_END,touchcancel:INPUT_CANCEL};var TOUCH_TARGET_EVENTS='touchstart touchmove touchend touchcancel';/**
 * @private
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */var TouchInput=/*#__PURE__*/function(_Input){_inheritsLoose(TouchInput,_Input);function TouchInput(){var _this;TouchInput.prototype.evTarget=TOUCH_TARGET_EVENTS;_this=_Input.apply(this,arguments)||this;_this.targetIds={};// this.evTarget = TOUCH_TARGET_EVENTS;
return _this;}var _proto=TouchInput.prototype;_proto.handler=function handler(ev){var type=TOUCH_INPUT_MAP[ev.type];var touches=getTouches.call(this,ev,type);if(!touches){return;}this.callback(this.manager,type,{pointers:touches[0],changedPointers:touches[1],pointerType:INPUT_TYPE_TOUCH,srcEvent:ev});};return TouchInput;}(Input);function getTouches(ev,type){var allTouches=toArray(ev.touches);var targetIds=this.targetIds;// when there is only one touch, the process can be simplified
if(type&(INPUT_START|INPUT_MOVE)&&allTouches.length===1){targetIds[allTouches[0].identifier]=true;return[allTouches,allTouches];}var i;var targetTouches;var changedTouches=toArray(ev.changedTouches);var changedTargetTouches=[];var target=this.target;// get target touches from touches
targetTouches=allTouches.filter(function(touch){return hasParent(touch.target,target);});// collect touches
if(type===INPUT_START){i=0;while(i<targetTouches.length){targetIds[targetTouches[i].identifier]=true;i++;}}// filter changed touches to only contain touches that exist in the collected target ids
i=0;while(i<changedTouches.length){if(targetIds[changedTouches[i].identifier]){changedTargetTouches.push(changedTouches[i]);}// cleanup removed touches
if(type&(INPUT_END|INPUT_CANCEL)){delete targetIds[changedTouches[i].identifier];}i++;}if(!changedTargetTouches.length){return;}return[// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
uniqueArray(targetTouches.concat(changedTargetTouches),'identifier',true),changedTargetTouches];}var MOUSE_INPUT_MAP={mousedown:INPUT_START,mousemove:INPUT_MOVE,mouseup:INPUT_END};var MOUSE_ELEMENT_EVENTS='mousedown';var MOUSE_WINDOW_EVENTS='mousemove mouseup';/**
 * @private
 * Mouse events input
 * @constructor
 * @extends Input
 */var MouseInput=/*#__PURE__*/function(_Input){_inheritsLoose(MouseInput,_Input);function MouseInput(){var _this;var proto=MouseInput.prototype;proto.evEl=MOUSE_ELEMENT_EVENTS;proto.evWin=MOUSE_WINDOW_EVENTS;_this=_Input.apply(this,arguments)||this;_this.pressed=false;// mousedown state
return _this;}/**
   * @private
   * handle mouse events
   * @param {Object} ev
   */var _proto=MouseInput.prototype;_proto.handler=function handler(ev){var eventType=MOUSE_INPUT_MAP[ev.type];// on start we want to have the left mouse button down
if(eventType&INPUT_START&&ev.button===0){this.pressed=true;}if(eventType&INPUT_MOVE&&ev.which!==1){eventType=INPUT_END;}// mouse must be down
if(!this.pressed){return;}if(eventType&INPUT_END){this.pressed=false;}this.callback(this.manager,eventType,{pointers:[ev],changedPointers:[ev],pointerType:INPUT_TYPE_MOUSE,srcEvent:ev});};return MouseInput;}(Input);/**
 * @private
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */var DEDUP_TIMEOUT=2500;var DEDUP_DISTANCE=25;function setLastTouch(eventData){var _eventData$changedPoi=eventData.changedPointers,touch=_eventData$changedPoi[0];if(touch.identifier===this.primaryTouch){var lastTouch={x:touch.clientX,y:touch.clientY};var lts=this.lastTouches;this.lastTouches.push(lastTouch);var removeLastTouch=function removeLastTouch(){var i=lts.indexOf(lastTouch);if(i>-1){lts.splice(i,1);}};setTimeout(removeLastTouch,DEDUP_TIMEOUT);}}function recordTouches(eventType,eventData){if(eventType&INPUT_START){this.primaryTouch=eventData.changedPointers[0].identifier;setLastTouch.call(this,eventData);}else if(eventType&(INPUT_END|INPUT_CANCEL)){setLastTouch.call(this,eventData);}}function isSyntheticEvent(eventData){var x=eventData.srcEvent.clientX;var y=eventData.srcEvent.clientY;for(var i=0;i<this.lastTouches.length;i++){var t=this.lastTouches[i];var dx=Math.abs(x-t.x);var dy=Math.abs(y-t.y);if(dx<=DEDUP_DISTANCE&&dy<=DEDUP_DISTANCE){return true;}}return false;}var TouchMouseInput=/*#__PURE__*/function(){var TouchMouseInput=/*#__PURE__*/function(_Input){_inheritsLoose(TouchMouseInput,_Input);function TouchMouseInput(_manager,callback){var _this;_this=_Input.call(this,_manager,callback)||this;_this.handler=function(manager,inputEvent,inputData){var isTouch=inputData.pointerType===INPUT_TYPE_TOUCH;var isMouse=inputData.pointerType===INPUT_TYPE_MOUSE;if(isMouse&&inputData.sourceCapabilities&&inputData.sourceCapabilities.firesTouchEvents){return;}// when we're in a touch event, record touches to  de-dupe synthetic mouse event
if(isTouch){recordTouches.call(_assertThisInitialized$1(_assertThisInitialized$1(_this)),inputEvent,inputData);}else if(isMouse&&isSyntheticEvent.call(_assertThisInitialized$1(_assertThisInitialized$1(_this)),inputData)){return;}_this.callback(manager,inputEvent,inputData);};_this.touch=new TouchInput(_this.manager,_this.handler);_this.mouse=new MouseInput(_this.manager,_this.handler);_this.primaryTouch=null;_this.lastTouches=[];return _this;}/**
     * @private
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */var _proto=TouchMouseInput.prototype;/**
     * @private
     * remove the event listeners
     */_proto.destroy=function destroy(){this.touch.destroy();this.mouse.destroy();};return TouchMouseInput;}(Input);return TouchMouseInput;}();/**
 * @private
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */function createInputInstance(manager){var Type;// let inputClass = manager.options.inputClass;
var inputClass=manager.options.inputClass;if(inputClass){Type=inputClass;}else if(SUPPORT_POINTER_EVENTS){Type=PointerEventInput;}else if(SUPPORT_ONLY_TOUCH){Type=TouchInput;}else if(!SUPPORT_TOUCH){Type=MouseInput;}else{Type=TouchMouseInput;}return new Type(manager,inputHandler);}/**
 * @private
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */function invokeArrayArg(arg,fn,context){if(Array.isArray(arg)){each(arg,context[fn],context);return true;}return false;}var STATE_POSSIBLE=1;var STATE_BEGAN=2;var STATE_CHANGED=4;var STATE_ENDED=8;var STATE_RECOGNIZED=STATE_ENDED;var STATE_CANCELLED=16;var STATE_FAILED=32;/**
 * @private
 * get a unique id
 * @returns {number} uniqueId
 */var _uniqueId=1;function uniqueId(){return _uniqueId++;}/**
 * @private
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */function getRecognizerByNameIfManager(otherRecognizer,recognizer){var manager=recognizer.manager;if(manager){return manager.get(otherRecognizer);}return otherRecognizer;}/**
 * @private
 * get a usable string, used as event postfix
 * @param {constant} state
 * @returns {String} state
 */function stateStr(state){if(state&STATE_CANCELLED){return'cancel';}else if(state&STATE_ENDED){return'end';}else if(state&STATE_CHANGED){return'move';}else if(state&STATE_BEGAN){return'start';}return'';}/**
 * @private
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */ /**
 * @private
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */var Recognizer=/*#__PURE__*/function(){function Recognizer(options){if(options===void 0){options={};}this.options=_extends({enable:true},options);this.id=uniqueId();this.manager=null;// default is enable true
this.state=STATE_POSSIBLE;this.simultaneous={};this.requireFail=[];}/**
   * @private
   * set options
   * @param {Object} options
   * @return {Recognizer}
   */var _proto=Recognizer.prototype;_proto.set=function set(options){assign$1(this.options,options);// also update the touchAction, in case something changed about the directions/enabled state
this.manager&&this.manager.touchAction.update();return this;};/**
   * @private
   * recognize simultaneous with an other recognizer.
   * @param {Recognizer} otherRecognizer
   * @returns {Recognizer} this
   */_proto.recognizeWith=function recognizeWith(otherRecognizer){if(invokeArrayArg(otherRecognizer,'recognizeWith',this)){return this;}var simultaneous=this.simultaneous;otherRecognizer=getRecognizerByNameIfManager(otherRecognizer,this);if(!simultaneous[otherRecognizer.id]){simultaneous[otherRecognizer.id]=otherRecognizer;otherRecognizer.recognizeWith(this);}return this;};/**
   * @private
   * drop the simultaneous link. it doesnt remove the link on the other recognizer.
   * @param {Recognizer} otherRecognizer
   * @returns {Recognizer} this
   */_proto.dropRecognizeWith=function dropRecognizeWith(otherRecognizer){if(invokeArrayArg(otherRecognizer,'dropRecognizeWith',this)){return this;}otherRecognizer=getRecognizerByNameIfManager(otherRecognizer,this);delete this.simultaneous[otherRecognizer.id];return this;};/**
   * @private
   * recognizer can only run when an other is failing
   * @param {Recognizer} otherRecognizer
   * @returns {Recognizer} this
   */_proto.requireFailure=function requireFailure(otherRecognizer){if(invokeArrayArg(otherRecognizer,'requireFailure',this)){return this;}var requireFail=this.requireFail;otherRecognizer=getRecognizerByNameIfManager(otherRecognizer,this);if(inArray(requireFail,otherRecognizer)===-1){requireFail.push(otherRecognizer);otherRecognizer.requireFailure(this);}return this;};/**
   * @private
   * drop the requireFailure link. it does not remove the link on the other recognizer.
   * @param {Recognizer} otherRecognizer
   * @returns {Recognizer} this
   */_proto.dropRequireFailure=function dropRequireFailure(otherRecognizer){if(invokeArrayArg(otherRecognizer,'dropRequireFailure',this)){return this;}otherRecognizer=getRecognizerByNameIfManager(otherRecognizer,this);var index=inArray(this.requireFail,otherRecognizer);if(index>-1){this.requireFail.splice(index,1);}return this;};/**
   * @private
   * has require failures boolean
   * @returns {boolean}
   */_proto.hasRequireFailures=function hasRequireFailures(){return this.requireFail.length>0;};/**
   * @private
   * if the recognizer can recognize simultaneous with an other recognizer
   * @param {Recognizer} otherRecognizer
   * @returns {Boolean}
   */_proto.canRecognizeWith=function canRecognizeWith(otherRecognizer){return!!this.simultaneous[otherRecognizer.id];};/**
   * @private
   * You should use `tryEmit` instead of `emit` directly to check
   * that all the needed recognizers has failed before emitting.
   * @param {Object} input
   */_proto.emit=function emit(input){var self=this;var state=this.state;function emit(event){self.manager.emit(event,input);}// 'panstart' and 'panmove'
if(state<STATE_ENDED){emit(self.options.event+stateStr(state));}emit(self.options.event);// simple 'eventName' events
if(input.additionalEvent){// additional event(panleft, panright, pinchin, pinchout...)
emit(input.additionalEvent);}// panend and pancancel
if(state>=STATE_ENDED){emit(self.options.event+stateStr(state));}};/**
   * @private
   * Check that all the require failure recognizers has failed,
   * if true, it emits a gesture event,
   * otherwise, setup the state to FAILED.
   * @param {Object} input
   */_proto.tryEmit=function tryEmit(input){if(this.canEmit()){return this.emit(input);}// it's failing anyway
this.state=STATE_FAILED;};/**
   * @private
   * can we emit?
   * @returns {boolean}
   */_proto.canEmit=function canEmit(){var i=0;while(i<this.requireFail.length){if(!(this.requireFail[i].state&(STATE_FAILED|STATE_POSSIBLE))){return false;}i++;}return true;};/**
   * @private
   * update the recognizer
   * @param {Object} inputData
   */_proto.recognize=function recognize(inputData){// make a new copy of the inputData
// so we can change the inputData without messing up the other recognizers
var inputDataClone=assign$1({},inputData);// is is enabled and allow recognizing?
if(!boolOrFn(this.options.enable,[this,inputDataClone])){this.reset();this.state=STATE_FAILED;return;}// reset when we've reached the end
if(this.state&(STATE_RECOGNIZED|STATE_CANCELLED|STATE_FAILED)){this.state=STATE_POSSIBLE;}this.state=this.process(inputDataClone);// the recognizer has recognized a gesture
// so trigger an event
if(this.state&(STATE_BEGAN|STATE_CHANGED|STATE_ENDED|STATE_CANCELLED)){this.tryEmit(inputDataClone);}};/**
   * @private
   * return the state of the recognizer
   * the actual recognizing happens in this method
   * @virtual
   * @param {Object} inputData
   * @returns {constant} STATE
   */ /* jshint ignore:start */_proto.process=function process(inputData){};/* jshint ignore:end */ /**
   * @private
   * return the preferred touch-action
   * @virtual
   * @returns {Array}
   */_proto.getTouchAction=function getTouchAction(){};/**
   * @private
   * called when the gesture isn't allowed to recognize
   * like when another is being recognized or it is disabled
   * @virtual
   */_proto.reset=function reset(){};return Recognizer;}();/**
 * @private
 * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */var TapRecognizer=/*#__PURE__*/function(_Recognizer){_inheritsLoose(TapRecognizer,_Recognizer);function TapRecognizer(options){var _this;if(options===void 0){options={};}_this=_Recognizer.call(this,_extends({event:'tap',pointers:1,taps:1,interval:300,// max time between the multi-tap taps
time:250,// max time of the pointer to be down (like finger on the screen)
threshold:9,// a minimal movement is ok, but keep it low
posThreshold:10},options))||this;// previous time and center,
// used for tap counting
_this.pTime=false;_this.pCenter=false;_this._timer=null;_this._input=null;_this.count=0;return _this;}var _proto=TapRecognizer.prototype;_proto.getTouchAction=function getTouchAction(){return[TOUCH_ACTION_MANIPULATION];};_proto.process=function process(input){var _this2=this;var options=this.options;var validPointers=input.pointers.length===options.pointers;var validMovement=input.distance<options.threshold;var validTouchTime=input.deltaTime<options.time;this.reset();if(input.eventType&INPUT_START&&this.count===0){return this.failTimeout();}// we only allow little movement
// and we've reached an end event, so a tap is possible
if(validMovement&&validTouchTime&&validPointers){if(input.eventType!==INPUT_END){return this.failTimeout();}var validInterval=this.pTime?input.timeStamp-this.pTime<options.interval:true;var validMultiTap=!this.pCenter||getDistance(this.pCenter,input.center)<options.posThreshold;this.pTime=input.timeStamp;this.pCenter=input.center;if(!validMultiTap||!validInterval){this.count=1;}else{this.count+=1;}this._input=input;// if tap count matches we have recognized it,
// else it has began recognizing...
var tapCount=this.count%options.taps;if(tapCount===0){// no failing requirements, immediately trigger the tap event
// or wait as long as the multitap interval to trigger
if(!this.hasRequireFailures()){return STATE_RECOGNIZED;}else{this._timer=setTimeout(function(){_this2.state=STATE_RECOGNIZED;_this2.tryEmit();},options.interval);return STATE_BEGAN;}}}return STATE_FAILED;};_proto.failTimeout=function failTimeout(){var _this3=this;this._timer=setTimeout(function(){_this3.state=STATE_FAILED;},this.options.interval);return STATE_FAILED;};_proto.reset=function reset(){clearTimeout(this._timer);};_proto.emit=function emit(){if(this.state===STATE_RECOGNIZED){this._input.tapCount=this.count;this.manager.emit(this.options.event,this._input);}};return TapRecognizer;}(Recognizer);/**
 * @private
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */var AttrRecognizer=/*#__PURE__*/function(_Recognizer){_inheritsLoose(AttrRecognizer,_Recognizer);function AttrRecognizer(options){if(options===void 0){options={};}return _Recognizer.call(this,_extends({pointers:1},options))||this;}/**
   * @private
   * Used to check if it the recognizer receives valid input, like input.distance > 10.
   * @memberof AttrRecognizer
   * @param {Object} input
   * @returns {Boolean} recognized
   */var _proto=AttrRecognizer.prototype;_proto.attrTest=function attrTest(input){var optionPointers=this.options.pointers;return optionPointers===0||input.pointers.length===optionPointers;};/**
   * @private
   * Process the input and return the state for the recognizer
   * @memberof AttrRecognizer
   * @param {Object} input
   * @returns {*} State
   */_proto.process=function process(input){var state=this.state;var eventType=input.eventType;var isRecognized=state&(STATE_BEGAN|STATE_CHANGED);var isValid=this.attrTest(input);// on cancel input and we've recognized before, return STATE_CANCELLED
if(isRecognized&&(eventType&INPUT_CANCEL||!isValid)){return state|STATE_CANCELLED;}else if(isRecognized||isValid){if(eventType&INPUT_END){return state|STATE_ENDED;}else if(!(state&STATE_BEGAN)){return STATE_BEGAN;}return state|STATE_CHANGED;}return STATE_FAILED;};return AttrRecognizer;}(Recognizer);/**
 * @private
 * direction cons to string
 * @param {constant} direction
 * @returns {String}
 */function directionStr(direction){if(direction===DIRECTION_DOWN){return'down';}else if(direction===DIRECTION_UP){return'up';}else if(direction===DIRECTION_LEFT){return'left';}else if(direction===DIRECTION_RIGHT){return'right';}return'';}/**
 * @private
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */var PanRecognizer=/*#__PURE__*/function(_AttrRecognizer){_inheritsLoose(PanRecognizer,_AttrRecognizer);function PanRecognizer(options){var _this;if(options===void 0){options={};}_this=_AttrRecognizer.call(this,_extends({event:'pan',threshold:10,pointers:1,direction:DIRECTION_ALL},options))||this;_this.pX=null;_this.pY=null;return _this;}var _proto=PanRecognizer.prototype;_proto.getTouchAction=function getTouchAction(){var direction=this.options.direction;var actions=[];if(direction&DIRECTION_HORIZONTAL){actions.push(TOUCH_ACTION_PAN_Y);}if(direction&DIRECTION_VERTICAL){actions.push(TOUCH_ACTION_PAN_X);}return actions;};_proto.directionTest=function directionTest(input){var options=this.options;var hasMoved=true;var distance=input.distance;var direction=input.direction;var x=input.deltaX;var y=input.deltaY;// lock to axis?
if(!(direction&options.direction)){if(options.direction&DIRECTION_HORIZONTAL){direction=x===0?DIRECTION_NONE:x<0?DIRECTION_LEFT:DIRECTION_RIGHT;hasMoved=x!==this.pX;distance=Math.abs(input.deltaX);}else{direction=y===0?DIRECTION_NONE:y<0?DIRECTION_UP:DIRECTION_DOWN;hasMoved=y!==this.pY;distance=Math.abs(input.deltaY);}}input.direction=direction;return hasMoved&&distance>options.threshold&&direction&options.direction;};_proto.attrTest=function attrTest(input){return AttrRecognizer.prototype.attrTest.call(this,input)&&(// replace with a super call
this.state&STATE_BEGAN||!(this.state&STATE_BEGAN)&&this.directionTest(input));};_proto.emit=function emit(input){this.pX=input.deltaX;this.pY=input.deltaY;var direction=directionStr(input.direction);if(direction){input.additionalEvent=this.options.event+direction;}_AttrRecognizer.prototype.emit.call(this,input);};return PanRecognizer;}(AttrRecognizer);/**
 * @private
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */var SwipeRecognizer=/*#__PURE__*/function(_AttrRecognizer){_inheritsLoose(SwipeRecognizer,_AttrRecognizer);function SwipeRecognizer(options){if(options===void 0){options={};}return _AttrRecognizer.call(this,_extends({event:'swipe',threshold:10,velocity:0.3,direction:DIRECTION_HORIZONTAL|DIRECTION_VERTICAL,pointers:1},options))||this;}var _proto=SwipeRecognizer.prototype;_proto.getTouchAction=function getTouchAction(){return PanRecognizer.prototype.getTouchAction.call(this);};_proto.attrTest=function attrTest(input){var direction=this.options.direction;var velocity;if(direction&(DIRECTION_HORIZONTAL|DIRECTION_VERTICAL)){velocity=input.overallVelocity;}else if(direction&DIRECTION_HORIZONTAL){velocity=input.overallVelocityX;}else if(direction&DIRECTION_VERTICAL){velocity=input.overallVelocityY;}return _AttrRecognizer.prototype.attrTest.call(this,input)&&direction&input.offsetDirection&&input.distance>this.options.threshold&&input.maxPointers===this.options.pointers&&abs$1(velocity)>this.options.velocity&&input.eventType&INPUT_END;};_proto.emit=function emit(input){var direction=directionStr(input.offsetDirection);if(direction){this.manager.emit(this.options.event+direction,input);}this.manager.emit(this.options.event,input);};return SwipeRecognizer;}(AttrRecognizer);/**
 * @private
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */var PinchRecognizer=/*#__PURE__*/function(_AttrRecognizer){_inheritsLoose(PinchRecognizer,_AttrRecognizer);function PinchRecognizer(options){if(options===void 0){options={};}return _AttrRecognizer.call(this,_extends({event:'pinch',threshold:0,pointers:2},options))||this;}var _proto=PinchRecognizer.prototype;_proto.getTouchAction=function getTouchAction(){return[TOUCH_ACTION_NONE];};_proto.attrTest=function attrTest(input){return _AttrRecognizer.prototype.attrTest.call(this,input)&&(Math.abs(input.scale-1)>this.options.threshold||this.state&STATE_BEGAN);};_proto.emit=function emit(input){if(input.scale!==1){var inOut=input.scale<1?'in':'out';input.additionalEvent=this.options.event+inOut;}_AttrRecognizer.prototype.emit.call(this,input);};return PinchRecognizer;}(AttrRecognizer);/**
 * @private
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */var RotateRecognizer=/*#__PURE__*/function(_AttrRecognizer){_inheritsLoose(RotateRecognizer,_AttrRecognizer);function RotateRecognizer(options){if(options===void 0){options={};}return _AttrRecognizer.call(this,_extends({event:'rotate',threshold:0,pointers:2},options))||this;}var _proto=RotateRecognizer.prototype;_proto.getTouchAction=function getTouchAction(){return[TOUCH_ACTION_NONE];};_proto.attrTest=function attrTest(input){return _AttrRecognizer.prototype.attrTest.call(this,input)&&(Math.abs(input.rotation)>this.options.threshold||this.state&STATE_BEGAN);};return RotateRecognizer;}(AttrRecognizer);/**
 * @private
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */var PressRecognizer=/*#__PURE__*/function(_Recognizer){_inheritsLoose(PressRecognizer,_Recognizer);function PressRecognizer(options){var _this;if(options===void 0){options={};}_this=_Recognizer.call(this,_extends({event:'press',pointers:1,time:251,// minimal time of the pointer to be pressed
threshold:9},options))||this;_this._timer=null;_this._input=null;return _this;}var _proto=PressRecognizer.prototype;_proto.getTouchAction=function getTouchAction(){return[TOUCH_ACTION_AUTO];};_proto.process=function process(input){var _this2=this;var options=this.options;var validPointers=input.pointers.length===options.pointers;var validMovement=input.distance<options.threshold;var validTime=input.deltaTime>options.time;this._input=input;// we only allow little movement
// and we've reached an end event, so a tap is possible
if(!validMovement||!validPointers||input.eventType&(INPUT_END|INPUT_CANCEL)&&!validTime){this.reset();}else if(input.eventType&INPUT_START){this.reset();this._timer=setTimeout(function(){_this2.state=STATE_RECOGNIZED;_this2.tryEmit();},options.time);}else if(input.eventType&INPUT_END){return STATE_RECOGNIZED;}return STATE_FAILED;};_proto.reset=function reset(){clearTimeout(this._timer);};_proto.emit=function emit(input){if(this.state!==STATE_RECOGNIZED){return;}if(input&&input.eventType&INPUT_END){this.manager.emit(this.options.event+"up",input);}else{this._input.timeStamp=now();this.manager.emit(this.options.event,this._input);}};return PressRecognizer;}(Recognizer);var defaults={/**
   * @private
   * set if DOM events are being triggered.
   * But this is slower and unused by simple implementations, so disabled by default.
   * @type {Boolean}
   * @default false
   */domEvents:false,/**
   * @private
   * The value for the touchAction property/fallback.
   * When set to `compute` it will magically set the correct value based on the added recognizers.
   * @type {String}
   * @default compute
   */touchAction:TOUCH_ACTION_COMPUTE,/**
   * @private
   * @type {Boolean}
   * @default true
   */enable:true,/**
   * @private
   * EXPERIMENTAL FEATURE -- can be removed/changed
   * Change the parent input target element.
   * If Null, then it is being set the to main element.
   * @type {Null|EventTarget}
   * @default null
   */inputTarget:null,/**
   * @private
   * force an input class
   * @type {Null|Function}
   * @default null
   */inputClass:null,/**
   * @private
   * Some CSS properties can be used to improve the working of Hammer.
   * Add them to this method and they will be set when creating a new Manager.
   * @namespace
   */cssProps:{/**
     * @private
     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
     * @type {String}
     * @default 'none'
     */userSelect:"none",/**
     * @private
     * Disable the Windows Phone grippers when pressing an element.
     * @type {String}
     * @default 'none'
     */touchSelect:"none",/**
     * @private
     * Disables the default callout shown when you touch and hold a touch target.
     * On iOS, when you touch and hold a touch target such as a link, Safari displays
     * a callout containing information about the link. This property allows you to disable that callout.
     * @type {String}
     * @default 'none'
     */touchCallout:"none",/**
     * @private
     * Specifies whether zooming is enabled. Used by IE10>
     * @type {String}
     * @default 'none'
     */contentZooming:"none",/**
     * @private
     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
     * @type {String}
     * @default 'none'
     */userDrag:"none",/**
     * @private
     * Overrides the highlight color shown when the user taps a link or a JavaScript
     * clickable element in iOS. This property obeys the alpha value, if specified.
     * @type {String}
     * @default 'rgba(0,0,0,0)'
     */tapHighlightColor:"rgba(0,0,0,0)"}};/**
 * @private
 * Default recognizer setup when calling `Hammer()`
 * When creating a new Manager these will be skipped.
 * This is separated with other defaults because of tree-shaking.
 * @type {Array}
 */var preset=[[RotateRecognizer,{enable:false}],[PinchRecognizer,{enable:false},['rotate']],[SwipeRecognizer,{direction:DIRECTION_HORIZONTAL}],[PanRecognizer,{direction:DIRECTION_HORIZONTAL},['swipe']],[TapRecognizer],[TapRecognizer,{event:'doubletap',taps:2},['tap']],[PressRecognizer]];var STOP=1;var FORCED_STOP=2;/**
 * @private
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */function toggleCssProps(manager,add){var element=manager.element;if(!element.style){return;}var prop;each(manager.options.cssProps,function(value,name){prop=prefixed(element.style,name);if(add){manager.oldCssProps[prop]=element.style[prop];element.style[prop]=value;}else{element.style[prop]=manager.oldCssProps[prop]||"";}});if(!add){manager.oldCssProps={};}}/**
 * @private
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */function triggerDomEvent(event,data){var gestureEvent=document.createEvent("Event");gestureEvent.initEvent(event,true,true);gestureEvent.gesture=data;data.target.dispatchEvent(gestureEvent);}/**
* @private
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */var Manager=/*#__PURE__*/function(){function Manager(element,options){var _this=this;this.options=assign$1({},defaults,options||{});this.options.inputTarget=this.options.inputTarget||element;this.handlers={};this.session={};this.recognizers=[];this.oldCssProps={};this.element=element;this.input=createInputInstance(this);this.touchAction=new TouchAction(this,this.options.touchAction);toggleCssProps(this,true);each(this.options.recognizers,function(item){var recognizer=_this.add(new item[0](item[1]));item[2]&&recognizer.recognizeWith(item[2]);item[3]&&recognizer.requireFailure(item[3]);},this);}/**
   * @private
   * set options
   * @param {Object} options
   * @returns {Manager}
   */var _proto=Manager.prototype;_proto.set=function set(options){assign$1(this.options,options);// Options that need a little more setup
if(options.touchAction){this.touchAction.update();}if(options.inputTarget){// Clean up existing event listeners and reinitialize
this.input.destroy();this.input.target=options.inputTarget;this.input.init();}return this;};/**
   * @private
   * stop recognizing for this session.
   * This session will be discarded, when a new [input]start event is fired.
   * When forced, the recognizer cycle is stopped immediately.
   * @param {Boolean} [force]
   */_proto.stop=function stop(force){this.session.stopped=force?FORCED_STOP:STOP;};/**
   * @private
   * run the recognizers!
   * called by the inputHandler function on every movement of the pointers (touches)
   * it walks through all the recognizers and tries to detect the gesture that is being made
   * @param {Object} inputData
   */_proto.recognize=function recognize(inputData){var session=this.session;if(session.stopped){return;}// run the touch-action polyfill
this.touchAction.preventDefaults(inputData);var recognizer;var recognizers=this.recognizers;// this holds the recognizer that is being recognized.
// so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
// if no recognizer is detecting a thing, it is set to `null`
var curRecognizer=session.curRecognizer;// reset when the last recognizer is recognized
// or when we're in a new session
if(!curRecognizer||curRecognizer&&curRecognizer.state&STATE_RECOGNIZED){session.curRecognizer=null;curRecognizer=null;}var i=0;while(i<recognizers.length){recognizer=recognizers[i];// find out if we are allowed try to recognize the input for this one.
// 1.   allow if the session is NOT forced stopped (see the .stop() method)
// 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
//      that is being recognized.
// 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
//      this can be setup with the `recognizeWith()` method on the recognizer.
if(session.stopped!==FORCED_STOP&&(// 1
!curRecognizer||recognizer===curRecognizer||// 2
recognizer.canRecognizeWith(curRecognizer))){// 3
recognizer.recognize(inputData);}else{recognizer.reset();}// if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
// current active recognizer. but only if we don't already have an active recognizer
if(!curRecognizer&&recognizer.state&(STATE_BEGAN|STATE_CHANGED|STATE_ENDED)){session.curRecognizer=recognizer;curRecognizer=recognizer;}i++;}};/**
   * @private
   * get a recognizer by its event name.
   * @param {Recognizer|String} recognizer
   * @returns {Recognizer|Null}
   */_proto.get=function get(recognizer){if(recognizer instanceof Recognizer){return recognizer;}var recognizers=this.recognizers;for(var i=0;i<recognizers.length;i++){if(recognizers[i].options.event===recognizer){return recognizers[i];}}return null;};/**
   * @private add a recognizer to the manager
   * existing recognizers with the same event name will be removed
   * @param {Recognizer} recognizer
   * @returns {Recognizer|Manager}
   */_proto.add=function add(recognizer){if(invokeArrayArg(recognizer,"add",this)){return this;}// remove existing
var existing=this.get(recognizer.options.event);if(existing){this.remove(existing);}this.recognizers.push(recognizer);recognizer.manager=this;this.touchAction.update();return recognizer;};/**
   * @private
   * remove a recognizer by name or instance
   * @param {Recognizer|String} recognizer
   * @returns {Manager}
   */_proto.remove=function remove(recognizer){if(invokeArrayArg(recognizer,"remove",this)){return this;}var targetRecognizer=this.get(recognizer);// let's make sure this recognizer exists
if(recognizer){var recognizers=this.recognizers;var index=inArray(recognizers,targetRecognizer);if(index!==-1){recognizers.splice(index,1);this.touchAction.update();}}return this;};/**
   * @private
   * bind event
   * @param {String} events
   * @param {Function} handler
   * @returns {EventEmitter} this
   */_proto.on=function on(events,handler){if(events===undefined||handler===undefined){return this;}var handlers=this.handlers;each(splitStr(events),function(event){handlers[event]=handlers[event]||[];handlers[event].push(handler);});return this;};/**
   * @private unbind event, leave emit blank to remove all handlers
   * @param {String} events
   * @param {Function} [handler]
   * @returns {EventEmitter} this
   */_proto.off=function off(events,handler){if(events===undefined){return this;}var handlers=this.handlers;each(splitStr(events),function(event){if(!handler){delete handlers[event];}else{handlers[event]&&handlers[event].splice(inArray(handlers[event],handler),1);}});return this;};/**
   * @private emit event to the listeners
   * @param {String} event
   * @param {Object} data
   */_proto.emit=function emit(event,data){// we also want to trigger dom events
if(this.options.domEvents){triggerDomEvent(event,data);}// no handlers, so skip it all
var handlers=this.handlers[event]&&this.handlers[event].slice();if(!handlers||!handlers.length){return;}data.type=event;data.preventDefault=function(){data.srcEvent.preventDefault();};var i=0;while(i<handlers.length){handlers[i](data);i++;}};/**
   * @private
   * destroy the manager and unbinds all events
   * it doesn't unbind dom events, that is the user own responsibility
   */_proto.destroy=function destroy(){this.element&&toggleCssProps(this,false);this.handlers={};this.session={};this.input.destroy();this.element=null;};return Manager;}();var SINGLE_TOUCH_INPUT_MAP={touchstart:INPUT_START,touchmove:INPUT_MOVE,touchend:INPUT_END,touchcancel:INPUT_CANCEL};var SINGLE_TOUCH_TARGET_EVENTS='touchstart';var SINGLE_TOUCH_WINDOW_EVENTS='touchstart touchmove touchend touchcancel';/**
 * @private
 * Touch events input
 * @constructor
 * @extends Input
 */var SingleTouchInput=/*#__PURE__*/function(_Input){_inheritsLoose(SingleTouchInput,_Input);function SingleTouchInput(){var _this;var proto=SingleTouchInput.prototype;proto.evTarget=SINGLE_TOUCH_TARGET_EVENTS;proto.evWin=SINGLE_TOUCH_WINDOW_EVENTS;_this=_Input.apply(this,arguments)||this;_this.started=false;return _this;}var _proto=SingleTouchInput.prototype;_proto.handler=function handler(ev){var type=SINGLE_TOUCH_INPUT_MAP[ev.type];// should we handle the touch events?
if(type===INPUT_START){this.started=true;}if(!this.started){return;}var touches=normalizeSingleTouches.call(this,ev,type);// when done, reset the started state
if(type&(INPUT_END|INPUT_CANCEL)&&touches[0].length-touches[1].length===0){this.started=false;}this.callback(this.manager,type,{pointers:touches[0],changedPointers:touches[1],pointerType:INPUT_TYPE_TOUCH,srcEvent:ev});};return SingleTouchInput;}(Input);function normalizeSingleTouches(ev,type){var all=toArray(ev.touches);var changed=toArray(ev.changedTouches);if(type&(INPUT_END|INPUT_CANCEL)){all=uniqueArray(all.concat(changed),'identifier',true);}return[all,changed];}/**
 * @private
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */function deprecate(method,name,message){var deprecationMessage="DEPRECATED METHOD: "+name+"\n"+message+" AT \n";return function(){var e=new Error('get-stack-trace');var stack=e&&e.stack?e.stack.replace(/^[^\(]+?[\n$]/gm,'').replace(/^\s+at\s+/gm,'').replace(/^Object.<anonymous>\s*\(/gm,'{anonymous}()@'):'Unknown Stack Trace';var log=window.console&&(window.console.warn||window.console.log);if(log){log.call(window.console,deprecationMessage,stack);}return method.apply(this,arguments);};}/**
 * @private
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */var extend=deprecate(function(dest,src,merge){var keys=Object.keys(src);var i=0;while(i<keys.length){if(!merge||merge&&dest[keys[i]]===undefined){dest[keys[i]]=src[keys[i]];}i++;}return dest;},'extend','Use `assign`.');/**
 * @private
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */var merge$2=deprecate(function(dest,src){return extend(dest,src,true);},'merge','Use `assign`.');/**
 * @private
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */function inherit(child,base,properties){var baseP=base.prototype;var childP;childP=child.prototype=Object.create(baseP);childP.constructor=child;childP._super=baseP;if(properties){assign$1(childP,properties);}}/**
 * @private
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */function bindFn(fn,context){return function boundFn(){return fn.apply(context,arguments);};}/**
 * @private
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */var Hammer$2=/*#__PURE__*/function(){var Hammer=/**
    * @private
    * @const {string}
    */function Hammer(element,options){if(options===void 0){options={};}return new Manager(element,_extends({recognizers:preset.concat()},options));};Hammer.VERSION="2.0.17-rc";Hammer.DIRECTION_ALL=DIRECTION_ALL;Hammer.DIRECTION_DOWN=DIRECTION_DOWN;Hammer.DIRECTION_LEFT=DIRECTION_LEFT;Hammer.DIRECTION_RIGHT=DIRECTION_RIGHT;Hammer.DIRECTION_UP=DIRECTION_UP;Hammer.DIRECTION_HORIZONTAL=DIRECTION_HORIZONTAL;Hammer.DIRECTION_VERTICAL=DIRECTION_VERTICAL;Hammer.DIRECTION_NONE=DIRECTION_NONE;Hammer.DIRECTION_DOWN=DIRECTION_DOWN;Hammer.INPUT_START=INPUT_START;Hammer.INPUT_MOVE=INPUT_MOVE;Hammer.INPUT_END=INPUT_END;Hammer.INPUT_CANCEL=INPUT_CANCEL;Hammer.STATE_POSSIBLE=STATE_POSSIBLE;Hammer.STATE_BEGAN=STATE_BEGAN;Hammer.STATE_CHANGED=STATE_CHANGED;Hammer.STATE_ENDED=STATE_ENDED;Hammer.STATE_RECOGNIZED=STATE_RECOGNIZED;Hammer.STATE_CANCELLED=STATE_CANCELLED;Hammer.STATE_FAILED=STATE_FAILED;Hammer.Manager=Manager;Hammer.Input=Input;Hammer.TouchAction=TouchAction;Hammer.TouchInput=TouchInput;Hammer.MouseInput=MouseInput;Hammer.PointerEventInput=PointerEventInput;Hammer.TouchMouseInput=TouchMouseInput;Hammer.SingleTouchInput=SingleTouchInput;Hammer.Recognizer=Recognizer;Hammer.AttrRecognizer=AttrRecognizer;Hammer.Tap=TapRecognizer;Hammer.Pan=PanRecognizer;Hammer.Swipe=SwipeRecognizer;Hammer.Pinch=PinchRecognizer;Hammer.Rotate=RotateRecognizer;Hammer.Press=PressRecognizer;Hammer.on=addEventListeners;Hammer.off=removeEventListeners;Hammer.each=each;Hammer.merge=merge$2;Hammer.extend=extend;Hammer.bindFn=bindFn;Hammer.assign=assign$1;Hammer.inherit=inherit;Hammer.bindFn=bindFn;Hammer.prefixed=prefixed;Hammer.toArray=toArray;Hammer.inArray=inArray;Hammer.uniqueArray=uniqueArray;Hammer.splitStr=splitStr;Hammer.boolOrFn=boolOrFn;Hammer.hasParent=hasParent;Hammer.addEventListeners=addEventListeners;Hammer.removeEventListeners=removeEventListeners;Hammer.defaults=assign$1({},defaults,{preset:preset});return Hammer;}();//  style loader but by script tag, not by the loader.
function _createForOfIteratorHelper$8(o,allowArrayLike){var it=typeof symbol!=="undefined"&&getIteratorMethod(o)||o["@@iterator"];if(!it){if(isArray(o)||(it=_unsupportedIterableToArray$8(o))||allowArrayLike&&o&&typeof o.length==="number"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};},e:function e(_e){throw _e;},f:F};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion=true,didErr=false,err;return{s:function s(){it=it.call(o);},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e2){didErr=true;err=_e2;},f:function f(){try{if(!normalCompletion&&it.return!=null)it.return();}finally{if(didErr)throw err;}}};}function _unsupportedIterableToArray$8(o,minLen){var _context21;if(!o)return;if(typeof o==="string")return _arrayLikeToArray$8(o,minLen);var n=slice$1(_context21=Object.prototype.toString.call(o)).call(_context21,8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return from$2(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray$8(o,minLen);}function _arrayLikeToArray$8(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}/**
 * Use this symbol to delete properies in deepObjectAssign.
 */var DELETE=symbol("DELETE");/**
 * Pure version of deepObjectAssign, it doesn't modify any of it's arguments.
 *
 * @param base - The base object that fullfils the whole interface T.
 * @param updates - Updates that may change or delete props.
 *
 * @returns A brand new instance with all the supplied objects deeply merged.
 */function pureDeepObjectAssign(base){var _context;for(var _len=arguments.length,updates=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){updates[_key-1]=arguments[_key];}return deepObjectAssign.apply(void 0,concat(_context=[{},base]).call(_context,updates));}/**
 * Deep version of object assign with additional deleting by the DELETE symbol.
 *
 * @param values - Objects to be deeply merged.
 *
 * @returns The first object from values.
 */function deepObjectAssign(){var merged=deepObjectAssignNonentry.apply(void 0,arguments);stripDelete(merged);return merged;}/**
 * Deep version of object assign with additional deleting by the DELETE symbol.
 *
 * @remarks
 * This doesn't strip the DELETE symbols so they may end up in the final object.
 *
 * @param values - Objects to be deeply merged.
 *
 * @returns The first object from values.
 */function deepObjectAssignNonentry(){for(var _len2=arguments.length,values=new Array(_len2),_key2=0;_key2<_len2;_key2++){values[_key2]=arguments[_key2];}if(values.length<2){return values[0];}else if(values.length>2){var _context2;return deepObjectAssignNonentry.apply(void 0,concat(_context2=[deepObjectAssign(values[0],values[1])]).call(_context2,_toConsumableArray(slice$1(values).call(values,2))));}var a=values[0];var b=values[1];var _iterator=_createForOfIteratorHelper$8(ownKeys$5(b)),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var prop=_step.value;if(!Object.prototype.propertyIsEnumerable.call(b,prop));else if(b[prop]===DELETE){delete a[prop];}else if(a[prop]!==null&&b[prop]!==null&&_typeof(a[prop])==="object"&&_typeof(b[prop])==="object"&&!isArray(a[prop])&&!isArray(b[prop])){a[prop]=deepObjectAssignNonentry(a[prop],b[prop]);}else{a[prop]=clone(b[prop]);}}}catch(err){_iterator.e(err);}finally{_iterator.f();}return a;}/**
 * Deep clone given object or array. In case of primitive simply return.
 *
 * @param a - Anything.
 *
 * @returns Deep cloned object/array or unchanged a.
 */function clone(a){if(isArray(a)){return map$3(a).call(a,function(value){return clone(value);});}else if(_typeof(a)==="object"&&a!==null){return deepObjectAssignNonentry({},a);}else{return a;}}/**
 * Strip DELETE from given object.
 *
 * @param a - Object which may contain DELETE but won't after this is executed.
 */function stripDelete(a){for(var _i=0,_Object$keys=keys$3(a);_i<_Object$keys.length;_i++){var prop=_Object$keys[_i];if(a[prop]===DELETE){delete a[prop];}else if(_typeof(a[prop])==="object"&&a[prop]!==null){stripDelete(a[prop]);}}}/**
 * Seedable, fast and reasonably good (not crypto but more than okay for our
 * needs) random number generator.
 *
 * @remarks
 * Adapted from {@link https://web.archive.org/web/20110429100736/http://baagoe.com:80/en/RandomMusings/javascript}.
 * Original algorithm created by Johannes Baagøe \<baagoe\@baagoe.com\> in 2010.
 */ /**
 * Create a seeded pseudo random generator based on Alea by Johannes Baagøe.
 *
 * @param seed - All supplied arguments will be used as a seed. In case nothing
 * is supplied the current time will be used to seed the generator.
 *
 * @returns A ready to use seeded generator.
 */function Alea(){for(var _len3=arguments.length,seed=new Array(_len3),_key3=0;_key3<_len3;_key3++){seed[_key3]=arguments[_key3];}return AleaImplementation(seed.length?seed:[now$1()]);}/**
 * An implementation of [[Alea]] without user input validation.
 *
 * @param seed - The data that will be used to seed the generator.
 *
 * @returns A ready to use seeded generator.
 */function AleaImplementation(seed){var _mashSeed=mashSeed(seed),_mashSeed2=_slicedToArray(_mashSeed,3),s0=_mashSeed2[0],s1=_mashSeed2[1],s2=_mashSeed2[2];var c=1;var random=function random(){var t=2091639*s0+c*2.3283064365386963e-10;// 2^-32
s0=s1;s1=s2;return s2=t-(c=t|0);};random.uint32=function(){return random()*0x100000000;};// 2^32
random.fract53=function(){return random()+(random()*0x200000|0)*1.1102230246251565e-16;};// 2^-53
random.algorithm="Alea";random.seed=seed;random.version="0.9";return random;}/**
 * Turn arbitrary data into values [[AleaImplementation]] can use to generate
 * random numbers.
 *
 * @param seed - Arbitrary data that will be used as the seed.
 *
 * @returns Three numbers to use as initial values for [[AleaImplementation]].
 */function mashSeed(){var mash=Mash();var s0=mash(" ");var s1=mash(" ");var s2=mash(" ");for(var i=0;i<arguments.length;i++){s0-=mash(i<0||arguments.length<=i?undefined:arguments[i]);if(s0<0){s0+=1;}s1-=mash(i<0||arguments.length<=i?undefined:arguments[i]);if(s1<0){s1+=1;}s2-=mash(i<0||arguments.length<=i?undefined:arguments[i]);if(s2<0){s2+=1;}}return[s0,s1,s2];}/**
 * Create a new mash function.
 *
 * @returns A nonpure function that takes arbitrary [[Mashable]] data and turns
 * them into numbers.
 */function Mash(){var n=0xefc8249d;return function(data){var string=data.toString();for(var i=0;i<string.length;i++){n+=string.charCodeAt(i);var h=0.02519603282416938*n;n=h>>>0;h-=n;h*=n;n=h>>>0;h-=n;n+=h*0x100000000;// 2^32
}return(n>>>0)*2.3283064365386963e-10;// 2^-32
};}/**
 * Setup a mock hammer.js object, for unit testing.
 *
 * Inspiration: https://github.com/uber/deck.gl/pull/658
 *
 * @returns {{on: noop, off: noop, destroy: noop, emit: noop, get: get}}
 */function hammerMock(){var noop=function noop(){};return{on:noop,off:noop,destroy:noop,emit:noop,get:function get(){return{set:noop};}};}var Hammer=typeof window!=="undefined"?window.Hammer||Hammer$2:function(){// hammer.js is only available in a browser, not in node.js. Replacing it with a mock object.
return hammerMock();};/**
 * Turn an element into an clickToUse element.
 * When not active, the element has a transparent overlay. When the overlay is
 * clicked, the mode is changed to active.
 * When active, the element is displayed with a blue border around it, and
 * the interactive contents of the element can be used. When clicked outside
 * the element, the elements mode is changed to inactive.
 *
 * @param {Element} container
 * @class Activator
 */function Activator(container){var _this=this,_context3;this._cleanupQueue=[];this.active=false;this._dom={container:container,overlay:document.createElement("div")};this._dom.overlay.classList.add("vis-overlay");this._dom.container.appendChild(this._dom.overlay);this._cleanupQueue.push(function(){_this._dom.overlay.parentNode.removeChild(_this._dom.overlay);});var hammer=Hammer(this._dom.overlay);hammer.on("tap",bind(_context3=this._onTapOverlay).call(_context3,this));this._cleanupQueue.push(function(){hammer.destroy();// FIXME: cleaning up hammer instances doesn't work (Timeline not removed
// from memory)
});// block all touch events (except tap)
var events=["tap","doubletap","press","pinch","pan","panstart","panmove","panend"];forEach$2(events).call(events,function(event){hammer.on(event,function(event){event.srcEvent.stopPropagation();});});// attach a click event to the window, in order to deactivate when clicking outside the timeline
if(document&&document.body){this._onClick=function(event){if(!_hasParent(event.target,container)){_this.deactivate();}};document.body.addEventListener("click",this._onClick);this._cleanupQueue.push(function(){document.body.removeEventListener("click",_this._onClick);});}// prepare escape key listener for deactivating when active
this._escListener=function(event){if("key"in event?event.key==="Escape":event.keyCode===27/* the keyCode is for IE11 */){_this.deactivate();}};}// turn into an event emitter
componentEmitter(Activator.prototype);// The currently active activator
Activator.current=null;/**
 * Destroy the activator. Cleans up all created DOM and event listeners
 */Activator.prototype.destroy=function(){var _context4,_context5;this.deactivate();var _iterator2=_createForOfIteratorHelper$8(reverse(_context4=splice(_context5=this._cleanupQueue).call(_context5,0)).call(_context4)),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var callback=_step2.value;callback();}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}};/**
 * Activate the element
 * Overlay is hidden, element is decorated with a blue shadow border
 */Activator.prototype.activate=function(){// we allow only one active activator at a time
if(Activator.current){Activator.current.deactivate();}Activator.current=this;this.active=true;this._dom.overlay.style.display="none";this._dom.container.classList.add("vis-active");this.emit("change");this.emit("activate");// ugly hack: bind ESC after emitting the events, as the Network rebinds all
// keyboard events on a 'change' event
document.body.addEventListener("keydown",this._escListener);};/**
 * Deactivate the element
 * Overlay is displayed on top of the element
 */Activator.prototype.deactivate=function(){this.active=false;this._dom.overlay.style.display="block";this._dom.container.classList.remove("vis-active");document.body.removeEventListener("keydown",this._escListener);this.emit("change");this.emit("deactivate");};/**
 * Handle a tap event: activate the container
 *
 * @param {Event}  event   The event
 * @private
 */Activator.prototype._onTapOverlay=function(event){// activate the container
this.activate();event.srcEvent.stopPropagation();};/**
 * Test whether the element has the requested parent element somewhere in
 * its chain of parent nodes.
 *
 * @param {HTMLElement} element
 * @param {HTMLElement} parent
 * @returns {boolean} Returns true when the parent is found somewhere in the
 *                    chain of parent nodes.
 * @private
 */function _hasParent(element,parent){while(element){if(element===parent){return true;}element=element.parentNode;}return false;}// utility functions
var fullHexRE=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;var shortHexRE=/^#?([a-f\d])([a-f\d])([a-f\d])$/i;var rgbRE=/^rgb\( *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *\)$/i;var rgbaRE=/^rgba\( *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *(1?\d{1,2}|2[0-4]\d|25[0-5]) *, *([01]|0?\.\d+) *\)$/i;/**
 * Remove everything in the DOM object.
 *
 * @param DOMobject - Node whose child nodes will be recursively deleted.
 */function recursiveDOMDelete(DOMobject){if(DOMobject){while(DOMobject.hasChildNodes()===true){var child=DOMobject.firstChild;if(child){recursiveDOMDelete(child);DOMobject.removeChild(child);}}}}/**
 * Test whether given object is a string.
 *
 * @param value - Input value of unknown type.
 *
 * @returns True if string, false otherwise.
 */function isString(value){return value instanceof String||typeof value==="string";}/**
 * Test whether given object is a object (not primitive or null).
 *
 * @param value - Input value of unknown type.
 *
 * @returns True if not null object, false otherwise.
 */function isObject(value){return _typeof(value)==="object"&&value!==null;}/**
 * Copy property from b to a if property present in a.
 * If property in b explicitly set to null, delete it if `allowDeletion` set.
 *
 * Internal helper routine, should not be exported. Not added to `exports` for that reason.
 *
 * @param a - Target object.
 * @param b - Source object.
 * @param prop - Name of property to copy from b to a.
 * @param allowDeletion - If true, delete property in a if explicitly set to null in b.
 */function copyOrDelete(a,b,prop,allowDeletion){var doDeletion=false;if(allowDeletion===true){doDeletion=b[prop]===null&&a[prop]!==undefined;}if(doDeletion){delete a[prop];}else{a[prop]=b[prop];// Remember, this is a reference copy!
}}/**
 * Fill an object with a possibly partially defined other object.
 *
 * Only copies values for the properties already present in a.
 * That means an object is not created on a property if only the b object has it.
 *
 * @param a - The object that will have it's properties updated.
 * @param b - The object with property updates.
 * @param allowDeletion - If true, delete properties in a that are explicitly set to null in b.
 */function fillIfDefined(a,b){var allowDeletion=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;// NOTE: iteration of properties of a
// NOTE: prototype properties iterated over as well
for(var prop in a){if(b[prop]!==undefined){if(b[prop]===null||_typeof(b[prop])!=="object"){// Note: typeof null === 'object'
copyOrDelete(a,b,prop,allowDeletion);}else{var aProp=a[prop];var bProp=b[prop];if(isObject(aProp)&&isObject(bProp)){fillIfDefined(aProp,bProp,allowDeletion);}}}}}/**
 * Extend object a with selected properties of object b.
 * Only properties with defined values are copied.
 *
 * @remarks
 * Previous version of this routine implied that multiple source objects could
 * be used; however, the implementation was **wrong**. Since multiple (\>1)
 * sources weren't used anywhere in the `vis.js` code, this has been removed
 *
 * @param props - Names of first-level properties to copy over.
 * @param a - Target object.
 * @param b - Source object.
 * @param allowDeletion - If true, delete property in a if explicitly set to null in b.
 *
 * @returns Argument a.
 */function selectiveDeepExtend(props,a,b){var allowDeletion=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;// TODO: add support for Arrays to deepExtend
if(isArray(b)){throw new TypeError("Arrays are not supported by deepExtend");}for(var p=0;p<props.length;p++){var prop=props[p];if(Object.prototype.hasOwnProperty.call(b,prop)){if(b[prop]&&b[prop].constructor===Object){if(a[prop]===undefined){a[prop]={};}if(a[prop].constructor===Object){deepExtend(a[prop],b[prop],false,allowDeletion);}else{copyOrDelete(a,b,prop,allowDeletion);}}else if(isArray(b[prop])){throw new TypeError("Arrays are not supported by deepExtend");}else{copyOrDelete(a,b,prop,allowDeletion);}}}return a;}/**
 * Extend object `a` with properties of object `b`, ignoring properties which
 * are explicitly specified to be excluded.
 *
 * @remarks
 * The properties of `b` are considered for copying. Properties which are
 * themselves objects are are also extended. Only properties with defined
 * values are copied.
 *
 * @param propsToExclude - Names of properties which should *not* be copied.
 * @param a - Object to extend.
 * @param b - Object to take properties from for extension.
 * @param allowDeletion - If true, delete properties in a that are explicitly
 * set to null in b.
 *
 * @returns Argument a.
 */function selectiveNotDeepExtend(propsToExclude,a,b){var allowDeletion=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;// TODO: add support for Arrays to deepExtend
// NOTE: array properties have an else-below; apparently, there is a problem here.
if(isArray(b)){throw new TypeError("Arrays are not supported by deepExtend");}for(var prop in b){if(!Object.prototype.hasOwnProperty.call(b,prop)){continue;}// Handle local properties only
if(includes(propsToExclude).call(propsToExclude,prop)){continue;}// In exclusion list, skip
if(b[prop]&&b[prop].constructor===Object){if(a[prop]===undefined){a[prop]={};}if(a[prop].constructor===Object){deepExtend(a[prop],b[prop]);// NOTE: allowDeletion not propagated!
}else{copyOrDelete(a,b,prop,allowDeletion);}}else if(isArray(b[prop])){a[prop]=[];for(var i=0;i<b[prop].length;i++){a[prop].push(b[prop][i]);}}else{copyOrDelete(a,b,prop,allowDeletion);}}return a;}/**
 * Deep extend an object a with the properties of object b.
 *
 * @param a - Target object.
 * @param b - Source object.
 * @param protoExtend - If true, the prototype values will also be extended.
 * (That is the options objects that inherit from others will also get the
 * inherited options).
 * @param allowDeletion - If true, the values of fields that are null will be deleted.
 *
 * @returns Argument a.
 */function deepExtend(a,b){var protoExtend=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var allowDeletion=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;for(var prop in b){if(Object.prototype.hasOwnProperty.call(b,prop)||protoExtend===true){if(_typeof(b[prop])==="object"&&b[prop]!==null&&getPrototypeOf$2(b[prop])===Object.prototype){if(a[prop]===undefined){a[prop]=deepExtend({},b[prop],protoExtend);// NOTE: allowDeletion not propagated!
}else if(_typeof(a[prop])==="object"&&a[prop]!==null&&getPrototypeOf$2(a[prop])===Object.prototype){deepExtend(a[prop],b[prop],protoExtend);// NOTE: allowDeletion not propagated!
}else{copyOrDelete(a,b,prop,allowDeletion);}}else if(isArray(b[prop])){var _context6;a[prop]=slice$1(_context6=b[prop]).call(_context6);}else{copyOrDelete(a,b,prop,allowDeletion);}}}return a;}/**
 * Used to extend an array and copy it. This is used to propagate paths recursively.
 *
 * @param arr - First part.
 * @param newValue - The value to be aadded into the array.
 *
 * @returns A new array with all items from arr and newValue (which is last).
 */function copyAndExtendArray(arr,newValue){var _context7;return concat(_context7=[]).call(_context7,_toConsumableArray(arr),[newValue]);}/**
 * Used to extend an array and copy it. This is used to propagate paths recursively.
 *
 * @param arr - The array to be copied.
 *
 * @returns Shallow copy of arr.
 */function copyArray(arr){return slice$1(arr).call(arr);}/**
 * Retrieve the absolute left value of a DOM element.
 *
 * @param elem - A dom element, for example a div.
 *
 * @returns The absolute left position of this element in the browser page.
 */function getAbsoluteLeft(elem){return elem.getBoundingClientRect().left;}/**
 * Retrieve the absolute top value of a DOM element.
 *
 * @param elem - A dom element, for example a div.
 *
 * @returns The absolute top position of this element in the browser page.
 */function getAbsoluteTop(elem){return elem.getBoundingClientRect().top;}/**
 * For each method for both arrays and objects.
 * In case of an array, the built-in Array.forEach() is applied (**No, it's not!**).
 * In case of an Object, the method loops over all properties of the object.
 *
 * @param object - An Object or Array to be iterated over.
 * @param callback - Array.forEach-like callback.
 */function forEach$1(object,callback){if(isArray(object)){// array
var len=object.length;for(var i=0;i<len;i++){callback(object[i],i,object);}}else{// object
for(var key in object){if(Object.prototype.hasOwnProperty.call(object,key)){callback(object[key],key,object);}}}}/**
 * Add and event listener. Works for all browsers.
 *
 * @param element - The element to bind the event listener to.
 * @param action - Same as Element.addEventListener(action, —, —).
 * @param listener - Same as Element.addEventListener(—, listener, —).
 * @param useCapture - Same as Element.addEventListener(—, —, useCapture).
 */function addEventListener(element,action,listener,useCapture){if(element.addEventListener){var _context8;if(useCapture===undefined){useCapture=false;}if(action==="mousewheel"&&includes(_context8=navigator.userAgent).call(_context8,"Firefox")){action="DOMMouseScroll";// For Firefox
}element.addEventListener(action,listener,useCapture);}else{// @TODO: IE types? Does anyone care?
element.attachEvent("on"+action,listener);// IE browsers
}}/**
 * Remove an event listener from an element.
 *
 * @param element - The element to bind the event listener to.
 * @param action - Same as Element.removeEventListener(action, —, —).
 * @param listener - Same as Element.removeEventListener(—, listener, —).
 * @param useCapture - Same as Element.removeEventListener(—, —, useCapture).
 */function removeEventListener(element,action,listener,useCapture){if(element.removeEventListener){var _context9;// non-IE browsers
if(useCapture===undefined){useCapture=false;}if(action==="mousewheel"&&includes(_context9=navigator.userAgent).call(_context9,"Firefox")){action="DOMMouseScroll";// For Firefox
}element.removeEventListener(action,listener,useCapture);}else{// @TODO: IE types? Does anyone care?
element.detachEvent("on"+action,listener);// IE browsers
}}/**
 * Convert hex color string into RGB color object.
 *
 * @remarks
 * {@link http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb}
 *
 * @param hex - Hex color string (3 or 6 digits, with or without #).
 *
 * @returns RGB color object.
 */function hexToRGB(hex){var result;switch(hex.length){case 3:case 4:result=shortHexRE.exec(hex);return result?{r:_parseInt(result[1]+result[1],16),g:_parseInt(result[2]+result[2],16),b:_parseInt(result[3]+result[3],16)}:null;case 6:case 7:result=fullHexRE.exec(hex);return result?{r:_parseInt(result[1],16),g:_parseInt(result[2],16),b:_parseInt(result[3],16)}:null;default:return null;}}/**
 * This function takes string color in hex or RGB format and adds the opacity, RGBA is passed through unchanged.
 *
 * @param color - The color string (hex, RGB, RGBA).
 * @param opacity - The new opacity.
 *
 * @returns RGBA string, for example 'rgba(255, 0, 127, 0.3)'.
 */function overrideOpacity(color,opacity){if(includes(color).call(color,"rgba")){return color;}else if(includes(color).call(color,"rgb")){var rgb=color.substr(indexOf(color).call(color,"(")+1).replace(")","").split(",");return"rgba("+rgb[0]+","+rgb[1]+","+rgb[2]+","+opacity+")";}else{var _rgb=hexToRGB(color);if(_rgb==null){return color;}else{return"rgba("+_rgb.r+","+_rgb.g+","+_rgb.b+","+opacity+")";}}}/**
 * Convert RGB \<0, 255\> into hex color string.
 *
 * @param red - Red channel.
 * @param green - Green channel.
 * @param blue - Blue channel.
 *
 * @returns Hex color string (for example: '#0acdc0').
 */function RGBToHex(red,green,blue){var _context10;return"#"+slice$1(_context10=((1<<24)+(red<<16)+(green<<8)+blue).toString(16)).call(_context10,1);}/**
 * Parse a color property into an object with border, background, and highlight colors.
 *
 * @param inputColor - Shorthand color string or input color object.
 * @param defaultColor - Full color object to fill in missing values in inputColor.
 *
 * @returns Color object.
 */function parseColor(inputColor,defaultColor){if(isString(inputColor)){var colorStr=inputColor;if(isValidRGB(colorStr)){var _context11;var rgb=map$3(_context11=colorStr.substr(4).substr(0,colorStr.length-5).split(",")).call(_context11,function(value){return _parseInt(value);});colorStr=RGBToHex(rgb[0],rgb[1],rgb[2]);}if(isValidHex(colorStr)===true){var hsv=hexToHSV(colorStr);var lighterColorHSV={h:hsv.h,s:hsv.s*0.8,v:Math.min(1,hsv.v*1.02)};var darkerColorHSV={h:hsv.h,s:Math.min(1,hsv.s*1.25),v:hsv.v*0.8};var darkerColorHex=HSVToHex(darkerColorHSV.h,darkerColorHSV.s,darkerColorHSV.v);var lighterColorHex=HSVToHex(lighterColorHSV.h,lighterColorHSV.s,lighterColorHSV.v);return{background:colorStr,border:darkerColorHex,highlight:{background:lighterColorHex,border:darkerColorHex},hover:{background:lighterColorHex,border:darkerColorHex}};}else{return{background:colorStr,border:colorStr,highlight:{background:colorStr,border:colorStr},hover:{background:colorStr,border:colorStr}};}}else{if(defaultColor){var color={background:inputColor.background||defaultColor.background,border:inputColor.border||defaultColor.border,highlight:isString(inputColor.highlight)?{border:inputColor.highlight,background:inputColor.highlight}:{background:inputColor.highlight&&inputColor.highlight.background||defaultColor.highlight.background,border:inputColor.highlight&&inputColor.highlight.border||defaultColor.highlight.border},hover:isString(inputColor.hover)?{border:inputColor.hover,background:inputColor.hover}:{border:inputColor.hover&&inputColor.hover.border||defaultColor.hover.border,background:inputColor.hover&&inputColor.hover.background||defaultColor.hover.background}};return color;}else{var _color={background:inputColor.background||undefined,border:inputColor.border||undefined,highlight:isString(inputColor.highlight)?{border:inputColor.highlight,background:inputColor.highlight}:{background:inputColor.highlight&&inputColor.highlight.background||undefined,border:inputColor.highlight&&inputColor.highlight.border||undefined},hover:isString(inputColor.hover)?{border:inputColor.hover,background:inputColor.hover}:{border:inputColor.hover&&inputColor.hover.border||undefined,background:inputColor.hover&&inputColor.hover.background||undefined}};return _color;}}}/**
 * Convert RGB \<0, 255\> into HSV object.
 *
 * @remarks
 * {@link http://www.javascripter.net/faq/rgb2hsv.htm}
 *
 * @param red - Red channel.
 * @param green - Green channel.
 * @param blue - Blue channel.
 *
 * @returns HSV color object.
 */function RGBToHSV(red,green,blue){red=red/255;green=green/255;blue=blue/255;var minRGB=Math.min(red,Math.min(green,blue));var maxRGB=Math.max(red,Math.max(green,blue));// Black-gray-white
if(minRGB===maxRGB){return{h:0,s:0,v:minRGB};}// Colors other than black-gray-white:
var d=red===minRGB?green-blue:blue===minRGB?red-green:blue-red;var h=red===minRGB?3:blue===minRGB?1:5;var hue=60*(h-d/(maxRGB-minRGB))/360;var saturation=(maxRGB-minRGB)/maxRGB;var value=maxRGB;return{h:hue,s:saturation,v:value};}/**
 * Convert HSV \<0, 1\> into RGB color object.
 *
 * @remarks
 * {@link https://gist.github.com/mjijackson/5311256}
 *
 * @param h - Hue.
 * @param s - Saturation.
 * @param v - Value.
 *
 * @returns RGB color object.
 */function HSVToRGB(h,s,v){var r;var g;var b;var i=Math.floor(h*6);var f=h*6-i;var p=v*(1-s);var q=v*(1-f*s);var t=v*(1-(1-f)*s);switch(i%6){case 0:r=v,g=t,b=p;break;case 1:r=q,g=v,b=p;break;case 2:r=p,g=v,b=t;break;case 3:r=p,g=q,b=v;break;case 4:r=t,g=p,b=v;break;case 5:r=v,g=p,b=q;break;}return{r:Math.floor(r*255),g:Math.floor(g*255),b:Math.floor(b*255)};}/**
 * Convert HSV \<0, 1\> into hex color string.
 *
 * @param h - Hue.
 * @param s - Saturation.
 * @param v - Value.
 *
 * @returns Hex color string.
 */function HSVToHex(h,s,v){var rgb=HSVToRGB(h,s,v);return RGBToHex(rgb.r,rgb.g,rgb.b);}/**
 * Convert hex color string into HSV \<0, 1\>.
 *
 * @param hex - Hex color string.
 *
 * @returns HSV color object.
 */function hexToHSV(hex){var rgb=hexToRGB(hex);if(!rgb){throw new TypeError("'".concat(hex,"' is not a valid color."));}return RGBToHSV(rgb.r,rgb.g,rgb.b);}/**
 * Validate hex color string.
 *
 * @param hex - Unknown string that may contain a color.
 *
 * @returns True if the string is valid, false otherwise.
 */function isValidHex(hex){var isOk=/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);return isOk;}/**
 * Validate RGB color string.
 *
 * @param rgb - Unknown string that may contain a color.
 *
 * @returns True if the string is valid, false otherwise.
 */function isValidRGB(rgb){return rgbRE.test(rgb);}/**
 * Validate RGBA color string.
 *
 * @param rgba - Unknown string that may contain a color.
 *
 * @returns True if the string is valid, false otherwise.
 */function isValidRGBA(rgba){return rgbaRE.test(rgba);}/**
 * This recursively redirects the prototype of JSON objects to the referenceObject.
 * This is used for default options.
 *
 * @param referenceObject - The original object.
 *
 * @returns The Element if the referenceObject is an Element, or a new object inheriting from the referenceObject.
 */function bridgeObject(referenceObject){if(referenceObject===null||_typeof(referenceObject)!=="object"){return null;}if(referenceObject instanceof Element){// Avoid bridging DOM objects
return referenceObject;}var objectTo=create$2(referenceObject);for(var i in referenceObject){if(Object.prototype.hasOwnProperty.call(referenceObject,i)){if(_typeof(referenceObject[i])=="object"){objectTo[i]=bridgeObject(referenceObject[i]);}}}return objectTo;}/**
 * This is used to set the options of subobjects in the options object.
 *
 * A requirement of these subobjects is that they have an 'enabled' element
 * which is optional for the user but mandatory for the program.
 *
 * The added value here of the merge is that option 'enabled' is set as required.
 *
 * @param mergeTarget - Either this.options or the options used for the groups.
 * @param options - Options.
 * @param option - Option key in the options argument.
 * @param globalOptions - Global options, passed in to determine value of option 'enabled'.
 */function mergeOptions(mergeTarget,options,option){var globalOptions=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};// Local helpers
var isPresent=function isPresent(obj){return obj!==null&&obj!==undefined;};var isObject=function isObject(obj){return obj!==null&&_typeof(obj)==="object";};// https://stackoverflow.com/a/34491287/1223531
var isEmpty=function isEmpty(obj){for(var x in obj){if(Object.prototype.hasOwnProperty.call(obj,x)){return false;}}return true;};// Guards
if(!isObject(mergeTarget)){throw new Error("Parameter mergeTarget must be an object");}if(!isObject(options)){throw new Error("Parameter options must be an object");}if(!isPresent(option)){throw new Error("Parameter option must have a value");}if(!isObject(globalOptions)){throw new Error("Parameter globalOptions must be an object");}//
// Actual merge routine, separated from main logic
// Only a single level of options is merged. Deeper levels are ref'd. This may actually be an issue.
//
var doMerge=function doMerge(target,options,option){if(!isObject(target[option])){target[option]={};}var src=options[option];var dst=target[option];for(var prop in src){if(Object.prototype.hasOwnProperty.call(src,prop)){dst[prop]=src[prop];}}};// Local initialization
var srcOption=options[option];var globalPassed=isObject(globalOptions)&&!isEmpty(globalOptions);var globalOption=globalPassed?globalOptions[option]:undefined;var globalEnabled=globalOption?globalOption.enabled:undefined;/////////////////////////////////////////
// Main routine
/////////////////////////////////////////
if(srcOption===undefined){return;// Nothing to do
}if(typeof srcOption==="boolean"){if(!isObject(mergeTarget[option])){mergeTarget[option]={};}mergeTarget[option].enabled=srcOption;return;}if(srcOption===null&&!isObject(mergeTarget[option])){// If possible, explicit copy from globals
if(isPresent(globalOption)){mergeTarget[option]=create$2(globalOption);}else{return;// Nothing to do
}}if(!isObject(srcOption)){return;}//
// Ensure that 'enabled' is properly set. It is required internally
// Note that the value from options will always overwrite the existing value
//
var enabled=true;// default value
if(srcOption.enabled!==undefined){enabled=srcOption.enabled;}else{// Take from globals, if present
if(globalEnabled!==undefined){enabled=globalOption.enabled;}}doMerge(mergeTarget,options,option);mergeTarget[option].enabled=enabled;}/*
 * Easing Functions.
 * Only considering the t value for the range [0, 1] => [0, 1].
 *
 * Inspiration: from http://gizma.com/easing/
 * https://gist.github.com/gre/1650294
 */var easingFunctions={/**
   * Provides no easing and no acceleration.
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */linear:function linear(t){return t;},/**
   * Accelerate from zero velocity.
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */easeInQuad:function easeInQuad(t){return t*t;},/**
   * Decelerate to zero velocity.
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */easeOutQuad:function easeOutQuad(t){return t*(2-t);},/**
   * Accelerate until halfway, then decelerate.
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */easeInOutQuad:function easeInOutQuad(t){return t<0.5?2*t*t:-1+(4-2*t)*t;},/**
   * Accelerate from zero velocity.
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */easeInCubic:function easeInCubic(t){return t*t*t;},/**
   * Decelerate to zero velocity.
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */easeOutCubic:function easeOutCubic(t){return--t*t*t+1;},/**
   * Accelerate until halfway, then decelerate.
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */easeInOutCubic:function easeInOutCubic(t){return t<0.5?4*t*t*t:(t-1)*(2*t-2)*(2*t-2)+1;},/**
   * Accelerate from zero velocity.
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */easeInQuart:function easeInQuart(t){return t*t*t*t;},/**
   * Decelerate to zero velocity.
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */easeOutQuart:function easeOutQuart(t){return 1- --t*t*t*t;},/**
   * Accelerate until halfway, then decelerate.
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */easeInOutQuart:function easeInOutQuart(t){return t<0.5?8*t*t*t*t:1-8*--t*t*t*t;},/**
   * Accelerate from zero velocity.
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */easeInQuint:function easeInQuint(t){return t*t*t*t*t;},/**
   * Decelerate to zero velocity.
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */easeOutQuint:function easeOutQuint(t){return 1+--t*t*t*t*t;},/**
   * Accelerate until halfway, then decelerate.
   *
   * @param t - Time.
   *
   * @returns Value at time t.
   */easeInOutQuint:function easeInOutQuint(t){return t<0.5?16*t*t*t*t*t:1+16*--t*t*t*t*t;}};// It works only for single property objects,
// otherwise it combines all of the types in a union.
// export function topMost<K1 extends string, V1> (
//   pile: Record<K1, undefined | V1>[],
//   accessors: K1 | [K1]
// ): undefined | V1
// export function topMost<K1 extends string, K2 extends string, V1, V2> (
//   pile: Record<K1, undefined | V1 | Record<K2, undefined | V2>>[],
//   accessors: [K1, K2]
// ): undefined | V1 | V2
// export function topMost<K1 extends string, K2 extends string, K3 extends string, V1, V2, V3> (
//   pile: Record<K1, undefined | V1 | Record<K2, undefined | V2 | Record<K3, undefined | V3>>>[],
//   accessors: [K1, K2, K3]
// ): undefined | V1 | V2 | V3
/**
 * Get the top most property value from a pile of objects.
 *
 * @param pile - Array of objects, no required format.
 * @param accessors - Array of property names.
 * For example `object['foo']['bar']` → `['foo', 'bar']`.
 *
 * @returns Value of the property with given accessors path from the first pile item where it's not undefined.
 */function topMost(pile,accessors){var candidate;if(!isArray(accessors)){accessors=[accessors];}var _iterator3=_createForOfIteratorHelper$8(pile),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var member=_step3.value;if(member){candidate=member[accessors[0]];for(var i=1;i<accessors.length;i++){if(candidate){candidate=candidate[accessors[i]];}}if(typeof candidate!=="undefined"){break;}}}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}return candidate;}var htmlColors={black:"#000000",navy:"#000080",darkblue:"#00008B",mediumblue:"#0000CD",blue:"#0000FF",darkgreen:"#006400",green:"#008000",teal:"#008080",darkcyan:"#008B8B",deepskyblue:"#00BFFF",darkturquoise:"#00CED1",mediumspringgreen:"#00FA9A",lime:"#00FF00",springgreen:"#00FF7F",aqua:"#00FFFF",cyan:"#00FFFF",midnightblue:"#191970",dodgerblue:"#1E90FF",lightseagreen:"#20B2AA",forestgreen:"#228B22",seagreen:"#2E8B57",darkslategray:"#2F4F4F",limegreen:"#32CD32",mediumseagreen:"#3CB371",turquoise:"#40E0D0",royalblue:"#4169E1",steelblue:"#4682B4",darkslateblue:"#483D8B",mediumturquoise:"#48D1CC",indigo:"#4B0082",darkolivegreen:"#556B2F",cadetblue:"#5F9EA0",cornflowerblue:"#6495ED",mediumaquamarine:"#66CDAA",dimgray:"#696969",slateblue:"#6A5ACD",olivedrab:"#6B8E23",slategray:"#708090",lightslategray:"#778899",mediumslateblue:"#7B68EE",lawngreen:"#7CFC00",chartreuse:"#7FFF00",aquamarine:"#7FFFD4",maroon:"#800000",purple:"#800080",olive:"#808000",gray:"#808080",skyblue:"#87CEEB",lightskyblue:"#87CEFA",blueviolet:"#8A2BE2",darkred:"#8B0000",darkmagenta:"#8B008B",saddlebrown:"#8B4513",darkseagreen:"#8FBC8F",lightgreen:"#90EE90",mediumpurple:"#9370D8",darkviolet:"#9400D3",palegreen:"#98FB98",darkorchid:"#9932CC",yellowgreen:"#9ACD32",sienna:"#A0522D",brown:"#A52A2A",darkgray:"#A9A9A9",lightblue:"#ADD8E6",greenyellow:"#ADFF2F",paleturquoise:"#AFEEEE",lightsteelblue:"#B0C4DE",powderblue:"#B0E0E6",firebrick:"#B22222",darkgoldenrod:"#B8860B",mediumorchid:"#BA55D3",rosybrown:"#BC8F8F",darkkhaki:"#BDB76B",silver:"#C0C0C0",mediumvioletred:"#C71585",indianred:"#CD5C5C",peru:"#CD853F",chocolate:"#D2691E",tan:"#D2B48C",lightgrey:"#D3D3D3",palevioletred:"#D87093",thistle:"#D8BFD8",orchid:"#DA70D6",goldenrod:"#DAA520",crimson:"#DC143C",gainsboro:"#DCDCDC",plum:"#DDA0DD",burlywood:"#DEB887",lightcyan:"#E0FFFF",lavender:"#E6E6FA",darksalmon:"#E9967A",violet:"#EE82EE",palegoldenrod:"#EEE8AA",lightcoral:"#F08080",khaki:"#F0E68C",aliceblue:"#F0F8FF",honeydew:"#F0FFF0",azure:"#F0FFFF",sandybrown:"#F4A460",wheat:"#F5DEB3",beige:"#F5F5DC",whitesmoke:"#F5F5F5",mintcream:"#F5FFFA",ghostwhite:"#F8F8FF",salmon:"#FA8072",antiquewhite:"#FAEBD7",linen:"#FAF0E6",lightgoldenrodyellow:"#FAFAD2",oldlace:"#FDF5E6",red:"#FF0000",fuchsia:"#FF00FF",magenta:"#FF00FF",deeppink:"#FF1493",orangered:"#FF4500",tomato:"#FF6347",hotpink:"#FF69B4",coral:"#FF7F50",darkorange:"#FF8C00",lightsalmon:"#FFA07A",orange:"#FFA500",lightpink:"#FFB6C1",pink:"#FFC0CB",gold:"#FFD700",peachpuff:"#FFDAB9",navajowhite:"#FFDEAD",moccasin:"#FFE4B5",bisque:"#FFE4C4",mistyrose:"#FFE4E1",blanchedalmond:"#FFEBCD",papayawhip:"#FFEFD5",lavenderblush:"#FFF0F5",seashell:"#FFF5EE",cornsilk:"#FFF8DC",lemonchiffon:"#FFFACD",floralwhite:"#FFFAF0",snow:"#FFFAFA",yellow:"#FFFF00",lightyellow:"#FFFFE0",ivory:"#FFFFF0",white:"#FFFFFF"};/**
 * @param {number} [pixelRatio=1]
 */var ColorPicker=/*#__PURE__*/function(){/**
   * @param {number} [pixelRatio=1]
   */function ColorPicker(){var pixelRatio=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;_classCallCheck(this,ColorPicker);this.pixelRatio=pixelRatio;this.generated=false;this.centerCoordinates={x:289/2,y:289/2};this.r=289*0.49;this.color={r:255,g:255,b:255,a:1.0};this.hueCircle=undefined;this.initialColor={r:255,g:255,b:255,a:1.0};this.previousColor=undefined;this.applied=false;// bound by
this.updateCallback=function(){};this.closeCallback=function(){};// create all DOM elements
this._create();}/**
   * this inserts the colorPicker into a div from the DOM
   *
   * @param {Element} container
   */_createClass(ColorPicker,[{key:"insertTo",value:function insertTo(container){if(this.hammer!==undefined){this.hammer.destroy();this.hammer=undefined;}this.container=container;this.container.appendChild(this.frame);this._bindHammer();this._setSize();}/**
     * the callback is executed on apply and save. Bind it to the application
     *
     * @param {Function} callback
     */},{key:"setUpdateCallback",value:function setUpdateCallback(callback){if(typeof callback==="function"){this.updateCallback=callback;}else{throw new Error("Function attempted to set as colorPicker update callback is not a function.");}}/**
     * the callback is executed on apply and save. Bind it to the application
     *
     * @param {Function} callback
     */},{key:"setCloseCallback",value:function setCloseCallback(callback){if(typeof callback==="function"){this.closeCallback=callback;}else{throw new Error("Function attempted to set as colorPicker closing callback is not a function.");}}/**
     *
     * @param {string} color
     * @returns {string}
     * @private
     */},{key:"_isColorString",value:function _isColorString(color){if(typeof color==="string"){return htmlColors[color];}}/**
     * Set the color of the colorPicker
     * Supported formats:
     * 'red'                   --> HTML color string
     * '#ffffff'               --> hex string
     * 'rgb(255,255,255)'      --> rgb string
     * 'rgba(255,255,255,1.0)' --> rgba string
     * {r:255,g:255,b:255}     --> rgb object
     * {r:255,g:255,b:255,a:1.0} --> rgba object
     *
     * @param {string | object} color
     * @param {boolean} [setInitial=true]
     */},{key:"setColor",value:function setColor(color){var setInitial=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;if(color==="none"){return;}var rgba;// if a html color shorthand is used, convert to hex
var htmlColor=this._isColorString(color);if(htmlColor!==undefined){color=htmlColor;}// check format
if(isString(color)===true){if(isValidRGB(color)===true){var rgbaArray=color.substr(4).substr(0,color.length-5).split(",");rgba={r:rgbaArray[0],g:rgbaArray[1],b:rgbaArray[2],a:1.0};}else if(isValidRGBA(color)===true){var _rgbaArray=color.substr(5).substr(0,color.length-6).split(",");rgba={r:_rgbaArray[0],g:_rgbaArray[1],b:_rgbaArray[2],a:_rgbaArray[3]};}else if(isValidHex(color)===true){var rgbObj=hexToRGB(color);rgba={r:rgbObj.r,g:rgbObj.g,b:rgbObj.b,a:1.0};}}else{if(color instanceof Object){if(color.r!==undefined&&color.g!==undefined&&color.b!==undefined){var alpha=color.a!==undefined?color.a:"1.0";rgba={r:color.r,g:color.g,b:color.b,a:alpha};}}}// set color
if(rgba===undefined){throw new Error("Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: "+stringify$1(color));}else{this._setColor(rgba,setInitial);}}/**
     * this shows the color picker.
     * The hue circle is constructed once and stored.
     */},{key:"show",value:function show(){if(this.closeCallback!==undefined){this.closeCallback();this.closeCallback=undefined;}this.applied=false;this.frame.style.display="block";this._generateHueCircle();}// ------------------------------------------ PRIVATE ----------------------------- //
/**
     * Hide the picker. Is called by the cancel button.
     * Optional boolean to store the previous color for easy access later on.
     *
     * @param {boolean} [storePrevious=true]
     * @private
     */},{key:"_hide",value:function _hide(){var _this2=this;var storePrevious=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;// store the previous color for next time;
if(storePrevious===true){this.previousColor=assign$2({},this.color);}if(this.applied===true){this.updateCallback(this.initialColor);}this.frame.style.display="none";// call the closing callback, restoring the onclick method.
// this is in a setTimeout because it will trigger the show again before the click is done.
setTimeout$1(function(){if(_this2.closeCallback!==undefined){_this2.closeCallback();_this2.closeCallback=undefined;}},0);}/**
     * bound to the save button. Saves and hides.
     *
     * @private
     */},{key:"_save",value:function _save(){this.updateCallback(this.color);this.applied=false;this._hide();}/**
     * Bound to apply button. Saves but does not close. Is undone by the cancel button.
     *
     * @private
     */},{key:"_apply",value:function _apply(){this.applied=true;this.updateCallback(this.color);this._updatePicker(this.color);}/**
     * load the color from the previous session.
     *
     * @private
     */},{key:"_loadLast",value:function _loadLast(){if(this.previousColor!==undefined){this.setColor(this.previousColor,false);}else{alert("There is no last color to load...");}}/**
     * set the color, place the picker
     *
     * @param {object} rgba
     * @param {boolean} [setInitial=true]
     * @private
     */},{key:"_setColor",value:function _setColor(rgba){var setInitial=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;// store the initial color
if(setInitial===true){this.initialColor=assign$2({},rgba);}this.color=rgba;var hsv=RGBToHSV(rgba.r,rgba.g,rgba.b);var angleConvert=2*Math.PI;var radius=this.r*hsv.s;var x=this.centerCoordinates.x+radius*Math.sin(angleConvert*hsv.h);var y=this.centerCoordinates.y+radius*Math.cos(angleConvert*hsv.h);this.colorPickerSelector.style.left=x-0.5*this.colorPickerSelector.clientWidth+"px";this.colorPickerSelector.style.top=y-0.5*this.colorPickerSelector.clientHeight+"px";this._updatePicker(rgba);}/**
     * bound to opacity control
     *
     * @param {number} value
     * @private
     */},{key:"_setOpacity",value:function _setOpacity(value){this.color.a=value/100;this._updatePicker(this.color);}/**
     * bound to brightness control
     *
     * @param {number} value
     * @private
     */},{key:"_setBrightness",value:function _setBrightness(value){var hsv=RGBToHSV(this.color.r,this.color.g,this.color.b);hsv.v=value/100;var rgba=HSVToRGB(hsv.h,hsv.s,hsv.v);rgba["a"]=this.color.a;this.color=rgba;this._updatePicker();}/**
     * update the color picker. A black circle overlays the hue circle to mimic the brightness decreasing.
     *
     * @param {object} rgba
     * @private
     */},{key:"_updatePicker",value:function _updatePicker(){var rgba=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.color;var hsv=RGBToHSV(rgba.r,rgba.g,rgba.b);var ctx=this.colorPickerCanvas.getContext("2d");if(this.pixelRation===undefined){this.pixelRatio=(window.devicePixelRatio||1)/(ctx.webkitBackingStorePixelRatio||ctx.mozBackingStorePixelRatio||ctx.msBackingStorePixelRatio||ctx.oBackingStorePixelRatio||ctx.backingStorePixelRatio||1);}ctx.setTransform(this.pixelRatio,0,0,this.pixelRatio,0,0);// clear the canvas
var w=this.colorPickerCanvas.clientWidth;var h=this.colorPickerCanvas.clientHeight;ctx.clearRect(0,0,w,h);ctx.putImageData(this.hueCircle,0,0);ctx.fillStyle="rgba(0,0,0,"+(1-hsv.v)+")";ctx.circle(this.centerCoordinates.x,this.centerCoordinates.y,this.r);fill(ctx).call(ctx);this.brightnessRange.value=100*hsv.v;this.opacityRange.value=100*rgba.a;this.initialColorDiv.style.backgroundColor="rgba("+this.initialColor.r+","+this.initialColor.g+","+this.initialColor.b+","+this.initialColor.a+")";this.newColorDiv.style.backgroundColor="rgba("+this.color.r+","+this.color.g+","+this.color.b+","+this.color.a+")";}/**
     * used by create to set the size of the canvas.
     *
     * @private
     */},{key:"_setSize",value:function _setSize(){this.colorPickerCanvas.style.width="100%";this.colorPickerCanvas.style.height="100%";this.colorPickerCanvas.width=289*this.pixelRatio;this.colorPickerCanvas.height=289*this.pixelRatio;}/**
     * create all dom elements
     * TODO: cleanup, lots of similar dom elements
     *
     * @private
     */},{key:"_create",value:function _create(){var _context16,_context17,_context18,_context19;this.frame=document.createElement("div");this.frame.className="vis-color-picker";this.colorPickerDiv=document.createElement("div");this.colorPickerSelector=document.createElement("div");this.colorPickerSelector.className="vis-selector";this.colorPickerDiv.appendChild(this.colorPickerSelector);this.colorPickerCanvas=document.createElement("canvas");this.colorPickerDiv.appendChild(this.colorPickerCanvas);if(!this.colorPickerCanvas.getContext){var noCanvas=document.createElement("DIV");noCanvas.style.color="red";noCanvas.style.fontWeight="bold";noCanvas.style.padding="10px";noCanvas.innerText="Error: your browser does not support HTML canvas";this.colorPickerCanvas.appendChild(noCanvas);}else{var ctx=this.colorPickerCanvas.getContext("2d");this.pixelRatio=(window.devicePixelRatio||1)/(ctx.webkitBackingStorePixelRatio||ctx.mozBackingStorePixelRatio||ctx.msBackingStorePixelRatio||ctx.oBackingStorePixelRatio||ctx.backingStorePixelRatio||1);this.colorPickerCanvas.getContext("2d").setTransform(this.pixelRatio,0,0,this.pixelRatio,0,0);}this.colorPickerDiv.className="vis-color";this.opacityDiv=document.createElement("div");this.opacityDiv.className="vis-opacity";this.brightnessDiv=document.createElement("div");this.brightnessDiv.className="vis-brightness";this.arrowDiv=document.createElement("div");this.arrowDiv.className="vis-arrow";this.opacityRange=document.createElement("input");try{this.opacityRange.type="range";// Not supported on IE9
this.opacityRange.min="0";this.opacityRange.max="100";}catch(err){// TODO: Add some error handling.
}this.opacityRange.value="100";this.opacityRange.className="vis-range";this.brightnessRange=document.createElement("input");try{this.brightnessRange.type="range";// Not supported on IE9
this.brightnessRange.min="0";this.brightnessRange.max="100";}catch(err){// TODO: Add some error handling.
}this.brightnessRange.value="100";this.brightnessRange.className="vis-range";this.opacityDiv.appendChild(this.opacityRange);this.brightnessDiv.appendChild(this.brightnessRange);var me=this;this.opacityRange.onchange=function(){me._setOpacity(this.value);};this.opacityRange.oninput=function(){me._setOpacity(this.value);};this.brightnessRange.onchange=function(){me._setBrightness(this.value);};this.brightnessRange.oninput=function(){me._setBrightness(this.value);};this.brightnessLabel=document.createElement("div");this.brightnessLabel.className="vis-label vis-brightness";this.brightnessLabel.innerText="brightness:";this.opacityLabel=document.createElement("div");this.opacityLabel.className="vis-label vis-opacity";this.opacityLabel.innerText="opacity:";this.newColorDiv=document.createElement("div");this.newColorDiv.className="vis-new-color";this.newColorDiv.innerText="new";this.initialColorDiv=document.createElement("div");this.initialColorDiv.className="vis-initial-color";this.initialColorDiv.innerText="initial";this.cancelButton=document.createElement("div");this.cancelButton.className="vis-button vis-cancel";this.cancelButton.innerText="cancel";this.cancelButton.onclick=bind(_context16=this._hide).call(_context16,this,false);this.applyButton=document.createElement("div");this.applyButton.className="vis-button vis-apply";this.applyButton.innerText="apply";this.applyButton.onclick=bind(_context17=this._apply).call(_context17,this);this.saveButton=document.createElement("div");this.saveButton.className="vis-button vis-save";this.saveButton.innerText="save";this.saveButton.onclick=bind(_context18=this._save).call(_context18,this);this.loadButton=document.createElement("div");this.loadButton.className="vis-button vis-load";this.loadButton.innerText="load last";this.loadButton.onclick=bind(_context19=this._loadLast).call(_context19,this);this.frame.appendChild(this.colorPickerDiv);this.frame.appendChild(this.arrowDiv);this.frame.appendChild(this.brightnessLabel);this.frame.appendChild(this.brightnessDiv);this.frame.appendChild(this.opacityLabel);this.frame.appendChild(this.opacityDiv);this.frame.appendChild(this.newColorDiv);this.frame.appendChild(this.initialColorDiv);this.frame.appendChild(this.cancelButton);this.frame.appendChild(this.applyButton);this.frame.appendChild(this.saveButton);this.frame.appendChild(this.loadButton);}/**
     * bind hammer to the color picker
     *
     * @private
     */},{key:"_bindHammer",value:function _bindHammer(){var _this3=this;this.drag={};this.pinch={};this.hammer=new Hammer(this.colorPickerCanvas);this.hammer.get("pinch").set({enable:true});this.hammer.on("hammer.input",function(event){if(event.isFirst){_this3._moveSelector(event);}});this.hammer.on("tap",function(event){_this3._moveSelector(event);});this.hammer.on("panstart",function(event){_this3._moveSelector(event);});this.hammer.on("panmove",function(event){_this3._moveSelector(event);});this.hammer.on("panend",function(event){_this3._moveSelector(event);});}/**
     * generate the hue circle. This is relatively heavy (200ms) and is done only once on the first time it is shown.
     *
     * @private
     */},{key:"_generateHueCircle",value:function _generateHueCircle(){if(this.generated===false){var ctx=this.colorPickerCanvas.getContext("2d");if(this.pixelRation===undefined){this.pixelRatio=(window.devicePixelRatio||1)/(ctx.webkitBackingStorePixelRatio||ctx.mozBackingStorePixelRatio||ctx.msBackingStorePixelRatio||ctx.oBackingStorePixelRatio||ctx.backingStorePixelRatio||1);}ctx.setTransform(this.pixelRatio,0,0,this.pixelRatio,0,0);// clear the canvas
var w=this.colorPickerCanvas.clientWidth;var h=this.colorPickerCanvas.clientHeight;ctx.clearRect(0,0,w,h);// draw hue circle
var x,y,hue,sat;this.centerCoordinates={x:w*0.5,y:h*0.5};this.r=0.49*w;var angleConvert=2*Math.PI/360;var hfac=1/360;var sfac=1/this.r;var rgb;for(hue=0;hue<360;hue++){for(sat=0;sat<this.r;sat++){x=this.centerCoordinates.x+sat*Math.sin(angleConvert*hue);y=this.centerCoordinates.y+sat*Math.cos(angleConvert*hue);rgb=HSVToRGB(hue*hfac,sat*sfac,1);ctx.fillStyle="rgb("+rgb.r+","+rgb.g+","+rgb.b+")";ctx.fillRect(x-0.5,y-0.5,2,2);}}ctx.strokeStyle="rgba(0,0,0,1)";ctx.circle(this.centerCoordinates.x,this.centerCoordinates.y,this.r);ctx.stroke();this.hueCircle=ctx.getImageData(0,0,w,h);}this.generated=true;}/**
     * move the selector. This is called by hammer functions.
     *
     * @param {Event}  event   The event
     * @private
     */},{key:"_moveSelector",value:function _moveSelector(event){var rect=this.colorPickerDiv.getBoundingClientRect();var left=event.center.x-rect.left;var top=event.center.y-rect.top;var centerY=0.5*this.colorPickerDiv.clientHeight;var centerX=0.5*this.colorPickerDiv.clientWidth;var x=left-centerX;var y=top-centerY;var angle=Math.atan2(x,y);var radius=0.98*Math.min(Math.sqrt(x*x+y*y),centerX);var newTop=Math.cos(angle)*radius+centerY;var newLeft=Math.sin(angle)*radius+centerX;this.colorPickerSelector.style.top=newTop-0.5*this.colorPickerSelector.clientHeight+"px";this.colorPickerSelector.style.left=newLeft-0.5*this.colorPickerSelector.clientWidth+"px";// set color
var h=angle/(2*Math.PI);h=h<0?h+1:h;var s=radius/this.r;var hsv=RGBToHSV(this.color.r,this.color.g,this.color.b);hsv.h=h;hsv.s=s;var rgba=HSVToRGB(hsv.h,hsv.s,hsv.v);rgba["a"]=this.color.a;this.color=rgba;// update previews
this.initialColorDiv.style.backgroundColor="rgba("+this.initialColor.r+","+this.initialColor.g+","+this.initialColor.b+","+this.initialColor.a+")";this.newColorDiv.style.backgroundColor="rgba("+this.color.r+","+this.color.g+","+this.color.b+","+this.color.a+")";}}]);return ColorPicker;}();/**
 * Wrap given text (last argument) in HTML elements (all preceding arguments).
 *
 * @param {...any} rest - List of tag names followed by inner text.
 *
 * @returns An element or a text node.
 */function wrapInTag(){for(var _len5=arguments.length,rest=new Array(_len5),_key5=0;_key5<_len5;_key5++){rest[_key5]=arguments[_key5];}if(rest.length<1){throw new TypeError("Invalid arguments.");}else if(rest.length===1){return document.createTextNode(rest[0]);}else{var element=document.createElement(rest[0]);element.appendChild(wrapInTag.apply(void 0,_toConsumableArray(slice$1(rest).call(rest,1))));return element;}}/**
 * The way this works is for all properties of this.possible options, you can supply the property name in any form to list the options.
 * Boolean options are recognised as Boolean
 * Number options should be written as array: [default value, min value, max value, stepsize]
 * Colors should be written as array: ['color', '#ffffff']
 * Strings with should be written as array: [option1, option2, option3, ..]
 *
 * The options are matched with their counterparts in each of the modules and the values used in the configuration are
 */var Configurator=/*#__PURE__*/function(){/**
   * @param {object} parentModule        | the location where parentModule.setOptions() can be called
   * @param {object} defaultContainer    | the default container of the module
   * @param {object} configureOptions    | the fully configured and predefined options set found in allOptions.js
   * @param {number} pixelRatio          | canvas pixel ratio
   * @param {Function} hideOption        | custom logic to dynamically hide options
   */function Configurator(parentModule,defaultContainer,configureOptions){var pixelRatio=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1;var hideOption=arguments.length>4&&arguments[4]!==undefined?arguments[4]:function(){return false;};_classCallCheck(this,Configurator);this.parent=parentModule;this.changedOptions=[];this.container=defaultContainer;this.allowCreation=false;this.hideOption=hideOption;this.options={};this.initialized=false;this.popupCounter=0;this.defaultOptions={enabled:false,filter:true,container:undefined,showButton:true};assign$2(this.options,this.defaultOptions);this.configureOptions=configureOptions;this.moduleOptions={};this.domElements=[];this.popupDiv={};this.popupLimit=5;this.popupHistory={};this.colorPicker=new ColorPicker(pixelRatio);this.wrapper=undefined;}/**
   * refresh all options.
   * Because all modules parse their options by themselves, we just use their options. We copy them here.
   *
   * @param {object} options
   */_createClass(Configurator,[{key:"setOptions",value:function setOptions(options){if(options!==undefined){// reset the popup history because the indices may have been changed.
this.popupHistory={};this._removePopup();var enabled=true;if(typeof options==="string"){this.options.filter=options;}else if(isArray(options)){this.options.filter=options.join();}else if(_typeof(options)==="object"){if(options==null){throw new TypeError("options cannot be null");}if(options.container!==undefined){this.options.container=options.container;}if(filter(options)!==undefined){this.options.filter=filter(options);}if(options.showButton!==undefined){this.options.showButton=options.showButton;}if(options.enabled!==undefined){enabled=options.enabled;}}else if(typeof options==="boolean"){this.options.filter=true;enabled=options;}else if(typeof options==="function"){this.options.filter=options;enabled=true;}if(filter(this.options)===false){enabled=false;}this.options.enabled=enabled;}this._clean();}/**
     *
     * @param {object} moduleOptions
     */},{key:"setModuleOptions",value:function setModuleOptions(moduleOptions){this.moduleOptions=moduleOptions;if(this.options.enabled===true){this._clean();if(this.options.container!==undefined){this.container=this.options.container;}this._create();}}/**
     * Create all DOM elements
     *
     * @private
     */},{key:"_create",value:function _create(){this._clean();this.changedOptions=[];var filter$1=filter(this.options);var counter=0;var show=false;for(var _option in this.configureOptions){if(Object.prototype.hasOwnProperty.call(this.configureOptions,_option)){this.allowCreation=false;show=false;if(typeof filter$1==="function"){show=filter$1(_option,[]);show=show||this._handleObject(this.configureOptions[_option],[_option],true);}else if(filter$1===true||indexOf(filter$1).call(filter$1,_option)!==-1){show=true;}if(show!==false){this.allowCreation=true;// linebreak between categories
if(counter>0){this._makeItem([]);}// a header for the category
this._makeHeader(_option);// get the sub options
this._handleObject(this.configureOptions[_option],[_option]);}counter++;}}this._makeButton();this._push();//~ this.colorPicker.insertTo(this.container);
}/**
     * draw all DOM elements on the screen
     *
     * @private
     */},{key:"_push",value:function _push(){this.wrapper=document.createElement("div");this.wrapper.className="vis-configuration-wrapper";this.container.appendChild(this.wrapper);for(var i=0;i<this.domElements.length;i++){this.wrapper.appendChild(this.domElements[i]);}this._showPopupIfNeeded();}/**
     * delete all DOM elements
     *
     * @private
     */},{key:"_clean",value:function _clean(){for(var i=0;i<this.domElements.length;i++){this.wrapper.removeChild(this.domElements[i]);}if(this.wrapper!==undefined){this.container.removeChild(this.wrapper);this.wrapper=undefined;}this.domElements=[];this._removePopup();}/**
     * get the value from the actualOptions if it exists
     *
     * @param {Array} path    | where to look for the actual option
     * @returns {*}
     * @private
     */},{key:"_getValue",value:function _getValue(path){var base=this.moduleOptions;for(var i=0;i<path.length;i++){if(base[path[i]]!==undefined){base=base[path[i]];}else{base=undefined;break;}}return base;}/**
     * all option elements are wrapped in an item
     *
     * @param {Array} path    | where to look for the actual option
     * @param {Array.<Element>} domElements
     * @returns {number}
     * @private
     */},{key:"_makeItem",value:function _makeItem(path){if(this.allowCreation===true){var item=document.createElement("div");item.className="vis-configuration vis-config-item vis-config-s"+path.length;for(var _len6=arguments.length,domElements=new Array(_len6>1?_len6-1:0),_key6=1;_key6<_len6;_key6++){domElements[_key6-1]=arguments[_key6];}forEach$2(domElements).call(domElements,function(element){item.appendChild(element);});this.domElements.push(item);return this.domElements.length;}return 0;}/**
     * header for major subjects
     *
     * @param {string} name
     * @private
     */},{key:"_makeHeader",value:function _makeHeader(name){var div=document.createElement("div");div.className="vis-configuration vis-config-header";div.innerText=name;this._makeItem([],div);}/**
     * make a label, if it is an object label, it gets different styling.
     *
     * @param {string} name
     * @param {Array} path    | where to look for the actual option
     * @param {string} objectLabel
     * @returns {HTMLElement}
     * @private
     */},{key:"_makeLabel",value:function _makeLabel(name,path){var objectLabel=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var div=document.createElement("div");div.className="vis-configuration vis-config-label vis-config-s"+path.length;if(objectLabel===true){while(div.firstChild){div.removeChild(div.firstChild);}div.appendChild(wrapInTag("i","b",name));}else{div.innerText=name+":";}return div;}/**
     * make a dropdown list for multiple possible string optoins
     *
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */},{key:"_makeDropdown",value:function _makeDropdown(arr,value,path){var select=document.createElement("select");select.className="vis-configuration vis-config-select";var selectedValue=0;if(value!==undefined){if(indexOf(arr).call(arr,value)!==-1){selectedValue=indexOf(arr).call(arr,value);}}for(var i=0;i<arr.length;i++){var _option2=document.createElement("option");_option2.value=arr[i];if(i===selectedValue){_option2.selected="selected";}_option2.innerText=arr[i];select.appendChild(_option2);}var me=this;select.onchange=function(){me._update(this.value,path);};var label=this._makeLabel(path[path.length-1],path);this._makeItem(path,label,select);}/**
     * make a range object for numeric options
     *
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */},{key:"_makeRange",value:function _makeRange(arr,value,path){var defaultValue=arr[0];var min=arr[1];var max=arr[2];var step=arr[3];var range=document.createElement("input");range.className="vis-configuration vis-config-range";try{range.type="range";// not supported on IE9
range.min=min;range.max=max;}catch(err){// TODO: Add some error handling.
}range.step=step;// set up the popup settings in case they are needed.
var popupString="";var popupValue=0;if(value!==undefined){var factor=1.2;if(value<0&&value*factor<min){range.min=Math.ceil(value*factor);popupValue=range.min;popupString="range increased";}else if(value/factor<min){range.min=Math.ceil(value/factor);popupValue=range.min;popupString="range increased";}if(value*factor>max&&max!==1){range.max=Math.ceil(value*factor);popupValue=range.max;popupString="range increased";}range.value=value;}else{range.value=defaultValue;}var input=document.createElement("input");input.className="vis-configuration vis-config-rangeinput";input.value=range.value;var me=this;range.onchange=function(){input.value=this.value;me._update(Number(this.value),path);};range.oninput=function(){input.value=this.value;};var label=this._makeLabel(path[path.length-1],path);var itemIndex=this._makeItem(path,label,range,input);// if a popup is needed AND it has not been shown for this value, show it.
if(popupString!==""&&this.popupHistory[itemIndex]!==popupValue){this.popupHistory[itemIndex]=popupValue;this._setupPopup(popupString,itemIndex);}}/**
     * make a button object
     *
     * @private
     */},{key:"_makeButton",value:function _makeButton(){var _this4=this;if(this.options.showButton===true){var generateButton=document.createElement("div");generateButton.className="vis-configuration vis-config-button";generateButton.innerText="generate options";generateButton.onclick=function(){_this4._printOptions();};generateButton.onmouseover=function(){generateButton.className="vis-configuration vis-config-button hover";};generateButton.onmouseout=function(){generateButton.className="vis-configuration vis-config-button";};this.optionsContainer=document.createElement("div");this.optionsContainer.className="vis-configuration vis-config-option-container";this.domElements.push(this.optionsContainer);this.domElements.push(generateButton);}}/**
     * prepare the popup
     *
     * @param {string} string
     * @param {number} index
     * @private
     */},{key:"_setupPopup",value:function _setupPopup(string,index){var _this5=this;if(this.initialized===true&&this.allowCreation===true&&this.popupCounter<this.popupLimit){var div=document.createElement("div");div.id="vis-configuration-popup";div.className="vis-configuration-popup";div.innerText=string;div.onclick=function(){_this5._removePopup();};this.popupCounter+=1;this.popupDiv={html:div,index:index};}}/**
     * remove the popup from the dom
     *
     * @private
     */},{key:"_removePopup",value:function _removePopup(){if(this.popupDiv.html!==undefined){this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);clearTimeout(this.popupDiv.hideTimeout);clearTimeout(this.popupDiv.deleteTimeout);this.popupDiv={};}}/**
     * Show the popup if it is needed.
     *
     * @private
     */},{key:"_showPopupIfNeeded",value:function _showPopupIfNeeded(){var _this6=this;if(this.popupDiv.html!==undefined){var correspondingElement=this.domElements[this.popupDiv.index];var rect=correspondingElement.getBoundingClientRect();this.popupDiv.html.style.left=rect.left+"px";this.popupDiv.html.style.top=rect.top-30+"px";// 30 is the height;
document.body.appendChild(this.popupDiv.html);this.popupDiv.hideTimeout=setTimeout$1(function(){_this6.popupDiv.html.style.opacity=0;},1500);this.popupDiv.deleteTimeout=setTimeout$1(function(){_this6._removePopup();},1800);}}/**
     * make a checkbox for boolean options.
     *
     * @param {number} defaultValue
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */},{key:"_makeCheckbox",value:function _makeCheckbox(defaultValue,value,path){var checkbox=document.createElement("input");checkbox.type="checkbox";checkbox.className="vis-configuration vis-config-checkbox";checkbox.checked=defaultValue;if(value!==undefined){checkbox.checked=value;if(value!==defaultValue){if(_typeof(defaultValue)==="object"){if(value!==defaultValue.enabled){this.changedOptions.push({path:path,value:value});}}else{this.changedOptions.push({path:path,value:value});}}}var me=this;checkbox.onchange=function(){me._update(this.checked,path);};var label=this._makeLabel(path[path.length-1],path);this._makeItem(path,label,checkbox);}/**
     * make a text input field for string options.
     *
     * @param {number} defaultValue
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */},{key:"_makeTextInput",value:function _makeTextInput(defaultValue,value,path){var checkbox=document.createElement("input");checkbox.type="text";checkbox.className="vis-configuration vis-config-text";checkbox.value=value;if(value!==defaultValue){this.changedOptions.push({path:path,value:value});}var me=this;checkbox.onchange=function(){me._update(this.value,path);};var label=this._makeLabel(path[path.length-1],path);this._makeItem(path,label,checkbox);}/**
     * make a color field with a color picker for color fields
     *
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */},{key:"_makeColorField",value:function _makeColorField(arr,value,path){var _this7=this;var defaultColor=arr[1];var div=document.createElement("div");value=value===undefined?defaultColor:value;if(value!=="none"){div.className="vis-configuration vis-config-colorBlock";div.style.backgroundColor=value;}else{div.className="vis-configuration vis-config-colorBlock none";}value=value===undefined?defaultColor:value;div.onclick=function(){_this7._showColorPicker(value,div,path);};var label=this._makeLabel(path[path.length-1],path);this._makeItem(path,label,div);}/**
     * used by the color buttons to call the color picker.
     *
     * @param {number} value
     * @param {HTMLElement} div
     * @param {Array} path    | where to look for the actual option
     * @private
     */},{key:"_showColorPicker",value:function _showColorPicker(value,div,path){var _this8=this;// clear the callback from this div
div.onclick=function(){};this.colorPicker.insertTo(div);this.colorPicker.show();this.colorPicker.setColor(value);this.colorPicker.setUpdateCallback(function(color){var colorString="rgba("+color.r+","+color.g+","+color.b+","+color.a+")";div.style.backgroundColor=colorString;_this8._update(colorString,path);});// on close of the colorpicker, restore the callback.
this.colorPicker.setCloseCallback(function(){div.onclick=function(){_this8._showColorPicker(value,div,path);};});}/**
     * parse an object and draw the correct items
     *
     * @param {object} obj
     * @param {Array} [path=[]]    | where to look for the actual option
     * @param {boolean} [checkOnly=false]
     * @returns {boolean}
     * @private
     */},{key:"_handleObject",value:function _handleObject(obj){var path=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];var checkOnly=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var show=false;var filter$1=filter(this.options);var visibleInSet=false;for(var subObj in obj){if(Object.prototype.hasOwnProperty.call(obj,subObj)){show=true;var item=obj[subObj];var newPath=copyAndExtendArray(path,subObj);if(typeof filter$1==="function"){show=filter$1(subObj,path);// if needed we must go deeper into the object.
if(show===false){if(!isArray(item)&&typeof item!=="string"&&typeof item!=="boolean"&&item instanceof Object){this.allowCreation=false;show=this._handleObject(item,newPath,true);this.allowCreation=checkOnly===false;}}}if(show!==false){visibleInSet=true;var value=this._getValue(newPath);if(isArray(item)){this._handleArray(item,value,newPath);}else if(typeof item==="string"){this._makeTextInput(item,value,newPath);}else if(typeof item==="boolean"){this._makeCheckbox(item,value,newPath);}else if(item instanceof Object){// skip the options that are not enabled
if(!this.hideOption(path,subObj,this.moduleOptions)){// initially collapse options with an disabled enabled option.
if(item.enabled!==undefined){var enabledPath=copyAndExtendArray(newPath,"enabled");var enabledValue=this._getValue(enabledPath);if(enabledValue===true){var label=this._makeLabel(subObj,newPath,true);this._makeItem(newPath,label);visibleInSet=this._handleObject(item,newPath)||visibleInSet;}else{this._makeCheckbox(item,enabledValue,newPath);}}else{var _label=this._makeLabel(subObj,newPath,true);this._makeItem(newPath,_label);visibleInSet=this._handleObject(item,newPath)||visibleInSet;}}}else{console.error("dont know how to handle",item,subObj,newPath);}}}}return visibleInSet;}/**
     * handle the array type of option
     *
     * @param {Array.<number>} arr
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */},{key:"_handleArray",value:function _handleArray(arr,value,path){if(typeof arr[0]==="string"&&arr[0]==="color"){this._makeColorField(arr,value,path);if(arr[1]!==value){this.changedOptions.push({path:path,value:value});}}else if(typeof arr[0]==="string"){this._makeDropdown(arr,value,path);if(arr[0]!==value){this.changedOptions.push({path:path,value:value});}}else if(typeof arr[0]==="number"){this._makeRange(arr,value,path);if(arr[0]!==value){this.changedOptions.push({path:path,value:Number(value)});}}}/**
     * called to update the network with the new settings.
     *
     * @param {number} value
     * @param {Array} path    | where to look for the actual option
     * @private
     */},{key:"_update",value:function _update(value,path){var options=this._constructOptions(value,path);if(this.parent.body&&this.parent.body.emitter&&this.parent.body.emitter.emit){this.parent.body.emitter.emit("configChange",options);}this.initialized=true;this.parent.setOptions(options);}/**
     *
     * @param {string | boolean} value
     * @param {Array.<string>} path
     * @param {{}} optionsObj
     * @returns {{}}
     * @private
     */},{key:"_constructOptions",value:function _constructOptions(value,path){var optionsObj=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var pointer=optionsObj;// when dropdown boxes can be string or boolean, we typecast it into correct types
value=value==="true"?true:value;value=value==="false"?false:value;for(var i=0;i<path.length;i++){if(path[i]!=="global"){if(pointer[path[i]]===undefined){pointer[path[i]]={};}if(i!==path.length-1){pointer=pointer[path[i]];}else{pointer[path[i]]=value;}}}return optionsObj;}/**
     * @private
     */},{key:"_printOptions",value:function _printOptions(){var options=this.getOptions();while(this.optionsContainer.firstChild){this.optionsContainer.removeChild(this.optionsContainer.firstChild);}this.optionsContainer.appendChild(wrapInTag("pre","const options = "+stringify$1(options,null,2)));}/**
     *
     * @returns {{}} options
     */},{key:"getOptions",value:function getOptions(){var options={};for(var i=0;i<this.changedOptions.length;i++){this._constructOptions(this.changedOptions[i].value,this.changedOptions[i].path,options);}return options;}}]);return Configurator;}();/**
 * Popup is a class to create a popup window with some text
 */var Popup=/*#__PURE__*/function(){/**
   * @param {Element} container       The container object.
   * @param {string}  overflowMethod  How the popup should act to overflowing ('flip' or 'cap')
   */function Popup(container,overflowMethod){_classCallCheck(this,Popup);this.container=container;this.overflowMethod=overflowMethod||"cap";this.x=0;this.y=0;this.padding=5;this.hidden=false;// create the frame
this.frame=document.createElement("div");this.frame.className="vis-tooltip";this.container.appendChild(this.frame);}/**
   * @param {number} x   Horizontal position of the popup window
   * @param {number} y   Vertical position of the popup window
   */_createClass(Popup,[{key:"setPosition",value:function setPosition(x,y){this.x=_parseInt(x);this.y=_parseInt(y);}/**
     * Set the content for the popup window. This can be HTML code or text.
     *
     * @param {string | Element} content
     */},{key:"setText",value:function setText(content){if(content instanceof Element){while(this.frame.firstChild){this.frame.removeChild(this.frame.firstChild);}this.frame.appendChild(content);}else{// String containing literal text, element has to be used for HTML due to
// XSS risks associated with innerHTML (i.e. prevent XSS by accident).
this.frame.innerText=content;}}/**
     * Show the popup window
     *
     * @param {boolean} [doShow]    Show or hide the window
     */},{key:"show",value:function show(doShow){if(doShow===undefined){doShow=true;}if(doShow===true){var height=this.frame.clientHeight;var width=this.frame.clientWidth;var maxHeight=this.frame.parentNode.clientHeight;var maxWidth=this.frame.parentNode.clientWidth;var left=0,top=0;if(this.overflowMethod=="flip"){var isLeft=false,isTop=true;// Where around the position it's located
if(this.y-height<this.padding){isTop=false;}if(this.x+width>maxWidth-this.padding){isLeft=true;}if(isLeft){left=this.x-width;}else{left=this.x;}if(isTop){top=this.y-height;}else{top=this.y;}}else{top=this.y-height;if(top+height+this.padding>maxHeight){top=maxHeight-height-this.padding;}if(top<this.padding){top=this.padding;}left=this.x;if(left+width+this.padding>maxWidth){left=maxWidth-width-this.padding;}if(left<this.padding){left=this.padding;}}this.frame.style.left=left+"px";this.frame.style.top=top+"px";this.frame.style.visibility="visible";this.hidden=false;}else{this.hide();}}/**
     * Hide the popup window
     */},{key:"hide",value:function hide(){this.hidden=true;this.frame.style.left="0";this.frame.style.top="0";this.frame.style.visibility="hidden";}/**
     * Remove the popup window
     */},{key:"destroy",value:function destroy(){this.frame.parentNode.removeChild(this.frame);// Remove element from DOM
}}]);return Popup;}();var errorFound=false;var allOptions$1;var VALIDATOR_PRINT_STYLE="background: #FFeeee; color: #dd0000";/**
 *  Used to validate options.
 */var Validator=/*#__PURE__*/function(){function Validator(){_classCallCheck(this,Validator);}_createClass(Validator,null,[{key:"validate",value:/**
     * Main function to be called
     *
     * @param {object} options
     * @param {object} referenceOptions
     * @param {object} subObject
     * @returns {boolean}
     * @static
     */function validate(options,referenceOptions,subObject){errorFound=false;allOptions$1=referenceOptions;var usedOptions=referenceOptions;if(subObject!==undefined){usedOptions=referenceOptions[subObject];}Validator.parse(options,usedOptions,[]);return errorFound;}/**
     * Will traverse an object recursively and check every value
     *
     * @param {object} options
     * @param {object} referenceOptions
     * @param {Array} path    | where to look for the actual option
     * @static
     */},{key:"parse",value:function parse(options,referenceOptions,path){for(var _option3 in options){if(Object.prototype.hasOwnProperty.call(options,_option3)){Validator.check(_option3,options,referenceOptions,path);}}}/**
     * Check every value. If the value is an object, call the parse function on that object.
     *
     * @param {string} option
     * @param {object} options
     * @param {object} referenceOptions
     * @param {Array} path    | where to look for the actual option
     * @static
     */},{key:"check",value:function check(option,options,referenceOptions,path){if(referenceOptions[option]===undefined&&referenceOptions.__any__===undefined){Validator.getSuggestion(option,referenceOptions,path);return;}var referenceOption=option;var is_object=true;if(referenceOptions[option]===undefined&&referenceOptions.__any__!==undefined){// NOTE: This only triggers if the __any__ is in the top level of the options object.
//       THAT'S A REALLY BAD PLACE TO ALLOW IT!!!!
// TODO: Examine if needed, remove if possible
// __any__ is a wildcard. Any value is accepted and will be further analysed by reference.
referenceOption="__any__";// if the any-subgroup is not a predefined object in the configurator,
// we do not look deeper into the object.
is_object=Validator.getType(options[option])==="object";}var refOptionObj=referenceOptions[referenceOption];if(is_object&&refOptionObj.__type__!==undefined){refOptionObj=refOptionObj.__type__;}Validator.checkFields(option,options,referenceOptions,referenceOption,refOptionObj,path);}/**
     *
     * @param {string}  option           | the option property
     * @param {object}  options          | The supplied options object
     * @param {object}  referenceOptions | The reference options containing all options and their allowed formats
     * @param {string}  referenceOption  | Usually this is the same as option, except when handling an __any__ tag.
     * @param {string}  refOptionObj     | This is the type object from the reference options
     * @param {Array}   path             | where in the object is the option
     * @static
     */},{key:"checkFields",value:function checkFields(option,options,referenceOptions,referenceOption,refOptionObj,path){var log=function log(message){console.error("%c"+message+Validator.printLocation(path,option),VALIDATOR_PRINT_STYLE);};var optionType=Validator.getType(options[option]);var refOptionType=refOptionObj[optionType];if(refOptionType!==undefined){// if the type is correct, we check if it is supposed to be one of a few select values
if(Validator.getType(refOptionType)==="array"&&indexOf(refOptionType).call(refOptionType,options[option])===-1){log('Invalid option detected in "'+option+'".'+" Allowed values are:"+Validator.print(refOptionType)+' not "'+options[option]+'". ');errorFound=true;}else if(optionType==="object"&&referenceOption!=="__any__"){path=copyAndExtendArray(path,option);Validator.parse(options[option],referenceOptions[referenceOption],path);}}else if(refOptionObj["any"]===undefined){// type of the field is incorrect and the field cannot be any
log('Invalid type received for "'+option+'". Expected: '+Validator.print(keys$3(refOptionObj))+". Received ["+optionType+'] "'+options[option]+'"');errorFound=true;}}/**
     *
     * @param {object | boolean | number | string | Array.<number> | Date | Node | Moment | undefined | null} object
     * @returns {string}
     * @static
     */},{key:"getType",value:function getType(object){var type=_typeof(object);if(type==="object"){if(object===null){return"null";}if(object instanceof Boolean){return"boolean";}if(object instanceof Number){return"number";}if(object instanceof String){return"string";}if(isArray(object)){return"array";}if(object instanceof Date){return"date";}if(object.nodeType!==undefined){return"dom";}if(object._isAMomentObject===true){return"moment";}return"object";}else if(type==="number"){return"number";}else if(type==="boolean"){return"boolean";}else if(type==="string"){return"string";}else if(type===undefined){return"undefined";}return type;}/**
     * @param {string} option
     * @param {object} options
     * @param {Array.<string>} path
     * @static
     */},{key:"getSuggestion",value:function getSuggestion(option,options,path){var localSearch=Validator.findInOptions(option,options,path,false);var globalSearch=Validator.findInOptions(option,allOptions$1,[],true);var localSearchThreshold=8;var globalSearchThreshold=4;var msg;if(localSearch.indexMatch!==undefined){msg=" in "+Validator.printLocation(localSearch.path,option,"")+'Perhaps it was incomplete? Did you mean: "'+localSearch.indexMatch+'"?\n\n';}else if(globalSearch.distance<=globalSearchThreshold&&localSearch.distance>globalSearch.distance){msg=" in "+Validator.printLocation(localSearch.path,option,"")+"Perhaps it was misplaced? Matching option found at: "+Validator.printLocation(globalSearch.path,globalSearch.closestMatch,"");}else if(localSearch.distance<=localSearchThreshold){msg='. Did you mean "'+localSearch.closestMatch+'"?'+Validator.printLocation(localSearch.path,option);}else{msg=". Did you mean one of these: "+Validator.print(keys$3(options))+Validator.printLocation(path,option);}console.error('%cUnknown option detected: "'+option+'"'+msg,VALIDATOR_PRINT_STYLE);errorFound=true;}/**
     * traverse the options in search for a match.
     *
     * @param {string} option
     * @param {object} options
     * @param {Array} path    | where to look for the actual option
     * @param {boolean} [recursive=false]
     * @returns {{closestMatch: string, path: Array, distance: number}}
     * @static
     */},{key:"findInOptions",value:function findInOptions(option,options,path){var recursive=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;var min=1e9;var closestMatch="";var closestMatchPath=[];var lowerCaseOption=option.toLowerCase();var indexMatch=undefined;for(var op in options){var distance=void 0;if(options[op].__type__!==undefined&&recursive===true){var result=Validator.findInOptions(option,options[op],copyAndExtendArray(path,op));if(min>result.distance){closestMatch=result.closestMatch;closestMatchPath=result.path;min=result.distance;indexMatch=result.indexMatch;}}else{var _context20;if(indexOf(_context20=op.toLowerCase()).call(_context20,lowerCaseOption)!==-1){indexMatch=op;}distance=Validator.levenshteinDistance(option,op);if(min>distance){closestMatch=op;closestMatchPath=copyArray(path);min=distance;}}}return{closestMatch:closestMatch,path:closestMatchPath,distance:min,indexMatch:indexMatch};}/**
     * @param {Array.<string>} path
     * @param {object} option
     * @param {string} prefix
     * @returns {string}
     * @static
     */},{key:"printLocation",value:function printLocation(path,option){var prefix=arguments.length>2&&arguments[2]!==undefined?arguments[2]:"Problem value found at: \n";var str="\n\n"+prefix+"options = {\n";for(var i=0;i<path.length;i++){for(var j=0;j<i+1;j++){str+="  ";}str+=path[i]+": {\n";}for(var _j=0;_j<path.length+1;_j++){str+="  ";}str+=option+"\n";for(var _i3=0;_i3<path.length+1;_i3++){for(var _j2=0;_j2<path.length-_i3;_j2++){str+="  ";}str+="}\n";}return str+"\n\n";}/**
     * @param {object} options
     * @returns {string}
     * @static
     */},{key:"print",value:function print(options){return stringify$1(options).replace(/(")|(\[)|(\])|(,"__type__")/g,"").replace(/(,)/g,", ");}/**
     *  Compute the edit distance between the two given strings
     * http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript
     *
     * Copyright (c) 2011 Andrei Mackenzie
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     *
     * @param {string} a
     * @param {string} b
     * @returns {Array.<Array.<number>>}}
     * @static
     */},{key:"levenshteinDistance",value:function levenshteinDistance(a,b){if(a.length===0)return b.length;if(b.length===0)return a.length;var matrix=[];// increment along the first column of each row
var i;for(i=0;i<=b.length;i++){matrix[i]=[i];}// increment each column in the first row
var j;for(j=0;j<=a.length;j++){matrix[0][j]=j;}// Fill in the rest of the matrix
for(i=1;i<=b.length;i++){for(j=1;j<=a.length;j++){if(b.charAt(i-1)==a.charAt(j-1)){matrix[i][j]=matrix[i-1][j-1];}else{matrix[i][j]=Math.min(matrix[i-1][j-1]+1,// substitution
Math.min(matrix[i][j-1]+1,// insertion
matrix[i-1][j]+1));// deletion
}}}return matrix[b.length][a.length];}}]);return Validator;}();var Activator$1=Activator;var Configurator$1=Configurator;var Hammer$1=Hammer;var Popup$1=Popup;var VALIDATOR_PRINT_STYLE$1=VALIDATOR_PRINT_STYLE;var Validator$1=Validator;/* eslint-disable no-prototype-builtins */ /* eslint-disable no-unused-vars */ /* eslint-disable no-var */ /**
 * Parse a text source containing data in DOT language into a JSON object.
 * The object contains two lists: one with nodes and one with edges.
 *
 * DOT language reference: http://www.graphviz.org/doc/info/lang.html
 *
 * DOT language attributes: http://graphviz.org/content/attrs
 *
 * @param {string} data     Text containing a graph in DOT-notation
 * @returns {object} graph   An object containing two parameters:
 *                          {Object[]} nodes
 *                          {Object[]} edges
 *
 * -------------------------------------------
 * TODO
 * ====
 *
 * For label handling, this is an incomplete implementation. From docs (quote #3015):
 *
 * > the escape sequences "\n", "\l" and "\r" divide the label into lines, centered,
 * > left-justified, and right-justified, respectively.
 *
 * Source: http://www.graphviz.org/content/attrs#kescString
 *
 * > As another aid for readability, dot allows double-quoted strings to span multiple physical
 * > lines using the standard C convention of a backslash immediately preceding a newline
 * > character
 * > In addition, double-quoted strings can be concatenated using a '+' operator.
 * > As HTML strings can contain newline characters, which are used solely for formatting,
 * > the language does not allow escaped newlines or concatenation operators to be used
 * > within them.
 *
 * - Currently, only '\\n' is handled
 * - Note that text explicitly says 'labels'; the dot parser currently handles escape
 *   sequences in **all** strings.
 */function parseDOT(data){dot=data;return parseGraph();}// mapping of attributes from DOT (the keys) to vis.js (the values)
var NODE_ATTR_MAPPING={fontsize:"font.size",fontcolor:"font.color",labelfontcolor:"font.color",fontname:"font.face",color:["color.border","color.background"],fillcolor:"color.background",tooltip:"title",labeltooltip:"title"};var EDGE_ATTR_MAPPING=create$2(NODE_ATTR_MAPPING);EDGE_ATTR_MAPPING.color="color.color";EDGE_ATTR_MAPPING.style="dashes";// token types enumeration
var TOKENTYPE={NULL:0,DELIMITER:1,IDENTIFIER:2,UNKNOWN:3};// map with all delimiters
var DELIMITERS={"{":true,"}":true,"[":true,"]":true,";":true,"=":true,",":true,"->":true,"--":true};var dot="";// current dot file
var index$1=0;// current index in dot file
var c="";// current token character in expr
var token="";// current token
var tokenType=TOKENTYPE.NULL;// type of the token
/**
 * Get the first character from the dot file.
 * The character is stored into the char c. If the end of the dot file is
 * reached, the function puts an empty string in c.
 */function first(){index$1=0;c=dot.charAt(0);}/**
 * Get the next character from the dot file.
 * The character is stored into the char c. If the end of the dot file is
 * reached, the function puts an empty string in c.
 */function next(){index$1++;c=dot.charAt(index$1);}/**
 * Preview the next character from the dot file.
 *
 * @returns {string} cNext
 */function nextPreview(){return dot.charAt(index$1+1);}/**
 * Test whether given character is alphabetic or numeric ( a-zA-Z_0-9.:# )
 *
 * @param {string} c
 * @returns {boolean} isAlphaNumeric
 */function isAlphaNumeric(c){var charCode=c.charCodeAt(0);if(charCode<47){// #.
return charCode===35||charCode===46;}if(charCode<59){// 0-9 and :
return charCode>47;}if(charCode<91){// A-Z
return charCode>64;}if(charCode<96){// _
return charCode===95;}if(charCode<123){// a-z
return charCode>96;}return false;}/**
 * Merge all options of object b into object b
 *
 * @param {object} a
 * @param {object} b
 * @returns {object} a
 */function merge$1(a,b){if(!a){a={};}if(b){for(var name in b){if(b.hasOwnProperty(name)){a[name]=b[name];}}}return a;}/**
 * Set a value in an object, where the provided parameter name can be a
 * path with nested parameters. For example:
 *
 *     var obj = {a: 2};
 *     setValue(obj, 'b.c', 3);     // obj = {a: 2, b: {c: 3}}
 *
 * @param {object} obj
 * @param {string} path  A parameter name or dot-separated parameter path,
 *                      like "color.highlight.border".
 * @param {*} value
 */function setValue(obj,path,value){var keys=path.split(".");var o=obj;while(keys.length){var key=keys.shift();if(keys.length){// this isn't the end point
if(!o[key]){o[key]={};}o=o[key];}else{// this is the end point
o[key]=value;}}}/**
 * Add a node to a graph object. If there is already a node with
 * the same id, their attributes will be merged.
 *
 * @param {object} graph
 * @param {object} node
 */function addNode(graph,node){var i,len;var current=null;// find root graph (in case of subgraph)
var graphs=[graph];// list with all graphs from current graph to root graph
var root=graph;while(root.parent){graphs.push(root.parent);root=root.parent;}// find existing node (at root level) by its id
if(root.nodes){for(i=0,len=root.nodes.length;i<len;i++){if(node.id===root.nodes[i].id){current=root.nodes[i];break;}}}if(!current){// this is a new node
current={id:node.id};if(graph.node){// clone default attributes
current.attr=merge$1(current.attr,graph.node);}}// add node to this (sub)graph and all its parent graphs
for(i=graphs.length-1;i>=0;i--){var _context;var g=graphs[i];if(!g.nodes){g.nodes=[];}if(indexOf(_context=g.nodes).call(_context,current)===-1){g.nodes.push(current);}}// merge attributes
if(node.attr){current.attr=merge$1(current.attr,node.attr);}}/**
 * Add an edge to a graph object
 *
 * @param {object} graph
 * @param {object} edge
 */function addEdge(graph,edge){if(!graph.edges){graph.edges=[];}graph.edges.push(edge);if(graph.edge){var attr=merge$1({},graph.edge);// clone default attributes
edge.attr=merge$1(attr,edge.attr);// merge attributes
}}/**
 * Create an edge to a graph object
 *
 * @param {object} graph
 * @param {string | number | object} from
 * @param {string | number | object} to
 * @param {string} type
 * @param {object | null} attr
 * @returns {object} edge
 */function createEdge(graph,from,to,type,attr){var edge={from:from,to:to,type:type};if(graph.edge){edge.attr=merge$1({},graph.edge);// clone default attributes
}edge.attr=merge$1(edge.attr||{},attr);// merge attributes
// Move arrows attribute from attr to edge temporally created in
// parseAttributeList().
if(attr!=null){if(attr.hasOwnProperty("arrows")&&attr["arrows"]!=null){edge["arrows"]={to:{enabled:true,type:attr.arrows.type}};attr["arrows"]=null;}}return edge;}/**
 * Get next token in the current dot file.
 * The token and token type are available as token and tokenType
 */function getToken(){tokenType=TOKENTYPE.NULL;token="";// skip over whitespaces
while(c===" "||c==="\t"||c==="\n"||c==="\r"){// space, tab, enter
next();}do{var isComment=false;// skip comment
if(c==="#"){// find the previous non-space character
var i=index$1-1;while(dot.charAt(i)===" "||dot.charAt(i)==="\t"){i--;}if(dot.charAt(i)==="\n"||dot.charAt(i)===""){// the # is at the start of a line, this is indeed a line comment
while(c!=""&&c!="\n"){next();}isComment=true;}}if(c==="/"&&nextPreview()==="/"){// skip line comment
while(c!=""&&c!="\n"){next();}isComment=true;}if(c==="/"&&nextPreview()==="*"){// skip block comment
while(c!=""){if(c==="*"&&nextPreview()==="/"){// end of block comment found. skip these last two characters
next();next();break;}else{next();}}isComment=true;}// skip over whitespaces
while(c===" "||c==="\t"||c==="\n"||c==="\r"){// space, tab, enter
next();}}while(isComment);// check for end of dot file
if(c===""){// token is still empty
tokenType=TOKENTYPE.DELIMITER;return;}// check for delimiters consisting of 2 characters
var c2=c+nextPreview();if(DELIMITERS[c2]){tokenType=TOKENTYPE.DELIMITER;token=c2;next();next();return;}// check for delimiters consisting of 1 character
if(DELIMITERS[c]){tokenType=TOKENTYPE.DELIMITER;token=c;next();return;}// check for an identifier (number or string)
// TODO: more precise parsing of numbers/strings (and the port separator ':')
if(isAlphaNumeric(c)||c==="-"){token+=c;next();while(isAlphaNumeric(c)){token+=c;next();}if(token==="false"){token=false;// convert to boolean
}else if(token==="true"){token=true;// convert to boolean
}else if(!isNaN(Number(token))){token=Number(token);// convert to number
}tokenType=TOKENTYPE.IDENTIFIER;return;}// check for a string enclosed by double quotes
if(c==='"'){next();while(c!=""&&(c!='"'||c==='"'&&nextPreview()==='"')){if(c==='"'){// skip the escape character
token+=c;next();}else if(c==="\\"&&nextPreview()==="n"){// Honor a newline escape sequence
token+="\n";next();}else{token+=c;}next();}if(c!='"'){throw newSyntaxError('End of string " expected');}next();tokenType=TOKENTYPE.IDENTIFIER;return;}// something unknown is found, wrong characters, a syntax error
tokenType=TOKENTYPE.UNKNOWN;while(c!=""){token+=c;next();}throw new SyntaxError('Syntax error in part "'+chop(token,30)+'"');}/**
 * Parse a graph.
 *
 * @returns {object} graph
 */function parseGraph(){var graph={};first();getToken();// optional strict keyword
if(token==="strict"){graph.strict=true;getToken();}// graph or digraph keyword
if(token==="graph"||token==="digraph"){graph.type=token;getToken();}// optional graph id
if(tokenType===TOKENTYPE.IDENTIFIER){graph.id=token;getToken();}// open angle bracket
if(token!="{"){throw newSyntaxError("Angle bracket { expected");}getToken();// statements
parseStatements(graph);// close angle bracket
if(token!="}"){throw newSyntaxError("Angle bracket } expected");}getToken();// end of file
if(token!==""){throw newSyntaxError("End of file expected");}getToken();// remove temporary default options
delete graph.node;delete graph.edge;delete graph.graph;return graph;}/**
 * Parse a list with statements.
 *
 * @param {object} graph
 */function parseStatements(graph){while(token!==""&&token!="}"){parseStatement(graph);if(token===";"){getToken();}}}/**
 * Parse a single statement. Can be a an attribute statement, node
 * statement, a series of node statements and edge statements, or a
 * parameter.
 *
 * @param {object} graph
 */function parseStatement(graph){// parse subgraph
var subgraph=parseSubgraph(graph);if(subgraph){// edge statements
parseEdge(graph,subgraph);return;}// parse an attribute statement
var attr=parseAttributeStatement(graph);if(attr){return;}// parse node
if(tokenType!=TOKENTYPE.IDENTIFIER){throw newSyntaxError("Identifier expected");}var id=token;// id can be a string or a number
getToken();if(token==="="){// id statement
getToken();if(tokenType!=TOKENTYPE.IDENTIFIER){throw newSyntaxError("Identifier expected");}graph[id]=token;getToken();// TODO: implement comma separated list with "a_list: ID=ID [','] [a_list] "
}else{parseNodeStatement(graph,id);}}/**
 * Parse a subgraph
 *
 * @param {object} graph    parent graph object
 * @returns {object | null} subgraph
 */function parseSubgraph(graph){var subgraph=null;// optional subgraph keyword
if(token==="subgraph"){subgraph={};subgraph.type="subgraph";getToken();// optional graph id
if(tokenType===TOKENTYPE.IDENTIFIER){subgraph.id=token;getToken();}}// open angle bracket
if(token==="{"){getToken();if(!subgraph){subgraph={};}subgraph.parent=graph;subgraph.node=graph.node;subgraph.edge=graph.edge;subgraph.graph=graph.graph;// statements
parseStatements(subgraph);// close angle bracket
if(token!="}"){throw newSyntaxError("Angle bracket } expected");}getToken();// remove temporary default options
delete subgraph.node;delete subgraph.edge;delete subgraph.graph;delete subgraph.parent;// register at the parent graph
if(!graph.subgraphs){graph.subgraphs=[];}graph.subgraphs.push(subgraph);}return subgraph;}/**
 * parse an attribute statement like "node [shape=circle fontSize=16]".
 * Available keywords are 'node', 'edge', 'graph'.
 * The previous list with default attributes will be replaced
 *
 * @param {object} graph
 * @returns {string | null} keyword Returns the name of the parsed attribute
 *                                  (node, edge, graph), or null if nothing
 *                                  is parsed.
 */function parseAttributeStatement(graph){// attribute statements
if(token==="node"){getToken();// node attributes
graph.node=parseAttributeList();return"node";}else if(token==="edge"){getToken();// edge attributes
graph.edge=parseAttributeList();return"edge";}else if(token==="graph"){getToken();// graph attributes
graph.graph=parseAttributeList();return"graph";}return null;}/**
 * parse a node statement
 *
 * @param {object} graph
 * @param {string | number} id
 */function parseNodeStatement(graph,id){// node statement
var node={id:id};var attr=parseAttributeList();if(attr){node.attr=attr;}addNode(graph,node);// edge statements
parseEdge(graph,id);}/**
 * Parse an edge or a series of edges
 *
 * @param {object} graph
 * @param {string | number} from        Id of the from node
 */function parseEdge(graph,from){while(token==="->"||token==="--"){var to;var type=token;getToken();var subgraph=parseSubgraph(graph);if(subgraph){to=subgraph;}else{if(tokenType!=TOKENTYPE.IDENTIFIER){throw newSyntaxError("Identifier or subgraph expected");}to=token;addNode(graph,{id:to});getToken();}// parse edge attributes
var attr=parseAttributeList();// create edge
var edge=createEdge(graph,from,to,type,attr);addEdge(graph,edge);from=to;}}/**
 * Parse a set with attributes,
 * for example [label="1.000", shape=solid]
 *
 * @returns {object | null} attr
 */function parseAttributeList(){var i;var attr=null;// edge styles of dot and vis
var edgeStyles={dashed:true,solid:false,dotted:[1,5]};/**
   * Define arrow types.
   * vis currently supports types defined in 'arrowTypes'.
   * Details of arrow shapes are described in
   * http://www.graphviz.org/content/arrow-shapes
   */var arrowTypes={dot:"circle",box:"box",crow:"crow",curve:"curve",icurve:"inv_curve",normal:"triangle",inv:"inv_triangle",diamond:"diamond",tee:"bar",vee:"vee"};/**
   * 'attr_list' contains attributes for checking if some of them are affected
   * later. For instance, both of 'arrowhead' and 'dir' (edge style defined
   * in DOT) make changes to 'arrows' attribute in vis.
   */var attr_list=new Array();var attr_names=new Array();// used for checking the case.
// parse attributes
while(token==="["){getToken();attr={};while(token!==""&&token!="]"){if(tokenType!=TOKENTYPE.IDENTIFIER){throw newSyntaxError("Attribute name expected");}var name=token;getToken();if(token!="="){throw newSyntaxError("Equal sign = expected");}getToken();if(tokenType!=TOKENTYPE.IDENTIFIER){throw newSyntaxError("Attribute value expected");}var value=token;// convert from dot style to vis
if(name==="style"){value=edgeStyles[value];}var arrowType;if(name==="arrowhead"){arrowType=arrowTypes[value];name="arrows";value={to:{enabled:true,type:arrowType}};}if(name==="arrowtail"){arrowType=arrowTypes[value];name="arrows";value={from:{enabled:true,type:arrowType}};}attr_list.push({attr:attr,name:name,value:value});attr_names.push(name);getToken();if(token==","){getToken();}}if(token!="]"){throw newSyntaxError("Bracket ] expected");}getToken();}/**
   * As explained in [1], graphviz has limitations for combination of
   * arrow[head|tail] and dir. If attribute list includes 'dir',
   * following cases just be supported.
   *   1. both or none + arrowhead, arrowtail
   *   2. forward + arrowhead (arrowtail is not affedted)
   *   3. back + arrowtail (arrowhead is not affected)
   * [1] https://www.graphviz.org/doc/info/attrs.html#h:undir_note
   */if(includes(attr_names).call(attr_names,"dir")){var idx={};// get index of 'arrows' and 'dir'
idx.arrows={};for(i=0;i<attr_list.length;i++){if(attr_list[i].name==="arrows"){if(attr_list[i].value.to!=null){idx.arrows.to=i;}else if(attr_list[i].value.from!=null){idx.arrows.from=i;}else{throw newSyntaxError("Invalid value of arrows");}}else if(attr_list[i].name==="dir"){idx.dir=i;}}// first, add default arrow shape if it is not assigned to avoid error
var dir_type=attr_list[idx.dir].value;if(!includes(attr_names).call(attr_names,"arrows")){if(dir_type==="both"){attr_list.push({attr:attr_list[idx.dir].attr,name:"arrows",value:{to:{enabled:true}}});idx.arrows.to=attr_list.length-1;attr_list.push({attr:attr_list[idx.dir].attr,name:"arrows",value:{from:{enabled:true}}});idx.arrows.from=attr_list.length-1;}else if(dir_type==="forward"){attr_list.push({attr:attr_list[idx.dir].attr,name:"arrows",value:{to:{enabled:true}}});idx.arrows.to=attr_list.length-1;}else if(dir_type==="back"){attr_list.push({attr:attr_list[idx.dir].attr,name:"arrows",value:{from:{enabled:true}}});idx.arrows.from=attr_list.length-1;}else if(dir_type==="none"){attr_list.push({attr:attr_list[idx.dir].attr,name:"arrows",value:""});idx.arrows.to=attr_list.length-1;}else{throw newSyntaxError('Invalid dir type "'+dir_type+'"');}}var from_type;var to_type;// update 'arrows' attribute from 'dir'.
if(dir_type==="both"){// both of shapes of 'from' and 'to' are given
if(idx.arrows.to&&idx.arrows.from){to_type=attr_list[idx.arrows.to].value.to.type;from_type=attr_list[idx.arrows.from].value.from.type;attr_list[idx.arrows.to]={attr:attr_list[idx.arrows.to].attr,name:attr_list[idx.arrows.to].name,value:{to:{enabled:true,type:to_type},from:{enabled:true,type:from_type}}};splice(attr_list).call(attr_list,idx.arrows.from,1);// shape of 'to' is assigned and use default to 'from'
}else if(idx.arrows.to){to_type=attr_list[idx.arrows.to].value.to.type;from_type="arrow";attr_list[idx.arrows.to]={attr:attr_list[idx.arrows.to].attr,name:attr_list[idx.arrows.to].name,value:{to:{enabled:true,type:to_type},from:{enabled:true,type:from_type}}};// only shape of 'from' is assigned and use default for 'to'
}else if(idx.arrows.from){to_type="arrow";from_type=attr_list[idx.arrows.from].value.from.type;attr_list[idx.arrows.from]={attr:attr_list[idx.arrows.from].attr,name:attr_list[idx.arrows.from].name,value:{to:{enabled:true,type:to_type},from:{enabled:true,type:from_type}}};}}else if(dir_type==="back"){// given both of shapes, but use only 'from'
if(idx.arrows.to&&idx.arrows.from){to_type="";from_type=attr_list[idx.arrows.from].value.from.type;attr_list[idx.arrows.from]={attr:attr_list[idx.arrows.from].attr,name:attr_list[idx.arrows.from].name,value:{to:{enabled:true,type:to_type},from:{enabled:true,type:from_type}}};// given shape of 'to', but does not use it
}else if(idx.arrows.to){to_type="";from_type="arrow";idx.arrows.from=idx.arrows.to;attr_list[idx.arrows.from]={attr:attr_list[idx.arrows.from].attr,name:attr_list[idx.arrows.from].name,value:{to:{enabled:true,type:to_type},from:{enabled:true,type:from_type}}};// assign given 'from' shape
}else if(idx.arrows.from){to_type="";from_type=attr_list[idx.arrows.from].value.from.type;attr_list[idx.arrows.to]={attr:attr_list[idx.arrows.from].attr,name:attr_list[idx.arrows.from].name,value:{to:{enabled:true,type:to_type},from:{enabled:true,type:from_type}}};}attr_list[idx.arrows.from]={attr:attr_list[idx.arrows.from].attr,name:attr_list[idx.arrows.from].name,value:{from:{enabled:true,type:attr_list[idx.arrows.from].value.from.type}}};}else if(dir_type==="none"){var idx_arrow;if(idx.arrows.to){idx_arrow=idx.arrows.to;}else{idx_arrow=idx.arrows.from;}attr_list[idx_arrow]={attr:attr_list[idx_arrow].attr,name:attr_list[idx_arrow].name,value:""};}else if(dir_type==="forward"){// given both of shapes, but use only 'to'
if(idx.arrows.to&&idx.arrows.from){to_type=attr_list[idx.arrows.to].value.to.type;from_type="";attr_list[idx.arrows.to]={attr:attr_list[idx.arrows.to].attr,name:attr_list[idx.arrows.to].name,value:{to:{enabled:true,type:to_type},from:{enabled:true,type:from_type}}};// assign given 'to' shape
}else if(idx.arrows.to){to_type=attr_list[idx.arrows.to].value.to.type;from_type="";attr_list[idx.arrows.to]={attr:attr_list[idx.arrows.to].attr,name:attr_list[idx.arrows.to].name,value:{to:{enabled:true,type:to_type},from:{enabled:true,type:from_type}}};// given shape of 'from', but does not use it
}else if(idx.arrows.from){to_type="arrow";from_type="";idx.arrows.to=idx.arrows.from;attr_list[idx.arrows.to]={attr:attr_list[idx.arrows.to].attr,name:attr_list[idx.arrows.to].name,value:{to:{enabled:true,type:to_type},from:{enabled:true,type:from_type}}};}attr_list[idx.arrows.to]={attr:attr_list[idx.arrows.to].attr,name:attr_list[idx.arrows.to].name,value:{to:{enabled:true,type:attr_list[idx.arrows.to].value.to.type}}};}else{throw newSyntaxError('Invalid dir type "'+dir_type+'"');}// remove 'dir' attribute no need anymore
splice(attr_list).call(attr_list,idx.dir,1);}// parse 'penwidth'
var nof_attr_list;if(includes(attr_names).call(attr_names,"penwidth")){var tmp_attr_list=[];nof_attr_list=attr_list.length;for(i=0;i<nof_attr_list;i++){// exclude 'width' from attr_list if 'penwidth' exists
if(attr_list[i].name!=="width"){if(attr_list[i].name==="penwidth"){attr_list[i].name="width";}tmp_attr_list.push(attr_list[i]);}}attr_list=tmp_attr_list;}nof_attr_list=attr_list.length;for(i=0;i<nof_attr_list;i++){setValue(attr_list[i].attr,attr_list[i].name,attr_list[i].value);}return attr;}/**
 * Create a syntax error with extra information on current token and index.
 *
 * @param {string} message
 * @returns {SyntaxError} err
 */function newSyntaxError(message){return new SyntaxError(message+', got "'+chop(token,30)+'" (char '+index$1+")");}/**
 * Chop off text after a maximum length
 *
 * @param {string} text
 * @param {number} maxLength
 * @returns {string}
 */function chop(text,maxLength){return text.length<=maxLength?text:text.substr(0,27)+"...";}/**
 * Execute a function fn for each pair of elements in two arrays
 *
 * @param {Array | *} array1
 * @param {Array | *} array2
 * @param {Function} fn
 */function forEach2(array1,array2,fn){if(isArray(array1)){forEach$2(array1).call(array1,function(elem1){if(isArray(array2)){forEach$2(array2).call(array2,function(elem2){fn(elem1,elem2);});}else{fn(elem1,array2);}});}else{if(isArray(array2)){forEach$2(array2).call(array2,function(elem2){fn(array1,elem2);});}else{fn(array1,array2);}}}/**
 * Set a nested property on an object
 * When nested objects are missing, they will be created.
 * For example setProp({}, 'font.color', 'red') will return {font: {color: 'red'}}
 *
 * @param {object} object
 * @param {string} path   A dot separated string like 'font.color'
 * @param {*} value       Value for the property
 * @returns {object} Returns the original object, allows for chaining.
 */function setProp(object,path,value){var names=path.split(".");var prop=names.pop();// traverse over the nested objects
var obj=object;for(var i=0;i<names.length;i++){var name=names[i];if(!(name in obj)){obj[name]={};}obj=obj[name];}// set the property value
obj[prop]=value;return object;}/**
 * Convert an object with DOT attributes to their vis.js equivalents.
 *
 * @param {object} attr     Object with DOT attributes
 * @param {object} mapping
 * @returns {object}         Returns an object with vis.js attributes
 */function convertAttr(attr,mapping){var converted={};for(var prop in attr){if(attr.hasOwnProperty(prop)){var visProp=mapping[prop];if(isArray(visProp)){forEach$2(visProp).call(visProp,function(visPropI){setProp(converted,visPropI,attr[prop]);});}else if(typeof visProp==="string"){setProp(converted,visProp,attr[prop]);}else{setProp(converted,prop,attr[prop]);}}}return converted;}/**
 * Convert a string containing a graph in DOT language into a map containing
 * with nodes and edges in the format of graph.
 *
 * @param {string} data         Text containing a graph in DOT-notation
 * @returns {object} graphData
 */function DOTToGraph(data){// parse the DOT file
var dotData=parseDOT(data);var graphData={nodes:[],edges:[],options:{}};// copy the nodes
if(dotData.nodes){var _context2;forEach$2(_context2=dotData.nodes).call(_context2,function(dotNode){var graphNode={id:dotNode.id,label:String(dotNode.label||dotNode.id)};merge$1(graphNode,convertAttr(dotNode.attr,NODE_ATTR_MAPPING));if(graphNode.image){graphNode.shape="image";}graphData.nodes.push(graphNode);});}// copy the edges
if(dotData.edges){var _context3;/**
     * Convert an edge in DOT format to an edge with VisGraph format
     *
     * @param {object} dotEdge
     * @returns {object} graphEdge
     */var convertEdge=function convertEdge(dotEdge){var graphEdge={from:dotEdge.from,to:dotEdge.to};merge$1(graphEdge,convertAttr(dotEdge.attr,EDGE_ATTR_MAPPING));// Add arrows attribute to default styled arrow.
// The reason why default style is not added in parseAttributeList() is
// because only default is cleared before here.
if(graphEdge.arrows==null&&dotEdge.type==="->"){graphEdge.arrows="to";}return graphEdge;};forEach$2(_context3=dotData.edges).call(_context3,function(dotEdge){var from,to;if(dotEdge.from instanceof Object){from=dotEdge.from.nodes;}else{from={id:dotEdge.from};}if(dotEdge.to instanceof Object){to=dotEdge.to.nodes;}else{to={id:dotEdge.to};}if(dotEdge.from instanceof Object&&dotEdge.from.edges){var _context4;forEach$2(_context4=dotEdge.from.edges).call(_context4,function(subEdge){var graphEdge=convertEdge(subEdge);graphData.edges.push(graphEdge);});}forEach2(from,to,function(from,to){var subEdge=createEdge(graphData,from.id,to.id,dotEdge.type,dotEdge.attr);var graphEdge=convertEdge(subEdge);graphData.edges.push(graphEdge);});if(dotEdge.to instanceof Object&&dotEdge.to.edges){var _context5;forEach$2(_context5=dotEdge.to.edges).call(_context5,function(subEdge){var graphEdge=convertEdge(subEdge);graphData.edges.push(graphEdge);});}});}// copy the options
if(dotData.attr){graphData.options=dotData.attr;}return graphData;}/* eslint-enable no-var */ /* eslint-enable no-unused-vars */ /* eslint-enable no-prototype-builtins */var dotparser=/*#__PURE__*/Object.freeze({__proto__:null,parseDOT:parseDOT,DOTToGraph:DOTToGraph});/**
 * Convert Gephi to Vis.
 *
 * @param gephiJSON - The parsed JSON data in Gephi format.
 * @param optionsObj - Additional options.
 *
 * @returns The converted data ready to be used in Vis.
 */exports.networkDOTParser=dotparser;function parseGephi(gephiJSON,optionsObj){var _context;var options={edges:{inheritColor:false},nodes:{fixed:false,parseColor:false}};if(optionsObj!=null){if(optionsObj.fixed!=null){options.nodes.fixed=optionsObj.fixed;}if(optionsObj.parseColor!=null){options.nodes.parseColor=optionsObj.parseColor;}if(optionsObj.inheritColor!=null){options.edges.inheritColor=optionsObj.inheritColor;}}var gEdges=gephiJSON.edges;var vEdges=map$3(gEdges).call(gEdges,function(gEdge){var vEdge={from:gEdge.source,id:gEdge.id,to:gEdge.target};if(gEdge.attributes!=null){vEdge.attributes=gEdge.attributes;}if(gEdge.label!=null){vEdge.label=gEdge.label;}if(gEdge.attributes!=null&&gEdge.attributes.title!=null){vEdge.title=gEdge.attributes.title;}if(gEdge.type==="Directed"){vEdge.arrows="to";}// edge['value'] = gEdge.attributes != null ? gEdge.attributes.Weight : undefined;
// edge['width'] = edge['value'] != null ? undefined : edgegEdge.size;
if(gEdge.color&&options.edges.inheritColor===false){vEdge.color=gEdge.color;}return vEdge;});var vNodes=map$3(_context=gephiJSON.nodes).call(_context,function(gNode){var vNode={id:gNode.id,fixed:options.nodes.fixed&&gNode.x!=null&&gNode.y!=null};if(gNode.attributes!=null){vNode.attributes=gNode.attributes;}if(gNode.label!=null){vNode.label=gNode.label;}if(gNode.size!=null){vNode.size=gNode.size;}if(gNode.attributes!=null&&gNode.attributes.title!=null){vNode.title=gNode.attributes.title;}if(gNode.title!=null){vNode.title=gNode.title;}if(gNode.x!=null){vNode.x=gNode.x;}if(gNode.y!=null){vNode.y=gNode.y;}if(gNode.color!=null){if(options.nodes.parseColor===true){vNode.color=gNode.color;}else{vNode.color={background:gNode.color,border:gNode.color,highlight:{background:gNode.color,border:gNode.color},hover:{background:gNode.color,border:gNode.color}};}}return vNode;});return{nodes:vNodes,edges:vEdges};}var gephiParser=/*#__PURE__*/Object.freeze({__proto__:null,parseGephi:parseGephi});// English
exports.networkGephiParser=gephiParser;var en={addDescription:"Click in an empty space to place a new node.",addEdge:"Add Edge",addNode:"Add Node",back:"Back",close:"Close",createEdgeError:"Cannot link edges to a cluster.",del:"Delete selected",deleteClusterError:"Clusters cannot be deleted.",edgeDescription:"Click on a node and drag the edge to another node to connect them.",edit:"Edit",editClusterError:"Clusters cannot be edited.",editEdge:"Edit Edge",editEdgeDescription:"Click on the control points and drag them to a node to connect to it.",editNode:"Edit Node"};// German
var de={addDescription:"Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.",addEdge:"Kante hinzuf\xFCgen",addNode:"Knoten hinzuf\xFCgen",back:"Zur\xFCck",close:"Schließen",createEdgeError:"Es ist nicht m\xF6glich, Kanten mit Clustern zu verbinden.",del:"L\xF6sche Auswahl",deleteClusterError:"Cluster k\xF6nnen nicht gel\xF6scht werden.",edgeDescription:"Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.",edit:"Editieren",editClusterError:"Cluster k\xF6nnen nicht editiert werden.",editEdge:"Kante editieren",editEdgeDescription:"Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.",editNode:"Knoten editieren"};// Spanish
var es={addDescription:"Haga clic en un lugar vac\xEDo para colocar un nuevo nodo.",addEdge:"A\xF1adir arista",addNode:"A\xF1adir nodo",back:"Atr\xE1s",close:"Cerrar",createEdgeError:"No se puede conectar una arista a un grupo.",del:"Eliminar selecci\xF3n",deleteClusterError:"No es posible eliminar grupos.",edgeDescription:"Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.",edit:"Editar",editClusterError:"No es posible editar grupos.",editEdge:"Editar arista",editEdgeDescription:"Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.",editNode:"Editar nodo"};//Italiano
var it={addDescription:"Clicca per aggiungere un nuovo nodo",addEdge:"Aggiungi un vertice",addNode:"Aggiungi un nodo",back:"Indietro",close:"Chiudere",createEdgeError:"Non si possono collegare vertici ad un cluster",del:"Cancella la selezione",deleteClusterError:"I cluster non possono essere cancellati",edgeDescription:"Clicca su un nodo e trascinalo ad un altro nodo per connetterli.",edit:"Modifica",editClusterError:"I clusters non possono essere modificati.",editEdge:"Modifica il vertice",editEdgeDescription:"Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.",editNode:"Modifica il nodo"};// Dutch
var nl={addDescription:"Klik op een leeg gebied om een nieuwe node te maken.",addEdge:"Link toevoegen",addNode:"Node toevoegen",back:"Terug",close:"Sluiten",createEdgeError:"Kan geen link maken naar een cluster.",del:"Selectie verwijderen",deleteClusterError:"Clusters kunnen niet worden verwijderd.",edgeDescription:"Klik op een node en sleep de link naar een andere node om ze te verbinden.",edit:"Wijzigen",editClusterError:"Clusters kunnen niet worden aangepast.",editEdge:"Link wijzigen",editEdgeDescription:"Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.",editNode:"Node wijzigen"};// Portuguese Brazil
var pt={addDescription:"Clique em um espaço em branco para adicionar um novo nó",addEdge:"Adicionar aresta",addNode:"Adicionar nó",back:"Voltar",close:"Fechar",createEdgeError:"Não foi possível linkar arestas a um cluster.",del:"Remover selecionado",deleteClusterError:"Clusters não puderam ser removidos.",edgeDescription:"Clique em um nó e arraste a aresta até outro nó para conectá-los",edit:"Editar",editClusterError:"Clusters não puderam ser editados.",editEdge:"Editar aresta",editEdgeDescription:"Clique nos pontos de controle e os arraste para um nó para conectá-los",editNode:"Editar nó"};// Russian
var ru={addDescription:"Кликните в свободное место, чтобы добавить новый узел.",addEdge:"Добавить ребро",addNode:"Добавить узел",back:"Назад",close:"Закрывать",createEdgeError:"Невозможно соединить ребра в кластер.",del:"Удалить выбранное",deleteClusterError:"Кластеры не могут быть удалены",edgeDescription:"Кликните на узел и протяните ребро к другому узлу, чтобы соединить их.",edit:"Редактировать",editClusterError:"Кластеры недоступны для редактирования.",editEdge:"Редактировать ребро",editEdgeDescription:"Кликните на контрольные точки и перетащите их в узел, чтобы подключиться к нему.",editNode:"Редактировать узел"};// Chinese
var cn={addDescription:"单击空白处放置新节点。",addEdge:"添加连接线",addNode:"添加节点",back:"返回",close:"關閉",createEdgeError:"无法将连接线连接到群集。",del:"删除选定",deleteClusterError:"无法删除群集。",edgeDescription:"单击某个节点并将该连接线拖动到另一个节点以连接它们。",edit:"编辑",editClusterError:"无法编辑群集。",editEdge:"编辑连接线",editEdgeDescription:"单击控制节点并将它们拖到节点上连接。",editNode:"编辑节点"};// Ukrainian
var uk={addDescription:"Kлікніть на вільне місце, щоб додати новий вузол.",addEdge:"Додати край",addNode:"Додати вузол",back:"Назад",close:"Закрити",createEdgeError:"Не можливо об'єднати краї в групу.",del:"Видалити обране",deleteClusterError:"Групи не можуть бути видалені.",edgeDescription:"Клікніть на вузол і перетягніть край до іншого вузла, щоб їх з'єднати.",edit:"Редагувати",editClusterError:"Групи недоступні для редагування.",editEdge:"Редагувати край",editEdgeDescription:"Клікніть на контрольні точки і перетягніть їх у вузол, щоб підключитися до нього.",editNode:"Редагувати вузол"};// French
var fr={addDescription:"Cliquez dans un endroit vide pour placer un nœud.",addEdge:"Ajouter un lien",addNode:"Ajouter un nœud",back:"Retour",close:"Fermer",createEdgeError:"Impossible de créer un lien vers un cluster.",del:"Effacer la sélection",deleteClusterError:"Les clusters ne peuvent pas être effacés.",edgeDescription:"Cliquez sur un nœud et glissez le lien vers un autre nœud pour les connecter.",edit:"Éditer",editClusterError:"Les clusters ne peuvent pas être édités.",editEdge:"Éditer le lien",editEdgeDescription:"Cliquez sur les points de contrôle et glissez-les pour connecter un nœud.",editNode:"Éditer le nœud"};// Czech
var cs={addDescription:"Kluknutím do prázdného prostoru můžete přidat nový vrchol.",addEdge:"Přidat hranu",addNode:"Přidat vrchol",back:"Zpět",close:"Zavřít",createEdgeError:"Nelze připojit hranu ke shluku.",del:"Smazat výběr",deleteClusterError:"Nelze mazat shluky.",edgeDescription:"Přetažením z jednoho vrcholu do druhého můžete spojit tyto vrcholy novou hranou.",edit:"Upravit",editClusterError:"Nelze upravovat shluky.",editEdge:"Upravit hranu",editEdgeDescription:"Přetažením kontrolního vrcholu hrany ji můžete připojit k jinému vrcholu.",editNode:"Upravit vrchol"};var locales=/*#__PURE__*/Object.freeze({__proto__:null,en:en,de:de,es:es,it:it,nl:nl,pt:pt,ru:ru,cn:cn,uk:uk,fr:fr,cs:cs});/**
 * Normalizes language code into the format used internally.
 *
 * @param locales - All the available locales.
 * @param rawCode - The original code as supplied by the user.
 *
 * @returns Language code in the format language-COUNTRY or language, eventually
 * fallbacks to en.
 */function normalizeLanguageCode(locales,rawCode){try{var _rawCode$split=rawCode.split(/[-_ /]/,2),_rawCode$split2=_slicedToArray(_rawCode$split,2),rawLanguage=_rawCode$split2[0],rawCountry=_rawCode$split2[1];var language=rawLanguage!=null?rawLanguage.toLowerCase():null;var country=rawCountry!=null?rawCountry.toUpperCase():null;if(language&&country){var code=language+"-"+country;if(Object.prototype.hasOwnProperty.call(locales,code)){return code;}else{var _context;console.warn(concat(_context="Unknown variant ".concat(country," of language ")).call(_context,language,"."));}}if(language){var _code=language;if(Object.prototype.hasOwnProperty.call(locales,_code)){return _code;}else{console.warn("Unknown language ".concat(language));}}console.warn("Unknown locale ".concat(rawCode,", falling back to English."));return"en";}catch(error){console.error(error);console.warn("Unexpected error while normalizing locale ".concat(rawCode,", falling back to English."));return"en";}}/**
 * Associates a canvas to a given image, containing a number of renderings
 * of the image at various sizes.
 *
 * This technique is known as 'mipmapping'.
 *
 * NOTE: Images can also be of type 'data:svg+xml`. This code also works
 *       for svg, but the mipmapping may not be necessary.
 *
 * @param {Image} image
 */var CachedImage=/*#__PURE__*/function(){/**
   * @ignore
   */function CachedImage(){_classCallCheck(this,CachedImage);this.NUM_ITERATIONS=4;// Number of items in the coordinates array
this.image=new Image();this.canvas=document.createElement("canvas");}/**
   * Called when the image has been successfully loaded.
   */_createClass(CachedImage,[{key:"init",value:function init(){if(this.initialized())return;this.src=this.image.src;// For same interface with Image
var w=this.image.width;var h=this.image.height;// Ease external access
this.width=w;this.height=h;var h2=Math.floor(h/2);var h4=Math.floor(h/4);var h8=Math.floor(h/8);var h16=Math.floor(h/16);var w2=Math.floor(w/2);var w4=Math.floor(w/4);var w8=Math.floor(w/8);var w16=Math.floor(w/16);// Make canvas as small as possible
this.canvas.width=3*w4;this.canvas.height=h2;// Coordinates and sizes of images contained in the canvas
// Values per row:  [top x, left y, width, height]
this.coordinates=[[0,0,w2,h2],[w2,0,w4,h4],[w2,h4,w8,h8],[5*w8,h4,w16,h16]];this._fillMipMap();}/**
     * @returns {boolean} true if init() has been called, false otherwise.
     */},{key:"initialized",value:function initialized(){return this.coordinates!==undefined;}/**
     * Redraw main image in various sizes to the context.
     *
     * The rationale behind this is to reduce artefacts due to interpolation
     * at differing zoom levels.
     *
     * Source: http://stackoverflow.com/q/18761404/1223531
     *
     * This methods takes the resizing out of the drawing loop, in order to
     * reduce performance overhead.
     *
     * TODO: The code assumes that a 2D context can always be gotten. This is
     *       not necessarily true! OTOH, if not true then usage of this class
     *       is senseless.
     *
     * @private
     */},{key:"_fillMipMap",value:function _fillMipMap(){var ctx=this.canvas.getContext("2d");// First zoom-level comes from the image
var to=this.coordinates[0];ctx.drawImage(this.image,to[0],to[1],to[2],to[3]);// The rest are copy actions internal to the canvas/context
for(var iterations=1;iterations<this.NUM_ITERATIONS;iterations++){var from=this.coordinates[iterations-1];var _to=this.coordinates[iterations];ctx.drawImage(this.canvas,from[0],from[1],from[2],from[3],_to[0],_to[1],_to[2],_to[3]);}}/**
     * Draw the image, using the mipmap if necessary.
     *
     * MipMap is only used if param factor > 2; otherwise, original bitmap
     * is resized. This is also used to skip mipmap usage, e.g. by setting factor = 1
     *
     * Credits to 'Alex de Mulder' for original implementation.
     *
     * @param {CanvasRenderingContext2D} ctx  context on which to draw zoomed image
     * @param {Float} factor scale factor at which to draw
     * @param {number} left
     * @param {number} top
     * @param {number} width
     * @param {number} height
     */},{key:"drawImageAtPosition",value:function drawImageAtPosition(ctx,factor,left,top,width,height){if(!this.initialized())return;//can't draw image yet not intialized
if(factor>2){// Determine which zoomed image to use
factor*=0.5;var iterations=0;while(factor>2&&iterations<this.NUM_ITERATIONS){factor*=0.5;iterations+=1;}if(iterations>=this.NUM_ITERATIONS){iterations=this.NUM_ITERATIONS-1;}//console.log("iterations: " + iterations);
var from=this.coordinates[iterations];ctx.drawImage(this.canvas,from[0],from[1],from[2],from[3],left,top,width,height);}else{// Draw image directly
ctx.drawImage(this.image,left,top,width,height);}}}]);return CachedImage;}();/**
 * This callback is a callback that accepts an Image.
 *
 * @callback ImageCallback
 * @param {Image} image
 */ /**
 * This class loads images and keeps them stored.
 *
 * @param {ImageCallback} callback
 */var Images=/*#__PURE__*/function(){/**
   * @param {ImageCallback} callback
   */function Images(callback){_classCallCheck(this,Images);this.images={};this.imageBroken={};this.callback=callback;}/**
   * @param {string} url                      The original Url that failed to load, if the broken image is successfully loaded it will be added to the cache using this Url as the key so that subsequent requests for this Url will return the broken image
   * @param {string} brokenUrl                Url the broken image to try and load
   * @param {Image} imageToLoadBrokenUrlOn   The image object
   */_createClass(Images,[{key:"_tryloadBrokenUrl",value:function _tryloadBrokenUrl(url,brokenUrl,imageToLoadBrokenUrlOn){//If these parameters aren't specified then exit the function because nothing constructive can be done
if(url===undefined||imageToLoadBrokenUrlOn===undefined)return;if(brokenUrl===undefined){console.warn("No broken url image defined");return;}//Clear the old subscription to the error event and put a new in place that only handle errors in loading the brokenImageUrl
imageToLoadBrokenUrlOn.image.onerror=function(){console.error("Could not load brokenImage:",brokenUrl);// cache item will contain empty image, this should be OK for default
};//Set the source of the image to the brokenUrl, this is actually what kicks off the loading of the broken image
imageToLoadBrokenUrlOn.image.src=brokenUrl;}/**
     *
     * @param {vis.Image} imageToRedrawWith
     * @private
     */},{key:"_redrawWithImage",value:function _redrawWithImage(imageToRedrawWith){if(this.callback){this.callback(imageToRedrawWith);}}/**
     * @param {string} url          Url of the image
     * @param {string} brokenUrl    Url of an image to use if the url image is not found
     * @returns {Image} img          The image object
     */},{key:"load",value:function load(url,brokenUrl){var _this=this;//Try and get the image from the cache, if successful then return the cached image
var cachedImage=this.images[url];if(cachedImage)return cachedImage;//Create a new image
var img=new CachedImage();// Need to add to cache here, otherwise final return will spawn different copies of the same image,
// Also, there will be multiple loads of the same image.
this.images[url]=img;//Subscribe to the event that is raised if the image loads successfully
img.image.onload=function(){// Properly init the cached item and then request a redraw
_this._fixImageCoordinates(img.image);img.init();_this._redrawWithImage(img);};//Subscribe to the event that is raised if the image fails to load
img.image.onerror=function(){console.error("Could not load image:",url);//Try and load the image specified by the brokenUrl using
_this._tryloadBrokenUrl(url,brokenUrl,img);};//Set the source of the image to the url, this is what actually kicks off the loading of the image
img.image.src=url;//Return the new image
return img;}/**
     * IE11 fix -- thanks dponch!
     *
     * Local helper function
     *
     * @param {vis.Image} imageToCache
     * @private
     */},{key:"_fixImageCoordinates",value:function _fixImageCoordinates(imageToCache){if(imageToCache.width===0){document.body.appendChild(imageToCache);imageToCache.width=imageToCache.offsetWidth;imageToCache.height=imageToCache.offsetHeight;document.body.removeChild(imageToCache);}}}]);return Images;}();exports.NetworkImages=Images;var freezing=!fails(function(){// eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
return Object.isExtensible(Object.preventExtensions({}));});var internalMetadata=createCommonjsModule(function(module){var defineProperty=objectDefineProperty.f;var METADATA=uid('meta');var id=0;// eslint-disable-next-line es/no-object-isextensible -- safe
var isExtensible=Object.isExtensible||function(){return true;};var setMetadata=function(it){defineProperty(it,METADATA,{value:{objectID:'O'+id++,// object ID
weakData:{}// weak collections IDs
}});};var fastKey=function(it,create){// return a primitive with prefix
if(!isObject$1(it))return typeof it=='symbol'?it:(typeof it=='string'?'S':'P')+it;if(!has$1(it,METADATA)){// can't set metadata to uncaught frozen object
if(!isExtensible(it))return'F';// not necessary to add metadata
if(!create)return'E';// add missing metadata
setMetadata(it);// return object ID
}return it[METADATA].objectID;};var getWeakData=function(it,create){if(!has$1(it,METADATA)){// can't set metadata to uncaught frozen object
if(!isExtensible(it))return true;// not necessary to add metadata
if(!create)return false;// add missing metadata
setMetadata(it);// return the store of weak collections IDs
}return it[METADATA].weakData;};// add metadata on freeze-family methods calling
var onFreeze=function(it){if(freezing&&meta.REQUIRED&&isExtensible(it)&&!has$1(it,METADATA))setMetadata(it);return it;};var meta=module.exports={REQUIRED:false,fastKey:fastKey,getWeakData:getWeakData,onFreeze:onFreeze};hiddenKeys$1[METADATA]=true;});var Result=function(stopped,result){this.stopped=stopped;this.result=result;};var iterate=function(iterable,unboundFunction,options){var that=options&&options.that;var AS_ENTRIES=!!(options&&options.AS_ENTRIES);var IS_ITERATOR=!!(options&&options.IS_ITERATOR);var INTERRUPTED=!!(options&&options.INTERRUPTED);var fn=functionBindContext(unboundFunction,that,1+AS_ENTRIES+INTERRUPTED);var iterator,iterFn,index,length,result,next,step;var stop=function(condition){if(iterator)iteratorClose(iterator);return new Result(true,condition);};var callFn=function(value){if(AS_ENTRIES){anObject(value);return INTERRUPTED?fn(value[0],value[1],stop):fn(value[0],value[1]);}return INTERRUPTED?fn(value,stop):fn(value);};if(IS_ITERATOR){iterator=iterable;}else{iterFn=getIteratorMethod$1(iterable);if(typeof iterFn!='function')throw TypeError('Target is not iterable');// optimisation for array iterators
if(isArrayIteratorMethod(iterFn)){for(index=0,length=toLength(iterable.length);length>index;index++){result=callFn(iterable[index]);if(result&&result instanceof Result)return result;}return new Result(false);}iterator=iterFn.call(iterable);}next=iterator.next;while(!(step=next.call(iterator)).done){try{result=callFn(step.value);}catch(error){iteratorClose(iterator);throw error;}if(typeof result=='object'&&result&&result instanceof Result)return result;}return new Result(false);};var anInstance=function(it,Constructor,name){if(!(it instanceof Constructor)){throw TypeError('Incorrect '+(name?name+' ':'')+'invocation');}return it;};var defineProperty$1=objectDefineProperty.f;var forEach=arrayIteration.forEach;var setInternalState$2=internalState.set;var internalStateGetterFor$2=internalState.getterFor;var collection=function(CONSTRUCTOR_NAME,wrapper,common){var IS_MAP=CONSTRUCTOR_NAME.indexOf('Map')!==-1;var IS_WEAK=CONSTRUCTOR_NAME.indexOf('Weak')!==-1;var ADDER=IS_MAP?'set':'add';var NativeConstructor=global$1[CONSTRUCTOR_NAME];var NativePrototype=NativeConstructor&&NativeConstructor.prototype;var exported={};var Constructor;if(!descriptors||typeof NativeConstructor!='function'||!(IS_WEAK||NativePrototype.forEach&&!fails(function(){new NativeConstructor().entries().next();}))){// create collection constructor
Constructor=common.getConstructor(wrapper,CONSTRUCTOR_NAME,IS_MAP,ADDER);internalMetadata.REQUIRED=true;}else{Constructor=wrapper(function(target,iterable){setInternalState$2(anInstance(target,Constructor,CONSTRUCTOR_NAME),{type:CONSTRUCTOR_NAME,collection:new NativeConstructor()});if(iterable!=undefined)iterate(iterable,target[ADDER],{that:target,AS_ENTRIES:IS_MAP});});var getInternalState=internalStateGetterFor$2(CONSTRUCTOR_NAME);forEach(['add','clear','delete','forEach','get','has','set','keys','values','entries'],function(KEY){var IS_ADDER=KEY=='add'||KEY=='set';if(KEY in NativePrototype&&!(IS_WEAK&&KEY=='clear')){createNonEnumerableProperty(Constructor.prototype,KEY,function(a,b){var collection=getInternalState(this).collection;if(!IS_ADDER&&IS_WEAK&&!isObject$1(a))return KEY=='get'?undefined:false;var result=collection[KEY](a===0?0:a,b);return IS_ADDER?this:result;});}});IS_WEAK||defineProperty$1(Constructor.prototype,'size',{configurable:true,get:function(){return getInternalState(this).collection.size;}});}setToStringTag(Constructor,CONSTRUCTOR_NAME,false,true);exported[CONSTRUCTOR_NAME]=Constructor;_export({global:true,forced:true},exported);if(!IS_WEAK)common.setStrong(Constructor,CONSTRUCTOR_NAME,IS_MAP);return Constructor;};var redefineAll=function(target,src,options){for(var key in src){if(options&&options.unsafe&&target[key])target[key]=src[key];else redefine(target,key,src[key],options);}return target;};var SPECIES=wellKnownSymbol('species');var setSpecies=function(CONSTRUCTOR_NAME){var Constructor=getBuiltIn(CONSTRUCTOR_NAME);var defineProperty=objectDefineProperty.f;if(descriptors&&Constructor&&!Constructor[SPECIES]){defineProperty(Constructor,SPECIES,{configurable:true,get:function(){return this;}});}};var defineProperty=objectDefineProperty.f;var fastKey=internalMetadata.fastKey;var setInternalState$1=internalState.set;var internalStateGetterFor$1=internalState.getterFor;var collectionStrong={getConstructor:function(wrapper,CONSTRUCTOR_NAME,IS_MAP,ADDER){var C=wrapper(function(that,iterable){anInstance(that,C,CONSTRUCTOR_NAME);setInternalState$1(that,{type:CONSTRUCTOR_NAME,index:objectCreate(null),first:undefined,last:undefined,size:0});if(!descriptors)that.size=0;if(iterable!=undefined)iterate(iterable,that[ADDER],{that:that,AS_ENTRIES:IS_MAP});});var getInternalState=internalStateGetterFor$1(CONSTRUCTOR_NAME);var define=function(that,key,value){var state=getInternalState(that);var entry=getEntry(that,key);var previous,index;// change existing entry
if(entry){entry.value=value;// create new entry
}else{state.last=entry={index:index=fastKey(key,true),key:key,value:value,previous:previous=state.last,next:undefined,removed:false};if(!state.first)state.first=entry;if(previous)previous.next=entry;if(descriptors)state.size++;else that.size++;// add to index
if(index!=='F')state.index[index]=entry;}return that;};var getEntry=function(that,key){var state=getInternalState(that);// fast case
var index=fastKey(key);var entry;if(index!=='F')return state.index[index];// frozen object case
for(entry=state.first;entry;entry=entry.next){if(entry.key==key)return entry;}};redefineAll(C.prototype,{// `{ Map, Set }.prototype.clear()` methods
// https://tc39.es/ecma262/#sec-map.prototype.clear
// https://tc39.es/ecma262/#sec-set.prototype.clear
clear:function clear(){var that=this;var state=getInternalState(that);var data=state.index;var entry=state.first;while(entry){entry.removed=true;if(entry.previous)entry.previous=entry.previous.next=undefined;delete data[entry.index];entry=entry.next;}state.first=state.last=undefined;if(descriptors)state.size=0;else that.size=0;},// `{ Map, Set }.prototype.delete(key)` methods
// https://tc39.es/ecma262/#sec-map.prototype.delete
// https://tc39.es/ecma262/#sec-set.prototype.delete
'delete':function(key){var that=this;var state=getInternalState(that);var entry=getEntry(that,key);if(entry){var next=entry.next;var prev=entry.previous;delete state.index[entry.index];entry.removed=true;if(prev)prev.next=next;if(next)next.previous=prev;if(state.first==entry)state.first=next;if(state.last==entry)state.last=prev;if(descriptors)state.size--;else that.size--;}return!!entry;},// `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods
// https://tc39.es/ecma262/#sec-map.prototype.foreach
// https://tc39.es/ecma262/#sec-set.prototype.foreach
forEach:function forEach(callbackfn/* , that = undefined */){var state=getInternalState(this);var boundFunction=functionBindContext(callbackfn,arguments.length>1?arguments[1]:undefined,3);var entry;while(entry=entry?entry.next:state.first){boundFunction(entry.value,entry.key,this);// revert to the last existing entry
while(entry&&entry.removed)entry=entry.previous;}},// `{ Map, Set}.prototype.has(key)` methods
// https://tc39.es/ecma262/#sec-map.prototype.has
// https://tc39.es/ecma262/#sec-set.prototype.has
has:function has(key){return!!getEntry(this,key);}});redefineAll(C.prototype,IS_MAP?{// `Map.prototype.get(key)` method
// https://tc39.es/ecma262/#sec-map.prototype.get
get:function get(key){var entry=getEntry(this,key);return entry&&entry.value;},// `Map.prototype.set(key, value)` method
// https://tc39.es/ecma262/#sec-map.prototype.set
set:function set(key,value){return define(this,key===0?0:key,value);}}:{// `Set.prototype.add(value)` method
// https://tc39.es/ecma262/#sec-set.prototype.add
add:function add(value){return define(this,value=value===0?0:value,value);}});if(descriptors)defineProperty(C.prototype,'size',{get:function(){return getInternalState(this).size;}});return C;},setStrong:function(C,CONSTRUCTOR_NAME,IS_MAP){var ITERATOR_NAME=CONSTRUCTOR_NAME+' Iterator';var getInternalCollectionState=internalStateGetterFor$1(CONSTRUCTOR_NAME);var getInternalIteratorState=internalStateGetterFor$1(ITERATOR_NAME);// `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods
// https://tc39.es/ecma262/#sec-map.prototype.entries
// https://tc39.es/ecma262/#sec-map.prototype.keys
// https://tc39.es/ecma262/#sec-map.prototype.values
// https://tc39.es/ecma262/#sec-map.prototype-@@iterator
// https://tc39.es/ecma262/#sec-set.prototype.entries
// https://tc39.es/ecma262/#sec-set.prototype.keys
// https://tc39.es/ecma262/#sec-set.prototype.values
// https://tc39.es/ecma262/#sec-set.prototype-@@iterator
defineIterator(C,CONSTRUCTOR_NAME,function(iterated,kind){setInternalState$1(this,{type:ITERATOR_NAME,target:iterated,state:getInternalCollectionState(iterated),kind:kind,last:undefined});},function(){var state=getInternalIteratorState(this);var kind=state.kind;var entry=state.last;// revert to the last existing entry
while(entry&&entry.removed)entry=entry.previous;// get next entry
if(!state.target||!(state.last=entry=entry?entry.next:state.state.first)){// or finish the iteration
state.target=undefined;return{value:undefined,done:true};}// return step by kind
if(kind=='keys')return{value:entry.key,done:false};if(kind=='values')return{value:entry.value,done:false};return{value:[entry.key,entry.value],done:false};},IS_MAP?'entries':'values',!IS_MAP,true);// `{ Map, Set }.prototype[@@species]` accessors
// https://tc39.es/ecma262/#sec-get-map-@@species
// https://tc39.es/ecma262/#sec-get-set-@@species
setSpecies(CONSTRUCTOR_NAME);}};// https://tc39.es/ecma262/#sec-map-objects
collection('Map',function(init){return function Map(){return init(this,arguments.length?arguments[0]:undefined);};},collectionStrong);var map$2=path.Map;var map$1=map$2;var map=map$1;/**
 * This class can store groups and options specific for groups.
 */var Groups=/*#__PURE__*/function(){/**
   * @ignore
   */function Groups(){_classCallCheck(this,Groups);this.clear();this._defaultIndex=0;this._groupIndex=0;this._defaultGroups=[{border:"#2B7CE9",background:"#97C2FC",highlight:{border:"#2B7CE9",background:"#D2E5FF"},hover:{border:"#2B7CE9",background:"#D2E5FF"}},// 0: blue
{border:"#FFA500",background:"#FFFF00",highlight:{border:"#FFA500",background:"#FFFFA3"},hover:{border:"#FFA500",background:"#FFFFA3"}},// 1: yellow
{border:"#FA0A10",background:"#FB7E81",highlight:{border:"#FA0A10",background:"#FFAFB1"},hover:{border:"#FA0A10",background:"#FFAFB1"}},// 2: red
{border:"#41A906",background:"#7BE141",highlight:{border:"#41A906",background:"#A1EC76"},hover:{border:"#41A906",background:"#A1EC76"}},// 3: green
{border:"#E129F0",background:"#EB7DF4",highlight:{border:"#E129F0",background:"#F0B3F5"},hover:{border:"#E129F0",background:"#F0B3F5"}},// 4: magenta
{border:"#7C29F0",background:"#AD85E4",highlight:{border:"#7C29F0",background:"#D3BDF0"},hover:{border:"#7C29F0",background:"#D3BDF0"}},// 5: purple
{border:"#C37F00",background:"#FFA807",highlight:{border:"#C37F00",background:"#FFCA66"},hover:{border:"#C37F00",background:"#FFCA66"}},// 6: orange
{border:"#4220FB",background:"#6E6EFD",highlight:{border:"#4220FB",background:"#9B9BFD"},hover:{border:"#4220FB",background:"#9B9BFD"}},// 7: darkblue
{border:"#FD5A77",background:"#FFC0CB",highlight:{border:"#FD5A77",background:"#FFD1D9"},hover:{border:"#FD5A77",background:"#FFD1D9"}},// 8: pink
{border:"#4AD63A",background:"#C2FABC",highlight:{border:"#4AD63A",background:"#E6FFE3"},hover:{border:"#4AD63A",background:"#E6FFE3"}},// 9: mint
{border:"#990000",background:"#EE0000",highlight:{border:"#BB0000",background:"#FF3333"},hover:{border:"#BB0000",background:"#FF3333"}},// 10:bright red
{border:"#FF6000",background:"#FF6000",highlight:{border:"#FF6000",background:"#FF6000"},hover:{border:"#FF6000",background:"#FF6000"}},// 12: real orange
{border:"#97C2FC",background:"#2B7CE9",highlight:{border:"#D2E5FF",background:"#2B7CE9"},hover:{border:"#D2E5FF",background:"#2B7CE9"}},// 13: blue
{border:"#399605",background:"#255C03",highlight:{border:"#399605",background:"#255C03"},hover:{border:"#399605",background:"#255C03"}},// 14: green
{border:"#B70054",background:"#FF007E",highlight:{border:"#B70054",background:"#FF007E"},hover:{border:"#B70054",background:"#FF007E"}},// 15: magenta
{border:"#AD85E4",background:"#7C29F0",highlight:{border:"#D3BDF0",background:"#7C29F0"},hover:{border:"#D3BDF0",background:"#7C29F0"}},// 16: purple
{border:"#4557FA",background:"#000EA1",highlight:{border:"#6E6EFD",background:"#000EA1"},hover:{border:"#6E6EFD",background:"#000EA1"}},// 17: darkblue
{border:"#FFC0CB",background:"#FD5A77",highlight:{border:"#FFD1D9",background:"#FD5A77"},hover:{border:"#FFD1D9",background:"#FD5A77"}},// 18: pink
{border:"#C2FABC",background:"#74D66A",highlight:{border:"#E6FFE3",background:"#74D66A"},hover:{border:"#E6FFE3",background:"#74D66A"}},// 19: mint
{border:"#EE0000",background:"#990000",highlight:{border:"#FF3333",background:"#BB0000"},hover:{border:"#FF3333",background:"#BB0000"}}// 20:bright red
];this.options={};this.defaultOptions={useDefaultGroups:true};assign$2(this.options,this.defaultOptions);}/**
   *
   * @param {object} options
   */_createClass(Groups,[{key:"setOptions",value:function setOptions(options){var optionFields=["useDefaultGroups"];if(options!==undefined){for(var groupName in options){if(Object.prototype.hasOwnProperty.call(options,groupName)){if(indexOf(optionFields).call(optionFields,groupName)===-1){var group=options[groupName];this.add(groupName,group);}}}}}/**
     * Clear all groups
     */},{key:"clear",value:function clear(){this._groups=new map();this._groupNames=[];}/**
     * Get group options of a groupname.
     * If groupname is not found, a new group may be created.
     *
     * @param {*}       groupname     Can be a number, string, Date, etc.
     * @param {boolean} [shouldCreate=true] If true, create a new group
     * @returns {object} The found or created group
     */},{key:"get",value:function get(groupname){var shouldCreate=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;var group=this._groups.get(groupname);if(group===undefined&&shouldCreate){if(this.options.useDefaultGroups===false&&this._groupNames.length>0){// create new group
var index=this._groupIndex%this._groupNames.length;++this._groupIndex;group={};group.color=this._groups.get(this._groupNames[index]);this._groups.set(groupname,group);}else{// create new group
var _index=this._defaultIndex%this._defaultGroups.length;this._defaultIndex++;group={};group.color=this._defaultGroups[_index];this._groups.set(groupname,group);}}return group;}/**
     * Add custom group style.
     *
     * @param {string} groupName - The name of the group, a new group will be
     * created if a group with the same name doesn't exist, otherwise the old
     * groups style will be overwritten.
     * @param {object} style - An object containing borderColor, backgroundColor,
     * etc.
     * @returns {object} The created group object.
     */},{key:"add",value:function add(groupName,style){// Only push group name once to prevent duplicates which would consume more
// RAM and also skew the distribution towards more often updated groups,
// neither of which is desirable.
if(!this._groups.has(groupName)){this._groupNames.push(groupName);}this._groups.set(groupName,style);return style;}}]);return Groups;}();// https://tc39.es/ecma262/#sec-number.isnan
_export({target:'Number',stat:true},{isNaN:function isNaN(number){// eslint-disable-next-line no-self-compare -- NaN check
return number!=number;}});var isNan$2=path.Number.isNaN;var isNan$1=isNan$2;var isNan=isNan$1;var globalIsFinite=global$1.isFinite;// `Number.isFinite` method
// https://tc39.es/ecma262/#sec-number.isfinite
// eslint-disable-next-line es/no-number-isfinite -- safe
var numberIsFinite=Number.isFinite||function isFinite(it){return typeof it=='number'&&globalIsFinite(it);};// https://tc39.es/ecma262/#sec-number.isfinite
_export({target:'Number',stat:true},{isFinite:numberIsFinite});var _isFinite$2=path.Number.isFinite;var _isFinite$1=_isFinite$2;var _isFinite=_isFinite$1;var $some=arrayIteration.some;var STRICT_METHOD$3=arrayMethodIsStrict('some');// `Array.prototype.some` method
// https://tc39.es/ecma262/#sec-array.prototype.some
_export({target:'Array',proto:true,forced:!STRICT_METHOD$3},{some:function some(callbackfn/* , thisArg */){return $some(this,callbackfn,arguments.length>1?arguments[1]:undefined);}});var some$2=entryVirtual('Array').some;var ArrayPrototype$7=Array.prototype;var some_1=function(it){var own=it.some;return it===ArrayPrototype$7||it instanceof Array&&own===ArrayPrototype$7.some?some$2:own;};var some$1=some_1;var some=some$1;var nativeConstruct=getBuiltIn('Reflect','construct');// `Reflect.construct` method
// https://tc39.es/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG=fails(function(){function F(){/* empty */}return!(nativeConstruct(function(){/* empty */},[],F)instanceof F);});var ARGS_BUG=!fails(function(){nativeConstruct(function(){/* empty */});});var FORCED$2=NEW_TARGET_BUG||ARGS_BUG;_export({target:'Reflect',stat:true,forced:FORCED$2,sham:FORCED$2},{construct:function construct(Target,args/* , newTarget */){aFunction$1(Target);anObject(args);var newTarget=arguments.length<3?Target:aFunction$1(arguments[2]);if(ARGS_BUG&&!NEW_TARGET_BUG)return nativeConstruct(Target,args,newTarget);if(Target==newTarget){// w/o altered newTarget, optimization for 0-4 arguments
switch(args.length){case 0:return new Target();case 1:return new Target(args[0]);case 2:return new Target(args[0],args[1]);case 3:return new Target(args[0],args[1],args[2]);case 4:return new Target(args[0],args[1],args[2],args[3]);}// w/o altered newTarget, lot of arguments case
var $args=[null];$args.push.apply($args,args);return new(functionBind.apply(Target,$args))();}// with altered newTarget, not support built-in constructors
var proto=newTarget.prototype;var instance=objectCreate(isObject$1(proto)?proto:Object.prototype);var result=Function.apply.call(Target,instance,args);return isObject$1(result)?result:instance;}});var construct$2=path.Reflect.construct;var construct$1=construct$2;var construct=construct$1;function _assertThisInitialized(self){if(self===void 0){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}var create$1=create$4;var create=create$1;// https://tc39.es/ecma262/#sec-object.setprototypeof
_export({target:'Object',stat:true},{setPrototypeOf:objectSetPrototypeOf});var setPrototypeOf$2=path.Object.setPrototypeOf;var setPrototypeOf$1=setPrototypeOf$2;var setPrototypeOf=setPrototypeOf$1;function _setPrototypeOf(o,p){_setPrototypeOf=setPrototypeOf||function _setPrototypeOf(o,p){o.__proto__=p;return o;};return _setPrototypeOf(o,p);}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function");}subClass.prototype=create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:true,configurable:true}});if(superClass)_setPrototypeOf(subClass,superClass);}function _possibleConstructorReturn(self,call){if(call&&(_typeof(call)==="object"||typeof call==="function")){return call;}return _assertThisInitialized(self);}var getPrototypeOf$1=getPrototypeOf$4;var getPrototypeOf=getPrototypeOf$1;function _getPrototypeOf(o){_getPrototypeOf=setPrototypeOf?getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||getPrototypeOf(o);};return _getPrototypeOf(o);}/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var runtime_1=createCommonjsModule(function(module){var runtime=function(exports){var Op=Object.prototype;var hasOwn=Op.hasOwnProperty;var undefined$1;// More compressible than void 0.
var $Symbol=typeof Symbol==="function"?Symbol:{};var iteratorSymbol=$Symbol.iterator||"@@iterator";var asyncIteratorSymbol=$Symbol.asyncIterator||"@@asyncIterator";var toStringTagSymbol=$Symbol.toStringTag||"@@toStringTag";function define(obj,key,value){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});return obj[key];}try{// IE 8 has a broken Object.defineProperty that only works on DOM objects.
define({},"");}catch(err){define=function(obj,key,value){return obj[key]=value;};}function wrap(innerFn,outerFn,self,tryLocsList){// If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
var protoGenerator=outerFn&&outerFn.prototype instanceof Generator?outerFn:Generator;var generator=Object.create(protoGenerator.prototype);var context=new Context(tryLocsList||[]);// The ._invoke method unifies the implementations of the .next,
// .throw, and .return methods.
generator._invoke=makeInvokeMethod(innerFn,self,context);return generator;}exports.wrap=wrap;// Try/catch helper to minimize deoptimizations. Returns a completion
// record like context.tryEntries[i].completion. This interface could
// have been (and was previously) designed to take a closure to be
// invoked without arguments, but in all the cases we care about we
// already have an existing method we want to call, so there's no need
// to create a new function object. We can even get away with assuming
// the method takes exactly one argument, since that happens to be true
// in every case, so we don't have to touch the arguments object. The
// only additional allocation required is the completion record, which
// has a stable shape and so hopefully should be cheap to allocate.
function tryCatch(fn,obj,arg){try{return{type:"normal",arg:fn.call(obj,arg)};}catch(err){return{type:"throw",arg:err};}}var GenStateSuspendedStart="suspendedStart";var GenStateSuspendedYield="suspendedYield";var GenStateExecuting="executing";var GenStateCompleted="completed";// Returning this object from the innerFn has the same effect as
// breaking out of the dispatch switch statement.
var ContinueSentinel={};// Dummy constructor functions that we use as the .constructor and
// .constructor.prototype properties for functions that return Generator
// objects. For full spec compliance, you may wish to configure your
// minifier not to mangle the names of these two functions.
function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}// This is a polyfill for %IteratorPrototype% for environments that
// don't natively support it.
var IteratorPrototype={};IteratorPrototype[iteratorSymbol]=function(){return this;};var getProto=Object.getPrototypeOf;var NativeIteratorPrototype=getProto&&getProto(getProto(values([])));if(NativeIteratorPrototype&&NativeIteratorPrototype!==Op&&hasOwn.call(NativeIteratorPrototype,iteratorSymbol)){// This environment has a native %IteratorPrototype%; use it instead
// of the polyfill.
IteratorPrototype=NativeIteratorPrototype;}var Gp=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(IteratorPrototype);GeneratorFunction.prototype=Gp.constructor=GeneratorFunctionPrototype;GeneratorFunctionPrototype.constructor=GeneratorFunction;GeneratorFunction.displayName=define(GeneratorFunctionPrototype,toStringTagSymbol,"GeneratorFunction");// Helper for defining the .next, .throw, and .return methods of the
// Iterator interface in terms of a single ._invoke method.
function defineIteratorMethods(prototype){["next","throw","return"].forEach(function(method){define(prototype,method,function(arg){return this._invoke(method,arg);});});}exports.isGeneratorFunction=function(genFun){var ctor=typeof genFun==="function"&&genFun.constructor;return ctor?ctor===GeneratorFunction||// For the native GeneratorFunction constructor, the best we can
// do is to check its .name property.
(ctor.displayName||ctor.name)==="GeneratorFunction":false;};exports.mark=function(genFun){if(Object.setPrototypeOf){Object.setPrototypeOf(genFun,GeneratorFunctionPrototype);}else{genFun.__proto__=GeneratorFunctionPrototype;define(genFun,toStringTagSymbol,"GeneratorFunction");}genFun.prototype=Object.create(Gp);return genFun;};// Within the body of any async function, `await x` is transformed to
// `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
// `hasOwn.call(value, "__await")` to determine if the yielded value is
// meant to be awaited.
exports.awrap=function(arg){return{__await:arg};};function AsyncIterator(generator,PromiseImpl){function invoke(method,arg,resolve,reject){var record=tryCatch(generator[method],generator,arg);if(record.type==="throw"){reject(record.arg);}else{var result=record.arg;var value=result.value;if(value&&typeof value==="object"&&hasOwn.call(value,"__await")){return PromiseImpl.resolve(value.__await).then(function(value){invoke("next",value,resolve,reject);},function(err){invoke("throw",err,resolve,reject);});}return PromiseImpl.resolve(value).then(function(unwrapped){// When a yielded Promise is resolved, its final value becomes
// the .value of the Promise<{value,done}> result for the
// current iteration.
result.value=unwrapped;resolve(result);},function(error){// If a rejected Promise was yielded, throw the rejection back
// into the async generator function so it can be handled there.
return invoke("throw",error,resolve,reject);});}}var previousPromise;function enqueue(method,arg){function callInvokeWithMethodAndArg(){return new PromiseImpl(function(resolve,reject){invoke(method,arg,resolve,reject);});}return previousPromise=// If enqueue has been called before, then we want to wait until
// all previous Promises have been resolved before calling invoke,
// so that results are always delivered in the correct order. If
// enqueue has not been called before, then it is important to
// call invoke immediately, without waiting on a callback to fire,
// so that the async generator function has the opportunity to do
// any necessary setup in a predictable way. This predictability
// is why the Promise constructor synchronously invokes its
// executor callback, and why async functions synchronously
// execute code before the first await. Since we implement simple
// async functions in terms of async generators, it is especially
// important to get this right, even though it requires care.
previousPromise?previousPromise.then(callInvokeWithMethodAndArg,// Avoid propagating failures to Promises returned by later
// invocations of the iterator.
callInvokeWithMethodAndArg):callInvokeWithMethodAndArg();}// Define the unified helper method that is used to implement .next,
// .throw, and .return (see defineIteratorMethods).
this._invoke=enqueue;}defineIteratorMethods(AsyncIterator.prototype);AsyncIterator.prototype[asyncIteratorSymbol]=function(){return this;};exports.AsyncIterator=AsyncIterator;// Note that simple async functions are implemented on top of
// AsyncIterator objects; they just return a Promise for the value of
// the final result produced by the iterator.
exports.async=function(innerFn,outerFn,self,tryLocsList,PromiseImpl){if(PromiseImpl===void 0)PromiseImpl=Promise;var iter=new AsyncIterator(wrap(innerFn,outerFn,self,tryLocsList),PromiseImpl);return exports.isGeneratorFunction(outerFn)?iter// If outerFn is a generator, return the full iterator.
:iter.next().then(function(result){return result.done?result.value:iter.next();});};function makeInvokeMethod(innerFn,self,context){var state=GenStateSuspendedStart;return function invoke(method,arg){if(state===GenStateExecuting){throw new Error("Generator is already running");}if(state===GenStateCompleted){if(method==="throw"){throw arg;}// Be forgiving, per 25.3.3.3.3 of the spec:
// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
return doneResult();}context.method=method;context.arg=arg;while(true){var delegate=context.delegate;if(delegate){var delegateResult=maybeInvokeDelegate(delegate,context);if(delegateResult){if(delegateResult===ContinueSentinel)continue;return delegateResult;}}if(context.method==="next"){// Setting context._sent for legacy support of Babel's
// function.sent implementation.
context.sent=context._sent=context.arg;}else if(context.method==="throw"){if(state===GenStateSuspendedStart){state=GenStateCompleted;throw context.arg;}context.dispatchException(context.arg);}else if(context.method==="return"){context.abrupt("return",context.arg);}state=GenStateExecuting;var record=tryCatch(innerFn,self,context);if(record.type==="normal"){// If an exception is thrown from innerFn, we leave state ===
// GenStateExecuting and loop back for another invocation.
state=context.done?GenStateCompleted:GenStateSuspendedYield;if(record.arg===ContinueSentinel){continue;}return{value:record.arg,done:context.done};}else if(record.type==="throw"){state=GenStateCompleted;// Dispatch the exception by looping back around to the
// context.dispatchException(context.arg) call above.
context.method="throw";context.arg=record.arg;}}};}// Call delegate.iterator[context.method](context.arg) and handle the
// result, either by returning a { value, done } result from the
// delegate iterator, or by modifying context.method and context.arg,
// setting context.delegate to null, and returning the ContinueSentinel.
function maybeInvokeDelegate(delegate,context){var method=delegate.iterator[context.method];if(method===undefined$1){// A .throw or .return when the delegate iterator has no .throw
// method always terminates the yield* loop.
context.delegate=null;if(context.method==="throw"){// Note: ["return"] must be used for ES3 parsing compatibility.
if(delegate.iterator["return"]){// If the delegate iterator has a return method, give it a
// chance to clean up.
context.method="return";context.arg=undefined$1;maybeInvokeDelegate(delegate,context);if(context.method==="throw"){// If maybeInvokeDelegate(context) changed context.method from
// "return" to "throw", let that override the TypeError below.
return ContinueSentinel;}}context.method="throw";context.arg=new TypeError("The iterator does not provide a 'throw' method");}return ContinueSentinel;}var record=tryCatch(method,delegate.iterator,context.arg);if(record.type==="throw"){context.method="throw";context.arg=record.arg;context.delegate=null;return ContinueSentinel;}var info=record.arg;if(!info){context.method="throw";context.arg=new TypeError("iterator result is not an object");context.delegate=null;return ContinueSentinel;}if(info.done){// Assign the result of the finished delegate to the temporary
// variable specified by delegate.resultName (see delegateYield).
context[delegate.resultName]=info.value;// Resume execution at the desired location (see delegateYield).
context.next=delegate.nextLoc;// If context.method was "throw" but the delegate handled the
// exception, let the outer generator proceed normally. If
// context.method was "next", forget context.arg since it has been
// "consumed" by the delegate iterator. If context.method was
// "return", allow the original .return call to continue in the
// outer generator.
if(context.method!=="return"){context.method="next";context.arg=undefined$1;}}else{// Re-yield the result returned by the delegate method.
return info;}// The delegate iterator is finished, so forget it and continue with
// the outer generator.
context.delegate=null;return ContinueSentinel;}// Define Generator.prototype.{next,throw,return} in terms of the
// unified ._invoke helper method.
defineIteratorMethods(Gp);define(Gp,toStringTagSymbol,"Generator");// A Generator should always return itself as the iterator object when the
// @@iterator function is called on it. Some browsers' implementations of the
// iterator prototype chain incorrectly implement this, causing the Generator
// object to not be returned from this call. This ensures that doesn't happen.
// See https://github.com/facebook/regenerator/issues/274 for more details.
Gp[iteratorSymbol]=function(){return this;};Gp.toString=function(){return"[object Generator]";};function pushTryEntry(locs){var entry={tryLoc:locs[0]};if(1 in locs){entry.catchLoc=locs[1];}if(2 in locs){entry.finallyLoc=locs[2];entry.afterLoc=locs[3];}this.tryEntries.push(entry);}function resetTryEntry(entry){var record=entry.completion||{};record.type="normal";delete record.arg;entry.completion=record;}function Context(tryLocsList){// The root entry object (effectively a try statement without a catch
// or a finally block) gives us a place to store values thrown from
// locations where there is no enclosing try statement.
this.tryEntries=[{tryLoc:"root"}];tryLocsList.forEach(pushTryEntry,this);this.reset(true);}exports.keys=function(object){var keys=[];for(var key in object){keys.push(key);}keys.reverse();// Rather than returning an object with a next method, we keep
// things simple and return the next function itself.
return function next(){while(keys.length){var key=keys.pop();if(key in object){next.value=key;next.done=false;return next;}}// To avoid creating an additional object, we just hang the .value
// and .done properties off the next function object itself. This
// also ensures that the minifier will not anonymize the function.
next.done=true;return next;};};function values(iterable){if(iterable){var iteratorMethod=iterable[iteratorSymbol];if(iteratorMethod){return iteratorMethod.call(iterable);}if(typeof iterable.next==="function"){return iterable;}if(!isNaN(iterable.length)){var i=-1,next=function next(){while(++i<iterable.length){if(hasOwn.call(iterable,i)){next.value=iterable[i];next.done=false;return next;}}next.value=undefined$1;next.done=true;return next;};return next.next=next;}}// Return an iterator with no values.
return{next:doneResult};}exports.values=values;function doneResult(){return{value:undefined$1,done:true};}Context.prototype={constructor:Context,reset:function(skipTempReset){this.prev=0;this.next=0;// Resetting context._sent for legacy support of Babel's
// function.sent implementation.
this.sent=this._sent=undefined$1;this.done=false;this.delegate=null;this.method="next";this.arg=undefined$1;this.tryEntries.forEach(resetTryEntry);if(!skipTempReset){for(var name in this){// Not sure about the optimal order of these conditions:
if(name.charAt(0)==="t"&&hasOwn.call(this,name)&&!isNaN(+name.slice(1))){this[name]=undefined$1;}}}},stop:function(){this.done=true;var rootEntry=this.tryEntries[0];var rootRecord=rootEntry.completion;if(rootRecord.type==="throw"){throw rootRecord.arg;}return this.rval;},dispatchException:function(exception){if(this.done){throw exception;}var context=this;function handle(loc,caught){record.type="throw";record.arg=exception;context.next=loc;if(caught){// If the dispatched exception was caught by a catch block,
// then let that catch block handle the exception normally.
context.method="next";context.arg=undefined$1;}return!!caught;}for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];var record=entry.completion;if(entry.tryLoc==="root"){// Exception thrown outside of any try block that could handle
// it, so set the completion value of the entire function to
// throw the exception.
return handle("end");}if(entry.tryLoc<=this.prev){var hasCatch=hasOwn.call(entry,"catchLoc");var hasFinally=hasOwn.call(entry,"finallyLoc");if(hasCatch&&hasFinally){if(this.prev<entry.catchLoc){return handle(entry.catchLoc,true);}else if(this.prev<entry.finallyLoc){return handle(entry.finallyLoc);}}else if(hasCatch){if(this.prev<entry.catchLoc){return handle(entry.catchLoc,true);}}else if(hasFinally){if(this.prev<entry.finallyLoc){return handle(entry.finallyLoc);}}else{throw new Error("try statement without catch or finally");}}}},abrupt:function(type,arg){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc<=this.prev&&hasOwn.call(entry,"finallyLoc")&&this.prev<entry.finallyLoc){var finallyEntry=entry;break;}}if(finallyEntry&&(type==="break"||type==="continue")&&finallyEntry.tryLoc<=arg&&arg<=finallyEntry.finallyLoc){// Ignore the finally entry if control is not jumping to a
// location outside the try/catch block.
finallyEntry=null;}var record=finallyEntry?finallyEntry.completion:{};record.type=type;record.arg=arg;if(finallyEntry){this.method="next";this.next=finallyEntry.finallyLoc;return ContinueSentinel;}return this.complete(record);},complete:function(record,afterLoc){if(record.type==="throw"){throw record.arg;}if(record.type==="break"||record.type==="continue"){this.next=record.arg;}else if(record.type==="return"){this.rval=this.arg=record.arg;this.method="return";this.next="end";}else if(record.type==="normal"&&afterLoc){this.next=afterLoc;}return ContinueSentinel;},finish:function(finallyLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.finallyLoc===finallyLoc){this.complete(entry.completion,entry.afterLoc);resetTryEntry(entry);return ContinueSentinel;}}},"catch":function(tryLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc===tryLoc){var record=entry.completion;if(record.type==="throw"){var thrown=record.arg;resetTryEntry(entry);}return thrown;}}// The context.catch method must only be called with a location
// argument that corresponds to a known catch block.
throw new Error("illegal catch attempt");},delegateYield:function(iterable,resultName,nextLoc){this.delegate={iterator:values(iterable),resultName:resultName,nextLoc:nextLoc};if(this.method==="next"){// Deliberately forget the last sent value so that we don't
// accidentally pass it on to the delegate.
this.arg=undefined$1;}return ContinueSentinel;}};// Regardless of whether this script is executing as a CommonJS module
// or not, return the runtime object so that we can declare the variable
// regeneratorRuntime in the outer scope, which allows this module to be
// injected easily by `bin/regenerator --include-runtime script.js`.
return exports;}(// If this script is executing as a CommonJS module, use module.exports
// as the regeneratorRuntime namespace. Otherwise create a new empty
// object. Either way, the resulting object will be used to initialize
// the regeneratorRuntime variable at the top of this file.
module.exports);try{regeneratorRuntime=runtime;}catch(accidentalStrictMode){// This module should not be running in strict mode, so the above
// assignment should always work unless something is misconfigured. Just
// in case runtime.js accidentally runs in strict mode, we can escape
// strict mode using a global Function call. This could conceivably fail
// if a Content Security Policy forbids using Function, but in that case
// the proper solution is to fix the accidental strict mode problem. If
// you've misconfigured your bundler to force strict mode and applied a
// CSP to forbid Function, and you're not willing to fix either of those
// problems, please detail your unique predicament in a GitHub issue.
Function("r","regeneratorRuntime = r")(runtime);}});var regenerator=runtime_1;var createMethod=function(IS_RIGHT){return function(that,callbackfn,argumentsLength,memo){aFunction$1(callbackfn);var O=toObject(that);var self=indexedObject(O);var length=toLength(O.length);var index=IS_RIGHT?length-1:0;var i=IS_RIGHT?-1:1;if(argumentsLength<2)while(true){if(index in self){memo=self[index];index+=i;break;}index+=i;if(IS_RIGHT?index<0:length<=index){throw TypeError('Reduce of empty array with no initial value');}}for(;IS_RIGHT?index>=0:length>index;index+=i)if(index in self){memo=callbackfn(memo,self[index],index,O);}return memo;};};var arrayReduce={// `Array.prototype.reduce` method
// https://tc39.es/ecma262/#sec-array.prototype.reduce
left:createMethod(false),// `Array.prototype.reduceRight` method
// https://tc39.es/ecma262/#sec-array.prototype.reduceright
right:createMethod(true)};var engineIsNode=classofRaw(global$1.process)=='process';var $reduce=arrayReduce.left;var STRICT_METHOD$2=arrayMethodIsStrict('reduce');// Chrome 80-82 has a critical bug
// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
var CHROME_BUG=!engineIsNode&&engineV8Version>79&&engineV8Version<83;// `Array.prototype.reduce` method
// https://tc39.es/ecma262/#sec-array.prototype.reduce
_export({target:'Array',proto:true,forced:!STRICT_METHOD$2||CHROME_BUG},{reduce:function reduce(callbackfn/* , initialValue */){return $reduce(this,callbackfn,arguments.length,arguments.length>1?arguments[1]:undefined);}});var reduce$2=entryVirtual('Array').reduce;var ArrayPrototype$6=Array.prototype;var reduce_1=function(it){var own=it.reduce;return it===ArrayPrototype$6||it instanceof Array&&own===ArrayPrototype$6.reduce?reduce$2:own;};var reduce$1=reduce_1;var reduce=reduce$1;// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var flattenIntoArray=function(target,original,source,sourceLen,start,depth,mapper,thisArg){var targetIndex=start;var sourceIndex=0;var mapFn=mapper?functionBindContext(mapper,thisArg,3):false;var element;while(sourceIndex<sourceLen){if(sourceIndex in source){element=mapFn?mapFn(source[sourceIndex],sourceIndex,original):source[sourceIndex];if(depth>0&&isArray$5(element)){targetIndex=flattenIntoArray(target,original,element,toLength(element.length),targetIndex,depth-1)-1;}else{if(targetIndex>=0x1FFFFFFFFFFFFF)throw TypeError('Exceed the acceptable array length');target[targetIndex]=element;}targetIndex++;}sourceIndex++;}return targetIndex;};var flattenIntoArray_1=flattenIntoArray;// https://tc39.es/ecma262/#sec-array.prototype.flatmap
_export({target:'Array',proto:true},{flatMap:function flatMap(callbackfn/* , thisArg */){var O=toObject(this);var sourceLen=toLength(O.length);var A;aFunction$1(callbackfn);A=arraySpeciesCreate(O,0);A.length=flattenIntoArray_1(A,O,O,sourceLen,0,1,callbackfn,arguments.length>1?arguments[1]:undefined);return A;}});var flatMap$2=entryVirtual('Array').flatMap;var ArrayPrototype$5=Array.prototype;var flatMap_1=function(it){var own=it.flatMap;return it===ArrayPrototype$5||it instanceof Array&&own===ArrayPrototype$5.flatMap?flatMap$2:own;};var flatMap$1=flatMap_1;var flatMap=flatMap$1;var iterator$1=iterator$4;var iterator=iterator$1;// https://tc39.es/ecma262/#sec-set-objects
collection('Set',function(init){return function Set(){return init(this,arguments.length?arguments[0]:undefined);};},collectionStrong);var set$2=path.Set;var set$1=set$2;var set=set$1;var getIterator$1=function(it){var iteratorMethod=getIteratorMethod$1(it);if(typeof iteratorMethod!='function'){throw TypeError(String(it)+' is not iterable');}return anObject(iteratorMethod.call(it));};var getIterator_1=getIterator$1;var getIterator=getIterator_1;// TODO: use something more complex like timsort?
var floor=Math.floor;var mergeSort=function(array,comparefn){var length=array.length;var middle=floor(length/2);return length<8?insertionSort(array,comparefn):merge(mergeSort(array.slice(0,middle),comparefn),mergeSort(array.slice(middle),comparefn),comparefn);};var insertionSort=function(array,comparefn){var length=array.length;var i=1;var element,j;while(i<length){j=i;element=array[i];while(j&&comparefn(array[j-1],element)>0){array[j]=array[--j];}if(j!==i++)array[j]=element;}return array;};var merge=function(left,right,comparefn){var llength=left.length;var rlength=right.length;var lindex=0;var rindex=0;var result=[];while(lindex<llength||rindex<rlength){if(lindex<llength&&rindex<rlength){result.push(comparefn(left[lindex],right[rindex])<=0?left[lindex++]:right[rindex++]);}else{result.push(lindex<llength?left[lindex++]:right[rindex++]);}}return result;};var arraySort=mergeSort;var firefox=engineUserAgent.match(/firefox\/(\d+)/i);var engineFfVersion=!!firefox&&+firefox[1];var engineIsIeOrEdge=/MSIE|Trident/.test(engineUserAgent);var webkit=engineUserAgent.match(/AppleWebKit\/(\d+)\./);var engineWebkitVersion=!!webkit&&+webkit[1];var test=[];var nativeSort=test.sort;// IE8-
var FAILS_ON_UNDEFINED=fails(function(){test.sort(undefined);});// V8 bug
var FAILS_ON_NULL=fails(function(){test.sort(null);});// Old WebKit
var STRICT_METHOD$1=arrayMethodIsStrict('sort');var STABLE_SORT=!fails(function(){// feature detection can be too slow, so check engines versions
if(engineV8Version)return engineV8Version<70;if(engineFfVersion&&engineFfVersion>3)return;if(engineIsIeOrEdge)return true;if(engineWebkitVersion)return engineWebkitVersion<603;var result='';var code,chr,value,index;// generate an array with more 512 elements (Chakra and old V8 fails only in this case)
for(code=65;code<76;code++){chr=String.fromCharCode(code);switch(code){case 66:case 69:case 70:case 72:value=3;break;case 68:case 71:value=4;break;default:value=2;}for(index=0;index<47;index++){test.push({k:chr+index,v:value});}}test.sort(function(a,b){return b.v-a.v;});for(index=0;index<test.length;index++){chr=test[index].k.charAt(0);if(result.charAt(result.length-1)!==chr)result+=chr;}return result!=='DGBEFHACIJK';});var FORCED$1=FAILS_ON_UNDEFINED||!FAILS_ON_NULL||!STRICT_METHOD$1||!STABLE_SORT;var getSortCompare=function(comparefn){return function(x,y){if(y===undefined)return-1;if(x===undefined)return 1;if(comparefn!==undefined)return+comparefn(x,y)||0;return String(x)>String(y)?1:-1;};};// `Array.prototype.sort` method
// https://tc39.es/ecma262/#sec-array.prototype.sort
_export({target:'Array',proto:true,forced:FORCED$1},{sort:function sort(comparefn){if(comparefn!==undefined)aFunction$1(comparefn);var array=toObject(this);if(STABLE_SORT)return comparefn===undefined?nativeSort.call(array):nativeSort.call(array,comparefn);var items=[];var arrayLength=toLength(array.length);var itemsLength,index;for(index=0;index<arrayLength;index++){if(index in array)items.push(array[index]);}items=arraySort(items,getSortCompare(comparefn));itemsLength=items.length;index=0;while(index<itemsLength)array[index]=items[index++];while(index<arrayLength)delete array[index++];return array;}});var sort$2=entryVirtual('Array').sort;var ArrayPrototype$4=Array.prototype;var sort_1=function(it){var own=it.sort;return it===ArrayPrototype$4||it instanceof Array&&own===ArrayPrototype$4.sort?sort$2:own;};var sort$1=sort_1;var sort=sort$1;var keys$2=entryVirtual('Array').keys;var keys$1=keys$2;var ArrayPrototype$3=Array.prototype;var DOMIterables$2={DOMTokenList:true,NodeList:true};var keys_1=function(it){var own=it.keys;return it===ArrayPrototype$3||it instanceof Array&&own===ArrayPrototype$3.keys// eslint-disable-next-line no-prototype-builtins -- safe
||DOMIterables$2.hasOwnProperty(classof(it))?keys$1:own;};var keys=keys_1;var values$2=entryVirtual('Array').values;var values$1=values$2;var ArrayPrototype$2=Array.prototype;var DOMIterables$1={DOMTokenList:true,NodeList:true};var values_1=function(it){var own=it.values;return it===ArrayPrototype$2||it instanceof Array&&own===ArrayPrototype$2.values// eslint-disable-next-line no-prototype-builtins -- safe
||DOMIterables$1.hasOwnProperty(classof(it))?values$1:own;};var values=values_1;var entries$2=entryVirtual('Array').entries;var entries$1=entries$2;var ArrayPrototype$1=Array.prototype;var DOMIterables={DOMTokenList:true,NodeList:true};var entries_1=function(it){var own=it.entries;return it===ArrayPrototype$1||it instanceof Array&&own===ArrayPrototype$1.entries// eslint-disable-next-line no-prototype-builtins -- safe
||DOMIterables.hasOwnProperty(classof(it))?entries$1:own;};var entries=entries_1;// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;var rnds8=new Uint8Array(16);function rng(){// lazy load so that environments that need to polyfill have a chance to do so
if(!getRandomValues){// getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
// find the complete implementation of crypto (msCrypto) on IE11.
getRandomValues=typeof crypto!=='undefined'&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto!=='undefined'&&typeof msCrypto.getRandomValues==='function'&&msCrypto.getRandomValues.bind(msCrypto);if(!getRandomValues){throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');}}return getRandomValues(rnds8);}var REGEX=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function validate(uuid){return typeof uuid==='string'&&REGEX.test(uuid);}/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */var byteToHex=[];for(var i=0;i<256;++i){byteToHex.push((i+0x100).toString(16).substr(1));}function stringify(arr){var offset=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;// Note: Be careful editing this code!  It's been tuned for performance
// and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
var uuid=(byteToHex[arr[offset+0]]+byteToHex[arr[offset+1]]+byteToHex[arr[offset+2]]+byteToHex[arr[offset+3]]+'-'+byteToHex[arr[offset+4]]+byteToHex[arr[offset+5]]+'-'+byteToHex[arr[offset+6]]+byteToHex[arr[offset+7]]+'-'+byteToHex[arr[offset+8]]+byteToHex[arr[offset+9]]+'-'+byteToHex[arr[offset+10]]+byteToHex[arr[offset+11]]+byteToHex[arr[offset+12]]+byteToHex[arr[offset+13]]+byteToHex[arr[offset+14]]+byteToHex[arr[offset+15]]).toLowerCase();// Consistency check for valid UUID.  If this throws, it's likely due to one
// of the following:
// - One or more input array values don't map to a hex octet (leading to
// "undefined" in the uuid)
// - Invalid input values for the RFC `version` or `variant` fields
if(!validate(uuid)){throw TypeError('Stringified UUID is invalid');}return uuid;}function v4(options,buf,offset){options=options||{};var rnds=options.random||(options.rng||rng)();// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
rnds[6]=rnds[6]&0x0f|0x40;rnds[8]=rnds[8]&0x3f|0x80;// Copy bytes to buffer, if provided
if(buf){offset=offset||0;for(var i=0;i<16;++i){buf[offset+i]=rnds[i];}return buf;}return stringify(rnds);}function ownKeys$4(object,enumerableOnly){var keys=keys$3(object);if(getOwnPropertySymbols){var symbols=getOwnPropertySymbols(object);if(enumerableOnly){symbols=filter(symbols).call(symbols,function(sym){return getOwnPropertyDescriptor$2(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread$4(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){var _context32;forEach$2(_context32=ownKeys$4(Object(source),true)).call(_context32,function(key){_defineProperty(target,key,source[key]);});}else if(getOwnPropertyDescriptors){defineProperties(target,getOwnPropertyDescriptors(source));}else{var _context33;forEach$2(_context33=ownKeys$4(Object(source))).call(_context33,function(key){defineProperty$4(target,key,getOwnPropertyDescriptor$2(source,key));});}}return target;}function _createSuper$t(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$t();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$t(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}function _createForOfIteratorHelper$7(o,allowArrayLike){var it=typeof symbol!=="undefined"&&getIteratorMethod(o)||o["@@iterator"];if(!it){if(isArray(o)||(it=_unsupportedIterableToArray$7(o))||allowArrayLike&&o&&typeof o.length==="number"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};},e:function e(_e){throw _e;},f:F};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion=true,didErr=false,err;return{s:function s(){it=it.call(o);},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e2){didErr=true;err=_e2;},f:function f(){try{if(!normalCompletion&&it.return!=null)it.return();}finally{if(didErr)throw err;}}};}function _unsupportedIterableToArray$7(o,minLen){var _context31;if(!o)return;if(typeof o==="string")return _arrayLikeToArray$7(o,minLen);var n=slice$1(_context31=Object.prototype.toString.call(o)).call(_context31,8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return from$2(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray$7(o,minLen);}function _arrayLikeToArray$7(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}/**
 * Create new data pipe.
 *
 * @param from - The source data set or data view.
 *
 * @remarks
 * Example usage:
 * ```typescript
 * interface AppItem {
 *   whoami: string;
 *   appData: unknown;
 *   visData: VisItem;
 * }
 * interface VisItem {
 *   id: number;
 *   label: string;
 *   color: string;
 *   x: number;
 *   y: number;
 * }
 *
 * const ds1 = new DataSet<AppItem, "whoami">([], { fieldId: "whoami" });
 * const ds2 = new DataSet<VisItem, "id">();
 *
 * const pipe = createNewDataPipeFrom(ds1)
 *   .filter((item): boolean => item.enabled === true)
 *   .map<VisItem, "id">((item): VisItem => item.visData)
 *   .to(ds2);
 *
 * pipe.start();
 * ```
 *
 * @returns A factory whose methods can be used to configure the pipe.
 */function createNewDataPipeFrom(from){return new DataPipeUnderConstruction(from);}/**
 * Internal implementation of the pipe. This should be accessible only through
 * `createNewDataPipeFrom` from the outside.
 *
 * @typeParam SI - Source item type.
 * @typeParam SP - Source item type's id property name.
 * @typeParam TI - Target item type.
 * @typeParam TP - Target item type's id property name.
 */var SimpleDataPipe=/*#__PURE__*/function(){/**
   * Create a new data pipe.
   *
   * @param _source - The data set or data view that will be observed.
   * @param _transformers - An array of transforming functions to be used to
   * filter or transform the items in the pipe.
   * @param _target - The data set or data view that will receive the items.
   */function SimpleDataPipe(_source,_transformers,_target){var _context,_context2,_context3;_classCallCheck(this,SimpleDataPipe);this._source=_source;this._transformers=_transformers;this._target=_target;/**
     * Bound listeners for use with `DataInterface['on' | 'off']`.
     */this._listeners={add:bind(_context=this._add).call(_context,this),remove:bind(_context2=this._remove).call(_context2,this),update:bind(_context3=this._update).call(_context3,this)};}/** @inheritDoc */_createClass(SimpleDataPipe,[{key:"all",value:function all(){this._target.update(this._transformItems(this._source.get()));return this;}/** @inheritDoc */},{key:"start",value:function start(){this._source.on("add",this._listeners.add);this._source.on("remove",this._listeners.remove);this._source.on("update",this._listeners.update);return this;}/** @inheritDoc */},{key:"stop",value:function stop(){this._source.off("add",this._listeners.add);this._source.off("remove",this._listeners.remove);this._source.off("update",this._listeners.update);return this;}/**
     * Apply the transformers to the items.
     *
     * @param items - The items to be transformed.
     *
     * @returns The transformed items.
     */},{key:"_transformItems",value:function _transformItems(items){var _context4;return reduce(_context4=this._transformers).call(_context4,function(items,transform){return transform(items);},items);}/**
     * Handle an add event.
     *
     * @param _name - Ignored.
     * @param payload - The payload containing the ids of the added items.
     */},{key:"_add",value:function _add(_name,payload){if(payload==null){return;}this._target.add(this._transformItems(this._source.get(payload.items)));}/**
     * Handle an update event.
     *
     * @param _name - Ignored.
     * @param payload - The payload containing the ids of the updated items.
     */},{key:"_update",value:function _update(_name,payload){if(payload==null){return;}this._target.update(this._transformItems(this._source.get(payload.items)));}/**
     * Handle a remove event.
     *
     * @param _name - Ignored.
     * @param payload - The payload containing the data of the removed items.
     */},{key:"_remove",value:function _remove(_name,payload){if(payload==null){return;}this._target.remove(this._transformItems(payload.oldData));}}]);return SimpleDataPipe;}();/**
 * Internal implementation of the pipe factory. This should be accessible
 * only through `createNewDataPipeFrom` from the outside.
 *
 * @typeParam TI - Target item type.
 * @typeParam TP - Target item type's id property name.
 */var DataPipeUnderConstruction=/*#__PURE__*/function(){/**
   * Create a new data pipe factory. This is an internal constructor that
   * should never be called from outside of this file.
   *
   * @param _source - The source data set or data view for this pipe.
   */function DataPipeUnderConstruction(_source){_classCallCheck(this,DataPipeUnderConstruction);this._source=_source;/**
     * Array transformers used to transform items within the pipe. This is typed
     * as any for the sake of simplicity.
     */this._transformers=[];}/**
   * Filter the items.
   *
   * @param callback - A filtering function that returns true if given item
   * should be piped and false if not.
   *
   * @returns This factory for further configuration.
   */_createClass(DataPipeUnderConstruction,[{key:"filter",value:function filter$1(callback){this._transformers.push(function(input){return filter(input).call(input,callback);});return this;}/**
     * Map each source item to a new type.
     *
     * @param callback - A mapping function that takes a source item and returns
     * corresponding mapped item.
     *
     * @typeParam TI - Target item type.
     * @typeParam TP - Target item type's id property name.
     *
     * @returns This factory for further configuration.
     */},{key:"map",value:function map(callback){this._transformers.push(function(input){return map$3(input).call(input,callback);});return this;}/**
     * Map each source item to zero or more items of a new type.
     *
     * @param callback - A mapping function that takes a source item and returns
     * an array of corresponding mapped items.
     *
     * @typeParam TI - Target item type.
     * @typeParam TP - Target item type's id property name.
     *
     * @returns This factory for further configuration.
     */},{key:"flatMap",value:function flatMap$1(callback){this._transformers.push(function(input){return flatMap(input).call(input,callback);});return this;}/**
     * Connect this pipe to given data set.
     *
     * @param target - The data set that will receive the items from this pipe.
     *
     * @returns The pipe connected between given data sets and performing
     * configured transformation on the processed items.
     */},{key:"to",value:function to(target){return new SimpleDataPipe(this._source,this._transformers,target);}}]);return DataPipeUnderConstruction;}();/**
 * Determine whether a value can be used as an id.
 *
 * @param value - Input value of unknown type.
 *
 * @returns True if the value is valid id, false otherwise.
 */function isId(value){return typeof value==="string"||typeof value==="number";}/**
 * A queue.
 *
 * @typeParam T - The type of method names to be replaced by queued versions.
 */var Queue=/*#__PURE__*/function(){/**
   * Construct a new Queue.
   *
   * @param options - Queue configuration.
   */function Queue(options){_classCallCheck(this,Queue);this._queue=[];this._timeout=null;this._extended=null;// options
this.delay=null;this.max=Infinity;this.setOptions(options);}/**
   * Update the configuration of the queue.
   *
   * @param options - Queue configuration.
   */_createClass(Queue,[{key:"setOptions",value:function setOptions(options){if(options&&typeof options.delay!=="undefined"){this.delay=options.delay;}if(options&&typeof options.max!=="undefined"){this.max=options.max;}this._flushIfNeeded();}/**
     * Extend an object with queuing functionality.
     * The object will be extended with a function flush, and the methods provided in options.replace will be replaced with queued ones.
     *
     * @param object - The object to be extended.
     * @param options - Additional options.
     *
     * @returns The created queue.
     */},{key:"destroy",value:/**
     * Destroy the queue. The queue will first flush all queued actions, and in case it has extended an object, will restore the original object.
     */function destroy(){this.flush();if(this._extended){var object=this._extended.object;var methods=this._extended.methods;for(var i=0;i<methods.length;i++){var method=methods[i];if(method.original){// @TODO: better solution?
object[method.name]=method.original;}else{// @TODO: better solution?
delete object[method.name];}}this._extended=null;}}/**
     * Replace a method on an object with a queued version.
     *
     * @param object - Object having the method.
     * @param method - The method name.
     */},{key:"replace",value:function replace(object,method){/* eslint-disable-next-line @typescript-eslint/no-this-alias -- Function this is necessary in the function bellow, so class this has to be saved into a variable here. */var me=this;var original=object[method];if(!original){throw new Error("Method "+method+" undefined");}object[method]=function(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}// add this call to the queue
me.queue({args:args,fn:original,context:this});};}/**
     * Queue a call.
     *
     * @param entry - The function or entry to be queued.
     */},{key:"queue",value:function queue(entry){if(typeof entry==="function"){this._queue.push({fn:entry});}else{this._queue.push(entry);}this._flushIfNeeded();}/**
     * Check whether the queue needs to be flushed.
     */},{key:"_flushIfNeeded",value:function _flushIfNeeded(){var _this=this;// flush when the maximum is exceeded.
if(this._queue.length>this.max){this.flush();}// flush after a period of inactivity when a delay is configured
if(this._timeout!=null){clearTimeout(this._timeout);this._timeout=null;}if(this.queue.length>0&&typeof this.delay==="number"){this._timeout=setTimeout$1(function(){_this.flush();},this.delay);}}/**
     * Flush all queued calls
     */},{key:"flush",value:function flush(){var _context5,_context6;forEach$2(_context5=splice(_context6=this._queue).call(_context6,0)).call(_context5,function(entry){entry.fn.apply(entry.context||entry.fn,entry.args||[]);});}}],[{key:"extend",value:function extend(object,options){var queue=new Queue(options);if(object.flush!==undefined){throw new Error("Target object already has a property flush");}object.flush=function(){queue.flush();};var methods=[{name:"flush",original:undefined}];if(options&&options.replace){for(var i=0;i<options.replace.length;i++){var name=options.replace[i];methods.push({name:name,// @TODO: better solution?
original:object[name]});// @TODO: better solution?
queue.replace(object,name);}}queue._extended={object:object,methods:methods};return queue;}}]);return Queue;}();/**
 * [[DataSet]] code that can be reused in [[DataView]] or other similar implementations of [[DataInterface]].
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 */exports.Queue=Queue;var DataSetPart=/*#__PURE__*/function(){function DataSetPart(){_classCallCheck(this,DataSetPart);this._subscribers={"*":[],add:[],remove:[],update:[]};/**
     * @deprecated Use on instead (PS: DataView.subscribe === DataView.on).
     */this.subscribe=DataSetPart.prototype.on;/**
     * @deprecated Use off instead (PS: DataView.unsubscribe === DataView.off).
     */this.unsubscribe=DataSetPart.prototype.off;}/**
   * Trigger an event
   *
   * @param event - Event name.
   * @param payload - Event payload.
   * @param senderId - Id of the sender.
   */_createClass(DataSetPart,[{key:"_trigger",value:function _trigger(event,payload,senderId){var _context7,_context8;if(event==="*"){throw new Error("Cannot trigger event *");}forEach$2(_context7=concat(_context8=[]).call(_context8,_toConsumableArray(this._subscribers[event]),_toConsumableArray(this._subscribers["*"]))).call(_context7,function(subscriber){subscriber(event,payload,senderId!=null?senderId:null);});}/**
     * Subscribe to an event, add an event listener.
     *
     * @remarks Non-function callbacks are ignored.
     *
     * @param event - Event name.
     * @param callback - Callback method.
     */},{key:"on",value:function on(event,callback){if(typeof callback==="function"){this._subscribers[event].push(callback);}// @TODO: Maybe throw for invalid callbacks?
}/**
     * Unsubscribe from an event, remove an event listener.
     *
     * @remarks If the same callback was subscribed more than once **all** occurences will be removed.
     *
     * @param event - Event name.
     * @param callback - Callback method.
     */},{key:"off",value:function off(event,callback){var _context9;this._subscribers[event]=filter(_context9=this._subscribers[event]).call(_context9,function(subscriber){return subscriber!==callback;});}}]);return DataSetPart;}();/**
 * Data stream
 *
 * @remarks
 * [[DataStream]] offers an always up to date stream of items from a [[DataSet]] or [[DataView]].
 * That means that the stream is evaluated at the time of iteration, conversion to another data type or when [[cache]] is called, not when the [[DataStream]] was created.
 * Multiple invocations of for example [[toItemArray]] may yield different results (if the data source like for example [[DataSet]] gets modified).
 *
 * @typeParam Item - The item type this stream is going to work with.
 */var DataStream=/*#__PURE__*/function(){/**
   * Create a new data stream.
   *
   * @param pairs - The id, item pairs.
   */function DataStream(pairs){_classCallCheck(this,DataStream);this._pairs=pairs;}/**
   * Return an iterable of key, value pairs for every entry in the stream.
   */_createClass(DataStream,[{key:iterator,value:/*#__PURE__*/regenerator.mark(function value(){var _iterator,_step,_step$value,id,item;return regenerator.wrap(function value$(_context10){while(1){switch(_context10.prev=_context10.next){case 0:_iterator=_createForOfIteratorHelper$7(this._pairs);_context10.prev=1;_iterator.s();case 3:if((_step=_iterator.n()).done){_context10.next=9;break;}_step$value=_slicedToArray(_step.value,2),id=_step$value[0],item=_step$value[1];_context10.next=7;return[id,item];case 7:_context10.next=3;break;case 9:_context10.next=14;break;case 11:_context10.prev=11;_context10.t0=_context10["catch"](1);_iterator.e(_context10.t0);case 14:_context10.prev=14;_iterator.f();return _context10.finish(14);case 17:case"end":return _context10.stop();}}},value,this,[[1,11,14,17]]);})/**
     * Return an iterable of key, value pairs for every entry in the stream.
     */},{key:"entries",value:/*#__PURE__*/regenerator.mark(function entries(){var _iterator2,_step2,_step2$value,id,item;return regenerator.wrap(function entries$(_context11){while(1){switch(_context11.prev=_context11.next){case 0:_iterator2=_createForOfIteratorHelper$7(this._pairs);_context11.prev=1;_iterator2.s();case 3:if((_step2=_iterator2.n()).done){_context11.next=9;break;}_step2$value=_slicedToArray(_step2.value,2),id=_step2$value[0],item=_step2$value[1];_context11.next=7;return[id,item];case 7:_context11.next=3;break;case 9:_context11.next=14;break;case 11:_context11.prev=11;_context11.t0=_context11["catch"](1);_iterator2.e(_context11.t0);case 14:_context11.prev=14;_iterator2.f();return _context11.finish(14);case 17:case"end":return _context11.stop();}}},entries,this,[[1,11,14,17]]);})/**
     * Return an iterable of keys in the stream.
     */},{key:"keys",value:/*#__PURE__*/regenerator.mark(function keys(){var _iterator3,_step3,_step3$value,id;return regenerator.wrap(function keys$(_context12){while(1){switch(_context12.prev=_context12.next){case 0:_iterator3=_createForOfIteratorHelper$7(this._pairs);_context12.prev=1;_iterator3.s();case 3:if((_step3=_iterator3.n()).done){_context12.next=9;break;}_step3$value=_slicedToArray(_step3.value,1),id=_step3$value[0];_context12.next=7;return id;case 7:_context12.next=3;break;case 9:_context12.next=14;break;case 11:_context12.prev=11;_context12.t0=_context12["catch"](1);_iterator3.e(_context12.t0);case 14:_context12.prev=14;_iterator3.f();return _context12.finish(14);case 17:case"end":return _context12.stop();}}},keys,this,[[1,11,14,17]]);})/**
     * Return an iterable of values in the stream.
     */},{key:"values",value:/*#__PURE__*/regenerator.mark(function values(){var _iterator4,_step4,_step4$value,item;return regenerator.wrap(function values$(_context13){while(1){switch(_context13.prev=_context13.next){case 0:_iterator4=_createForOfIteratorHelper$7(this._pairs);_context13.prev=1;_iterator4.s();case 3:if((_step4=_iterator4.n()).done){_context13.next=9;break;}_step4$value=_slicedToArray(_step4.value,2),item=_step4$value[1];_context13.next=7;return item;case 7:_context13.next=3;break;case 9:_context13.next=14;break;case 11:_context13.prev=11;_context13.t0=_context13["catch"](1);_iterator4.e(_context13.t0);case 14:_context13.prev=14;_iterator4.f();return _context13.finish(14);case 17:case"end":return _context13.stop();}}},values,this,[[1,11,14,17]]);})/**
     * Return an array containing all the ids in this stream.
     *
     * @remarks
     * The array may contain duplicities.
     *
     * @returns The array with all ids from this stream.
     */},{key:"toIdArray",value:function toIdArray(){var _context14;return map$3(_context14=_toConsumableArray(this._pairs)).call(_context14,function(pair){return pair[0];});}/**
     * Return an array containing all the items in this stream.
     *
     * @remarks
     * The array may contain duplicities.
     *
     * @returns The array with all items from this stream.
     */},{key:"toItemArray",value:function toItemArray(){var _context15;return map$3(_context15=_toConsumableArray(this._pairs)).call(_context15,function(pair){return pair[1];});}/**
     * Return an array containing all the entries in this stream.
     *
     * @remarks
     * The array may contain duplicities.
     *
     * @returns The array with all entries from this stream.
     */},{key:"toEntryArray",value:function toEntryArray(){return _toConsumableArray(this._pairs);}/**
     * Return an object map containing all the items in this stream accessible by ids.
     *
     * @remarks
     * In case of duplicate ids (coerced to string so `7 == '7'`) the last encoutered appears in the returned object.
     *
     * @returns The object map of all id → item pairs from this stream.
     */},{key:"toObjectMap",value:function toObjectMap(){var map=create$2(null);var _iterator5=_createForOfIteratorHelper$7(this._pairs),_step5;try{for(_iterator5.s();!(_step5=_iterator5.n()).done;){var _step5$value=_slicedToArray(_step5.value,2),id=_step5$value[0],item=_step5$value[1];map[id]=item;}}catch(err){_iterator5.e(err);}finally{_iterator5.f();}return map;}/**
     * Return a map containing all the items in this stream accessible by ids.
     *
     * @returns The map of all id → item pairs from this stream.
     */},{key:"toMap",value:function toMap(){return new map(this._pairs);}/**
     * Return a set containing all the (unique) ids in this stream.
     *
     * @returns The set of all ids from this stream.
     */},{key:"toIdSet",value:function toIdSet(){return new set(this.toIdArray());}/**
     * Return a set containing all the (unique) items in this stream.
     *
     * @returns The set of all items from this stream.
     */},{key:"toItemSet",value:function toItemSet(){return new set(this.toItemArray());}/**
     * Cache the items from this stream.
     *
     * @remarks
     * This method allows for items to be fetched immediatelly and used (possibly multiple times) later.
     * It can also be used to optimize performance as [[DataStream]] would otherwise reevaluate everything upon each iteration.
     *
     * ## Example
     * ```javascript
     * const ds = new DataSet([…])
     *
     * const cachedStream = ds.stream()
     *   .filter(…)
     *   .sort(…)
     *   .map(…)
     *   .cached(…) // Data are fetched, processed and cached here.
     *
     * ds.clear()
     * chachedStream // Still has all the items.
     * ```
     *
     * @returns A new [[DataStream]] with cached items (detached from the original [[DataSet]]).
     */},{key:"cache",value:function cache(){return new DataStream(_toConsumableArray(this._pairs));}/**
     * Get the distinct values of given property.
     *
     * @param callback - The function that picks and possibly converts the property.
     *
     * @typeParam T - The type of the distinct value.
     *
     * @returns A set of all distinct properties.
     */},{key:"distinct",value:function distinct(callback){var set$1=new set();var _iterator6=_createForOfIteratorHelper$7(this._pairs),_step6;try{for(_iterator6.s();!(_step6=_iterator6.n()).done;){var _step6$value=_slicedToArray(_step6.value,2),id=_step6$value[0],item=_step6$value[1];set$1.add(callback(item,id));}}catch(err){_iterator6.e(err);}finally{_iterator6.f();}return set$1;}/**
     * Filter the items of the stream.
     *
     * @param callback - The function that decides whether an item will be included.
     *
     * @returns A new data stream with the filtered items.
     */},{key:"filter",value:function filter(callback){var pairs=this._pairs;return new DataStream(_defineProperty({},iterator,/*#__PURE__*/regenerator.mark(function _callee(){var _iterator7,_step7,_step7$value,id,item;return regenerator.wrap(function _callee$(_context16){while(1){switch(_context16.prev=_context16.next){case 0:_iterator7=_createForOfIteratorHelper$7(pairs);_context16.prev=1;_iterator7.s();case 3:if((_step7=_iterator7.n()).done){_context16.next=10;break;}_step7$value=_slicedToArray(_step7.value,2),id=_step7$value[0],item=_step7$value[1];if(!callback(item,id)){_context16.next=8;break;}_context16.next=8;return[id,item];case 8:_context16.next=3;break;case 10:_context16.next=15;break;case 12:_context16.prev=12;_context16.t0=_context16["catch"](1);_iterator7.e(_context16.t0);case 15:_context16.prev=15;_iterator7.f();return _context16.finish(15);case 18:case"end":return _context16.stop();}}},_callee,null,[[1,12,15,18]]);})));}/**
     * Execute a callback for each item of the stream.
     *
     * @param callback - The function that will be invoked for each item.
     */},{key:"forEach",value:function forEach(callback){var _iterator8=_createForOfIteratorHelper$7(this._pairs),_step8;try{for(_iterator8.s();!(_step8=_iterator8.n()).done;){var _step8$value=_slicedToArray(_step8.value,2),id=_step8$value[0],item=_step8$value[1];callback(item,id);}}catch(err){_iterator8.e(err);}finally{_iterator8.f();}}/**
     * Map the items into a different type.
     *
     * @param callback - The function that does the conversion.
     *
     * @typeParam Mapped - The type of the item after mapping.
     *
     * @returns A new data stream with the mapped items.
     */},{key:"map",value:function map(callback){var pairs=this._pairs;return new DataStream(_defineProperty({},iterator,/*#__PURE__*/regenerator.mark(function _callee2(){var _iterator9,_step9,_step9$value,id,item;return regenerator.wrap(function _callee2$(_context17){while(1){switch(_context17.prev=_context17.next){case 0:_iterator9=_createForOfIteratorHelper$7(pairs);_context17.prev=1;_iterator9.s();case 3:if((_step9=_iterator9.n()).done){_context17.next=9;break;}_step9$value=_slicedToArray(_step9.value,2),id=_step9$value[0],item=_step9$value[1];_context17.next=7;return[id,callback(item,id)];case 7:_context17.next=3;break;case 9:_context17.next=14;break;case 11:_context17.prev=11;_context17.t0=_context17["catch"](1);_iterator9.e(_context17.t0);case 14:_context17.prev=14;_iterator9.f();return _context17.finish(14);case 17:case"end":return _context17.stop();}}},_callee2,null,[[1,11,14,17]]);})));}/**
     * Get the item with the maximum value of given property.
     *
     * @param callback - The function that picks and possibly converts the property.
     *
     * @returns The item with the maximum if found otherwise null.
     */},{key:"max",value:function max(callback){var iter=getIterator(this._pairs);var curr=iter.next();if(curr.done){return null;}var maxItem=curr.value[1];var maxValue=callback(curr.value[1],curr.value[0]);while(!(curr=iter.next()).done){var _curr$value=_slicedToArray(curr.value,2),id=_curr$value[0],item=_curr$value[1];var _value=callback(item,id);if(_value>maxValue){maxValue=_value;maxItem=item;}}return maxItem;}/**
     * Get the item with the minimum value of given property.
     *
     * @param callback - The function that picks and possibly converts the property.
     *
     * @returns The item with the minimum if found otherwise null.
     */},{key:"min",value:function min(callback){var iter=getIterator(this._pairs);var curr=iter.next();if(curr.done){return null;}var minItem=curr.value[1];var minValue=callback(curr.value[1],curr.value[0]);while(!(curr=iter.next()).done){var _curr$value2=_slicedToArray(curr.value,2),id=_curr$value2[0],item=_curr$value2[1];var _value2=callback(item,id);if(_value2<minValue){minValue=_value2;minItem=item;}}return minItem;}/**
     * Reduce the items into a single value.
     *
     * @param callback - The function that does the reduction.
     * @param accumulator - The initial value of the accumulator.
     *
     * @typeParam T - The type of the accumulated value.
     *
     * @returns The reduced value.
     */},{key:"reduce",value:function reduce(callback,accumulator){var _iterator10=_createForOfIteratorHelper$7(this._pairs),_step10;try{for(_iterator10.s();!(_step10=_iterator10.n()).done;){var _step10$value=_slicedToArray(_step10.value,2),id=_step10$value[0],item=_step10$value[1];accumulator=callback(accumulator,item,id);}}catch(err){_iterator10.e(err);}finally{_iterator10.f();}return accumulator;}/**
     * Sort the items.
     *
     * @param callback - Item comparator.
     *
     * @returns A new stream with sorted items.
     */},{key:"sort",value:function sort$1(callback){var _this2=this;return new DataStream(_defineProperty({},iterator,function(){var _context18;return getIterator(sort(_context18=_toConsumableArray(_this2._pairs)).call(_context18,function(_ref,_ref2){var _ref3=_slicedToArray(_ref,2),idA=_ref3[0],itemA=_ref3[1];var _ref4=_slicedToArray(_ref2,2),idB=_ref4[0],itemB=_ref4[1];return callback(itemA,itemB,idA,idB);}));}));}}]);return DataStream;}();/**
 * Add an id to given item if it doesn't have one already.
 *
 * @remarks
 * The item will be modified.
 *
 * @param item - The item that will have an id after a call to this function.
 * @param idProp - The key of the id property.
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 *
 * @returns true
 */function ensureFullItem(item,idProp){if(item[idProp]==null){// generate an id
item[idProp]=v4();}return item;}/**
 * # DataSet
 *
 * Vis.js comes with a flexible DataSet, which can be used to hold and
 * manipulate unstructured data and listen for changes in the data. The DataSet
 * is key/value based. Data items can be added, updated and removed from the
 * DataSet, and one can subscribe to changes in the DataSet. The data in the
 * DataSet can be filtered and ordered. Data can be normalized when appending it
 * to the DataSet as well.
 *
 * ## Example
 *
 * The following example shows how to use a DataSet.
 *
 * ```javascript
 * // create a DataSet
 * var options = {};
 * var data = new vis.DataSet(options);
 *
 * // add items
 * // note that the data items can contain different properties and data formats
 * data.add([
 *   {id: 1, text: 'item 1', date: new Date(2013, 6, 20), group: 1, first: true},
 *   {id: 2, text: 'item 2', date: '2013-06-23', group: 2},
 *   {id: 3, text: 'item 3', date: '2013-06-25', group: 2},
 *   {id: 4, text: 'item 4'}
 * ]);
 *
 * // subscribe to any change in the DataSet
 * data.on('*', function (event, properties, senderId) {
 *   console.log('event', event, properties);
 * });
 *
 * // update an existing item
 * data.update({id: 2, group: 1});
 *
 * // remove an item
 * data.remove(4);
 *
 * // get all ids
 * var ids = data.getIds();
 * console.log('ids', ids);
 *
 * // get a specific item
 * var item1 = data.get(1);
 * console.log('item1', item1);
 *
 * // retrieve a filtered subset of the data
 * var items = data.get({
 *   filter: function (item) {
 *     return item.group == 1;
 *   }
 * });
 * console.log('filtered items', items);
 * ```
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 */var DataSet=/*#__PURE__*/function(_DataSetPart){_inherits(DataSet,_DataSetPart);var _super=_createSuper$t(DataSet);/**
   * Construct a new DataSet.
   *
   * @param data - Initial data or options.
   * @param options - Options (type error if data is also options).
   */function DataSet(data,options){var _this3;_classCallCheck(this,DataSet);_this3=_super.call(this);_this3._queue=null;// correctly read optional arguments
if(data&&!isArray(data)){options=data;data=[];}_this3._options=options||{};_this3._data=new map();// map with data indexed by id
_this3.length=0;// number of items in the DataSet
_this3._idProp=_this3._options.fieldId||"id";// name of the field containing id
// add initial data when provided
if(data&&data.length){_this3.add(data);}_this3.setOptions(options);return _this3;}/** @inheritDoc */_createClass(DataSet,[{key:"idProp",get:function get(){return this._idProp;}/**
     * Set new options.
     *
     * @param options - The new options.
     */},{key:"setOptions",value:function setOptions(options){if(options&&options.queue!==undefined){if(options.queue===false){// delete queue if loaded
if(this._queue){this._queue.destroy();this._queue=null;}}else{// create queue and update its options
if(!this._queue){this._queue=Queue.extend(this,{replace:["add","update","remove"]});}if(options.queue&&_typeof(options.queue)==="object"){this._queue.setOptions(options.queue);}}}}/**
     * Add a data item or an array with items.
     *
     * After the items are added to the DataSet, the DataSet will trigger an event `add`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     *
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet()
     *
     * // add items
     * const ids = data.add([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { text: 'item without an id' }
     * ])
     *
     * console.log(ids) // [1, 2, '<UUIDv4>']
     * ```
     *
     * @param data - Items to be added (ids will be generated if missing).
     * @param senderId - Sender id.
     *
     * @returns addedIds - Array with the ids (generated if not present) of the added items.
     *
     * @throws When an item with the same id as any of the added items already exists.
     */},{key:"add",value:function add(data,senderId){var _this4=this;var addedIds=[];var id;if(isArray(data)){// Array
var idsToAdd=map$3(data).call(data,function(d){return d[_this4._idProp];});if(some(idsToAdd).call(idsToAdd,function(id){return _this4._data.has(id);})){throw new Error("A duplicate id was found in the parameter array.");}for(var i=0,len=data.length;i<len;i++){id=this._addItem(data[i]);addedIds.push(id);}}else if(data&&_typeof(data)==="object"){// Single item
id=this._addItem(data);addedIds.push(id);}else{throw new Error("Unknown dataType");}if(addedIds.length){this._trigger("add",{items:addedIds},senderId);}return addedIds;}/**
     * Update existing items. When an item does not exist, it will be created.
     *
     * @remarks
     * The provided properties will be merged in the existing item. When an item does not exist, it will be created.
     *
     * After the items are updated, the DataSet will trigger an event `add` for the added items, and an event `update`. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     *
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { id: 3, text: 'item 3' }
     * ])
     *
     * // update items
     * const ids = data.update([
     *   { id: 2, text: 'item 2 (updated)' },
     *   { id: 4, text: 'item 4 (new)' }
     * ])
     *
     * console.log(ids) // [2, 4]
     * ```
     *
     * ## Warning for TypeScript users
     * This method may introduce partial items into the data set. Use add or updateOnly instead for better type safety.
     *
     * @param data - Items to be updated (if the id is already present) or added (if the id is missing).
     * @param senderId - Sender id.
     *
     * @returns updatedIds - The ids of the added (these may be newly generated if there was no id in the item from the data) or updated items.
     *
     * @throws When the supplied data is neither an item nor an array of items.
     */},{key:"update",value:function update(data,senderId){var _this5=this;var addedIds=[];var updatedIds=[];var oldData=[];var updatedData=[];var idProp=this._idProp;var addOrUpdate=function addOrUpdate(item){var origId=item[idProp];if(origId!=null&&_this5._data.has(origId)){var fullItem=item;// it has an id, therefore it is a fullitem
var oldItem=assign$2({},_this5._data.get(origId));// update item
var id=_this5._updateItem(fullItem);updatedIds.push(id);updatedData.push(fullItem);oldData.push(oldItem);}else{// add new item
var _id=_this5._addItem(item);addedIds.push(_id);}};if(isArray(data)){// Array
for(var i=0,len=data.length;i<len;i++){if(data[i]&&_typeof(data[i])==="object"){addOrUpdate(data[i]);}else{console.warn("Ignoring input item, which is not an object at index "+i);}}}else if(data&&_typeof(data)==="object"){// Single item
addOrUpdate(data);}else{throw new Error("Unknown dataType");}if(addedIds.length){this._trigger("add",{items:addedIds},senderId);}if(updatedIds.length){var props={items:updatedIds,oldData:oldData,data:updatedData};// TODO: remove deprecated property 'data' some day
//Object.defineProperty(props, 'data', {
//  'get': (function() {
//    console.warn('Property data is deprecated. Use DataSet.get(ids) to retrieve the new data, use the oldData property on this object to get the old data');
//    return updatedData;
//  }).bind(this)
//});
this._trigger("update",props,senderId);}return concat(addedIds).call(addedIds,updatedIds);}/**
     * Update existing items. When an item does not exist, an error will be thrown.
     *
     * @remarks
     * The provided properties will be deeply merged into the existing item.
     * When an item does not exist (id not present in the data set or absent), an error will be thrown and nothing will be changed.
     *
     * After the items are updated, the DataSet will trigger an event `update`.
     * When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     *
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { id: 3, text: 'item 3' },
     * ])
     *
     * // update items
     * const ids = data.update([
     *   { id: 2, text: 'item 2 (updated)' }, // works
     *   // { id: 4, text: 'item 4 (new)' }, // would throw
     *   // { text: 'item 4 (new)' }, // would also throw
     * ])
     *
     * console.log(ids) // [2]
     * ```
     *
     * @param data - Updates (the id and optionally other props) to the items in this data set.
     * @param senderId - Sender id.
     *
     * @returns updatedIds - The ids of the updated items.
     *
     * @throws When the supplied data is neither an item nor an array of items, when the ids are missing.
     */},{key:"updateOnly",value:function updateOnly(data,senderId){var _context19,_this6=this;if(!isArray(data)){data=[data];}var updateEventData=map$3(_context19=map$3(data).call(data,function(update){var oldData=_this6._data.get(update[_this6._idProp]);if(oldData==null){throw new Error("Updating non-existent items is not allowed.");}return{oldData:oldData,update:update};})).call(_context19,function(_ref5){var oldData=_ref5.oldData,update=_ref5.update;var id=oldData[_this6._idProp];var updatedData=pureDeepObjectAssign(oldData,update);_this6._data.set(id,updatedData);return{id:id,oldData:oldData,updatedData:updatedData};});if(updateEventData.length){var props={items:map$3(updateEventData).call(updateEventData,function(value){return value.id;}),oldData:map$3(updateEventData).call(updateEventData,function(value){return value.oldData;}),data:map$3(updateEventData).call(updateEventData,function(value){return value.updatedData;})};// TODO: remove deprecated property 'data' some day
//Object.defineProperty(props, 'data', {
//  'get': (function() {
//    console.warn('Property data is deprecated. Use DataSet.get(ids) to retrieve the new data, use the oldData property on this object to get the old data');
//    return updatedData;
//  }).bind(this)
//});
this._trigger("update",props,senderId);return props.items;}else{return[];}}/** @inheritDoc */},{key:"get",value:function get(first,second){// @TODO: Woudn't it be better to split this into multiple methods?
// parse the arguments
var id=undefined;var ids=undefined;var options=undefined;if(isId(first)){// get(id [, options])
id=first;options=second;}else if(isArray(first)){// get(ids [, options])
ids=first;options=second;}else{// get([, options])
options=first;}// determine the return type
var returnType=options&&options.returnType==="Object"?"Object":"Array";// @TODO: WTF is this? Or am I missing something?
// var returnType
// if (options && options.returnType) {
//   var allowedValues = ['Array', 'Object']
//   returnType =
//     allowedValues.indexOf(options.returnType) == -1
//       ? 'Array'
//       : options.returnType
// } else {
//   returnType = 'Array'
// }
// build options
var filter$1=options&&filter(options);var items=[];var item=undefined;var itemIds=undefined;var itemId=undefined;// convert items
if(id!=null){// return a single item
item=this._data.get(id);if(item&&filter$1&&!filter$1(item)){item=undefined;}}else if(ids!=null){// return a subset of items
for(var i=0,len=ids.length;i<len;i++){item=this._data.get(ids[i]);if(item!=null&&(!filter$1||filter$1(item))){items.push(item);}}}else{var _context20;// return all items
itemIds=_toConsumableArray(keys(_context20=this._data).call(_context20));for(var _i=0,_len2=itemIds.length;_i<_len2;_i++){itemId=itemIds[_i];item=this._data.get(itemId);if(item!=null&&(!filter$1||filter$1(item))){items.push(item);}}}// order the results
if(options&&options.order&&id==undefined){this._sort(items,options.order);}// filter fields of the items
if(options&&options.fields){var fields=options.fields;if(id!=undefined&&item!=null){item=this._filterFields(item,fields);}else{for(var _i2=0,_len3=items.length;_i2<_len3;_i2++){items[_i2]=this._filterFields(items[_i2],fields);}}}// return the results
if(returnType=="Object"){var result={};for(var _i3=0,_len4=items.length;_i3<_len4;_i3++){var resultant=items[_i3];// @TODO: Shoudn't this be this._fieldId?
// result[resultant.id] = resultant
var _id2=resultant[this._idProp];result[_id2]=resultant;}return result;}else{if(id!=null){var _item;// a single item
return(_item=item)!==null&&_item!==void 0?_item:null;}else{// just return our array
return items;}}}/** @inheritDoc */},{key:"getIds",value:function getIds(options){var data=this._data;var filter$1=options&&filter(options);var order=options&&options.order;var itemIds=_toConsumableArray(keys(data).call(data));var ids=[];if(filter$1){// get filtered items
if(order){// create ordered list
var items=[];for(var i=0,len=itemIds.length;i<len;i++){var id=itemIds[i];var item=this._data.get(id);if(item!=null&&filter$1(item)){items.push(item);}}this._sort(items,order);for(var _i4=0,_len5=items.length;_i4<_len5;_i4++){ids.push(items[_i4][this._idProp]);}}else{// create unordered list
for(var _i5=0,_len6=itemIds.length;_i5<_len6;_i5++){var _id3=itemIds[_i5];var _item2=this._data.get(_id3);if(_item2!=null&&filter$1(_item2)){ids.push(_item2[this._idProp]);}}}}else{// get all items
if(order){// create an ordered list
var _items=[];for(var _i6=0,_len7=itemIds.length;_i6<_len7;_i6++){var _id4=itemIds[_i6];_items.push(data.get(_id4));}this._sort(_items,order);for(var _i7=0,_len8=_items.length;_i7<_len8;_i7++){ids.push(_items[_i7][this._idProp]);}}else{// create unordered list
for(var _i8=0,_len9=itemIds.length;_i8<_len9;_i8++){var _id5=itemIds[_i8];var _item3=data.get(_id5);if(_item3!=null){ids.push(_item3[this._idProp]);}}}}return ids;}/** @inheritDoc */},{key:"getDataSet",value:function getDataSet(){return this;}/** @inheritDoc */},{key:"forEach",value:function forEach(callback,options){var filter$1=options&&filter(options);var data=this._data;var itemIds=_toConsumableArray(keys(data).call(data));if(options&&options.order){// execute forEach on ordered list
var items=this.get(options);for(var i=0,len=items.length;i<len;i++){var item=items[i];var id=item[this._idProp];callback(item,id);}}else{// unordered
for(var _i9=0,_len10=itemIds.length;_i9<_len10;_i9++){var _id6=itemIds[_i9];var _item4=this._data.get(_id6);if(_item4!=null&&(!filter$1||filter$1(_item4))){callback(_item4,_id6);}}}}/** @inheritDoc */},{key:"map",value:function map(callback,options){var filter$1=options&&filter(options);var mappedItems=[];var data=this._data;var itemIds=_toConsumableArray(keys(data).call(data));// convert and filter items
for(var i=0,len=itemIds.length;i<len;i++){var id=itemIds[i];var item=this._data.get(id);if(item!=null&&(!filter$1||filter$1(item))){mappedItems.push(callback(item,id));}}// order items
if(options&&options.order){this._sort(mappedItems,options.order);}return mappedItems;}/**
     * Filter the fields of an item.
     *
     * @param item - The item whose fields should be filtered.
     * @param fields - The names of the fields that will be kept.
     *
     * @typeParam K - Field name type.
     *
     * @returns The item without any additional fields.
     */},{key:"_filterFields",value:function _filterFields(item,fields){var _context21;if(!item){// item is null
return item;}return reduce(_context21=isArray(fields)?// Use the supplied array
fields:// Use the keys of the supplied object
keys$3(fields)).call(_context21,function(filteredItem,field){filteredItem[field]=item[field];return filteredItem;},{});}/**
     * Sort the provided array with items.
     *
     * @param items - Items to be sorted in place.
     * @param order - A field name or custom sort function.
     *
     * @typeParam T - The type of the items in the items array.
     */},{key:"_sort",value:function _sort(items,order){if(typeof order==="string"){// order by provided field name
var name=order;// field name
sort(items).call(items,function(a,b){// @TODO: How to treat missing properties?
var av=a[name];var bv=b[name];return av>bv?1:av<bv?-1:0;});}else if(typeof order==="function"){// order by sort function
sort(items).call(items,order);}else{// TODO: extend order by an Object {field:string, direction:string}
//       where direction can be 'asc' or 'desc'
throw new TypeError("Order must be a function or a string");}}/**
     * Remove an item or multiple items by “reference” (only the id is used) or by id.
     *
     * The method ignores removal of non-existing items, and returns an array containing the ids of the items which are actually removed from the DataSet.
     *
     * After the items are removed, the DataSet will trigger an event `remove` for the removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * ## Example
     * ```javascript
     * // create a DataSet
     * const data = new vis.DataSet([
     *   { id: 1, text: 'item 1' },
     *   { id: 2, text: 'item 2' },
     *   { id: 3, text: 'item 3' }
     * ])
     *
     * // remove items
     * const ids = data.remove([2, { id: 3 }, 4])
     *
     * console.log(ids) // [2, 3]
     * ```
     *
     * @param id - One or more items or ids of items to be removed.
     * @param senderId - Sender id.
     *
     * @returns The ids of the removed items.
     */},{key:"remove",value:function remove(id,senderId){var removedIds=[];var removedItems=[];// force everything to be an array for simplicity
var ids=isArray(id)?id:[id];for(var i=0,len=ids.length;i<len;i++){var item=this._remove(ids[i]);if(item){var itemId=item[this._idProp];if(itemId!=null){removedIds.push(itemId);removedItems.push(item);}}}if(removedIds.length){this._trigger("remove",{items:removedIds,oldData:removedItems},senderId);}return removedIds;}/**
     * Remove an item by its id or reference.
     *
     * @param id - Id of an item or the item itself.
     *
     * @returns The removed item if removed, null otherwise.
     */},{key:"_remove",value:function _remove(id){// @TODO: It origianlly returned the item although the docs say id.
// The code expects the item, so probably an error in the docs.
var ident;// confirm the id to use based on the args type
if(isId(id)){ident=id;}else if(id&&_typeof(id)==="object"){ident=id[this._idProp];// look for the identifier field using ._idProp
}// do the removing if the item is found
if(ident!=null&&this._data.has(ident)){var item=this._data.get(ident)||null;this._data.delete(ident);--this.length;return item;}return null;}/**
     * Clear the entire data set.
     *
     * After the items are removed, the [[DataSet]] will trigger an event `remove` for all removed items. When a `senderId` is provided, this id will be passed with the triggered event to all subscribers.
     *
     * @param senderId - Sender id.
     *
     * @returns removedIds - The ids of all removed items.
     */},{key:"clear",value:function clear(senderId){var _context22;var ids=_toConsumableArray(keys(_context22=this._data).call(_context22));var items=[];for(var i=0,len=ids.length;i<len;i++){items.push(this._data.get(ids[i]));}this._data.clear();this.length=0;this._trigger("remove",{items:ids,oldData:items},senderId);return ids;}/**
     * Find the item with maximum value of a specified field.
     *
     * @param field - Name of the property that should be searched for max value.
     *
     * @returns Item containing max value, or null if no items.
     */},{key:"max",value:function max(field){var _context23;var max=null;var maxField=null;var _iterator11=_createForOfIteratorHelper$7(values(_context23=this._data).call(_context23)),_step11;try{for(_iterator11.s();!(_step11=_iterator11.n()).done;){var item=_step11.value;var itemField=item[field];if(typeof itemField==="number"&&(maxField==null||itemField>maxField)){max=item;maxField=itemField;}}}catch(err){_iterator11.e(err);}finally{_iterator11.f();}return max||null;}/**
     * Find the item with minimum value of a specified field.
     *
     * @param field - Name of the property that should be searched for min value.
     *
     * @returns Item containing min value, or null if no items.
     */},{key:"min",value:function min(field){var _context24;var min=null;var minField=null;var _iterator12=_createForOfIteratorHelper$7(values(_context24=this._data).call(_context24)),_step12;try{for(_iterator12.s();!(_step12=_iterator12.n()).done;){var item=_step12.value;var itemField=item[field];if(typeof itemField==="number"&&(minField==null||itemField<minField)){min=item;minField=itemField;}}}catch(err){_iterator12.e(err);}finally{_iterator12.f();}return min||null;}/**
     * Find all distinct values of a specified field
     *
     * @param prop - The property name whose distinct values should be returned.
     *
     * @returns Unordered array containing all distinct values. Items without specified property are ignored.
     */},{key:"distinct",value:function distinct(prop){var data=this._data;var itemIds=_toConsumableArray(keys(data).call(data));var values=[];var count=0;for(var i=0,len=itemIds.length;i<len;i++){var id=itemIds[i];var item=data.get(id);var _value3=item[prop];var exists=false;for(var j=0;j<count;j++){if(values[j]==_value3){exists=true;break;}}if(!exists&&_value3!==undefined){values[count]=_value3;count++;}}return values;}/**
     * Add a single item. Will fail when an item with the same id already exists.
     *
     * @param item - A new item to be added.
     *
     * @returns Added item's id. An id is generated when it is not present in the item.
     */},{key:"_addItem",value:function _addItem(item){var fullItem=ensureFullItem(item,this._idProp);var id=fullItem[this._idProp];// check whether this id is already taken
if(this._data.has(id)){// item already exists
throw new Error("Cannot add item: item with id "+id+" already exists");}this._data.set(id,fullItem);++this.length;return id;}/**
     * Update a single item: merge with existing item.
     * Will fail when the item has no id, or when there does not exist an item with the same id.
     *
     * @param update - The new item
     *
     * @returns The id of the updated item.
     */},{key:"_updateItem",value:function _updateItem(update){var id=update[this._idProp];if(id==null){throw new Error("Cannot update item: item has no id (item: "+stringify$1(update)+")");}var item=this._data.get(id);if(!item){// item doesn't exist
throw new Error("Cannot update item: no item with id "+id+" found");}this._data.set(id,_objectSpread$4(_objectSpread$4({},item),update));return id;}/** @inheritDoc */},{key:"stream",value:function stream(ids){if(ids){var data=this._data;return new DataStream(_defineProperty({},iterator,/*#__PURE__*/regenerator.mark(function _callee3(){var _iterator13,_step13,id,item;return regenerator.wrap(function _callee3$(_context25){while(1){switch(_context25.prev=_context25.next){case 0:_iterator13=_createForOfIteratorHelper$7(ids);_context25.prev=1;_iterator13.s();case 3:if((_step13=_iterator13.n()).done){_context25.next=11;break;}id=_step13.value;item=data.get(id);if(!(item!=null)){_context25.next=9;break;}_context25.next=9;return[id,item];case 9:_context25.next=3;break;case 11:_context25.next=16;break;case 13:_context25.prev=13;_context25.t0=_context25["catch"](1);_iterator13.e(_context25.t0);case 16:_context25.prev=16;_iterator13.f();return _context25.finish(16);case 19:case"end":return _context25.stop();}}},_callee3,null,[[1,13,16,19]]);})));}else{var _context26;return new DataStream(_defineProperty({},iterator,bind(_context26=entries(this._data)).call(_context26,this._data)));}}}]);return DataSet;}(DataSetPart);/**
 * DataView
 *
 * A DataView offers a filtered and/or formatted view on a DataSet. One can subscribe to changes in a DataView, and easily get filtered or formatted data without having to specify filters and field types all the time.
 *
 * ## Example
 * ```javascript
 * // create a DataSet
 * var data = new vis.DataSet();
 * data.add([
 *   {id: 1, text: 'item 1', date: new Date(2013, 6, 20), group: 1, first: true},
 *   {id: 2, text: 'item 2', date: '2013-06-23', group: 2},
 *   {id: 3, text: 'item 3', date: '2013-06-25', group: 2},
 *   {id: 4, text: 'item 4'}
 * ]);
 *
 * // create a DataView
 * // the view will only contain items having a property group with value 1,
 * // and will only output fields id, text, and date.
 * var view = new vis.DataView(data, {
 *   filter: function (item) {
 *     return (item.group == 1);
 *   },
 *   fields: ['id', 'text', 'date']
 * });
 *
 * // subscribe to any change in the DataView
 * view.on('*', function (event, properties, senderId) {
 *   console.log('event', event, properties);
 * });
 *
 * // update an item in the data set
 * data.update({id: 2, group: 1});
 *
 * // get all ids in the view
 * var ids = view.getIds();
 * console.log('ids', ids); // will output [1, 2]
 *
 * // get all items in the view
 * var items = view.get();
 * ```
 *
 * @typeParam Item - Item type that may or may not have an id.
 * @typeParam IdProp - Name of the property that contains the id.
 */exports.DataSet=DataSet;var DataView=/*#__PURE__*/function(_DataSetPart2){_inherits(DataView,_DataSetPart2);var _super2=_createSuper$t(DataView);/**
   * Create a DataView.
   *
   * @param data - The instance containing data (directly or indirectly).
   * @param options - Options to configure this data view.
   */function DataView(data,options){var _context27;var _this7;_classCallCheck(this,DataView);_this7=_super2.call(this);/** @inheritDoc */_this7.length=0;_this7._ids=new set();// ids of the items currently in memory (just contains a boolean true)
_this7._options=options||{};_this7._listener=bind(_context27=_this7._onEvent).call(_context27,_assertThisInitialized(_this7));_this7.setData(data);return _this7;}/** @inheritDoc */_createClass(DataView,[{key:"idProp",get:function get(){return this.getDataSet().idProp;}// TODO: implement a function .config() to dynamically update things like configured filter
// and trigger changes accordingly
/**
     * Set a data source for the view.
     *
     * @param data - The instance containing data (directly or indirectly).
     *
     * @remarks
     * Note that when the data view is bound to a data set it won't be garbage
     * collected unless the data set is too. Use `dataView.setData(null)` or
     * `dataView.dispose()` to enable garbage collection before you lose the last
     * reference.
     */},{key:"setData",value:function setData(data){if(this._data){// unsubscribe from current dataset
if(this._data.off){this._data.off("*",this._listener);}// trigger a remove of all items in memory
var ids=this._data.getIds({filter:filter(this._options)});var items=this._data.get(ids);this._ids.clear();this.length=0;this._trigger("remove",{items:ids,oldData:items});}if(data!=null){this._data=data;// trigger an add of all added items
var _ids=this._data.getIds({filter:filter(this._options)});for(var i=0,len=_ids.length;i<len;i++){var id=_ids[i];this._ids.add(id);}this.length=_ids.length;this._trigger("add",{items:_ids});}else{this._data=new DataSet();}// subscribe to new dataset
if(this._data.on){this._data.on("*",this._listener);}}/**
     * Refresh the DataView.
     * Useful when the DataView has a filter function containing a variable parameter.
     */},{key:"refresh",value:function refresh(){var ids=this._data.getIds({filter:filter(this._options)});var oldIds=_toConsumableArray(this._ids);var newIds={};var addedIds=[];var removedIds=[];var removedItems=[];// check for additions
for(var i=0,len=ids.length;i<len;i++){var id=ids[i];newIds[id]=true;if(!this._ids.has(id)){addedIds.push(id);this._ids.add(id);}}// check for removals
for(var _i10=0,_len11=oldIds.length;_i10<_len11;_i10++){var _id7=oldIds[_i10];var item=this._data.get(_id7);if(item==null){// @TODO: Investigate.
// Doesn't happen during tests or examples.
// Is it really impossible or could it eventually happen?
// How to handle it if it does? The types guarantee non-nullable items.
console.error("If you see this, report it please.");}else if(!newIds[_id7]){removedIds.push(_id7);removedItems.push(item);this._ids.delete(_id7);}}this.length+=addedIds.length-removedIds.length;// trigger events
if(addedIds.length){this._trigger("add",{items:addedIds});}if(removedIds.length){this._trigger("remove",{items:removedIds,oldData:removedItems});}}/** @inheritDoc */},{key:"get",value:function get(first,second){if(this._data==null){return null;}// parse the arguments
var ids=null;var options;if(isId(first)||isArray(first)){ids=first;options=second;}else{options=first;}// extend the options with the default options and provided options
var viewOptions=assign$2({},this._options,options);// create a combined filter method when needed
var thisFilter=filter(this._options);var optionsFilter=options&&filter(options);if(thisFilter&&optionsFilter){viewOptions.filter=function(item){return thisFilter(item)&&optionsFilter(item);};}if(ids==null){return this._data.get(viewOptions);}else{return this._data.get(ids,viewOptions);}}/** @inheritDoc */},{key:"getIds",value:function getIds(options){if(this._data.length){var defaultFilter=filter(this._options);var optionsFilter=options!=null?filter(options):null;var filter$1;if(optionsFilter){if(defaultFilter){filter$1=function filter(item){return defaultFilter(item)&&optionsFilter(item);};}else{filter$1=optionsFilter;}}else{filter$1=defaultFilter;}return this._data.getIds({filter:filter$1,order:options&&options.order});}else{return[];}}/** @inheritDoc */},{key:"forEach",value:function forEach(callback,options){if(this._data){var _context28;var defaultFilter=filter(this._options);var optionsFilter=options&&filter(options);var filter$1;if(optionsFilter){if(defaultFilter){filter$1=function filter(item){return defaultFilter(item)&&optionsFilter(item);};}else{filter$1=optionsFilter;}}else{filter$1=defaultFilter;}forEach$2(_context28=this._data).call(_context28,callback,{filter:filter$1,order:options&&options.order});}}/** @inheritDoc */},{key:"map",value:function map(callback,options){if(this._data){var _context29;var defaultFilter=filter(this._options);var optionsFilter=options&&filter(options);var filter$1;if(optionsFilter){if(defaultFilter){filter$1=function filter(item){return defaultFilter(item)&&optionsFilter(item);};}else{filter$1=optionsFilter;}}else{filter$1=defaultFilter;}return map$3(_context29=this._data).call(_context29,callback,{filter:filter$1,order:options&&options.order});}else{return[];}}/** @inheritDoc */},{key:"getDataSet",value:function getDataSet(){return this._data.getDataSet();}/** @inheritDoc */},{key:"stream",value:function stream(ids){var _context30;return this._data.stream(ids||_defineProperty({},iterator,bind(_context30=keys(this._ids)).call(_context30,this._ids)));}/**
     * Render the instance unusable prior to garbage collection.
     *
     * @remarks
     * The intention of this method is to help discover scenarios where the data
     * view is being used when the programmer thinks it has been garbage collected
     * already. It's stricter version of `dataView.setData(null)`.
     */},{key:"dispose",value:function dispose(){var _this$_data;if((_this$_data=this._data)!==null&&_this$_data!==void 0&&_this$_data.off){this._data.off("*",this._listener);}var message="This data view has already been disposed of.";var replacement={get:function get(){throw new Error(message);},set:function set(){throw new Error(message);},configurable:false};var _iterator14=_createForOfIteratorHelper$7(ownKeys$5(DataView.prototype)),_step14;try{for(_iterator14.s();!(_step14=_iterator14.n()).done;){var key=_step14.value;defineProperty$4(this,key,replacement);}}catch(err){_iterator14.e(err);}finally{_iterator14.f();}}/**
     * Event listener. Will propagate all events from the connected data set to the subscribers of the DataView, but will filter the items and only trigger when there are changes in the filtered data set.
     *
     * @param event - The name of the event.
     * @param params - Parameters of the event.
     * @param senderId - Id supplied by the sender.
     */},{key:"_onEvent",value:function _onEvent(event,params,senderId){if(!params||!params.items||!this._data){return;}var ids=params.items;var addedIds=[];var updatedIds=[];var removedIds=[];var oldItems=[];var updatedItems=[];var removedItems=[];switch(event){case"add":// filter the ids of the added items
for(var i=0,len=ids.length;i<len;i++){var id=ids[i];var item=this.get(id);if(item){this._ids.add(id);addedIds.push(id);}}break;case"update":// determine the event from the views viewpoint: an updated
// item can be added, updated, or removed from this view.
for(var _i11=0,_len12=ids.length;_i11<_len12;_i11++){var _id8=ids[_i11];var _item5=this.get(_id8);if(_item5){if(this._ids.has(_id8)){updatedIds.push(_id8);updatedItems.push(params.data[_i11]);oldItems.push(params.oldData[_i11]);}else{this._ids.add(_id8);addedIds.push(_id8);}}else{if(this._ids.has(_id8)){this._ids.delete(_id8);removedIds.push(_id8);removedItems.push(params.oldData[_i11]);}}}break;case"remove":// filter the ids of the removed items
for(var _i12=0,_len13=ids.length;_i12<_len13;_i12++){var _id9=ids[_i12];if(this._ids.has(_id9)){this._ids.delete(_id9);removedIds.push(_id9);removedItems.push(params.oldData[_i12]);}}break;}this.length+=addedIds.length-removedIds.length;if(addedIds.length){this._trigger("add",{items:addedIds},senderId);}if(updatedIds.length){this._trigger("update",{items:updatedIds,oldData:oldItems,data:updatedItems},senderId);}if(removedIds.length){this._trigger("remove",{items:removedIds,oldData:removedItems},senderId);}}}]);return DataView;}(DataSetPart);/**
 * Check that given value is compatible with Vis Data Set interface.
 *
 * @param idProp - The expected property to contain item id.
 * @param v - The value to be tested.
 *
 * @returns True if all expected values and methods match, false otherwise.
 */exports.DataView=DataView;function isDataSetLike(idProp,v){return _typeof(v)==="object"&&v!==null&&idProp===v.idProp&&typeof v.add==="function"&&typeof v.clear==="function"&&typeof v.distinct==="function"&&typeof forEach$2(v)==="function"&&typeof v.get==="function"&&typeof v.getDataSet==="function"&&typeof v.getIds==="function"&&typeof v.length==="number"&&typeof map$3(v)==="function"&&typeof v.max==="function"&&typeof v.min==="function"&&typeof v.off==="function"&&typeof v.on==="function"&&typeof v.remove==="function"&&typeof v.setOptions==="function"&&typeof v.stream==="function"&&typeof v.update==="function"&&typeof v.updateOnly==="function";}/**
 * Check that given value is compatible with Vis Data View interface.
 *
 * @param idProp - The expected property to contain item id.
 * @param v - The value to be tested.
 *
 * @returns True if all expected values and methods match, false otherwise.
 */function isDataViewLike(idProp,v){return _typeof(v)==="object"&&v!==null&&idProp===v.idProp&&typeof forEach$2(v)==="function"&&typeof v.get==="function"&&typeof v.getDataSet==="function"&&typeof v.getIds==="function"&&typeof v.length==="number"&&typeof map$3(v)==="function"&&typeof v.off==="function"&&typeof v.on==="function"&&typeof v.stream==="function"&&isDataSetLike(idProp,v.getDataSet());}var index=/*#__PURE__*/Object.freeze({__proto__:null,DELETE:DELETE,DataSet:DataSet,DataStream:DataStream,DataView:DataView,Queue:Queue,createNewDataPipeFrom:createNewDataPipeFrom,isDataSetLike:isDataSetLike,isDataViewLike:isDataViewLike});exports.data=index;var trim=stringTrim.trim;var $parseFloat=global$1.parseFloat;var FORCED=1/$parseFloat(whitespaces+'-0')!==-Infinity;// `parseFloat` method
// https://tc39.es/ecma262/#sec-parsefloat-string
var numberParseFloat=FORCED?function parseFloat(string){var trimmedString=trim(String(string));var result=$parseFloat(trimmedString);return result===0&&trimmedString.charAt(0)=='-'?-0:result;}:$parseFloat;// https://tc39.es/ecma262/#sec-parsefloat-string
_export({global:true,forced:parseFloat!=numberParseFloat},{parseFloat:numberParseFloat});var _parseFloat$2=path.parseFloat;var _parseFloat$1=_parseFloat$2;var _parseFloat=_parseFloat$1;var getOwnPropertyNames$3=objectGetOwnPropertyNamesExternal.f;// eslint-disable-next-line es/no-object-getownpropertynames -- required for testing
var FAILS_ON_PRIMITIVES=fails(function(){return!Object.getOwnPropertyNames(1);});// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
_export({target:'Object',stat:true,forced:FAILS_ON_PRIMITIVES},{getOwnPropertyNames:getOwnPropertyNames$3});var Object$1=path.Object;var getOwnPropertyNames$2=function getOwnPropertyNames(it){return Object$1.getOwnPropertyNames(it);};var getOwnPropertyNames$1=getOwnPropertyNames$2;var getOwnPropertyNames=getOwnPropertyNames$1;/**
 * Helper functions for components
 */ /**
 * Determine values to use for (sub)options of 'chosen'.
 *
 * This option is either a boolean or an object whose values should be examined further.
 * The relevant structures are:
 *
 * - chosen: <boolean value>
 * - chosen: { subOption: <boolean or function> }
 *
 * Where subOption is 'node', 'edge' or 'label'.
 *
 * The intention of this method appears to be to set a specific priority to the options;
 * Since most properties are either bridged or merged into the local options objects, there
 * is not much point in handling them separately.
 * TODO: examine if 'most' in previous sentence can be replaced with 'all'. In that case, we
 *       should be able to get rid of this method.
 *
 * @param {string}  subOption  option within object 'chosen' to consider; either 'node', 'edge' or 'label'
 * @param {object}  pile       array of options objects to consider
 *
 * @returns {boolean | Function}  value for passed subOption of 'chosen' to use
 */function choosify(subOption,pile){// allowed values for subOption
var allowed=["node","edge","label"];var value=true;var chosen=topMost(pile,"chosen");if(typeof chosen==="boolean"){value=chosen;}else if(_typeof(chosen)==="object"){if(indexOf(allowed).call(allowed,subOption)===-1){throw new Error("choosify: subOption '"+subOption+"' should be one of "+"'"+allowed.join("', '")+"'");}var chosenEdge=topMost(pile,["chosen",subOption]);if(typeof chosenEdge==="boolean"||typeof chosenEdge==="function"){value=chosenEdge;}}return value;}/**
 * Check if the point falls within the given rectangle.
 *
 * @param {rect} rect
 * @param {point} point
 * @param {rotationPoint} [rotationPoint] if specified, the rotation that applies to the rectangle.
 * @returns {boolean}  true if point within rectangle, false otherwise
 */function pointInRect(rect,point,rotationPoint){if(rect.width<=0||rect.height<=0){return false;// early out
}if(rotationPoint!==undefined){// Rotate the point the same amount as the rectangle
var tmp={x:point.x-rotationPoint.x,y:point.y-rotationPoint.y};if(rotationPoint.angle!==0){// In order to get the coordinates the same, you need to
// rotate in the reverse direction
var angle=-rotationPoint.angle;var tmp2={x:Math.cos(angle)*tmp.x-Math.sin(angle)*tmp.y,y:Math.sin(angle)*tmp.x+Math.cos(angle)*tmp.y};point=tmp2;}else{point=tmp;}// Note that if a rotation is specified, the rectangle coordinates
// are **not* the full canvas coordinates. They are relative to the
// rotationPoint. Hence, the point coordinates need not be translated
// back in this case.
}var right=rect.x+rect.width;var bottom=rect.y+rect.width;return rect.left<point.x&&right>point.x&&rect.top<point.y&&bottom>point.y;}/**
 * Check if given value is acceptable as a label text.
 *
 * @param {*} text value to check; can be anything at this point
 * @returns {boolean} true if valid label value, false otherwise
 */function isValidLabel(text){// Note that this is quite strict: types that *might* be converted to string are disallowed
return typeof text==="string"&&text!=="";}/**
 * Returns x, y of self reference circle based on provided angle
 *
 * @param {object} ctx
 * @param {number} angle
 * @param {number} radius
 * @param {VisNode} node
 *
 * @returns {object} x and y coordinates
 */function getSelfRefCoordinates(ctx,angle,radius,node){var x=node.x;var y=node.y;if(typeof node.distanceToBorder==="function"){//calculating opposite and adjacent
//distaneToBorder becomes Hypotenuse.
//Formulas sin(a) = Opposite / Hypotenuse and cos(a) = Adjacent / Hypotenuse
var toBorderDist=node.distanceToBorder(ctx,angle);var yFromNodeCenter=Math.sin(angle)*toBorderDist;var xFromNodeCenter=Math.cos(angle)*toBorderDist;//xFromNodeCenter is basically x and if xFromNodeCenter equals to the distance to border then it means
//that y does not need calculation because it is equal node.height / 2 or node.y
//same thing with yFromNodeCenter and if yFromNodeCenter equals to the distance to border then it means
//that x is equal node.width / 2 or node.x
if(xFromNodeCenter===toBorderDist){x+=toBorderDist;y=node.y;}else if(yFromNodeCenter===toBorderDist){x=node.x;y-=toBorderDist;}else{x+=xFromNodeCenter;y-=yFromNodeCenter;}}else if(node.shape.width>node.shape.height){x=node.x+node.shape.width*0.5;y=node.y-radius;}else{x=node.x+radius;y=node.y-node.shape.height*0.5;}return{x:x,y:y};}/**
 * Callback to determine text dimensions, using the parent label settings.
 *
 * @callback MeasureText
 * @param {text} text
 * @param {text} mod
 * @returns {object} { width, values} width in pixels and font attributes
 */ /**
 * Helper class for Label which collects results of splitting labels into lines and blocks.
 *
 * @private
 */var LabelAccumulator=/*#__PURE__*/function(){/**
   * @param {MeasureText} measureText
   */function LabelAccumulator(measureText){_classCallCheck(this,LabelAccumulator);this.measureText=measureText;this.current=0;this.width=0;this.height=0;this.lines=[];}/**
   * Append given text to the given line.
   *
   * @param {number}  l    index of line to add to
   * @param {string}  text string to append to line
   * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']
   * @private
   */_createClass(LabelAccumulator,[{key:"_add",value:function _add(l,text){var mod=arguments.length>2&&arguments[2]!==undefined?arguments[2]:"normal";if(this.lines[l]===undefined){this.lines[l]={width:0,height:0,blocks:[]};}// We still need to set a block for undefined and empty texts, hence return at this point
// This is necessary because we don't know at this point if we're at the
// start of an empty line or not.
// To compensate, empty blocks are removed in `finalize()`.
//
// Empty strings should still have a height
var tmpText=text;if(text===undefined||text==="")tmpText=" ";// Determine width and get the font properties
var result=this.measureText(tmpText,mod);var block=assign$2({},values(result));block.text=text;block.width=result.width;block.mod=mod;if(text===undefined||text===""){block.width=0;}this.lines[l].blocks.push(block);// Update the line width. We need this for determining if a string goes over max width
this.lines[l].width+=block.width;}/**
     * Returns the width in pixels of the current line.
     *
     * @returns {number}
     */},{key:"curWidth",value:function curWidth(){var line=this.lines[this.current];if(line===undefined)return 0;return line.width;}/**
     * Add text in block to current line
     *
     * @param {string} text
     * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']
     */},{key:"append",value:function append(text){var mod=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"normal";this._add(this.current,text,mod);}/**
     * Add text in block to current line and start a new line
     *
     * @param {string} text
     * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']
     */},{key:"newLine",value:function newLine(text){var mod=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"normal";this._add(this.current,text,mod);this.current++;}/**
     * Determine and set the heights of all the lines currently contained in this instance
     *
     * Note that width has already been set.
     *
     * @private
     */},{key:"determineLineHeights",value:function determineLineHeights(){for(var k=0;k<this.lines.length;k++){var line=this.lines[k];// Looking for max height of blocks in line
var height=0;if(line.blocks!==undefined){// Can happen if text contains e.g. '\n '
for(var l=0;l<line.blocks.length;l++){var block=line.blocks[l];if(height<block.height){height=block.height;}}}line.height=height;}}/**
     * Determine the full size of the label text, as determined by current lines and blocks
     *
     * @private
     */},{key:"determineLabelSize",value:function determineLabelSize(){var width=0;var height=0;for(var k=0;k<this.lines.length;k++){var line=this.lines[k];if(line.width>width){width=line.width;}height+=line.height;}this.width=width;this.height=height;}/**
     * Remove all empty blocks and empty lines we don't need
     *
     * This must be done after the width/height determination,
     * so that these are set properly for processing here.
     *
     * @returns {Array<Line>} Lines with empty blocks (and some empty lines) removed
     * @private
     */},{key:"removeEmptyBlocks",value:function removeEmptyBlocks(){var tmpLines=[];for(var k=0;k<this.lines.length;k++){var line=this.lines[k];// Note: an empty line in between text has width zero but is still relevant to layout.
// So we can't use width for testing empty line here
if(line.blocks.length===0)continue;// Discard final empty line always
if(k===this.lines.length-1){if(line.width===0)continue;}var tmpLine={};assign$2(tmpLine,line);tmpLine.blocks=[];var firstEmptyBlock=void 0;var tmpBlocks=[];for(var l=0;l<line.blocks.length;l++){var block=line.blocks[l];if(block.width!==0){tmpBlocks.push(block);}else{if(firstEmptyBlock===undefined){firstEmptyBlock=block;}}}// Ensure that there is *some* text present
if(tmpBlocks.length===0&&firstEmptyBlock!==undefined){tmpBlocks.push(firstEmptyBlock);}tmpLine.blocks=tmpBlocks;tmpLines.push(tmpLine);}return tmpLines;}/**
     * Set the sizes for all lines and the whole thing.
     *
     * @returns {{width: (number|*), height: (number|*), lines: Array}}
     */},{key:"finalize",value:function finalize(){//console.log(JSON.stringify(this.lines, null, 2));
this.determineLineHeights();this.determineLabelSize();var tmpLines=this.removeEmptyBlocks();// Return a simple hash object for further processing.
return{width:this.width,height:this.height,lines:tmpLines};}}]);return LabelAccumulator;}();var tagPattern={// HTML
"<b>":/<b>/,"<i>":/<i>/,"<code>":/<code>/,"</b>":/<\/b>/,"</i>":/<\/i>/,"</code>":/<\/code>/,// Markdown
"*":/\*/,// bold
_:/_/,// ital
"`":/`/,// mono
afterBold:/[^*]/,afterItal:/[^_]/,afterMono:/[^`]/};/**
 * Internal helper class for parsing the markup tags for HTML and Markdown.
 *
 * NOTE: Sequences of tabs and spaces are reduced to single space.
 *       Scan usage of `this.spacing` within method
 */var MarkupAccumulator=/*#__PURE__*/function(){/**
   * Create an instance
   *
   * @param {string} text  text to parse for markup
   */function MarkupAccumulator(text){_classCallCheck(this,MarkupAccumulator);this.text=text;this.bold=false;this.ital=false;this.mono=false;this.spacing=false;this.position=0;this.buffer="";this.modStack=[];this.blocks=[];}/**
   * Return the mod label currently on the top of the stack
   *
   * @returns {string}  label of topmost mod
   * @private
   */_createClass(MarkupAccumulator,[{key:"mod",value:function mod(){return this.modStack.length===0?"normal":this.modStack[0];}/**
     * Return the mod label currently active
     *
     * @returns {string}  label of active mod
     * @private
     */},{key:"modName",value:function modName(){if(this.modStack.length===0)return"normal";else if(this.modStack[0]==="mono")return"mono";else{if(this.bold&&this.ital){return"boldital";}else if(this.bold){return"bold";}else if(this.ital){return"ital";}}}/**
     * @private
     */},{key:"emitBlock",value:function emitBlock(){if(this.spacing){this.add(" ");this.spacing=false;}if(this.buffer.length>0){this.blocks.push({text:this.buffer,mod:this.modName()});this.buffer="";}}/**
     * Output text to buffer
     *
     * @param {string} text  text to add
     * @private
     */},{key:"add",value:function add(text){if(text===" "){this.spacing=true;}if(this.spacing){this.buffer+=" ";this.spacing=false;}if(text!=" "){this.buffer+=text;}}/**
     * Handle parsing of whitespace
     *
     * @param {string} ch  the character to check
     * @returns {boolean} true if the character was processed as whitespace, false otherwise
     */},{key:"parseWS",value:function parseWS(ch){if(/[ \t]/.test(ch)){if(!this.mono){this.spacing=true;}else{this.add(ch);}return true;}return false;}/**
     * @param {string} tagName  label for block type to set
     * @private
     */},{key:"setTag",value:function setTag(tagName){this.emitBlock();this[tagName]=true;this.modStack.unshift(tagName);}/**
     * @param {string} tagName  label for block type to unset
     * @private
     */},{key:"unsetTag",value:function unsetTag(tagName){this.emitBlock();this[tagName]=false;this.modStack.shift();}/**
     * @param {string} tagName label for block type we are currently processing
     * @param {string|RegExp} tag string to match in text
     * @returns {boolean} true if the tag was processed, false otherwise
     */},{key:"parseStartTag",value:function parseStartTag(tagName,tag){// Note: if 'mono' passed as tagName, there is a double check here. This is OK
if(!this.mono&&!this[tagName]&&this.match(tag)){this.setTag(tagName);return true;}return false;}/**
     * @param {string|RegExp} tag
     * @param {number} [advance=true] if set, advance current position in text
     * @returns {boolean} true if match at given position, false otherwise
     * @private
     */},{key:"match",value:function match(tag){var advance=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;var _this$prepareRegExp=this.prepareRegExp(tag),_this$prepareRegExp2=_slicedToArray(_this$prepareRegExp,2),regExp=_this$prepareRegExp2[0],length=_this$prepareRegExp2[1];var matched=regExp.test(this.text.substr(this.position,length));if(matched&&advance){this.position+=length-1;}return matched;}/**
     * @param {string} tagName label for block type we are currently processing
     * @param {string|RegExp} tag string to match in text
     * @param {RegExp} [nextTag] regular expression to match for characters *following* the current tag
     * @returns {boolean} true if the tag was processed, false otherwise
     */},{key:"parseEndTag",value:function parseEndTag(tagName,tag,nextTag){var checkTag=this.mod()===tagName;if(tagName==="mono"){// special handling for 'mono'
checkTag=checkTag&&this.mono;}else{checkTag=checkTag&&!this.mono;}if(checkTag&&this.match(tag)){if(nextTag!==undefined){// Purpose of the following match is to prevent a direct unset/set of a given tag
// E.g. '*bold **still bold*' => '*bold still bold*'
if(this.position===this.text.length-1||this.match(nextTag,false)){this.unsetTag(tagName);}}else{this.unsetTag(tagName);}return true;}return false;}/**
     * @param {string|RegExp} tag  string to match in text
     * @param {value} value  string to replace tag with, if found at current position
     * @returns {boolean} true if the tag was processed, false otherwise
     */},{key:"replace",value:function replace(tag,value){if(this.match(tag)){this.add(value);this.position+=length-1;return true;}return false;}/**
     * Create a regular expression for the tag if it isn't already one.
     *
     * The return value is an array `[RegExp, number]`, with exactly two value, where:
     *  - RegExp is the regular expression to use
     *  - number is the lenth of the input string to match
     *
     * @param {string|RegExp} tag  string to match in text
     * @returns {Array}  regular expression to use and length of input string to match
     * @private
     */},{key:"prepareRegExp",value:function prepareRegExp(tag){var length;var regExp;if(tag instanceof RegExp){regExp=tag;length=1;// ASSUMPTION: regexp only tests one character
}else{// use prepared regexp if present
var prepared=tagPattern[tag];if(prepared!==undefined){regExp=prepared;}else{regExp=new RegExp(tag);}length=tag.length;}return[regExp,length];}}]);return MarkupAccumulator;}();/**
 * Helper class for Label which explodes the label text into lines and blocks within lines
 *
 * @private
 */var LabelSplitter=/*#__PURE__*/function(){/**
   * @param {CanvasRenderingContext2D} ctx Canvas rendering context
   * @param {Label} parent reference to the Label instance using current instance
   * @param {boolean} selected
   * @param {boolean} hover
   */function LabelSplitter(ctx,parent,selected,hover){var _this=this;_classCallCheck(this,LabelSplitter);this.ctx=ctx;this.parent=parent;this.selected=selected;this.hover=hover;/**
     * Callback to determine text width; passed to LabelAccumulator instance
     *
     * @param  {string} text string to determine width of
     * @param  {string} mod  font type to use for this text
     * @returns {object} { width, values} width in pixels and font attributes
     */var textWidth=function textWidth(text,mod){if(text===undefined)return 0;// TODO: This can be done more efficiently with caching
// This will set the ctx.font correctly, depending on selected/hover and mod - so that ctx.measureText() will be accurate.
var values=_this.parent.getFormattingValues(ctx,selected,hover,mod);var width=0;if(text!==""){var measure=_this.ctx.measureText(text);width=measure.width;}return{width:width,values:values};};this.lines=new LabelAccumulator(textWidth);}/**
   * Split passed text of a label into lines and blocks.
   *
   * # NOTE
   *
   * The handling of spacing is option dependent:
   *
   * - if `font.multi : false`, all spaces are retained
   * - if `font.multi : true`, every sequence of spaces is compressed to a single space
   *
   * This might not be the best way to do it, but this is as it has been working till now.
   * In order not to break existing functionality, for the time being this behaviour will
   * be retained in any code changes.
   *
   * @param {string} text  text to split
   * @returns {Array<line>}
   */_createClass(LabelSplitter,[{key:"process",value:function process(text){if(!isValidLabel(text)){return this.lines.finalize();}var font=this.parent.fontOptions;// Normalize the end-of-line's to a single representation - order important
text=text.replace(/\r\n/g,"\n");// Dos EOL's
text=text.replace(/\r/g,"\n");// Mac EOL's
// Note that at this point, there can be no \r's in the text.
// This is used later on splitStringIntoLines() to split multifont texts.
var nlLines=String(text).split("\n");var lineCount=nlLines.length;if(font.multi){// Multi-font case: styling tags active
for(var i=0;i<lineCount;i++){var blocks=this.splitBlocks(nlLines[i],font.multi);// Post: Sequences of tabs and spaces are reduced to single space
if(blocks===undefined)continue;if(blocks.length===0){this.lines.newLine("");continue;}if(font.maxWdt>0){// widthConstraint.maximum defined
//console.log('Running widthConstraint multi, max: ' + this.fontOptions.maxWdt);
for(var j=0;j<blocks.length;j++){var mod=blocks[j].mod;var _text=blocks[j].text;this.splitStringIntoLines(_text,mod,true);}}else{// widthConstraint.maximum NOT defined
for(var _j=0;_j<blocks.length;_j++){var _mod=blocks[_j].mod;var _text2=blocks[_j].text;this.lines.append(_text2,_mod);}}this.lines.newLine();}}else{// Single-font case
if(font.maxWdt>0){// widthConstraint.maximum defined
// console.log('Running widthConstraint normal, max: ' + this.fontOptions.maxWdt);
for(var _i=0;_i<lineCount;_i++){this.splitStringIntoLines(nlLines[_i]);}}else{// widthConstraint.maximum NOT defined
for(var _i2=0;_i2<lineCount;_i2++){this.lines.newLine(nlLines[_i2]);}}}return this.lines.finalize();}/**
     * normalize the markup system
     *
     * @param {boolean|'md'|'markdown'|'html'} markupSystem
     * @returns {string}
     */},{key:"decodeMarkupSystem",value:function decodeMarkupSystem(markupSystem){var system="none";if(markupSystem==="markdown"||markupSystem==="md"){system="markdown";}else if(markupSystem===true||markupSystem==="html"){system="html";}return system;}/**
     *
     * @param {string} text
     * @returns {Array}
     */},{key:"splitHtmlBlocks",value:function splitHtmlBlocks(text){var s=new MarkupAccumulator(text);var parseEntities=function parseEntities(ch){if(/&/.test(ch)){var parsed=s.replace(s.text,"&lt;","<")||s.replace(s.text,"&amp;","&");if(!parsed){s.add("&");}return true;}return false;};while(s.position<s.text.length){var ch=s.text.charAt(s.position);var parsed=s.parseWS(ch)||/</.test(ch)&&(s.parseStartTag("bold","<b>")||s.parseStartTag("ital","<i>")||s.parseStartTag("mono","<code>")||s.parseEndTag("bold","</b>")||s.parseEndTag("ital","</i>")||s.parseEndTag("mono","</code>"))||parseEntities(ch);if(!parsed){s.add(ch);}s.position++;}s.emitBlock();return s.blocks;}/**
     *
     * @param {string} text
     * @returns {Array}
     */},{key:"splitMarkdownBlocks",value:function splitMarkdownBlocks(text){var _this2=this;var s=new MarkupAccumulator(text);var beginable=true;var parseOverride=function parseOverride(ch){if(/\\/.test(ch)){if(s.position<_this2.text.length+1){s.position++;ch=_this2.text.charAt(s.position);if(/ \t/.test(ch)){s.spacing=true;}else{s.add(ch);beginable=false;}}return true;}return false;};while(s.position<s.text.length){var ch=s.text.charAt(s.position);var parsed=s.parseWS(ch)||parseOverride(ch)||(beginable||s.spacing)&&(s.parseStartTag("bold","*")||s.parseStartTag("ital","_")||s.parseStartTag("mono","`"))||s.parseEndTag("bold","*","afterBold")||s.parseEndTag("ital","_","afterItal")||s.parseEndTag("mono","`","afterMono");if(!parsed){s.add(ch);beginable=false;}s.position++;}s.emitBlock();return s.blocks;}/**
     * Explodes a piece of text into single-font blocks using a given markup
     *
     * @param {string} text
     * @param {boolean|'md'|'markdown'|'html'} markupSystem
     * @returns {Array.<{text: string, mod: string}>}
     * @private
     */},{key:"splitBlocks",value:function splitBlocks(text,markupSystem){var system=this.decodeMarkupSystem(markupSystem);if(system==="none"){return[{text:text,mod:"normal"}];}else if(system==="markdown"){return this.splitMarkdownBlocks(text);}else if(system==="html"){return this.splitHtmlBlocks(text);}}/**
     * @param {string} text
     * @returns {boolean} true if text length over the current max with
     * @private
     */},{key:"overMaxWidth",value:function overMaxWidth(text){var width=this.ctx.measureText(text).width;return this.lines.curWidth()+width>this.parent.fontOptions.maxWdt;}/**
     * Determine the longest part of the sentence which still fits in the
     * current max width.
     *
     * @param {Array} words  Array of strings signifying a text lines
     * @returns {number}      index of first item in string making string go over max
     * @private
     */},{key:"getLongestFit",value:function getLongestFit(words){var text="";var w=0;while(w<words.length){var pre=text===""?"":" ";var newText=text+pre+words[w];if(this.overMaxWidth(newText))break;text=newText;w++;}return w;}/**
     * Determine the longest part of the string which still fits in the
     * current max width.
     *
     * @param {Array} words Array of strings signifying a text lines
     * @returns {number} index of first item in string making string go over max
     */},{key:"getLongestFitWord",value:function getLongestFitWord(words){var w=0;while(w<words.length){if(this.overMaxWidth(slice$1(words).call(words,0,w)))break;w++;}return w;}/**
     * Split the passed text into lines, according to width constraint (if any).
     *
     * The method assumes that the input string is a single line, i.e. without lines break.
     *
     * This method retains spaces, if still present (case `font.multi: false`).
     * A space which falls on an internal line break, will be replaced by a newline.
     * There is no special handling of tabs; these go along with the flow.
     *
     * @param {string} str
     * @param {string} [mod='normal']
     * @param {boolean} [appendLast=false]
     * @private
     */},{key:"splitStringIntoLines",value:function splitStringIntoLines(str){var mod=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"normal";var appendLast=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;// Set the canvas context font, based upon the current selected/hover state
// and the provided mod, so the text measurement performed by getLongestFit
// will be accurate - and not just use the font of whoever last used the canvas.
this.parent.getFormattingValues(this.ctx,this.selected,this.hover,mod);// Still-present spaces are relevant, retain them
str=str.replace(/^( +)/g,"$1\r");str=str.replace(/([^\r][^ ]*)( +)/g,"$1\r$2\r");var words=str.split("\r");while(words.length>0){var w=this.getLongestFit(words);if(w===0){// Special case: the first word is already larger than the max width.
var word=words[0];// Break the word to the largest part that fits the line
var x=this.getLongestFitWord(word);this.lines.newLine(slice$1(word).call(word,0,x),mod);// Adjust the word, so that the rest will be done next iteration
words[0]=slice$1(word).call(word,x);}else{// skip any space that is replaced by a newline
var newW=w;if(words[w-1]===" "){w--;}else if(words[newW]===" "){newW++;}var text=slice$1(words).call(words,0,w).join("");if(w==words.length&&appendLast){this.lines.append(text,mod);}else{this.lines.newLine(text,mod);}// Adjust the word, so that the rest will be done next iteration
words=slice$1(words).call(words,newW);}}}}]);return LabelSplitter;}();/**
 * List of special styles for multi-fonts
 *
 * @private
 */var multiFontStyle=["bold","ital","boldital","mono"];/**
 * A Label to be used for Nodes or Edges.
 */var Label=/*#__PURE__*/function(){/**
   * @param {object} body
   * @param {object} options
   * @param {boolean} [edgelabel=false]
   */function Label(body,options){var edgelabel=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;_classCallCheck(this,Label);this.body=body;this.pointToSelf=false;this.baseSize=undefined;this.fontOptions={};// instance variable containing the *instance-local* font options
this.setOptions(options);this.size={top:0,left:0,width:0,height:0,yLine:0};this.isEdgeLabel=edgelabel;}/**
   * @param {object} options the options of the parent Node-instance
   */_createClass(Label,[{key:"setOptions",value:function setOptions(options){this.elementOptions=options;// Reference to the options of the parent Node-instance
this.initFontOptions(options.font);if(isValidLabel(options.label)){this.labelDirty=true;}else{// Bad label! Change the option value to prevent bad stuff happening
options.label=undefined;}if(options.font!==undefined&&options.font!==null){// font options can be deleted at various levels
if(typeof options.font==="string"){this.baseSize=this.fontOptions.size;}else if(_typeof(options.font)==="object"){var size=options.font.size;if(size!==undefined){this.baseSize=size;}}}}/**
     * Init the font Options structure.
     *
     * Member fontOptions serves as an accumulator for the current font options.
     * As such, it needs to be completely separated from the node options.
     *
     * @param {object} newFontOptions the new font options to process
     * @private
     */},{key:"initFontOptions",value:function initFontOptions(newFontOptions){var _this=this;// Prepare the multi-font option objects.
// These will be filled in propagateFonts(), if required
forEach$1(multiFontStyle,function(style){_this.fontOptions[style]={};});// Handle shorthand option, if present
if(Label.parseFontString(this.fontOptions,newFontOptions)){this.fontOptions.vadjust=0;return;}// Copy over the non-multifont options, if specified
forEach$1(newFontOptions,function(prop,n){if(prop!==undefined&&prop!==null&&_typeof(prop)!=="object"){_this.fontOptions[n]=prop;}});}/**
     * If in-variable is a string, parse it as a font specifier.
     *
     * Note that following is not done here and have to be done after the call:
     * - Not all font options are set (vadjust, mod)
     *
     * @param {object} outOptions  out-parameter, object in which to store the parse results (if any)
     * @param {object} inOptions  font options to parse
     * @returns {boolean} true if font parsed as string, false otherwise
     * @static
     */},{key:"constrain",value:/**
     * Set the width and height constraints based on 'nearest' value
     *
     * @param {Array} pile array of option objects to consider
     * @returns {object} the actual constraint values to use
     * @private
     */function constrain(pile){// NOTE: constrainWidth and  constrainHeight never set!
// NOTE: for edge labels, only 'maxWdt' set
// Node labels can set all the fields
var fontOptions={constrainWidth:false,maxWdt:-1,minWdt:-1,constrainHeight:false,minHgt:-1,valign:"middle"};var widthConstraint=topMost(pile,"widthConstraint");if(typeof widthConstraint==="number"){fontOptions.maxWdt=Number(widthConstraint);fontOptions.minWdt=Number(widthConstraint);}else if(_typeof(widthConstraint)==="object"){var widthConstraintMaximum=topMost(pile,["widthConstraint","maximum"]);if(typeof widthConstraintMaximum==="number"){fontOptions.maxWdt=Number(widthConstraintMaximum);}var widthConstraintMinimum=topMost(pile,["widthConstraint","minimum"]);if(typeof widthConstraintMinimum==="number"){fontOptions.minWdt=Number(widthConstraintMinimum);}}var heightConstraint=topMost(pile,"heightConstraint");if(typeof heightConstraint==="number"){fontOptions.minHgt=Number(heightConstraint);}else if(_typeof(heightConstraint)==="object"){var heightConstraintMinimum=topMost(pile,["heightConstraint","minimum"]);if(typeof heightConstraintMinimum==="number"){fontOptions.minHgt=Number(heightConstraintMinimum);}var heightConstraintValign=topMost(pile,["heightConstraint","valign"]);if(typeof heightConstraintValign==="string"){if(heightConstraintValign==="top"||heightConstraintValign==="bottom"){fontOptions.valign=heightConstraintValign;}}}return fontOptions;}/**
     * Set options and update internal state
     *
     * @param {object} options  options to set
     * @param {Array}  pile     array of option objects to consider for option 'chosen'
     */},{key:"update",value:function update(options,pile){this.setOptions(options,true);this.propagateFonts(pile);deepExtend(this.fontOptions,this.constrain(pile));this.fontOptions.chooser=choosify("label",pile);}/**
     * When margins are set in an element, adjust sizes is called to remove them
     * from the width/height constraints. This must be done prior to label sizing.
     *
     * @param {{top: number, right: number, bottom: number, left: number}} margins
     */},{key:"adjustSizes",value:function adjustSizes(margins){var widthBias=margins?margins.right+margins.left:0;if(this.fontOptions.constrainWidth){this.fontOptions.maxWdt-=widthBias;this.fontOptions.minWdt-=widthBias;}var heightBias=margins?margins.top+margins.bottom:0;if(this.fontOptions.constrainHeight){this.fontOptions.minHgt-=heightBias;}}/////////////////////////////////////////////////////////
// Methods for handling options piles
// Eventually, these will be moved to a separate class
/////////////////////////////////////////////////////////
/**
     * Add the font members of the passed list of option objects to the pile.
     *
     * @param {Pile} dstPile  pile of option objects add to
     * @param {Pile} srcPile  pile of option objects to take font options from
     * @private
     */},{key:"addFontOptionsToPile",value:function addFontOptionsToPile(dstPile,srcPile){for(var i=0;i<srcPile.length;++i){this.addFontToPile(dstPile,srcPile[i]);}}/**
     * Add given font option object to the list of objects (the 'pile') to consider for determining
     * multi-font option values.
     *
     * @param {Pile} pile  pile of option objects to use
     * @param {object} options  instance to add to pile
     * @private
     */},{key:"addFontToPile",value:function addFontToPile(pile,options){if(options===undefined)return;if(options.font===undefined||options.font===null)return;var item=options.font;pile.push(item);}/**
     * Collect all own-property values from the font pile that aren't multi-font option objectss.
     *
     * @param {Pile} pile  pile of option objects to use
     * @returns {object} object with all current own basic font properties
     * @private
     */},{key:"getBasicOptions",value:function getBasicOptions(pile){var ret={};// Scans the whole pile to get all options present
for(var n=0;n<pile.length;++n){var fontOptions=pile[n];// Convert shorthand if necessary
var tmpShorthand={};if(Label.parseFontString(tmpShorthand,fontOptions)){fontOptions=tmpShorthand;}forEach$1(fontOptions,function(opt,name){if(opt===undefined)return;// multi-font option need not be present
if(Object.prototype.hasOwnProperty.call(ret,name))return;// Keep first value we encounter
if(indexOf(multiFontStyle).call(multiFontStyle,name)!==-1){// Skip multi-font properties but we do need the structure
ret[name]={};}else{ret[name]=opt;}});}return ret;}/**
     * Return the value for given option for the given multi-font.
     *
     * All available option objects are trawled in the set order to construct the option values.
     *
     * ---------------------------------------------------------------------
     * ## Traversal of pile for multi-fonts
     *
     * The determination of multi-font option values is a special case, because any values not
     * present in the multi-font options should by definition be taken from the main font options,
     * i.e. from the current 'parent' object of the multi-font option.
     *
     * ### Search order for multi-fonts
     *
     * 'bold' used as example:
     *
     *   - search in option group 'bold' in local properties
     *   - search in main font option group in local properties
     *
     * ---------------------------------------------------------------------
     *
     * @param {Pile} pile  pile of option objects to use
     * @param {MultiFontStyle} multiName sub path for the multi-font
     * @param {string} option  the option to search for, for the given multi-font
     * @returns {string|number} the value for the given option
     * @private
     */},{key:"getFontOption",value:function getFontOption(pile,multiName,option){var multiFont;// Search multi font in local properties
for(var n=0;n<pile.length;++n){var fontOptions=pile[n];if(Object.prototype.hasOwnProperty.call(fontOptions,multiName)){multiFont=fontOptions[multiName];if(multiFont===undefined||multiFont===null)continue;// Convert shorthand if necessary
// TODO: inefficient to do this conversion every time; find a better way.
var tmpShorthand={};if(Label.parseFontString(tmpShorthand,multiFont)){multiFont=tmpShorthand;}if(Object.prototype.hasOwnProperty.call(multiFont,option)){return multiFont[option];}}}// Option is not mentioned in the multi font options; take it from the parent font options.
// These have already been converted with getBasicOptions(), so use the converted values.
if(Object.prototype.hasOwnProperty.call(this.fontOptions,option)){return this.fontOptions[option];}// A value **must** be found; you should never get here.
throw new Error("Did not find value for multi-font for property: '"+option+"'");}/**
     * Return all options values for the given multi-font.
     *
     * All available option objects are trawled in the set order to construct the option values.
     *
     * @param {Pile} pile  pile of option objects to use
     * @param {MultiFontStyle} multiName sub path for the mod-font
     * @returns {MultiFontOptions}
     * @private
     */},{key:"getFontOptions",value:function getFontOptions(pile,multiName){var result={};var optionNames=["color","size","face","mod","vadjust"];// List of allowed options per multi-font
for(var i=0;i<optionNames.length;++i){var mod=optionNames[i];result[mod]=this.getFontOption(pile,multiName,mod);}return result;}/////////////////////////////////////////////////////////
// End methods for handling options piles
/////////////////////////////////////////////////////////
/**
     * Collapse the font options for the multi-font to single objects, from
     * the chain of option objects passed (the 'pile').
     *
     * @param {Pile} pile  sequence of option objects to consider.
     *                     First item in list assumed to be the newly set options.
     */},{key:"propagateFonts",value:function propagateFonts(pile){var _this2=this;var fontPile=[];// sequence of font objects to consider, order important
// Note that this.elementOptions is not used here.
this.addFontOptionsToPile(fontPile,pile);this.fontOptions=this.getBasicOptions(fontPile);// We set multifont values even if multi === false, for consistency (things break otherwise)
var _loop=function _loop(i){var mod=multiFontStyle[i];var modOptions=_this2.fontOptions[mod];var tmpMultiFontOptions=_this2.getFontOptions(fontPile,mod);// Copy over found values
forEach$1(tmpMultiFontOptions,function(option,n){modOptions[n]=option;});modOptions.size=Number(modOptions.size);modOptions.vadjust=Number(modOptions.vadjust);};for(var i=0;i<multiFontStyle.length;++i){_loop(i);}}/**
     * Main function. This is called from anything that wants to draw a label.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x
     * @param {number} y
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {string} [baseline='middle']
     */},{key:"draw",value:function draw(ctx,x,y,selected,hover){var baseline=arguments.length>5&&arguments[5]!==undefined?arguments[5]:"middle";// if no label, return
if(this.elementOptions.label===undefined)return;// check if we have to render the label
var viewFontSize=this.fontOptions.size*this.body.view.scale;if(this.elementOptions.label&&viewFontSize<this.elementOptions.scaling.label.drawThreshold-1)return;// This ensures that there will not be HUGE letters on screen
// by setting an upper limit on the visible text size (regardless of zoomLevel)
if(viewFontSize>=this.elementOptions.scaling.label.maxVisible){viewFontSize=Number(this.elementOptions.scaling.label.maxVisible)/this.body.view.scale;}// update the size cache if required
this.calculateLabelSize(ctx,selected,hover,x,y,baseline);this._drawBackground(ctx);this._drawText(ctx,x,this.size.yLine,baseline,viewFontSize);}/**
     * Draws the label background
     *
     * @param {CanvasRenderingContext2D} ctx
     * @private
     */},{key:"_drawBackground",value:function _drawBackground(ctx){if(this.fontOptions.background!==undefined&&this.fontOptions.background!=="none"){ctx.fillStyle=this.fontOptions.background;var size=this.getSize();ctx.fillRect(size.left,size.top,size.width,size.height);}}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x
     * @param {number} y
     * @param {string} [baseline='middle']
     * @param {number} viewFontSize
     * @private
     */},{key:"_drawText",value:function _drawText(ctx,x,y){var baseline=arguments.length>3&&arguments[3]!==undefined?arguments[3]:"middle";var viewFontSize=arguments.length>4?arguments[4]:undefined;var _this$_setAlignment=this._setAlignment(ctx,x,y,baseline);var _this$_setAlignment2=_slicedToArray(_this$_setAlignment,2);x=_this$_setAlignment2[0];y=_this$_setAlignment2[1];ctx.textAlign="left";x=x-this.size.width/2;// Shift label 1/2-distance to the left
if(this.fontOptions.valign&&this.size.height>this.size.labelHeight){if(this.fontOptions.valign==="top"){y-=(this.size.height-this.size.labelHeight)/2;}if(this.fontOptions.valign==="bottom"){y+=(this.size.height-this.size.labelHeight)/2;}}// draw the text
for(var i=0;i<this.lineCount;i++){var line=this.lines[i];if(line&&line.blocks){var width=0;if(this.isEdgeLabel||this.fontOptions.align==="center"){width+=(this.size.width-line.width)/2;}else if(this.fontOptions.align==="right"){width+=this.size.width-line.width;}for(var j=0;j<line.blocks.length;j++){var block=line.blocks[j];ctx.font=block.font;var _this$_getColor=this._getColor(block.color,viewFontSize,block.strokeColor),_this$_getColor2=_slicedToArray(_this$_getColor,2),fontColor=_this$_getColor2[0],strokeColor=_this$_getColor2[1];if(block.strokeWidth>0){ctx.lineWidth=block.strokeWidth;ctx.strokeStyle=strokeColor;ctx.lineJoin="round";}ctx.fillStyle=fontColor;if(block.strokeWidth>0){ctx.strokeText(block.text,x+width,y+block.vadjust);}ctx.fillText(block.text,x+width,y+block.vadjust);width+=block.width;}y+=line.height;}}}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x
     * @param {number} y
     * @param {string} baseline
     * @returns {Array.<number>}
     * @private
     */},{key:"_setAlignment",value:function _setAlignment(ctx,x,y,baseline){// check for label alignment (for edges)
// TODO: make alignment for nodes
if(this.isEdgeLabel&&this.fontOptions.align!=="horizontal"&&this.pointToSelf===false){x=0;y=0;var lineMargin=2;if(this.fontOptions.align==="top"){ctx.textBaseline="alphabetic";y-=2*lineMargin;// distance from edge, required because we use alphabetic. Alphabetic has less difference between browsers
}else if(this.fontOptions.align==="bottom"){ctx.textBaseline="hanging";y+=2*lineMargin;// distance from edge, required because we use hanging. Hanging has less difference between browsers
}else{ctx.textBaseline="middle";}}else{ctx.textBaseline=baseline;}return[x,y];}/**
     * fade in when relative scale is between threshold and threshold - 1.
     * If the relative scale would be smaller than threshold -1 the draw function would have returned before coming here.
     *
     * @param {string} color  The font color to use
     * @param {number} viewFontSize
     * @param {string} initialStrokeColor
     * @returns {Array.<string>} An array containing the font color and stroke color
     * @private
     */},{key:"_getColor",value:function _getColor(color,viewFontSize,initialStrokeColor){var fontColor=color||"#000000";var strokeColor=initialStrokeColor||"#ffffff";if(viewFontSize<=this.elementOptions.scaling.label.drawThreshold){var opacity=Math.max(0,Math.min(1,1-(this.elementOptions.scaling.label.drawThreshold-viewFontSize)));fontColor=overrideOpacity(fontColor,opacity);strokeColor=overrideOpacity(strokeColor,opacity);}return[fontColor,strokeColor];}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @returns {{width: number, height: number}}
     */},{key:"getTextSize",value:function getTextSize(ctx){var selected=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var hover=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;this._processLabel(ctx,selected,hover);return{width:this.size.width,height:this.size.height,lineCount:this.lineCount};}/**
     * Get the current dimensions of the label
     *
     * @returns {rect}
     */},{key:"getSize",value:function getSize(){var lineMargin=2;var x=this.size.left;// default values which might be overridden below
var y=this.size.top-0.5*lineMargin;// idem
if(this.isEdgeLabel){var x2=-this.size.width*0.5;switch(this.fontOptions.align){case"middle":x=x2;y=-this.size.height*0.5;break;case"top":x=x2;y=-(this.size.height+lineMargin);break;case"bottom":x=x2;y=lineMargin;break;}}var ret={left:x,top:y,width:this.size.width,height:this.size.height};return ret;}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {number} [x=0]
     * @param {number} [y=0]
     * @param {'middle'|'hanging'} [baseline='middle']
     */},{key:"calculateLabelSize",value:function calculateLabelSize(ctx,selected,hover){var x=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;var y=arguments.length>4&&arguments[4]!==undefined?arguments[4]:0;var baseline=arguments.length>5&&arguments[5]!==undefined?arguments[5]:"middle";this._processLabel(ctx,selected,hover);this.size.left=x-this.size.width*0.5;this.size.top=y-this.size.height*0.5;this.size.yLine=y+(1-this.lineCount)*0.5*this.fontOptions.size;if(baseline==="hanging"){this.size.top+=0.5*this.fontOptions.size;this.size.top+=4;// distance from node, required because we use hanging. Hanging has less difference between browsers
this.size.yLine+=4;// distance from node
}}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {string} mod
     * @returns {{color, size, face, mod, vadjust, strokeWidth: *, strokeColor: (*|string|allOptions.edges.font.strokeColor|{string}|allOptions.nodes.font.strokeColor|Array)}}
     */},{key:"getFormattingValues",value:function getFormattingValues(ctx,selected,hover,mod){var getValue=function getValue(fontOptions,mod,option){if(mod==="normal"){if(option==="mod")return"";return fontOptions[option];}if(fontOptions[mod][option]!==undefined){// Grumbl leaving out test on undefined equals false for ""
return fontOptions[mod][option];}else{// Take from parent font option
return fontOptions[option];}};var values={color:getValue(this.fontOptions,mod,"color"),size:getValue(this.fontOptions,mod,"size"),face:getValue(this.fontOptions,mod,"face"),mod:getValue(this.fontOptions,mod,"mod"),vadjust:getValue(this.fontOptions,mod,"vadjust"),strokeWidth:this.fontOptions.strokeWidth,strokeColor:this.fontOptions.strokeColor};if(selected||hover){if(mod==="normal"&&this.fontOptions.chooser===true&&this.elementOptions.labelHighlightBold){values.mod="bold";}else{if(typeof this.fontOptions.chooser==="function"){this.fontOptions.chooser(values,this.elementOptions.id,selected,hover);}}}var fontString="";if(values.mod!==undefined&&values.mod!==""){// safeguard for undefined - this happened
fontString+=values.mod+" ";}fontString+=values.size+"px "+values.face;ctx.font=fontString.replace(/"/g,"");values.font=ctx.font;values.height=values.size;return values;}/**
     *
     * @param {boolean} selected
     * @param {boolean} hover
     * @returns {boolean}
     */},{key:"differentState",value:function differentState(selected,hover){return selected!==this.selectedState||hover!==this.hoverState;}/**
     * This explodes the passed text into lines and determines the width, height and number of lines.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {string} inText  the text to explode
     * @returns {{width, height, lines}|*}
     * @private
     */},{key:"_processLabelText",value:function _processLabelText(ctx,selected,hover,inText){var splitter=new LabelSplitter(ctx,this,selected,hover);return splitter.process(inText);}/**
     * This explodes the label string into lines and sets the width, height and number of lines.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @private
     */},{key:"_processLabel",value:function _processLabel(ctx,selected,hover){if(this.labelDirty===false&&!this.differentState(selected,hover))return;var state=this._processLabelText(ctx,selected,hover,this.elementOptions.label);if(this.fontOptions.minWdt>0&&state.width<this.fontOptions.minWdt){state.width=this.fontOptions.minWdt;}this.size.labelHeight=state.height;if(this.fontOptions.minHgt>0&&state.height<this.fontOptions.minHgt){state.height=this.fontOptions.minHgt;}this.lines=state.lines;this.lineCount=state.lines.length;this.size.width=state.width;this.size.height=state.height;this.selectedState=selected;this.hoverState=hover;this.labelDirty=false;}/**
     * Check if this label is visible
     *
     * @returns {boolean} true if this label will be show, false otherwise
     */},{key:"visible",value:function visible(){if(this.size.width===0||this.size.height===0||this.elementOptions.label===undefined){return false;// nothing to display
}var viewFontSize=this.fontOptions.size*this.body.view.scale;if(viewFontSize<this.elementOptions.scaling.label.drawThreshold-1){return false;// Too small or too far away to show
}return true;}}],[{key:"parseFontString",value:function parseFontString(outOptions,inOptions){if(!inOptions||typeof inOptions!=="string")return false;var newOptionsArray=inOptions.split(" ");outOptions.size=+newOptionsArray[0].replace("px","");outOptions.face=newOptionsArray[1];outOptions.color=newOptionsArray[2];return true;}}]);return Label;}();/**
 * The Base class for all Nodes.
 */var NodeBase=/*#__PURE__*/function(){/**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */function NodeBase(options,body,labelModule){_classCallCheck(this,NodeBase);this.body=body;this.labelModule=labelModule;this.setOptions(options);this.top=undefined;this.left=undefined;this.height=undefined;this.width=undefined;this.radius=undefined;this.margin=undefined;this.refreshNeeded=true;this.boundingBox={top:0,left:0,right:0,bottom:0};}/**
   *
   * @param {object} options
   */_createClass(NodeBase,[{key:"setOptions",value:function setOptions(options){this.options=options;}/**
     *
     * @param {Label} labelModule
     * @private
     */},{key:"_setMargins",value:function _setMargins(labelModule){this.margin={};if(this.options.margin){if(_typeof(this.options.margin)=="object"){this.margin.top=this.options.margin.top;this.margin.right=this.options.margin.right;this.margin.bottom=this.options.margin.bottom;this.margin.left=this.options.margin.left;}else{this.margin.top=this.options.margin;this.margin.right=this.options.margin;this.margin.bottom=this.options.margin;this.margin.left=this.options.margin;}}labelModule.adjustSizes(this.margin);}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     * @private
     */},{key:"_distanceToBorder",value:function _distanceToBorder(ctx,angle){var borderWidth=this.options.borderWidth;if(ctx){this.resize(ctx);}return Math.min(Math.abs(this.width/2/Math.cos(angle)),Math.abs(this.height/2/Math.sin(angle)))+borderWidth;}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */},{key:"enableShadow",value:function enableShadow(ctx,values){if(values.shadow){ctx.shadowColor=values.shadowColor;ctx.shadowBlur=values.shadowSize;ctx.shadowOffsetX=values.shadowX;ctx.shadowOffsetY=values.shadowY;}}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */},{key:"disableShadow",value:function disableShadow(ctx,values){if(values.shadow){ctx.shadowColor="rgba(0,0,0,0)";ctx.shadowBlur=0;ctx.shadowOffsetX=0;ctx.shadowOffsetY=0;}}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */},{key:"enableBorderDashes",value:function enableBorderDashes(ctx,values){if(values.borderDashes!==false){if(ctx.setLineDash!==undefined){var dashes=values.borderDashes;if(dashes===true){dashes=[5,15];}ctx.setLineDash(dashes);}else{console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used.");this.options.shapeProperties.borderDashes=false;values.borderDashes=false;}}}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */},{key:"disableBorderDashes",value:function disableBorderDashes(ctx,values){if(values.borderDashes!==false){if(ctx.setLineDash!==undefined){ctx.setLineDash([0]);}else{console.warn("setLineDash is not supported in this browser. The dashed borders cannot be used.");this.options.shapeProperties.borderDashes=false;values.borderDashes=false;}}}/**
     * Determine if the shape of a node needs to be recalculated.
     *
     * @param {boolean} selected
     * @param {boolean} hover
     * @returns {boolean}
     * @protected
     */},{key:"needsRefresh",value:function needsRefresh(selected,hover){if(this.refreshNeeded===true){// This is probably not the best location to reset this member.
// However, in the current logic, it is the most convenient one.
this.refreshNeeded=false;return true;}return this.width===undefined||this.labelModule.differentState(selected,hover);}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */},{key:"initContextForDraw",value:function initContextForDraw(ctx,values){var borderWidth=values.borderWidth/this.body.view.scale;ctx.lineWidth=Math.min(this.width,borderWidth);ctx.strokeStyle=values.borderColor;ctx.fillStyle=values.color;}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */},{key:"performStroke",value:function performStroke(ctx,values){var borderWidth=values.borderWidth/this.body.view.scale;//draw dashed border if enabled, save and restore is required for firefox not to crash on unix.
ctx.save();// if borders are zero width, they will be drawn with width 1 by default. This prevents that
if(borderWidth>0){this.enableBorderDashes(ctx,values);//draw the border
ctx.stroke();//disable dashed border for other elements
this.disableBorderDashes(ctx,values);}ctx.restore();}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     */},{key:"performFill",value:function performFill(ctx,values){ctx.save();ctx.fillStyle=values.color;// draw shadow if enabled
this.enableShadow(ctx,values);// draw the background
fill(ctx).call(ctx);// disable shadows for other elements.
this.disableShadow(ctx,values);ctx.restore();this.performStroke(ctx,values);}/**
     *
     * @param {number} margin
     * @private
     */},{key:"_addBoundingBoxMargin",value:function _addBoundingBoxMargin(margin){this.boundingBox.left-=margin;this.boundingBox.top-=margin;this.boundingBox.bottom+=margin;this.boundingBox.right+=margin;}/**
     * Actual implementation of this method call.
     *
     * Doing it like this makes it easier to override
     * in the child classes.
     *
     * @param {number} x width
     * @param {number} y height
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     * @private
     */},{key:"_updateBoundingBox",value:function _updateBoundingBox(x,y,ctx,selected,hover){if(ctx!==undefined){this.resize(ctx,selected,hover);}this.left=x-this.width/2;this.top=y-this.height/2;this.boundingBox.left=this.left;this.boundingBox.top=this.top;this.boundingBox.bottom=this.top+this.height;this.boundingBox.right=this.left+this.width;}/**
     * Default implementation of this method call.
     * This acts as a stub which can be overridden.
     *
     * @param {number} x width
     * @param {number} y height
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     */},{key:"updateBoundingBox",value:function updateBoundingBox(x,y,ctx,selected,hover){this._updateBoundingBox(x,y,ctx,selected,hover);}/**
     * Determine the dimensions to use for nodes with an internal label
     *
     * Currently, these are: Circle, Ellipse, Database, Box
     * The other nodes have external labels, and will not call this method
     *
     * If there is no label, decent default values are supplied.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} [selected]
     * @param {boolean} [hover]
     * @returns {{width:number, height:number}}
     */},{key:"getDimensionsFromLabel",value:function getDimensionsFromLabel(ctx,selected,hover){// NOTE: previously 'textSize' was not put in 'this' for Ellipse
// TODO: examine the consequences.
this.textSize=this.labelModule.getTextSize(ctx,selected,hover);var width=this.textSize.width;var height=this.textSize.height;var DEFAULT_SIZE=14;if(width===0){// This happens when there is no label text set
width=DEFAULT_SIZE;// use a decent default
height=DEFAULT_SIZE;// if width zero, then height also always zero
}return{width:width,height:height};}}]);return NodeBase;}();function _createSuper$s(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$s();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$s(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * A Box Node/Cluster shape.
 *
 * @augments NodeBase
 */var Box$1=/*#__PURE__*/function(_NodeBase){_inherits(Box,_NodeBase);var _super=_createSuper$s(Box);/**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */function Box(options,body,labelModule){var _this;_classCallCheck(this,Box);_this=_super.call(this,options,body,labelModule);_this._setMargins(labelModule);return _this;}/**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */_createClass(Box,[{key:"resize",value:function resize(ctx){var selected=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.selected;var hover=arguments.length>2&&arguments[2]!==undefined?arguments[2]:this.hover;if(this.needsRefresh(selected,hover)){var dimensions=this.getDimensionsFromLabel(ctx,selected,hover);this.width=dimensions.width+this.margin.right+this.margin.left;this.height=dimensions.height+this.margin.top+this.margin.bottom;this.radius=this.width/2;}}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */},{key:"draw",value:function draw(ctx,x,y,selected,hover,values){this.resize(ctx,selected,hover);this.left=x-this.width/2;this.top=y-this.height/2;this.initContextForDraw(ctx,values);drawRoundRect(ctx,this.left,this.top,this.width,this.height,values.borderRadius);this.performFill(ctx,values);this.updateBoundingBox(x,y,ctx,selected,hover);this.labelModule.draw(ctx,this.left+this.textSize.width/2+this.margin.left,this.top+this.textSize.height/2+this.margin.top,selected,hover);}/**
     *
     * @param {number} x width
     * @param {number} y height
     * @param {CanvasRenderingContext2D} ctx
     * @param {boolean} selected
     * @param {boolean} hover
     */},{key:"updateBoundingBox",value:function updateBoundingBox(x,y,ctx,selected,hover){this._updateBoundingBox(x,y,ctx,selected,hover);var borderRadius=this.options.shapeProperties.borderRadius;// only effective for box
this._addBoundingBoxMargin(borderRadius);}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */},{key:"distanceToBorder",value:function distanceToBorder(ctx,angle){if(ctx){this.resize(ctx);}var borderWidth=this.options.borderWidth;return Math.min(Math.abs(this.width/2/Math.cos(angle)),Math.abs(this.height/2/Math.sin(angle)))+borderWidth;}}]);return Box;}(NodeBase);function _createSuper$r(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$r();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$r(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * NOTE: This is a bad base class
 *
 * Child classes are:
 *
 *   Image       - uses *only* image methods
 *   Circle      - uses *only* _drawRawCircle
 *   CircleImage - uses all
 *
 * TODO: Refactor, move _drawRawCircle to different module, derive Circle from NodeBase
 *       Rename this to ImageBase
 *       Consolidate common code in Image and CircleImage to base class
 *
 * @augments NodeBase
 */var CircleImageBase=/*#__PURE__*/function(_NodeBase){_inherits(CircleImageBase,_NodeBase);var _super=_createSuper$r(CircleImageBase);/**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */function CircleImageBase(options,body,labelModule){var _this;_classCallCheck(this,CircleImageBase);_this=_super.call(this,options,body,labelModule);_this.labelOffset=0;_this.selected=false;return _this;}/**
   *
   * @param {object} options
   * @param {object} [imageObj]
   * @param {object} [imageObjAlt]
   */_createClass(CircleImageBase,[{key:"setOptions",value:function setOptions(options,imageObj,imageObjAlt){this.options=options;if(!(imageObj===undefined&&imageObjAlt===undefined)){this.setImages(imageObj,imageObjAlt);}}/**
     * Set the images for this node.
     *
     * The images can be updated after the initial setting of options;
     * therefore, this method needs to be reentrant.
     *
     * For correct working in error cases, it is necessary to properly set
     * field 'nodes.brokenImage' in the options.
     *
     * @param {Image} imageObj  required; main image to show for this node
     * @param {Image|undefined} imageObjAlt optional; image to show when node is selected
     */},{key:"setImages",value:function setImages(imageObj,imageObjAlt){if(imageObjAlt&&this.selected){this.imageObj=imageObjAlt;this.imageObjAlt=imageObj;}else{this.imageObj=imageObj;this.imageObjAlt=imageObjAlt;}}/**
     * Set selection and switch between the base and the selected image.
     *
     * Do the switch only if imageObjAlt exists.
     *
     * @param {boolean} selected value of new selected state for current node
     */},{key:"switchImages",value:function switchImages(selected){var selection_changed=selected&&!this.selected||!selected&&this.selected;this.selected=selected;// Remember new selection
if(this.imageObjAlt!==undefined&&selection_changed){var imageTmp=this.imageObj;this.imageObj=this.imageObjAlt;this.imageObjAlt=imageTmp;}}/**
     * Returns Image Padding from node options
     *
     * @returns {{top: number,left: number,bottom: number,right: number}} image padding inside this shape
     * @private
     */},{key:"_getImagePadding",value:function _getImagePadding(){var imgPadding={top:0,right:0,bottom:0,left:0};if(this.options.imagePadding){var optImgPadding=this.options.imagePadding;if(_typeof(optImgPadding)=="object"){imgPadding.top=optImgPadding.top;imgPadding.right=optImgPadding.right;imgPadding.bottom=optImgPadding.bottom;imgPadding.left=optImgPadding.left;}else{imgPadding.top=optImgPadding;imgPadding.right=optImgPadding;imgPadding.bottom=optImgPadding;imgPadding.left=optImgPadding;}}return imgPadding;}/**
     * Adjust the node dimensions for a loaded image.
     *
     * Pre: this.imageObj is valid
     */},{key:"_resizeImage",value:function _resizeImage(){var width,height;if(this.options.shapeProperties.useImageSize===false){// Use the size property
var ratio_width=1;var ratio_height=1;// Only calculate the proper ratio if both width and height not zero
if(this.imageObj.width&&this.imageObj.height){if(this.imageObj.width>this.imageObj.height){ratio_width=this.imageObj.width/this.imageObj.height;}else{ratio_height=this.imageObj.height/this.imageObj.width;}}width=this.options.size*2*ratio_width;height=this.options.size*2*ratio_height;}else{// Use the image size with image padding
var imgPadding=this._getImagePadding();width=this.imageObj.width+imgPadding.left+imgPadding.right;height=this.imageObj.height+imgPadding.top+imgPadding.bottom;}this.width=width;this.height=height;this.radius=0.5*this.width;}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {ArrowOptions} values
     * @private
     */},{key:"_drawRawCircle",value:function _drawRawCircle(ctx,x,y,values){this.initContextForDraw(ctx,values);drawCircle(ctx,x,y,values.size);this.performFill(ctx,values);}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {ArrowOptions} values
     * @private
     */},{key:"_drawImageAtPosition",value:function _drawImageAtPosition(ctx,values){if(this.imageObj.width!=0){// draw the image
ctx.globalAlpha=values.opacity!==undefined?values.opacity:1;// draw shadow if enabled
this.enableShadow(ctx,values);var factor=1;if(this.options.shapeProperties.interpolation===true){factor=this.imageObj.width/this.width/this.body.view.scale;}var imgPadding=this._getImagePadding();var imgPosLeft=this.left+imgPadding.left;var imgPosTop=this.top+imgPadding.top;var imgWidth=this.width-imgPadding.left-imgPadding.right;var imgHeight=this.height-imgPadding.top-imgPadding.bottom;this.imageObj.drawImageAtPosition(ctx,factor,imgPosLeft,imgPosTop,imgWidth,imgHeight);// disable shadows for other elements.
this.disableShadow(ctx,values);}}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @private
     */},{key:"_drawImageLabel",value:function _drawImageLabel(ctx,x,y,selected,hover){var offset=0;if(this.height!==undefined){offset=this.height*0.5;var labelDimensions=this.labelModule.getTextSize(ctx,selected,hover);if(labelDimensions.lineCount>=1){offset+=labelDimensions.height/2;}}var yLabel=y+offset;if(this.options.label){this.labelOffset=offset;}this.labelModule.draw(ctx,x,yLabel,selected,hover,"hanging");}}]);return CircleImageBase;}(NodeBase);function _createSuper$q(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$q();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$q(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * A Circle Node/Cluster shape.
 *
 * @augments CircleImageBase
 */var Circle$1=/*#__PURE__*/function(_CircleImageBase){_inherits(Circle,_CircleImageBase);var _super=_createSuper$q(Circle);/**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */function Circle(options,body,labelModule){var _this;_classCallCheck(this,Circle);_this=_super.call(this,options,body,labelModule);_this._setMargins(labelModule);return _this;}/**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */_createClass(Circle,[{key:"resize",value:function resize(ctx){var selected=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.selected;var hover=arguments.length>2&&arguments[2]!==undefined?arguments[2]:this.hover;if(this.needsRefresh(selected,hover)){var dimensions=this.getDimensionsFromLabel(ctx,selected,hover);var diameter=Math.max(dimensions.width+this.margin.right+this.margin.left,dimensions.height+this.margin.top+this.margin.bottom);this.options.size=diameter/2;// NOTE: this size field only set here, not in Ellipse, Database, Box
this.width=diameter;this.height=diameter;this.radius=this.width/2;}}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */},{key:"draw",value:function draw(ctx,x,y,selected,hover,values){this.resize(ctx,selected,hover);this.left=x-this.width/2;this.top=y-this.height/2;this._drawRawCircle(ctx,x,y,values);this.updateBoundingBox(x,y);this.labelModule.draw(ctx,this.left+this.textSize.width/2+this.margin.left,y,selected,hover);}/**
     *
     * @param {number} x width
     * @param {number} y height
     */},{key:"updateBoundingBox",value:function updateBoundingBox(x,y){this.boundingBox.top=y-this.options.size;this.boundingBox.left=x-this.options.size;this.boundingBox.right=x+this.options.size;this.boundingBox.bottom=y+this.options.size;}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @returns {number}
     */},{key:"distanceToBorder",value:function distanceToBorder(ctx){if(ctx){this.resize(ctx);}return this.width*0.5;}}]);return Circle;}(CircleImageBase);function _createSuper$p(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$p();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$p(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * A CircularImage Node/Cluster shape.
 *
 * @augments CircleImageBase
 */var CircularImage=/*#__PURE__*/function(_CircleImageBase){_inherits(CircularImage,_CircleImageBase);var _super=_createSuper$p(CircularImage);/**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   * @param {Image} imageObj
   * @param {Image} imageObjAlt
   */function CircularImage(options,body,labelModule,imageObj,imageObjAlt){var _this;_classCallCheck(this,CircularImage);_this=_super.call(this,options,body,labelModule);_this.setImages(imageObj,imageObjAlt);return _this;}/**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */_createClass(CircularImage,[{key:"resize",value:function resize(ctx){var selected=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.selected;var hover=arguments.length>2&&arguments[2]!==undefined?arguments[2]:this.hover;var imageAbsent=this.imageObj.src===undefined||this.imageObj.width===undefined||this.imageObj.height===undefined;if(imageAbsent){var diameter=this.options.size*2;this.width=diameter;this.height=diameter;this.radius=0.5*this.width;return;}// At this point, an image is present, i.e. this.imageObj is valid.
if(this.needsRefresh(selected,hover)){this._resizeImage();}}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */},{key:"draw",value:function draw(ctx,x,y,selected,hover,values){this.switchImages(selected);this.resize();var labelX=x,labelY=y;if(this.options.shapeProperties.coordinateOrigin==="top-left"){this.left=x;this.top=y;labelX+=this.width/2;labelY+=this.height/2;}else{this.left=x-this.width/2;this.top=y-this.height/2;}// draw the background circle. IMPORTANT: the stroke in this method is used by the clip method below.
this._drawRawCircle(ctx,labelX,labelY,values);// now we draw in the circle, we save so we can revert the clip operation after drawing.
ctx.save();// clip is used to use the stroke in drawRawCircle as an area that we can draw in.
ctx.clip();// draw the image
this._drawImageAtPosition(ctx,values);// restore so we can again draw on the full canvas
ctx.restore();this._drawImageLabel(ctx,labelX,labelY,selected,hover);this.updateBoundingBox(x,y);}// TODO: compare with Circle.updateBoundingBox(), consolidate? More stuff is happening here
/**
     *
     * @param {number} x width
     * @param {number} y height
     */},{key:"updateBoundingBox",value:function updateBoundingBox(x,y){if(this.options.shapeProperties.coordinateOrigin==="top-left"){this.boundingBox.top=y;this.boundingBox.left=x;this.boundingBox.right=x+this.options.size*2;this.boundingBox.bottom=y+this.options.size*2;}else{this.boundingBox.top=y-this.options.size;this.boundingBox.left=x-this.options.size;this.boundingBox.right=x+this.options.size;this.boundingBox.bottom=y+this.options.size;}// TODO: compare with Image.updateBoundingBox(), consolidate?
this.boundingBox.left=Math.min(this.boundingBox.left,this.labelModule.size.left);this.boundingBox.right=Math.max(this.boundingBox.right,this.labelModule.size.left+this.labelModule.size.width);this.boundingBox.bottom=Math.max(this.boundingBox.bottom,this.boundingBox.bottom+this.labelOffset);}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @returns {number}
     */},{key:"distanceToBorder",value:function distanceToBorder(ctx){if(ctx){this.resize(ctx);}return this.width*0.5;}}]);return CircularImage;}(CircleImageBase);function _createSuper$o(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$o();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$o(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * Base class for constructing Node/Cluster Shapes.
 *
 * @augments NodeBase
 */var ShapeBase=/*#__PURE__*/function(_NodeBase){_inherits(ShapeBase,_NodeBase);var _super=_createSuper$o(ShapeBase);/**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */function ShapeBase(options,body,labelModule){_classCallCheck(this,ShapeBase);return _super.call(this,options,body,labelModule);}/**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   * @param {object} [values={size: this.options.size}]
   */_createClass(ShapeBase,[{key:"resize",value:function resize(ctx){var selected=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.selected;var hover=arguments.length>2&&arguments[2]!==undefined?arguments[2]:this.hover;var values=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{size:this.options.size};if(this.needsRefresh(selected,hover)){var _this$customSizeWidth,_this$customSizeHeigh;this.labelModule.getTextSize(ctx,selected,hover);var size=2*values.size;this.width=(_this$customSizeWidth=this.customSizeWidth)!==null&&_this$customSizeWidth!==void 0?_this$customSizeWidth:size;this.height=(_this$customSizeHeigh=this.customSizeHeight)!==null&&_this$customSizeHeigh!==void 0?_this$customSizeHeigh:size;this.radius=0.5*this.width;}}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {string} shape
     * @param {number} sizeMultiplier - Unused! TODO: Remove next major release
     * @param {number} x
     * @param {number} y
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     * @private
     *
     * @returns {object} Callbacks to draw later on higher layers.
     */},{key:"_drawShape",value:function _drawShape(ctx,shape,sizeMultiplier,x,y,selected,hover,values){var _this=this;this.resize(ctx,selected,hover,values);this.left=x-this.width/2;this.top=y-this.height/2;this.initContextForDraw(ctx,values);getShape(shape)(ctx,x,y,values.size);this.performFill(ctx,values);if(this.options.icon!==undefined){if(this.options.icon.code!==undefined){ctx.font=(selected?"bold ":"")+this.height/2+"px "+(this.options.icon.face||"FontAwesome");ctx.fillStyle=this.options.icon.color||"black";ctx.textAlign="center";ctx.textBaseline="middle";ctx.fillText(this.options.icon.code,x,y);}}return{drawExternalLabel:function drawExternalLabel(){if(_this.options.label!==undefined){// Need to call following here in order to ensure value for
// `this.labelModule.size.height`.
_this.labelModule.calculateLabelSize(ctx,selected,hover,x,y,"hanging");var yLabel=y+0.5*_this.height+0.5*_this.labelModule.size.height;_this.labelModule.draw(ctx,x,yLabel,selected,hover,"hanging");}_this.updateBoundingBox(x,y);}};}/**
     *
     * @param {number} x
     * @param {number} y
     */},{key:"updateBoundingBox",value:function updateBoundingBox(x,y){this.boundingBox.top=y-this.options.size;this.boundingBox.left=x-this.options.size;this.boundingBox.right=x+this.options.size;this.boundingBox.bottom=y+this.options.size;if(this.options.label!==undefined&&this.labelModule.size.width>0){this.boundingBox.left=Math.min(this.boundingBox.left,this.labelModule.size.left);this.boundingBox.right=Math.max(this.boundingBox.right,this.labelModule.size.left+this.labelModule.size.width);this.boundingBox.bottom=Math.max(this.boundingBox.bottom,this.boundingBox.bottom+this.labelModule.size.height);}}}]);return ShapeBase;}(NodeBase);function ownKeys$3(object,enumerableOnly){var keys=keys$3(object);if(getOwnPropertySymbols){var symbols=getOwnPropertySymbols(object);if(enumerableOnly){symbols=filter(symbols).call(symbols,function(sym){return getOwnPropertyDescriptor$2(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread$3(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){var _context;forEach$2(_context=ownKeys$3(Object(source),true)).call(_context,function(key){_defineProperty(target,key,source[key]);});}else if(getOwnPropertyDescriptors){defineProperties(target,getOwnPropertyDescriptors(source));}else{var _context2;forEach$2(_context2=ownKeys$3(Object(source))).call(_context2,function(key){defineProperty$4(target,key,getOwnPropertyDescriptor$2(source,key));});}}return target;}function _createSuper$n(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$n();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$n(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * A CustomShape Node/Cluster shape.
 *
 * @augments ShapeBase
 */var CustomShape=/*#__PURE__*/function(_ShapeBase){_inherits(CustomShape,_ShapeBase);var _super=_createSuper$n(CustomShape);/**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   * @param {Function} ctxRenderer
   
   */function CustomShape(options,body,labelModule,ctxRenderer){var _this;_classCallCheck(this,CustomShape);_this=_super.call(this,options,body,labelModule,ctxRenderer);_this.ctxRenderer=ctxRenderer;return _this;}/**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   *
   * @returns {object} Callbacks to draw later on different layers.
   */_createClass(CustomShape,[{key:"draw",value:function draw(ctx,x,y,selected,hover,values){this.resize(ctx,selected,hover,values);this.left=x-this.width/2;this.top=y-this.height/2;// Guard right away because someone may just draw in the function itself.
ctx.save();var drawLater=this.ctxRenderer({ctx:ctx,id:this.options.id,x:x,y:y,state:{selected:selected,hover:hover},style:_objectSpread$3({},values),label:this.options.label});// Render the node shape bellow arrows.
if(drawLater.drawNode!=null){drawLater.drawNode();}ctx.restore();if(drawLater.drawExternalLabel){// Guard the external label (above arrows) drawing function.
var drawExternalLabel=drawLater.drawExternalLabel;drawLater.drawExternalLabel=function(){ctx.save();drawExternalLabel();ctx.restore();};}if(drawLater.nodeDimensions){this.customSizeWidth=drawLater.nodeDimensions.width;this.customSizeHeight=drawLater.nodeDimensions.height;}return drawLater;}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */},{key:"distanceToBorder",value:function distanceToBorder(ctx,angle){return this._distanceToBorder(ctx,angle);}}]);return CustomShape;}(ShapeBase);function _createSuper$m(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$m();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$m(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * A Database Node/Cluster shape.
 *
 * @augments NodeBase
 */var Database=/*#__PURE__*/function(_NodeBase){_inherits(Database,_NodeBase);var _super=_createSuper$m(Database);/**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */function Database(options,body,labelModule){var _this;_classCallCheck(this,Database);_this=_super.call(this,options,body,labelModule);_this._setMargins(labelModule);return _this;}/**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} selected
   * @param {boolean} hover
   */_createClass(Database,[{key:"resize",value:function resize(ctx,selected,hover){if(this.needsRefresh(selected,hover)){var dimensions=this.getDimensionsFromLabel(ctx,selected,hover);var size=dimensions.width+this.margin.right+this.margin.left;this.width=size;this.height=size;this.radius=this.width/2;}}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */},{key:"draw",value:function draw(ctx,x,y,selected,hover,values){this.resize(ctx,selected,hover);this.left=x-this.width/2;this.top=y-this.height/2;this.initContextForDraw(ctx,values);drawDatabase(ctx,x-this.width/2,y-this.height/2,this.width,this.height);this.performFill(ctx,values);this.updateBoundingBox(x,y,ctx,selected,hover);this.labelModule.draw(ctx,this.left+this.textSize.width/2+this.margin.left,this.top+this.textSize.height/2+this.margin.top,selected,hover);}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */},{key:"distanceToBorder",value:function distanceToBorder(ctx,angle){return this._distanceToBorder(ctx,angle);}}]);return Database;}(NodeBase);function _createSuper$l(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$l();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$l(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * A Diamond Node/Cluster shape.
 *
 * @augments ShapeBase
 */var Diamond$1=/*#__PURE__*/function(_ShapeBase){_inherits(Diamond,_ShapeBase);var _super=_createSuper$l(Diamond);/**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */function Diamond(options,body,labelModule){_classCallCheck(this,Diamond);return _super.call(this,options,body,labelModule);}/**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   *
   * @returns {object} Callbacks to draw later on higher layers.
   */_createClass(Diamond,[{key:"draw",value:function draw(ctx,x,y,selected,hover,values){return this._drawShape(ctx,"diamond",4,x,y,selected,hover,values);}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */},{key:"distanceToBorder",value:function distanceToBorder(ctx,angle){return this._distanceToBorder(ctx,angle);}}]);return Diamond;}(ShapeBase);function _createSuper$k(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$k();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$k(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * A Dot Node/Cluster shape.
 *
 * @augments ShapeBase
 */var Dot=/*#__PURE__*/function(_ShapeBase){_inherits(Dot,_ShapeBase);var _super=_createSuper$k(Dot);/**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */function Dot(options,body,labelModule){_classCallCheck(this,Dot);return _super.call(this,options,body,labelModule);}/**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   *
   * @returns {object} Callbacks to draw later on higher layers.
   */_createClass(Dot,[{key:"draw",value:function draw(ctx,x,y,selected,hover,values){return this._drawShape(ctx,"circle",2,x,y,selected,hover,values);}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @returns {number}
     */},{key:"distanceToBorder",value:function distanceToBorder(ctx){if(ctx){this.resize(ctx);}return this.options.size;}}]);return Dot;}(ShapeBase);function _createSuper$j(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$j();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$j(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * Am Ellipse Node/Cluster shape.
 *
 * @augments NodeBase
 */var Ellipse=/*#__PURE__*/function(_NodeBase){_inherits(Ellipse,_NodeBase);var _super=_createSuper$j(Ellipse);/**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */function Ellipse(options,body,labelModule){_classCallCheck(this,Ellipse);return _super.call(this,options,body,labelModule);}/**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */_createClass(Ellipse,[{key:"resize",value:function resize(ctx){var selected=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.selected;var hover=arguments.length>2&&arguments[2]!==undefined?arguments[2]:this.hover;if(this.needsRefresh(selected,hover)){var dimensions=this.getDimensionsFromLabel(ctx,selected,hover);this.height=dimensions.height*2;this.width=dimensions.width+dimensions.height;this.radius=0.5*this.width;}}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */},{key:"draw",value:function draw(ctx,x,y,selected,hover,values){this.resize(ctx,selected,hover);this.left=x-this.width*0.5;this.top=y-this.height*0.5;this.initContextForDraw(ctx,values);drawEllipse(ctx,this.left,this.top,this.width,this.height);this.performFill(ctx,values);this.updateBoundingBox(x,y,ctx,selected,hover);this.labelModule.draw(ctx,x,y,selected,hover);}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */},{key:"distanceToBorder",value:function distanceToBorder(ctx,angle){if(ctx){this.resize(ctx);}var a=this.width*0.5;var b=this.height*0.5;var w=Math.sin(angle)*a;var h=Math.cos(angle)*b;return a*b/Math.sqrt(w*w+h*h);}}]);return Ellipse;}(NodeBase);function _createSuper$i(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$i();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$i(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * An icon replacement for the default Node shape.
 *
 * @augments NodeBase
 */var Icon=/*#__PURE__*/function(_NodeBase){_inherits(Icon,_NodeBase);var _super=_createSuper$i(Icon);/**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */function Icon(options,body,labelModule){var _this;_classCallCheck(this,Icon);_this=_super.call(this,options,body,labelModule);_this._setMargins(labelModule);return _this;}/**
   *
   * @param {CanvasRenderingContext2D} ctx - Unused.
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */_createClass(Icon,[{key:"resize",value:function resize(ctx,selected,hover){if(this.needsRefresh(selected,hover)){this.iconSize={width:Number(this.options.icon.size),height:Number(this.options.icon.size)};this.width=this.iconSize.width+this.margin.right+this.margin.left;this.height=this.iconSize.height+this.margin.top+this.margin.bottom;this.radius=0.5*this.width;}}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     *
     * @returns {object} Callbacks to draw later on higher layers.
     */},{key:"draw",value:function draw(ctx,x,y,selected,hover,values){var _this2=this;this.resize(ctx,selected,hover);this.options.icon.size=this.options.icon.size||50;this.left=x-this.width/2;this.top=y-this.height/2;this._icon(ctx,x,y,selected,hover,values);return{drawExternalLabel:function drawExternalLabel(){if(_this2.options.label!==undefined){var iconTextSpacing=5;_this2.labelModule.draw(ctx,_this2.left+_this2.iconSize.width/2+_this2.margin.left,y+_this2.height/2+iconTextSpacing,selected);}_this2.updateBoundingBox(x,y);}};}/**
     *
     * @param {number} x
     * @param {number} y
     */},{key:"updateBoundingBox",value:function updateBoundingBox(x,y){this.boundingBox.top=y-this.options.icon.size*0.5;this.boundingBox.left=x-this.options.icon.size*0.5;this.boundingBox.right=x+this.options.icon.size*0.5;this.boundingBox.bottom=y+this.options.icon.size*0.5;if(this.options.label!==undefined&&this.labelModule.size.width>0){var iconTextSpacing=5;this.boundingBox.left=Math.min(this.boundingBox.left,this.labelModule.size.left);this.boundingBox.right=Math.max(this.boundingBox.right,this.labelModule.size.left+this.labelModule.size.width);this.boundingBox.bottom=Math.max(this.boundingBox.bottom,this.boundingBox.bottom+this.labelModule.size.height+iconTextSpacing);}}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover - Unused
     * @param {ArrowOptions} values
     */},{key:"_icon",value:function _icon(ctx,x,y,selected,hover,values){var iconSize=Number(this.options.icon.size);if(this.options.icon.code!==undefined){ctx.font=[this.options.icon.weight!=null?this.options.icon.weight:selected?"bold":"",// If the weight is forced (for example to make Font Awesome 5 work
// properly) substitute slightly bigger size for bold font face.
(this.options.icon.weight!=null&&selected?5:0)+iconSize+"px",this.options.icon.face].join(" ");// draw icon
ctx.fillStyle=this.options.icon.color||"black";ctx.textAlign="center";ctx.textBaseline="middle";// draw shadow if enabled
this.enableShadow(ctx,values);ctx.fillText(this.options.icon.code,x,y);// disable shadows for other elements.
this.disableShadow(ctx,values);}else{console.error("When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.");}}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */},{key:"distanceToBorder",value:function distanceToBorder(ctx,angle){return this._distanceToBorder(ctx,angle);}}]);return Icon;}(NodeBase);function _createSuper$h(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$h();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$h(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * An image-based replacement for the default Node shape.
 *
 * @augments CircleImageBase
 */var Image$2=/*#__PURE__*/function(_CircleImageBase){_inherits(Image,_CircleImageBase);var _super=_createSuper$h(Image);/**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   * @param {Image} imageObj
   * @param {Image} imageObjAlt
   */function Image(options,body,labelModule,imageObj,imageObjAlt){var _this;_classCallCheck(this,Image);_this=_super.call(this,options,body,labelModule);_this.setImages(imageObj,imageObjAlt);return _this;}/**
   *
   * @param {CanvasRenderingContext2D} ctx - Unused.
   * @param {boolean} [selected]
   * @param {boolean} [hover]
   */_createClass(Image,[{key:"resize",value:function resize(ctx){var selected=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.selected;var hover=arguments.length>2&&arguments[2]!==undefined?arguments[2]:this.hover;var imageAbsent=this.imageObj.src===undefined||this.imageObj.width===undefined||this.imageObj.height===undefined;if(imageAbsent){var side=this.options.size*2;this.width=side;this.height=side;return;}if(this.needsRefresh(selected,hover)){this._resizeImage();}}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */},{key:"draw",value:function draw(ctx,x,y,selected,hover,values){ctx.save();this.switchImages(selected);this.resize();var labelX=x,labelY=y;if(this.options.shapeProperties.coordinateOrigin==="top-left"){this.left=x;this.top=y;labelX+=this.width/2;labelY+=this.height/2;}else{this.left=x-this.width/2;this.top=y-this.height/2;}if(this.options.shapeProperties.useBorderWithImage===true){var neutralborderWidth=this.options.borderWidth;var selectionLineWidth=this.options.borderWidthSelected||2*this.options.borderWidth;var borderWidth=(selected?selectionLineWidth:neutralborderWidth)/this.body.view.scale;ctx.lineWidth=Math.min(this.width,borderWidth);ctx.beginPath();var strokeStyle=selected?this.options.color.highlight.border:hover?this.options.color.hover.border:this.options.color.border;var fillStyle=selected?this.options.color.highlight.background:hover?this.options.color.hover.background:this.options.color.background;if(values.opacity!==undefined){strokeStyle=overrideOpacity(strokeStyle,values.opacity);fillStyle=overrideOpacity(fillStyle,values.opacity);}// setup the line properties.
ctx.strokeStyle=strokeStyle;// set a fillstyle
ctx.fillStyle=fillStyle;// draw a rectangle to form the border around. This rectangle is filled so the opacity of a picture (in future vis releases?) can be used to tint the image
ctx.rect(this.left-0.5*ctx.lineWidth,this.top-0.5*ctx.lineWidth,this.width+ctx.lineWidth,this.height+ctx.lineWidth);fill(ctx).call(ctx);this.performStroke(ctx,values);ctx.closePath();}this._drawImageAtPosition(ctx,values);this._drawImageLabel(ctx,labelX,labelY,selected,hover);this.updateBoundingBox(x,y);ctx.restore();}/**
     *
     * @param {number} x
     * @param {number} y
     */},{key:"updateBoundingBox",value:function updateBoundingBox(x,y){this.resize();if(this.options.shapeProperties.coordinateOrigin==="top-left"){this.left=x;this.top=y;}else{this.left=x-this.width/2;this.top=y-this.height/2;}this.boundingBox.left=this.left;this.boundingBox.top=this.top;this.boundingBox.bottom=this.top+this.height;this.boundingBox.right=this.left+this.width;if(this.options.label!==undefined&&this.labelModule.size.width>0){this.boundingBox.left=Math.min(this.boundingBox.left,this.labelModule.size.left);this.boundingBox.right=Math.max(this.boundingBox.right,this.labelModule.size.left+this.labelModule.size.width);this.boundingBox.bottom=Math.max(this.boundingBox.bottom,this.boundingBox.bottom+this.labelOffset);}}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */},{key:"distanceToBorder",value:function distanceToBorder(ctx,angle){return this._distanceToBorder(ctx,angle);}}]);return Image;}(CircleImageBase);function _createSuper$g(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$g();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$g(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * A Square Node/Cluster shape.
 *
 * @augments ShapeBase
 */var Square=/*#__PURE__*/function(_ShapeBase){_inherits(Square,_ShapeBase);var _super=_createSuper$g(Square);/**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */function Square(options,body,labelModule){_classCallCheck(this,Square);return _super.call(this,options,body,labelModule);}/**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   *
   * @returns {object} Callbacks to draw later on higher layers.
   */_createClass(Square,[{key:"draw",value:function draw(ctx,x,y,selected,hover,values){return this._drawShape(ctx,"square",2,x,y,selected,hover,values);}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */},{key:"distanceToBorder",value:function distanceToBorder(ctx,angle){return this._distanceToBorder(ctx,angle);}}]);return Square;}(ShapeBase);function _createSuper$f(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$f();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$f(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * A Hexagon Node/Cluster shape.
 *
 * @augments ShapeBase
 */var Hexagon=/*#__PURE__*/function(_ShapeBase){_inherits(Hexagon,_ShapeBase);var _super=_createSuper$f(Hexagon);/**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */function Hexagon(options,body,labelModule){_classCallCheck(this,Hexagon);return _super.call(this,options,body,labelModule);}/**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   *
   * @returns {object} Callbacks to draw later on higher layers.
   */_createClass(Hexagon,[{key:"draw",value:function draw(ctx,x,y,selected,hover,values){return this._drawShape(ctx,"hexagon",4,x,y,selected,hover,values);}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */},{key:"distanceToBorder",value:function distanceToBorder(ctx,angle){return this._distanceToBorder(ctx,angle);}}]);return Hexagon;}(ShapeBase);function _createSuper$e(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$e();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$e(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * A Star Node/Cluster shape.
 *
 * @augments ShapeBase
 */var Star=/*#__PURE__*/function(_ShapeBase){_inherits(Star,_ShapeBase);var _super=_createSuper$e(Star);/**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */function Star(options,body,labelModule){_classCallCheck(this,Star);return _super.call(this,options,body,labelModule);}/**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x width
   * @param {number} y height
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   *
   * @returns {object} Callbacks to draw later on higher layers.
   */_createClass(Star,[{key:"draw",value:function draw(ctx,x,y,selected,hover,values){return this._drawShape(ctx,"star",4,x,y,selected,hover,values);}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */},{key:"distanceToBorder",value:function distanceToBorder(ctx,angle){return this._distanceToBorder(ctx,angle);}}]);return Star;}(ShapeBase);function _createSuper$d(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$d();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$d(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * A text-based replacement for the default Node shape.
 *
 * @augments NodeBase
 */var Text=/*#__PURE__*/function(_NodeBase){_inherits(Text,_NodeBase);var _super=_createSuper$d(Text);/**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */function Text(options,body,labelModule){var _this;_classCallCheck(this,Text);_this=_super.call(this,options,body,labelModule);_this._setMargins(labelModule);return _this;}/**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {boolean} selected
   * @param {boolean} hover
   */_createClass(Text,[{key:"resize",value:function resize(ctx,selected,hover){if(this.needsRefresh(selected,hover)){this.textSize=this.labelModule.getTextSize(ctx,selected,hover);this.width=this.textSize.width+this.margin.right+this.margin.left;this.height=this.textSize.height+this.margin.top+this.margin.bottom;this.radius=0.5*this.width;}}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} x width
     * @param {number} y height
     * @param {boolean} selected
     * @param {boolean} hover
     * @param {ArrowOptions} values
     */},{key:"draw",value:function draw(ctx,x,y,selected,hover,values){this.resize(ctx,selected,hover);this.left=x-this.width/2;this.top=y-this.height/2;// draw shadow if enabled
this.enableShadow(ctx,values);this.labelModule.draw(ctx,this.left+this.textSize.width/2+this.margin.left,this.top+this.textSize.height/2+this.margin.top,selected,hover);// disable shadows for other elements.
this.disableShadow(ctx,values);this.updateBoundingBox(x,y,ctx,selected,hover);}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */},{key:"distanceToBorder",value:function distanceToBorder(ctx,angle){return this._distanceToBorder(ctx,angle);}}]);return Text;}(NodeBase);function _createSuper$c(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$c();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$c(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * A Triangle Node/Cluster shape.
 *
 * @augments ShapeBase
 */var Triangle$1=/*#__PURE__*/function(_ShapeBase){_inherits(Triangle,_ShapeBase);var _super=_createSuper$c(Triangle);/**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */function Triangle(options,body,labelModule){_classCallCheck(this,Triangle);return _super.call(this,options,body,labelModule);}/**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x
   * @param {number} y
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   *
   * @returns {object} Callbacks to draw later on higher layers.
   */_createClass(Triangle,[{key:"draw",value:function draw(ctx,x,y,selected,hover,values){return this._drawShape(ctx,"triangle",3,x,y,selected,hover,values);}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */},{key:"distanceToBorder",value:function distanceToBorder(ctx,angle){return this._distanceToBorder(ctx,angle);}}]);return Triangle;}(ShapeBase);function _createSuper$b(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$b();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$b(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * A downward facing Triangle Node/Cluster shape.
 *
 * @augments ShapeBase
 */var TriangleDown=/*#__PURE__*/function(_ShapeBase){_inherits(TriangleDown,_ShapeBase);var _super=_createSuper$b(TriangleDown);/**
   * @param {object} options
   * @param {object} body
   * @param {Label} labelModule
   */function TriangleDown(options,body,labelModule){_classCallCheck(this,TriangleDown);return _super.call(this,options,body,labelModule);}/**
   *
   * @param {CanvasRenderingContext2D} ctx
   * @param {number} x
   * @param {number} y
   * @param {boolean} selected
   * @param {boolean} hover
   * @param {ArrowOptions} values
   *
   * @returns {object} Callbacks to draw later on higher layers.
   */_createClass(TriangleDown,[{key:"draw",value:function draw(ctx,x,y,selected,hover,values){return this._drawShape(ctx,"triangleDown",3,x,y,selected,hover,values);}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {number} angle
     * @returns {number}
     */},{key:"distanceToBorder",value:function distanceToBorder(ctx,angle){return this._distanceToBorder(ctx,angle);}}]);return TriangleDown;}(ShapeBase);function ownKeys$2(object,enumerableOnly){var keys=keys$3(object);if(getOwnPropertySymbols){var symbols=getOwnPropertySymbols(object);if(enumerableOnly){symbols=filter(symbols).call(symbols,function(sym){return getOwnPropertyDescriptor$2(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread$2(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){var _context5;forEach$2(_context5=ownKeys$2(Object(source),true)).call(_context5,function(key){_defineProperty(target,key,source[key]);});}else if(getOwnPropertyDescriptors){defineProperties(target,getOwnPropertyDescriptors(source));}else{var _context6;forEach$2(_context6=ownKeys$2(Object(source))).call(_context6,function(key){defineProperty$4(target,key,getOwnPropertyDescriptor$2(source,key));});}}return target;}/**
 * A node. A node can be connected to other nodes via one or multiple edges.
 */var Node=/*#__PURE__*/function(){/**
   *
   * @param {object} options An object containing options for the node. All
   *                            options are optional, except for the id.
   *                              {number} id     Id of the node. Required
   *                              {string} label  Text label for the node
   *                              {number} x      Horizontal position of the node
   *                              {number} y      Vertical position of the node
   *                              {string} shape  Node shape
   *                              {string} image  An image url
   *                              {string} title  A title text, can be HTML
   *                              {anytype} group A group name or number
   *
   * @param {object} body               Shared state of current network instance
   * @param {Network.Images} imagelist  A list with images. Only needed when the node has an image
   * @param {Groups} grouplist          A list with groups. Needed for retrieving group options
   * @param {object} globalOptions      Current global node options; these serve as defaults for the node instance
   * @param {object} defaultOptions     Global default options for nodes; note that this is also the prototype
   *                                    for parameter `globalOptions`.
   */function Node(options,body,imagelist,grouplist,globalOptions,defaultOptions){_classCallCheck(this,Node);this.options=bridgeObject(globalOptions);this.globalOptions=globalOptions;this.defaultOptions=defaultOptions;this.body=body;this.edges=[];// all edges connected to this node
// set defaults for the options
this.id=undefined;this.imagelist=imagelist;this.grouplist=grouplist;// state options
this.x=undefined;this.y=undefined;this.baseSize=this.options.size;this.baseFontSize=this.options.font.size;this.predefinedPosition=false;// used to check if initial fit should just take the range or approximate
this.selected=false;this.hover=false;this.labelModule=new Label(this.body,this.options,false/* Not edge label */);this.setOptions(options);}/**
   * Attach a edge to the node
   *
   * @param {Edge} edge
   */_createClass(Node,[{key:"attachEdge",value:function attachEdge(edge){var _context;if(indexOf(_context=this.edges).call(_context,edge)===-1){this.edges.push(edge);}}/**
     * Detach a edge from the node
     *
     * @param {Edge} edge
     */},{key:"detachEdge",value:function detachEdge(edge){var _context2;var index=indexOf(_context2=this.edges).call(_context2,edge);if(index!=-1){var _context3;splice(_context3=this.edges).call(_context3,index,1);}}/**
     * Set or overwrite options for the node
     *
     * @param {object} options an object with options
     * @returns {null|boolean}
     */},{key:"setOptions",value:function setOptions(options){var currentShape=this.options.shape;if(!options){return;// Note that the return value will be 'undefined'! This is OK.
}// Save the color for later.
// This is necessary in order to prevent local color from being overwritten by group color.
// TODO: To prevent such workarounds the way options are handled should be rewritten from scratch.
// This is not the only problem with current options handling.
if(typeof options.color!=="undefined"){this._localColor=options.color;}// basic options
if(options.id!==undefined){this.id=options.id;}if(this.id===undefined){throw new Error("Node must have an id");}Node.checkMass(options,this.id);// set these options locally
// clear x and y positions
if(options.x!==undefined){if(options.x===null){this.x=undefined;this.predefinedPosition=false;}else{this.x=_parseInt(options.x);this.predefinedPosition=true;}}if(options.y!==undefined){if(options.y===null){this.y=undefined;this.predefinedPosition=false;}else{this.y=_parseInt(options.y);this.predefinedPosition=true;}}if(options.size!==undefined){this.baseSize=options.size;}if(options.value!==undefined){options.value=_parseFloat(options.value);}// this transforms all shorthands into fully defined options
Node.parseOptions(this.options,options,true,this.globalOptions,this.grouplist);var pile=[options,this.options,this.defaultOptions];this.chooser=choosify("node",pile);this._load_images();this.updateLabelModule(options);// Need to set local opacity after `this.updateLabelModule(options);` because `this.updateLabelModule(options);` overrites local opacity with group opacity
if(options.opacity!==undefined&&Node.checkOpacity(options.opacity)){this.options.opacity=options.opacity;}this.updateShape(currentShape);return options.hidden!==undefined||options.physics!==undefined;}/**
     * Load the images from the options, for the nodes that need them.
     *
     * Images are always loaded, even if they are not used in the current shape.
     * The user may switch to an image shape later on.
     *
     * @private
     */},{key:"_load_images",value:function _load_images(){if(this.options.shape==="circularImage"||this.options.shape==="image"){if(this.options.image===undefined){throw new Error("Option image must be defined for node type '"+this.options.shape+"'");}}if(this.options.image===undefined){return;}if(this.imagelist===undefined){throw new Error("Internal Error: No images provided");}if(typeof this.options.image==="string"){this.imageObj=this.imagelist.load(this.options.image,this.options.brokenImage,this.id);}else{if(this.options.image.unselected===undefined){throw new Error("No unselected image provided");}this.imageObj=this.imagelist.load(this.options.image.unselected,this.options.brokenImage,this.id);if(this.options.image.selected!==undefined){this.imageObjAlt=this.imagelist.load(this.options.image.selected,this.options.brokenImage,this.id);}else{this.imageObjAlt=undefined;}}}/**
     * Check that opacity is only between 0 and 1
     *
     * @param {number} opacity
     * @returns {boolean}
     */},{key:"getFormattingValues",value:/**
     *
     * @returns {{color: *, borderWidth: *, borderColor: *, size: *, borderDashes: (boolean|Array|allOptions.nodes.shapeProperties.borderDashes|{boolean, array}), borderRadius: (number|allOptions.nodes.shapeProperties.borderRadius|{number}|Array), shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *}}
     */function getFormattingValues(){var values={color:this.options.color.background,opacity:this.options.opacity,borderWidth:this.options.borderWidth,borderColor:this.options.color.border,size:this.options.size,borderDashes:this.options.shapeProperties.borderDashes,borderRadius:this.options.shapeProperties.borderRadius,shadow:this.options.shadow.enabled,shadowColor:this.options.shadow.color,shadowSize:this.options.shadow.size,shadowX:this.options.shadow.x,shadowY:this.options.shadow.y};if(this.selected||this.hover){if(this.chooser===true){if(this.selected){if(this.options.borderWidthSelected!=null){values.borderWidth=this.options.borderWidthSelected;}else{values.borderWidth*=2;}values.color=this.options.color.highlight.background;values.borderColor=this.options.color.highlight.border;values.shadow=this.options.shadow.enabled;}else if(this.hover){values.color=this.options.color.hover.background;values.borderColor=this.options.color.hover.border;values.shadow=this.options.shadow.enabled;}}else if(typeof this.chooser==="function"){this.chooser(values,this.options.id,this.selected,this.hover);if(values.shadow===false){if(values.shadowColor!==this.options.shadow.color||values.shadowSize!==this.options.shadow.size||values.shadowX!==this.options.shadow.x||values.shadowY!==this.options.shadow.y){values.shadow=true;}}}}else{values.shadow=this.options.shadow.enabled;}if(this.options.opacity!==undefined){var opacity=this.options.opacity;values.borderColor=overrideOpacity(values.borderColor,opacity);values.color=overrideOpacity(values.color,opacity);values.shadowColor=overrideOpacity(values.shadowColor,opacity);}return values;}/**
     *
     * @param {object} options
     */},{key:"updateLabelModule",value:function updateLabelModule(options){if(this.options.label===undefined||this.options.label===null){this.options.label="";}Node.updateGroupOptions(this.options,_objectSpread$2(_objectSpread$2({},options),{},{color:options&&options.color||this._localColor||undefined}),this.grouplist);//
// Note:The prototype chain for this.options is:
//
// this.options ->    NodesHandler.options    -> NodesHandler.defaultOptions
//                 (also: this.globalOptions)
//
// Note that the prototypes are mentioned explicitly in the pile list below;
// WE DON'T WANT THE ORDER OF THE PROTOTYPES!!!! At least, not for font handling of labels.
// This is a good indication that the prototype usage of options is deficient.
//
var currentGroup=this.grouplist.get(this.options.group,false);var pile=[options,// new options
this.options,// current node options, see comment above for prototype
currentGroup,// group options, if any
this.globalOptions,// Currently set global node options
this.defaultOptions// Default global node options
];this.labelModule.update(this.options,pile);if(this.labelModule.baseSize!==undefined){this.baseFontSize=this.labelModule.baseSize;}}/**
     *
     * @param {string} currentShape
     */},{key:"updateShape",value:function updateShape(currentShape){if(currentShape===this.options.shape&&this.shape){this.shape.setOptions(this.options,this.imageObj,this.imageObjAlt);}else{// choose draw method depending on the shape
switch(this.options.shape){case"box":this.shape=new Box$1(this.options,this.body,this.labelModule);break;case"circle":this.shape=new Circle$1(this.options,this.body,this.labelModule);break;case"circularImage":this.shape=new CircularImage(this.options,this.body,this.labelModule,this.imageObj,this.imageObjAlt);break;case"custom":this.shape=new CustomShape(this.options,this.body,this.labelModule,this.options.ctxRenderer);break;case"database":this.shape=new Database(this.options,this.body,this.labelModule);break;case"diamond":this.shape=new Diamond$1(this.options,this.body,this.labelModule);break;case"dot":this.shape=new Dot(this.options,this.body,this.labelModule);break;case"ellipse":this.shape=new Ellipse(this.options,this.body,this.labelModule);break;case"icon":this.shape=new Icon(this.options,this.body,this.labelModule);break;case"image":this.shape=new Image$2(this.options,this.body,this.labelModule,this.imageObj,this.imageObjAlt);break;case"square":this.shape=new Square(this.options,this.body,this.labelModule);break;case"hexagon":this.shape=new Hexagon(this.options,this.body,this.labelModule);break;case"star":this.shape=new Star(this.options,this.body,this.labelModule);break;case"text":this.shape=new Text(this.options,this.body,this.labelModule);break;case"triangle":this.shape=new Triangle$1(this.options,this.body,this.labelModule);break;case"triangleDown":this.shape=new TriangleDown(this.options,this.body,this.labelModule);break;default:this.shape=new Ellipse(this.options,this.body,this.labelModule);break;}}this.needsRefresh();}/**
     * select this node
     */},{key:"select",value:function select(){this.selected=true;this.needsRefresh();}/**
     * unselect this node
     */},{key:"unselect",value:function unselect(){this.selected=false;this.needsRefresh();}/**
     * Reset the calculated size of the node, forces it to recalculate its size
     */},{key:"needsRefresh",value:function needsRefresh(){this.shape.refreshNeeded=true;}/**
     * get the title of this node.
     *
     * @returns {string} title    The title of the node, or undefined when no title
     *                           has been set.
     */},{key:"getTitle",value:function getTitle(){return this.options.title;}/**
     * Calculate the distance to the border of the Node
     *
     * @param {CanvasRenderingContext2D}   ctx
     * @param {number} angle        Angle in radians
     * @returns {number} distance   Distance to the border in pixels
     */},{key:"distanceToBorder",value:function distanceToBorder(ctx,angle){return this.shape.distanceToBorder(ctx,angle);}/**
     * Check if this node has a fixed x and y position
     *
     * @returns {boolean}      true if fixed, false if not
     */},{key:"isFixed",value:function isFixed(){return this.options.fixed.x&&this.options.fixed.y;}/**
     * check if this node is selecte
     *
     * @returns {boolean} selected   True if node is selected, else false
     */},{key:"isSelected",value:function isSelected(){return this.selected;}/**
     * Retrieve the value of the node. Can be undefined
     *
     * @returns {number} value
     */},{key:"getValue",value:function getValue(){return this.options.value;}/**
     * Get the current dimensions of the label
     *
     * @returns {rect}
     */},{key:"getLabelSize",value:function getLabelSize(){return this.labelModule.size();}/**
     * Adjust the value range of the node. The node will adjust it's size
     * based on its value.
     *
     * @param {number} min
     * @param {number} max
     * @param {number} total
     */},{key:"setValueRange",value:function setValueRange(min,max,total){if(this.options.value!==undefined){var scale=this.options.scaling.customScalingFunction(min,max,total,this.options.value);var sizeDiff=this.options.scaling.max-this.options.scaling.min;if(this.options.scaling.label.enabled===true){var fontDiff=this.options.scaling.label.max-this.options.scaling.label.min;this.options.font.size=this.options.scaling.label.min+scale*fontDiff;}this.options.size=this.options.scaling.min+scale*sizeDiff;}else{this.options.size=this.baseSize;this.options.font.size=this.baseFontSize;}this.updateLabelModule();}/**
     * Draw this node in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     *
     * @param {CanvasRenderingContext2D}   ctx
     *
     * @returns {object} Callbacks to draw later on higher layers.
     */},{key:"draw",value:function draw(ctx){var values=this.getFormattingValues();return this.shape.draw(ctx,this.x,this.y,this.selected,this.hover,values)||{};}/**
     * Update the bounding box of the shape
     *
     * @param {CanvasRenderingContext2D}   ctx
     */},{key:"updateBoundingBox",value:function updateBoundingBox(ctx){this.shape.updateBoundingBox(this.x,this.y,ctx);}/**
     * Recalculate the size of this node in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     *
     * @param {CanvasRenderingContext2D}   ctx
     */},{key:"resize",value:function resize(ctx){var values=this.getFormattingValues();this.shape.resize(ctx,this.selected,this.hover,values);}/**
     * Determine all visual elements of this node instance, in which the given
     * point falls within the bounding shape.
     *
     * @param {point} point
     * @returns {Array.<nodeClickItem|nodeLabelClickItem>} list with the items which are on the point
     */},{key:"getItemsOnPoint",value:function getItemsOnPoint(point){var ret=[];if(this.labelModule.visible()){if(pointInRect(this.labelModule.getSize(),point)){ret.push({nodeId:this.id,labelId:0});}}if(pointInRect(this.shape.boundingBox,point)){ret.push({nodeId:this.id});}return ret;}/**
     * Check if this object is overlapping with the provided object
     *
     * @param {object} obj   an object with parameters left, top, right, bottom
     * @returns {boolean}     True if location is located on node
     */},{key:"isOverlappingWith",value:function isOverlappingWith(obj){return this.shape.left<obj.right&&this.shape.left+this.shape.width>obj.left&&this.shape.top<obj.bottom&&this.shape.top+this.shape.height>obj.top;}/**
     * Check if this object is overlapping with the provided object
     *
     * @param {object} obj   an object with parameters left, top, right, bottom
     * @returns {boolean}     True if location is located on node
     */},{key:"isBoundingBoxOverlappingWith",value:function isBoundingBoxOverlappingWith(obj){return this.shape.boundingBox.left<obj.right&&this.shape.boundingBox.right>obj.left&&this.shape.boundingBox.top<obj.bottom&&this.shape.boundingBox.bottom>obj.top;}/**
     * Check valid values for mass
     *
     * The mass may not be negative or zero. If it is, reset to 1
     *
     * @param {object} options
     * @param {Node.id} id
     * @static
     */}],[{key:"checkOpacity",value:function checkOpacity(opacity){return 0<=opacity&&opacity<=1;}/**
     * Check that origin is 'center' or 'top-left'
     *
     * @param {string} origin
     * @returns {boolean}
     */},{key:"checkCoordinateOrigin",value:function checkCoordinateOrigin(origin){return origin===undefined||origin==="center"||origin==="top-left";}/**
     * Copy group option values into the node options.
     *
     * The group options override the global node options, so the copy of group options
     *  must happen *after* the global node options have been set.
     *
     * This method must also be called also if the global node options have changed and the group options did not.
     *
     * @param {object} parentOptions
     * @param {object} newOptions  new values for the options, currently only passed in for check
     * @param {object} groupList
     */},{key:"updateGroupOptions",value:function updateGroupOptions(parentOptions,newOptions,groupList){var _context4;if(groupList===undefined)return;// No groups, nothing to do
var group=parentOptions.group;// paranoia: the selected group is already merged into node options, check.
if(newOptions!==undefined&&newOptions.group!==undefined&&group!==newOptions.group){throw new Error("updateGroupOptions: group values in options don't match.");}var hasGroup=typeof group==="number"||typeof group==="string"&&group!="";if(!hasGroup)return;// current node has no group, no need to merge
var groupObj=groupList.get(group);if(groupObj.opacity!==undefined&&newOptions.opacity===undefined){if(!Node.checkOpacity(groupObj.opacity)){console.error("Invalid option for node opacity. Value must be between 0 and 1, found: "+groupObj.opacity);groupObj.opacity=undefined;}}// Skip any new option to avoid them being overridden by the group options.
var skipProperties=filter(_context4=getOwnPropertyNames(newOptions)).call(_context4,function(p){return newOptions[p]!=null;});// Always skip merging group font options into parent; these are required to be distinct for labels
skipProperties.push("font");selectiveNotDeepExtend(skipProperties,parentOptions,groupObj);// the color object needs to be completely defined.
// Since groups can partially overwrite the colors, we parse it again, just in case.
parentOptions.color=parseColor(parentOptions.color);}/**
     * This process all possible shorthands in the new options and makes sure that the parentOptions are fully defined.
     * Static so it can also be used by the handler.
     *
     * @param {object} parentOptions
     * @param {object} newOptions
     * @param {boolean} [allowDeletion=false]
     * @param {object} [globalOptions={}]
     * @param {object} [groupList]
     * @static
     */},{key:"parseOptions",value:function parseOptions(parentOptions,newOptions){var allowDeletion=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var globalOptions=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};var groupList=arguments.length>4?arguments[4]:undefined;var fields=["color","fixed","shadow"];selectiveNotDeepExtend(fields,parentOptions,newOptions,allowDeletion);Node.checkMass(newOptions);if(parentOptions.opacity!==undefined){if(!Node.checkOpacity(parentOptions.opacity)){console.error("Invalid option for node opacity. Value must be between 0 and 1, found: "+parentOptions.opacity);parentOptions.opacity=undefined;}}if(newOptions.opacity!==undefined){if(!Node.checkOpacity(newOptions.opacity)){console.error("Invalid option for node opacity. Value must be between 0 and 1, found: "+newOptions.opacity);newOptions.opacity=undefined;}}if(newOptions.shapeProperties&&!Node.checkCoordinateOrigin(newOptions.shapeProperties.coordinateOrigin)){console.error("Invalid option for node coordinateOrigin, found: "+newOptions.shapeProperties.coordinateOrigin);}// merge the shadow options into the parent.
mergeOptions(parentOptions,newOptions,"shadow",globalOptions);// individual shape newOptions
if(newOptions.color!==undefined&&newOptions.color!==null){var parsedColor=parseColor(newOptions.color);fillIfDefined(parentOptions.color,parsedColor);}else if(allowDeletion===true&&newOptions.color===null){parentOptions.color=bridgeObject(globalOptions.color);// set the object back to the global options
}// handle the fixed options
if(newOptions.fixed!==undefined&&newOptions.fixed!==null){if(typeof newOptions.fixed==="boolean"){parentOptions.fixed.x=newOptions.fixed;parentOptions.fixed.y=newOptions.fixed;}else{if(newOptions.fixed.x!==undefined&&typeof newOptions.fixed.x==="boolean"){parentOptions.fixed.x=newOptions.fixed.x;}if(newOptions.fixed.y!==undefined&&typeof newOptions.fixed.y==="boolean"){parentOptions.fixed.y=newOptions.fixed.y;}}}if(allowDeletion===true&&newOptions.font===null){parentOptions.font=bridgeObject(globalOptions.font);// set the object back to the global options
}Node.updateGroupOptions(parentOptions,newOptions,groupList);// handle the scaling options, specifically the label part
if(newOptions.scaling!==undefined){mergeOptions(parentOptions.scaling,newOptions.scaling,"label",globalOptions.scaling);}}},{key:"checkMass",value:function checkMass(options,id){if(options.mass!==undefined&&options.mass<=0){var strId="";if(id!==undefined){strId=" in node id: "+id;}console.error("%cNegative or zero mass disallowed"+strId+", setting mass to 1.",VALIDATOR_PRINT_STYLE$1);options.mass=1;}}}]);return Node;}();function _createForOfIteratorHelper$6(o,allowArrayLike){var it=typeof symbol!=="undefined"&&getIteratorMethod(o)||o["@@iterator"];if(!it){if(isArray(o)||(it=_unsupportedIterableToArray$6(o))||allowArrayLike&&o&&typeof o.length==="number"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};},e:function e(_e){throw _e;},f:F};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion=true,didErr=false,err;return{s:function s(){it=it.call(o);},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e2){didErr=true;err=_e2;},f:function f(){try{if(!normalCompletion&&it.return!=null)it.return();}finally{if(didErr)throw err;}}};}function _unsupportedIterableToArray$6(o,minLen){var _context4;if(!o)return;if(typeof o==="string")return _arrayLikeToArray$6(o,minLen);var n=slice$1(_context4=Object.prototype.toString.call(o)).call(_context4,8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return from$2(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray$6(o,minLen);}function _arrayLikeToArray$6(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}/**
 * Handler for Nodes
 */var NodesHandler=/*#__PURE__*/function(){/**
   * @param {object} body
   * @param {Images} images
   * @param {Array.<Group>} groups
   * @param {LayoutEngine} layoutEngine
   */function NodesHandler(body,images,groups,layoutEngine){var _context,_this=this;_classCallCheck(this,NodesHandler);this.body=body;this.images=images;this.groups=groups;this.layoutEngine=layoutEngine;// create the node API in the body container
this.body.functions.createNode=bind(_context=this.create).call(_context,this);this.nodesListeners={add:function add(event,params){_this.add(params.items);},update:function update(event,params){_this.update(params.items,params.data,params.oldData);},remove:function remove(event,params){_this.remove(params.items);}};this.defaultOptions={borderWidth:1,borderWidthSelected:undefined,brokenImage:undefined,color:{border:"#2B7CE9",background:"#97C2FC",highlight:{border:"#2B7CE9",background:"#D2E5FF"},hover:{border:"#2B7CE9",background:"#D2E5FF"}},opacity:undefined,// number between 0 and 1
fixed:{x:false,y:false},font:{color:"#343434",size:14,// px
face:"arial",background:"none",strokeWidth:0,// px
strokeColor:"#ffffff",align:"center",vadjust:0,multi:false,bold:{mod:"bold"},boldital:{mod:"bold italic"},ital:{mod:"italic"},mono:{mod:"",size:15,// px
face:"monospace",vadjust:2}},group:undefined,hidden:false,icon:{face:"FontAwesome",//'FontAwesome',
code:undefined,//'\uf007',
size:50,//50,
color:"#2B7CE9"//'#aa00ff'
},image:undefined,// --> URL
imagePadding:{// only for image shape
top:0,right:0,bottom:0,left:0},label:undefined,labelHighlightBold:true,level:undefined,margin:{top:5,right:5,bottom:5,left:5},mass:1,physics:true,scaling:{min:10,max:30,label:{enabled:false,min:14,max:30,maxVisible:30,drawThreshold:5},customScalingFunction:function customScalingFunction(min,max,total,value){if(max===min){return 0.5;}else{var scale=1/(max-min);return Math.max(0,(value-min)*scale);}}},shadow:{enabled:false,color:"rgba(0,0,0,0.5)",size:10,x:5,y:5},shape:"ellipse",shapeProperties:{borderDashes:false,// only for borders
borderRadius:6,// only for box shape
interpolation:true,// only for image and circularImage shapes
useImageSize:false,// only for image and circularImage shapes
useBorderWithImage:false,// only for image shape
coordinateOrigin:"center"// only for image and circularImage shapes
},size:25,title:undefined,value:undefined,x:undefined,y:undefined};// Protect from idiocy
if(this.defaultOptions.mass<=0){throw"Internal error: mass in defaultOptions of NodesHandler may not be zero or negative";}this.options=bridgeObject(this.defaultOptions);this.bindEventListeners();}/**
   * Binds event listeners
   */_createClass(NodesHandler,[{key:"bindEventListeners",value:function bindEventListeners(){var _context2,_context3,_this2=this;// refresh the nodes. Used when reverting from hierarchical layout
this.body.emitter.on("refreshNodes",bind(_context2=this.refresh).call(_context2,this));this.body.emitter.on("refresh",bind(_context3=this.refresh).call(_context3,this));this.body.emitter.on("destroy",function(){forEach$1(_this2.nodesListeners,function(callback,event){if(_this2.body.data.nodes)_this2.body.data.nodes.off(event,callback);});delete _this2.body.functions.createNode;delete _this2.nodesListeners.add;delete _this2.nodesListeners.update;delete _this2.nodesListeners.remove;delete _this2.nodesListeners;});}/**
     *
     * @param {object} options
     */},{key:"setOptions",value:function setOptions(options){if(options!==undefined){Node.parseOptions(this.options,options);// Need to set opacity here because Node.parseOptions is also used for groups,
// if you set opacity in Node.parseOptions it overwrites group opacity.
if(options.opacity!==undefined){if(isNan(options.opacity)||!_isFinite(options.opacity)||options.opacity<0||options.opacity>1){console.error("Invalid option for node opacity. Value must be between 0 and 1, found: "+options.opacity);}else{this.options.opacity=options.opacity;}}// update the shape in all nodes
if(options.shape!==undefined){for(var nodeId in this.body.nodes){if(Object.prototype.hasOwnProperty.call(this.body.nodes,nodeId)){this.body.nodes[nodeId].updateShape();}}}// Update the labels of nodes if any relevant options changed.
if(typeof options.font!=="undefined"||typeof options.widthConstraint!=="undefined"||typeof options.heightConstraint!=="undefined"){for(var _i=0,_Object$keys=keys$3(this.body.nodes);_i<_Object$keys.length;_i++){var _nodeId=_Object$keys[_i];this.body.nodes[_nodeId].updateLabelModule();this.body.nodes[_nodeId].needsRefresh();}}// update the shape size in all nodes
if(options.size!==undefined){for(var _nodeId2 in this.body.nodes){if(Object.prototype.hasOwnProperty.call(this.body.nodes,_nodeId2)){this.body.nodes[_nodeId2].needsRefresh();}}}// update the state of the variables if needed
if(options.hidden!==undefined||options.physics!==undefined){this.body.emitter.emit("_dataChanged");}}}/**
     * Set a data set with nodes for the network
     *
     * @param {Array | DataSet | DataView} nodes         The data containing the nodes.
     * @param {boolean} [doNotEmit=false] - Suppress data changed event.
     * @private
     */},{key:"setData",value:function setData(nodes){var doNotEmit=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var oldNodesData=this.body.data.nodes;if(isDataViewLike("id",nodes)){this.body.data.nodes=nodes;}else if(isArray(nodes)){this.body.data.nodes=new DataSet();this.body.data.nodes.add(nodes);}else if(!nodes){this.body.data.nodes=new DataSet();}else{throw new TypeError("Array or DataSet expected");}if(oldNodesData){// unsubscribe from old dataset
forEach$1(this.nodesListeners,function(callback,event){oldNodesData.off(event,callback);});}// remove drawn nodes
this.body.nodes={};if(this.body.data.nodes){// subscribe to new dataset
var me=this;forEach$1(this.nodesListeners,function(callback,event){me.body.data.nodes.on(event,callback);});// draw all new nodes
var ids=this.body.data.nodes.getIds();this.add(ids,true);}if(doNotEmit===false){this.body.emitter.emit("_dataChanged");}}/**
     * Add nodes
     *
     * @param {number[] | string[]} ids
     * @param {boolean} [doNotEmit=false]
     * @private
     */},{key:"add",value:function add(ids){var doNotEmit=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var id;var newNodes=[];for(var i=0;i<ids.length;i++){id=ids[i];var properties=this.body.data.nodes.get(id);var node=this.create(properties);newNodes.push(node);this.body.nodes[id]=node;// note: this may replace an existing node
}this.layoutEngine.positionInitially(newNodes);if(doNotEmit===false){this.body.emitter.emit("_dataChanged");}}/**
     * Update existing nodes, or create them when not yet existing
     *
     * @param {number[] | string[]} ids id's of changed nodes
     * @param {Array} changedData array with changed data
     * @param {Array|undefined} oldData optional; array with previous data
     * @private
     */},{key:"update",value:function update(ids,changedData,oldData){var nodes=this.body.nodes;var dataChanged=false;for(var i=0;i<ids.length;i++){var id=ids[i];var node=nodes[id];var data=changedData[i];if(node!==undefined){// update node
if(node.setOptions(data)){dataChanged=true;}}else{dataChanged=true;// create node
node=this.create(data);nodes[id]=node;}}if(!dataChanged&&oldData!==undefined){// Check for any changes which should trigger a layout recalculation
// For now, this is just 'level' for hierarchical layout
// Assumption: old and new data arranged in same order; at time of writing, this holds.
dataChanged=some(changedData).call(changedData,function(newValue,index){var oldValue=oldData[index];return oldValue&&oldValue.level!==newValue.level;});}if(dataChanged===true){this.body.emitter.emit("_dataChanged");}else{this.body.emitter.emit("_dataUpdated");}}/**
     * Remove existing nodes. If nodes do not exist, the method will just ignore it.
     *
     * @param {number[] | string[]} ids
     * @private
     */},{key:"remove",value:function remove(ids){var nodes=this.body.nodes;for(var i=0;i<ids.length;i++){var id=ids[i];delete nodes[id];}this.body.emitter.emit("_dataChanged");}/**
     * create a node
     *
     * @param {object} properties
     * @param {class} [constructorClass=Node.default]
     * @returns {*}
     */},{key:"create",value:function create(properties){var constructorClass=arguments.length>1&&arguments[1]!==undefined?arguments[1]:Node;return new constructorClass(properties,this.body,this.images,this.groups,this.options,this.defaultOptions);}/**
     *
     * @param {boolean} [clearPositions=false]
     */},{key:"refresh",value:function refresh(){var _this3=this;var clearPositions=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;forEach$1(this.body.nodes,function(node,nodeId){var data=_this3.body.data.nodes.get(nodeId);if(data!==undefined){if(clearPositions===true){node.setOptions({x:null,y:null});}node.setOptions({fixed:false});node.setOptions(data);}});}/**
     * Returns the positions of the nodes.
     *
     * @param {Array.<Node.id> | string} [ids]  --> optional, can be array of nodeIds, can be string
     * @returns {{}}
     */},{key:"getPositions",value:function getPositions(ids){var dataArray={};if(ids!==undefined){if(isArray(ids)===true){for(var i=0;i<ids.length;i++){if(this.body.nodes[ids[i]]!==undefined){var node=this.body.nodes[ids[i]];dataArray[ids[i]]={x:Math.round(node.x),y:Math.round(node.y)};}}}else{if(this.body.nodes[ids]!==undefined){var _node=this.body.nodes[ids];dataArray[ids]={x:Math.round(_node.x),y:Math.round(_node.y)};}}}else{for(var _i2=0;_i2<this.body.nodeIndices.length;_i2++){var _node2=this.body.nodes[this.body.nodeIndices[_i2]];dataArray[this.body.nodeIndices[_i2]]={x:Math.round(_node2.x),y:Math.round(_node2.y)};}}return dataArray;}/**
     * Retrieves the x y position of a specific id.
     *
     * @param {string} id The id to retrieve.
     *
     * @throws {TypeError} If no id is included.
     * @throws {ReferenceError} If an invalid id is provided.
     *
     * @returns {{ x: number, y: number }} Returns X, Y canvas position of the node with given id.
     */},{key:"getPosition",value:function getPosition(id){if(id==undefined){throw new TypeError("No id was specified for getPosition method.");}else if(this.body.nodes[id]==undefined){throw new ReferenceError("NodeId provided for getPosition does not exist. Provided: ".concat(id));}else{return{x:Math.round(this.body.nodes[id].x),y:Math.round(this.body.nodes[id].y)};}}/**
     * Load the XY positions of the nodes into the dataset.
     */},{key:"storePositions",value:function storePositions(){// todo: add support for clusters and hierarchical.
var dataArray=[];var dataset=this.body.data.nodes.getDataSet();var _iterator=_createForOfIteratorHelper$6(dataset.get()),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var dsNode=_step.value;var id=dsNode.id;var bodyNode=this.body.nodes[id];var x=Math.round(bodyNode.x);var y=Math.round(bodyNode.y);if(dsNode.x!==x||dsNode.y!==y){dataArray.push({id:id,x:x,y:y});}}}catch(err){_iterator.e(err);}finally{_iterator.f();}dataset.update(dataArray);}/**
     * get the bounding box of a node.
     *
     * @param {Node.id} nodeId
     * @returns {j|*}
     */},{key:"getBoundingBox",value:function getBoundingBox(nodeId){if(this.body.nodes[nodeId]!==undefined){return this.body.nodes[nodeId].shape.boundingBox;}}/**
     * Get the Ids of nodes connected to this node.
     *
     * @param {Node.id} nodeId
     * @param {'to'|'from'|undefined} direction values 'from' and 'to' select respectively parent and child nodes only.
     *                                          Any other value returns both parent and child nodes.
     * @returns {Array}
     */},{key:"getConnectedNodes",value:function getConnectedNodes(nodeId,direction){var nodeList=[];if(this.body.nodes[nodeId]!==undefined){var node=this.body.nodes[nodeId];var nodeObj={};// used to quickly check if node already exists
for(var i=0;i<node.edges.length;i++){var edge=node.edges[i];if(direction!=="to"&&edge.toId==node.id){// these are double equals since ids can be numeric or string
if(nodeObj[edge.fromId]===undefined){nodeList.push(edge.fromId);nodeObj[edge.fromId]=true;}}else if(direction!=="from"&&edge.fromId==node.id){// these are double equals since ids can be numeric or string
if(nodeObj[edge.toId]===undefined){nodeList.push(edge.toId);nodeObj[edge.toId]=true;}}}}return nodeList;}/**
     * Get the ids of the edges connected to this node.
     *
     * @param {Node.id} nodeId
     * @returns {*}
     */},{key:"getConnectedEdges",value:function getConnectedEdges(nodeId){var edgeList=[];if(this.body.nodes[nodeId]!==undefined){var node=this.body.nodes[nodeId];for(var i=0;i<node.edges.length;i++){edgeList.push(node.edges[i].id);}}else{console.error("NodeId provided for getConnectedEdges does not exist. Provided: ",nodeId);}return edgeList;}/**
     * Move a node.
     *
     * @param {Node.id} nodeId
     * @param {number} x
     * @param {number} y
     */},{key:"moveNode",value:function moveNode(nodeId,x,y){var _this4=this;if(this.body.nodes[nodeId]!==undefined){this.body.nodes[nodeId].x=Number(x);this.body.nodes[nodeId].y=Number(y);setTimeout$1(function(){_this4.body.emitter.emit("startSimulation");},0);}else{console.error("Node id supplied to moveNode does not exist. Provided: ",nodeId);}}}]);return NodesHandler;}();// https://tc39.es/ecma262/#sec-reflect.get
function get$3(target,propertyKey/* , receiver */){var receiver=arguments.length<3?target:arguments[2];var descriptor,prototype;if(anObject(target)===receiver)return target[propertyKey];if(descriptor=objectGetOwnPropertyDescriptor.f(target,propertyKey))return has$1(descriptor,'value')?descriptor.value:descriptor.get===undefined?undefined:descriptor.get.call(receiver);if(isObject$1(prototype=objectGetPrototypeOf(target)))return get$3(prototype,propertyKey,receiver);}_export({target:'Reflect',stat:true},{get:get$3});var get$2=path.Reflect.get;var get$1=get$2;var get=get$1;var getOwnPropertyDescriptor$1=getOwnPropertyDescriptor_1;var getOwnPropertyDescriptor=getOwnPropertyDescriptor$1;function _superPropBase(object,property){while(!Object.prototype.hasOwnProperty.call(object,property)){object=_getPrototypeOf(object);if(object===null)break;}return object;}function _get(target,property,receiver){if(typeof Reflect!=="undefined"&&get){_get=get;}else{_get=function _get(target,property,receiver){var base=_superPropBase(target,property);if(!base)return;var desc=getOwnPropertyDescriptor(base,property);if(desc.get){return desc.get.call(receiver);}return desc.value;};}return _get(target,property,receiver||target);}var $hypot=Math.hypot;var abs=Math.abs;var sqrt=Math.sqrt;// Chrome 77 bug
// https://bugs.chromium.org/p/v8/issues/detail?id=9546
var BUGGY=!!$hypot&&$hypot(Infinity,NaN)!==Infinity;// `Math.hypot` method
// https://tc39.es/ecma262/#sec-math.hypot
_export({target:'Math',stat:true,forced:BUGGY},{// eslint-disable-next-line no-unused-vars -- required for `.length`
hypot:function hypot(value1,value2){var sum=0;var i=0;var aLen=arguments.length;var larg=0;var arg,div;while(i<aLen){arg=abs(arguments[i++]);if(larg<arg){div=larg/arg;sum=sum*div*div+1;larg=arg;}else if(arg>0){div=arg/larg;sum+=div*div;}else sum+=arg;}return larg===Infinity?Infinity:larg*sqrt(sum);}});var hypot$2=path.Math.hypot;var hypot$1=hypot$2;var hypot=hypot$1;function _createSuper$a(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$a();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$a(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * Common methods for endpoints
 *
 * @class
 */var EndPoint=/*#__PURE__*/function(){function EndPoint(){_classCallCheck(this,EndPoint);}_createClass(EndPoint,null,[{key:"transform",value:/**
     * Apply transformation on points for display.
     *
     * The following is done:
     * - rotate by the specified angle
     * - multiply the (normalized) coordinates by the passed length
     * - offset by the target coordinates
     *
     * @param points - The point(s) to be transformed.
     * @param arrowData - The data determining the result of the transformation.
     */function transform(points,arrowData){if(!isArray(points)){points=[points];}var x=arrowData.point.x;var y=arrowData.point.y;var angle=arrowData.angle;var length=arrowData.length;for(var i=0;i<points.length;++i){var p=points[i];var xt=p.x*Math.cos(angle)-p.y*Math.sin(angle);var yt=p.x*Math.sin(angle)+p.y*Math.cos(angle);p.x=x+length*xt;p.y=y+length*yt;}}/**
     * Draw a closed path using the given real coordinates.
     *
     * @param ctx - The path will be rendered into this context.
     * @param points - The points of the path.
     */},{key:"drawPath",value:function drawPath(ctx,points){ctx.beginPath();ctx.moveTo(points[0].x,points[0].y);for(var i=1;i<points.length;++i){ctx.lineTo(points[i].x,points[i].y);}ctx.closePath();}}]);return EndPoint;}();/**
 * Drawing methods for the arrow endpoint.
 */var Image$1=/*#__PURE__*/function(_EndPoint){_inherits(Image,_EndPoint);var _super=_createSuper$a(Image);function Image(){_classCallCheck(this,Image);return _super.apply(this,arguments);}_createClass(Image,null,[{key:"draw",value:/**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     *
     * @returns False as there is no way to fill an image.
     */function draw(ctx,arrowData){if(arrowData.image){ctx.save();ctx.translate(arrowData.point.x,arrowData.point.y);ctx.rotate(Math.PI/2+arrowData.angle);var width=arrowData.imageWidth!=null?arrowData.imageWidth:arrowData.image.width;var height=arrowData.imageHeight!=null?arrowData.imageHeight:arrowData.image.height;arrowData.image.drawImageAtPosition(ctx,1,// scale
-width/2,// x
0,// y
width,height);ctx.restore();}return false;}}]);return Image;}(EndPoint);/**
 * Drawing methods for the arrow endpoint.
 */var Arrow=/*#__PURE__*/function(_EndPoint2){_inherits(Arrow,_EndPoint2);var _super2=_createSuper$a(Arrow);function Arrow(){_classCallCheck(this,Arrow);return _super2.apply(this,arguments);}_createClass(Arrow,null,[{key:"draw",value:/**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     *
     * @returns True because ctx.fill() can be used to fill the arrow.
     */function draw(ctx,arrowData){// Normalized points of closed path, in the order that they should be drawn.
// (0, 0) is the attachment point, and the point around which should be rotated
var points=[{x:0,y:0},{x:-1,y:0.3},{x:-0.9,y:0},{x:-1,y:-0.3}];EndPoint.transform(points,arrowData);EndPoint.drawPath(ctx,points);return true;}}]);return Arrow;}(EndPoint);/**
 * Drawing methods for the crow endpoint.
 */var Crow=/*#__PURE__*/function(){function Crow(){_classCallCheck(this,Crow);}_createClass(Crow,null,[{key:"draw",value:/**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     *
     * @returns True because ctx.fill() can be used to fill the arrow.
     */function draw(ctx,arrowData){// Normalized points of closed path, in the order that they should be drawn.
// (0, 0) is the attachment point, and the point around which should be rotated
var points=[{x:-1,y:0},{x:0,y:0.3},{x:-0.4,y:0},{x:0,y:-0.3}];EndPoint.transform(points,arrowData);EndPoint.drawPath(ctx,points);return true;}}]);return Crow;}();/**
 * Drawing methods for the curve endpoint.
 */var Curve=/*#__PURE__*/function(){function Curve(){_classCallCheck(this,Curve);}_createClass(Curve,null,[{key:"draw",value:/**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     *
     * @returns True because ctx.fill() can be used to fill the arrow.
     */function draw(ctx,arrowData){// Normalized points of closed path, in the order that they should be drawn.
// (0, 0) is the attachment point, and the point around which should be rotated
var point={x:-0.4,y:0};EndPoint.transform(point,arrowData);// Update endpoint style for drawing transparent arc.
ctx.strokeStyle=ctx.fillStyle;ctx.fillStyle="rgba(0, 0, 0, 0)";// Define curve endpoint as semicircle.
var pi=Math.PI;var startAngle=arrowData.angle-pi/2;var endAngle=arrowData.angle+pi/2;ctx.beginPath();ctx.arc(point.x,point.y,arrowData.length*0.4,startAngle,endAngle,false);ctx.stroke();return true;}}]);return Curve;}();/**
 * Drawing methods for the inverted curve endpoint.
 */var InvertedCurve=/*#__PURE__*/function(){function InvertedCurve(){_classCallCheck(this,InvertedCurve);}_createClass(InvertedCurve,null,[{key:"draw",value:/**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     *
     * @returns True because ctx.fill() can be used to fill the arrow.
     */function draw(ctx,arrowData){// Normalized points of closed path, in the order that they should be drawn.
// (0, 0) is the attachment point, and the point around which should be rotated
var point={x:-0.3,y:0};EndPoint.transform(point,arrowData);// Update endpoint style for drawing transparent arc.
ctx.strokeStyle=ctx.fillStyle;ctx.fillStyle="rgba(0, 0, 0, 0)";// Define inverted curve endpoint as semicircle.
var pi=Math.PI;var startAngle=arrowData.angle+pi/2;var endAngle=arrowData.angle+3*pi/2;ctx.beginPath();ctx.arc(point.x,point.y,arrowData.length*0.4,startAngle,endAngle,false);ctx.stroke();return true;}}]);return InvertedCurve;}();/**
 * Drawing methods for the trinagle endpoint.
 */var Triangle=/*#__PURE__*/function(){function Triangle(){_classCallCheck(this,Triangle);}_createClass(Triangle,null,[{key:"draw",value:/**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     *
     * @returns True because ctx.fill() can be used to fill the arrow.
     */function draw(ctx,arrowData){// Normalized points of closed path, in the order that they should be drawn.
// (0, 0) is the attachment point, and the point around which should be rotated
var points=[{x:0.02,y:0},{x:-1,y:0.3},{x:-1,y:-0.3}];EndPoint.transform(points,arrowData);EndPoint.drawPath(ctx,points);return true;}}]);return Triangle;}();/**
 * Drawing methods for the inverted trinagle endpoint.
 */var InvertedTriangle=/*#__PURE__*/function(){function InvertedTriangle(){_classCallCheck(this,InvertedTriangle);}_createClass(InvertedTriangle,null,[{key:"draw",value:/**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     *
     * @returns True because ctx.fill() can be used to fill the arrow.
     */function draw(ctx,arrowData){// Normalized points of closed path, in the order that they should be drawn.
// (0, 0) is the attachment point, and the point around which should be rotated
var points=[{x:0,y:0.3},{x:0,y:-0.3},{x:-1,y:0}];EndPoint.transform(points,arrowData);EndPoint.drawPath(ctx,points);return true;}}]);return InvertedTriangle;}();/**
 * Drawing methods for the circle endpoint.
 */var Circle=/*#__PURE__*/function(){function Circle(){_classCallCheck(this,Circle);}_createClass(Circle,null,[{key:"draw",value:/**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     *
     * @returns True because ctx.fill() can be used to fill the arrow.
     */function draw(ctx,arrowData){var point={x:-0.4,y:0};EndPoint.transform(point,arrowData);drawCircle(ctx,point.x,point.y,arrowData.length*0.4);return true;}}]);return Circle;}();/**
 * Drawing methods for the bar endpoint.
 */var Bar=/*#__PURE__*/function(){function Bar(){_classCallCheck(this,Bar);}_createClass(Bar,null,[{key:"draw",value:/**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     *
     * @returns True because ctx.fill() can be used to fill the arrow.
     */function draw(ctx,arrowData){/*
      var points = [
        {x:0, y:0.5},
        {x:0, y:-0.5}
      ];
           EndPoint.transform(points, arrowData);
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      ctx.lineTo(points[1].x, points[1].y);
      ctx.stroke();
      */var points=[{x:0,y:0.5},{x:0,y:-0.5},{x:-0.15,y:-0.5},{x:-0.15,y:0.5}];EndPoint.transform(points,arrowData);EndPoint.drawPath(ctx,points);return true;}}]);return Bar;}();/**
 * Drawing methods for the box endpoint.
 */var Box=/*#__PURE__*/function(){function Box(){_classCallCheck(this,Box);}_createClass(Box,null,[{key:"draw",value:/**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     *
     * @returns True because ctx.fill() can be used to fill the arrow.
     */function draw(ctx,arrowData){var points=[{x:0,y:0.3},{x:0,y:-0.3},{x:-0.6,y:-0.3},{x:-0.6,y:0.3}];EndPoint.transform(points,arrowData);EndPoint.drawPath(ctx,points);return true;}}]);return Box;}();/**
 * Drawing methods for the diamond endpoint.
 */var Diamond=/*#__PURE__*/function(){function Diamond(){_classCallCheck(this,Diamond);}_createClass(Diamond,null,[{key:"draw",value:/**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     *
     * @returns True because ctx.fill() can be used to fill the arrow.
     */function draw(ctx,arrowData){var points=[{x:0,y:0},{x:-0.5,y:-0.3},{x:-1,y:0},{x:-0.5,y:0.3}];EndPoint.transform(points,arrowData);EndPoint.drawPath(ctx,points);return true;}}]);return Diamond;}();/**
 * Drawing methods for the vee endpoint.
 */var Vee=/*#__PURE__*/function(){function Vee(){_classCallCheck(this,Vee);}_createClass(Vee,null,[{key:"draw",value:/**
     * Draw this shape at the end of a line.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     *
     * @returns True because ctx.fill() can be used to fill the arrow.
     */function draw(ctx,arrowData){// Normalized points of closed path, in the order that they should be drawn.
// (0, 0) is the attachment point, and the point around which should be rotated
var points=[{x:-1,y:0.3},{x:-0.5,y:0},{x:-1,y:-0.3},{x:0,y:0}];EndPoint.transform(points,arrowData);EndPoint.drawPath(ctx,points);return true;}}]);return Vee;}();/**
 * Drawing methods for the endpoints.
 */var EndPoints=/*#__PURE__*/function(){function EndPoints(){_classCallCheck(this,EndPoints);}_createClass(EndPoints,null,[{key:"draw",value:/**
     * Draw an endpoint.
     *
     * @param ctx - The shape will be rendered into this context.
     * @param arrowData - The data determining the shape.
     *
     * @returns True if ctx.fill() can be used to fill the arrow, false otherwise.
     */function draw(ctx,arrowData){var type;if(arrowData.type){type=arrowData.type.toLowerCase();}switch(type){case"image":return Image$1.draw(ctx,arrowData);case"circle":return Circle.draw(ctx,arrowData);case"box":return Box.draw(ctx,arrowData);case"crow":return Crow.draw(ctx,arrowData);case"curve":return Curve.draw(ctx,arrowData);case"diamond":return Diamond.draw(ctx,arrowData);case"inv_curve":return InvertedCurve.draw(ctx,arrowData);case"triangle":return Triangle.draw(ctx,arrowData);case"inv_triangle":return InvertedTriangle.draw(ctx,arrowData);case"bar":return Bar.draw(ctx,arrowData);case"vee":return Vee.draw(ctx,arrowData);case"arrow":// fall-through
default:return Arrow.draw(ctx,arrowData);}}}]);return EndPoints;}();function ownKeys$1(object,enumerableOnly){var keys=keys$3(object);if(getOwnPropertySymbols){var symbols=getOwnPropertySymbols(object);if(enumerableOnly){symbols=filter(symbols).call(symbols,function(sym){return getOwnPropertyDescriptor$2(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread$1(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){var _context2;forEach$2(_context2=ownKeys$1(Object(source),true)).call(_context2,function(key){_defineProperty(target,key,source[key]);});}else if(getOwnPropertyDescriptors){defineProperties(target,getOwnPropertyDescriptors(source));}else{var _context3;forEach$2(_context3=ownKeys$1(Object(source))).call(_context3,function(key){defineProperty$4(target,key,getOwnPropertyDescriptor$2(source,key));});}}return target;}/**
 * The Base Class for all edges.
 */var EdgeBase=/*#__PURE__*/function(){/**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param _body - The body of the network.
   * @param _labelModule - Label module.
   */function EdgeBase(options,_body,_labelModule){_classCallCheck(this,EdgeBase);this._body=_body;this._labelModule=_labelModule;this.color={};this.colorDirty=true;this.hoverWidth=1.5;this.selectionWidth=2;this.setOptions(options);this.fromPoint=this.from;this.toPoint=this.to;}/** @inheritDoc */_createClass(EdgeBase,[{key:"connect",value:function connect(){this.from=this._body.nodes[this.options.from];this.to=this._body.nodes[this.options.to];}/** @inheritDoc */},{key:"cleanup",value:function cleanup(){return false;}/**
     * Set new edge options.
     *
     * @param options - The new edge options object.
     */},{key:"setOptions",value:function setOptions(options){this.options=options;this.from=this._body.nodes[this.options.from];this.to=this._body.nodes[this.options.to];this.id=this.options.id;}/** @inheritDoc */},{key:"drawLine",value:function drawLine(ctx,values,_selected,_hover){var viaNode=arguments.length>4&&arguments[4]!==undefined?arguments[4]:this.getViaNode();// set style
ctx.strokeStyle=this.getColor(ctx,values);ctx.lineWidth=values.width;if(values.dashes!==false){this._drawDashedLine(ctx,values,viaNode);}else{this._drawLine(ctx,values,viaNode);}}/**
     * Draw a line with given style between two nodes through supplied node(s).
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values like color, opacity or shadow.
     * @param viaNode - Additional control point(s) for the edge.
     * @param fromPoint - TODO: Seems ignored, remove?
     * @param toPoint - TODO: Seems ignored, remove?
     */},{key:"_drawLine",value:function _drawLine(ctx,values,viaNode,fromPoint,toPoint){if(this.from!=this.to){// draw line
this._line(ctx,values,viaNode,fromPoint,toPoint);}else{var _this$_getCircleData=this._getCircleData(ctx),_this$_getCircleData2=_slicedToArray(_this$_getCircleData,3),x=_this$_getCircleData2[0],y=_this$_getCircleData2[1],radius=_this$_getCircleData2[2];this._circle(ctx,values,x,y,radius);}}/**
     * Draw a dashed line with given style between two nodes through supplied node(s).
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values like color, opacity or shadow.
     * @param viaNode - Additional control point(s) for the edge.
     * @param _fromPoint - Ignored (TODO: remove in the future).
     * @param _toPoint - Ignored (TODO: remove in the future).
     */},{key:"_drawDashedLine",value:function _drawDashedLine(ctx,values,viaNode,_fromPoint,_toPoint){ctx.lineCap="round";var pattern=isArray(values.dashes)?values.dashes:[5,5];// only firefox and chrome support this method, else we use the legacy one.
if(ctx.setLineDash!==undefined){ctx.save();// set dash settings for chrome or firefox
ctx.setLineDash(pattern);ctx.lineDashOffset=0;// draw the line
if(this.from!=this.to){// draw line
this._line(ctx,values,viaNode);}else{var _this$_getCircleData3=this._getCircleData(ctx),_this$_getCircleData4=_slicedToArray(_this$_getCircleData3,3),x=_this$_getCircleData4[0],y=_this$_getCircleData4[1],radius=_this$_getCircleData4[2];this._circle(ctx,values,x,y,radius);}// restore the dash settings.
ctx.setLineDash([0]);ctx.lineDashOffset=0;ctx.restore();}else{// unsupporting smooth lines
if(this.from!=this.to){// draw line
drawDashedLine(ctx,this.from.x,this.from.y,this.to.x,this.to.y,pattern);}else{var _this$_getCircleData5=this._getCircleData(ctx),_this$_getCircleData6=_slicedToArray(_this$_getCircleData5,3),_x=_this$_getCircleData6[0],_y=_this$_getCircleData6[1],_radius=_this$_getCircleData6[2];this._circle(ctx,values,_x,_y,_radius);}// draw shadow if enabled
this.enableShadow(ctx,values);ctx.stroke();// disable shadows for other elements.
this.disableShadow(ctx,values);}}/**
     * Find the intersection between the border of the node and the edge.
     *
     * @param node - The node (either from or to node of the edge).
     * @param ctx - The context that will be used for rendering.
     * @param options - Additional options.
     *
     * @returns Cartesian coordinates of the intersection between the border of the node and the edge.
     */},{key:"findBorderPosition",value:function findBorderPosition(node,ctx,options){if(this.from!=this.to){return this._findBorderPosition(node,ctx,options);}else{return this._findBorderPositionCircle(node,ctx,options);}}/** @inheritDoc */},{key:"findBorderPositions",value:function findBorderPositions(ctx){if(this.from!=this.to){return{from:this._findBorderPosition(this.from,ctx),to:this._findBorderPosition(this.to,ctx)};}else{var _context;var _this$_getCircleData$=slice$1(_context=this._getCircleData(ctx)).call(_context,0,2),_this$_getCircleData$2=_slicedToArray(_this$_getCircleData$,2),x=_this$_getCircleData$2[0],y=_this$_getCircleData$2[1];return{from:this._findBorderPositionCircle(this.from,ctx,{x:x,y:y,low:0.25,high:0.6,direction:-1}),to:this._findBorderPositionCircle(this.from,ctx,{x:x,y:y,low:0.6,high:0.8,direction:1})};}}/**
     * Compute the center point and radius of an edge connected to the same node at both ends.
     *
     * @param ctx - The context that will be used for rendering.
     *
     * @returns `[x, y, radius]`
     */},{key:"_getCircleData",value:function _getCircleData(ctx){var radius=this.options.selfReference.size;if(ctx!==undefined){if(this.from.shape.width===undefined){this.from.shape.resize(ctx);}}// get circle coordinates
var coordinates=getSelfRefCoordinates(ctx,this.options.selfReference.angle,radius,this.from);return[coordinates.x,coordinates.y,radius];}/**
     * Get a point on a circle.
     *
     * @param x - Center of the circle on the x axis.
     * @param y - Center of the circle on the y axis.
     * @param radius - Radius of the circle.
     * @param position - Value between 0 (line start) and 1 (line end).
     *
     * @returns Cartesian coordinates of requested point on the circle.
     */},{key:"_pointOnCircle",value:function _pointOnCircle(x,y,radius,position){var angle=position*2*Math.PI;return{x:x+radius*Math.cos(angle),y:y-radius*Math.sin(angle)};}/**
     * Find the intersection between the border of the node and the edge.
     *
     * @remarks
     * This function uses binary search to look for the point where the circle crosses the border of the node.
     *
     * @param nearNode - The node (either from or to node of the edge).
     * @param ctx - The context that will be used for rendering.
     * @param options - Additional options.
     *
     * @returns Cartesian coordinates of the intersection between the border of the node and the edge.
     */},{key:"_findBorderPositionCircle",value:function _findBorderPositionCircle(nearNode,ctx,options){var x=options.x;var y=options.y;var low=options.low;var high=options.high;var direction=options.direction;var maxIterations=10;var radius=this.options.selfReference.size;var threshold=0.05;var pos;var middle=(low+high)*0.5;var endPointOffset=0;if(this.options.arrowStrikethrough===true){if(direction===-1){endPointOffset=this.options.endPointOffset.from;}else if(direction===1){endPointOffset=this.options.endPointOffset.to;}}var iteration=0;do{middle=(low+high)*0.5;pos=this._pointOnCircle(x,y,radius,middle);var angle=Math.atan2(nearNode.y-pos.y,nearNode.x-pos.x);var distanceToBorder=nearNode.distanceToBorder(ctx,angle)+endPointOffset;var distanceToPoint=Math.sqrt(Math.pow(pos.x-nearNode.x,2)+Math.pow(pos.y-nearNode.y,2));var difference=distanceToBorder-distanceToPoint;if(Math.abs(difference)<threshold){break;// found
}else if(difference>0){// distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.
if(direction>0){low=middle;}else{high=middle;}}else{if(direction>0){high=middle;}else{low=middle;}}++iteration;}while(low<=high&&iteration<maxIterations);return _objectSpread$1(_objectSpread$1({},pos),{},{t:middle});}/**
     * Get the line width of the edge. Depends on width and whether one of the connected nodes is selected.
     *
     * @param selected - Determines wheter the line is selected.
     * @param hover - Determines wheter the line is being hovered, only applies if selected is false.
     *
     * @returns The width of the line.
     */},{key:"getLineWidth",value:function getLineWidth(selected,hover){if(selected===true){return Math.max(this.selectionWidth,0.3/this._body.view.scale);}else if(hover===true){return Math.max(this.hoverWidth,0.3/this._body.view.scale);}else{return Math.max(this.options.width,0.3/this._body.view.scale);}}/**
     * Compute the color or gradient for given edge.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values like color, opacity or shadow.
     * @param _selected - Ignored (TODO: remove in the future).
     * @param _hover - Ignored (TODO: remove in the future).
     *
     * @returns Color string if single color is inherited or gradient if two.
     */},{key:"getColor",value:function getColor(ctx,values){if(values.inheritsColor!==false){// when this is a loop edge, just use the 'from' method
if(values.inheritsColor==="both"&&this.from.id!==this.to.id){var grd=ctx.createLinearGradient(this.from.x,this.from.y,this.to.x,this.to.y);var fromColor=this.from.options.color.highlight.border;var toColor=this.to.options.color.highlight.border;if(this.from.selected===false&&this.to.selected===false){fromColor=overrideOpacity(this.from.options.color.border,values.opacity);toColor=overrideOpacity(this.to.options.color.border,values.opacity);}else if(this.from.selected===true&&this.to.selected===false){toColor=this.to.options.color.border;}else if(this.from.selected===false&&this.to.selected===true){fromColor=this.from.options.color.border;}grd.addColorStop(0,fromColor);grd.addColorStop(1,toColor);// -------------------- this returns -------------------- //
return grd;}if(values.inheritsColor==="to"){return overrideOpacity(this.to.options.color.border,values.opacity);}else{// "from"
return overrideOpacity(this.from.options.color.border,values.opacity);}}else{return overrideOpacity(values.color,values.opacity);}}/**
     * Draw a line from a node to itself, a circle.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values like color, opacity or shadow.
     * @param x - Center of the circle on the x axis.
     * @param y - Center of the circle on the y axis.
     * @param radius - Radius of the circle.
     */},{key:"_circle",value:function _circle(ctx,values,x,y,radius){// draw shadow if enabled
this.enableShadow(ctx,values);//full circle
var angleFrom=0;var angleTo=Math.PI*2;if(!this.options.selfReference.renderBehindTheNode){//render only parts which are not overlaping with parent node
//need to find x,y of from point and x,y to point
//calculating radians
var low=this.options.selfReference.angle;var high=this.options.selfReference.angle+Math.PI;var pointTFrom=this._findBorderPositionCircle(this.from,ctx,{x:x,y:y,low:low,high:high,direction:-1});var pointTTo=this._findBorderPositionCircle(this.from,ctx,{x:x,y:y,low:low,high:high,direction:1});angleFrom=Math.atan2(pointTFrom.y-y,pointTFrom.x-x);angleTo=Math.atan2(pointTTo.y-y,pointTTo.x-x);}// draw a circle
ctx.beginPath();ctx.arc(x,y,radius,angleFrom,angleTo,false);ctx.stroke();// disable shadows for other elements.
this.disableShadow(ctx,values);}/**
     * @inheritDoc
     *
     * @remarks
     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
     */},{key:"getDistanceToEdge",value:function getDistanceToEdge(x1,y1,x2,y2,x3,y3){if(this.from!=this.to){return this._getDistanceToEdge(x1,y1,x2,y2,x3,y3);}else{var _this$_getCircleData7=this._getCircleData(undefined),_this$_getCircleData8=_slicedToArray(_this$_getCircleData7,3),x=_this$_getCircleData8[0],y=_this$_getCircleData8[1],radius=_this$_getCircleData8[2];var dx=x-x3;var dy=y-y3;return Math.abs(Math.sqrt(dx*dx+dy*dy)-radius);}}/**
     * Calculate the distance between a point (x3, y3) and a line segment from (x1, y1) to (x2, y2).
     *
     * @param x1 - First end of the line segment on the x axis.
     * @param y1 - First end of the line segment on the y axis.
     * @param x2 - Second end of the line segment on the x axis.
     * @param y2 - Second end of the line segment on the y axis.
     * @param x3 - Position of the point on the x axis.
     * @param y3 - Position of the point on the y axis.
     *
     * @returns The distance between the line segment and the point.
     */},{key:"_getDistanceToLine",value:function _getDistanceToLine(x1,y1,x2,y2,x3,y3){var px=x2-x1;var py=y2-y1;var something=px*px+py*py;var u=((x3-x1)*px+(y3-y1)*py)/something;if(u>1){u=1;}else if(u<0){u=0;}var x=x1+u*px;var y=y1+u*py;var dx=x-x3;var dy=y-y3;//# Note: If the actual distance does not matter,
//# if you only want to compare what this function
//# returns to other results of this function, you
//# can just return the squared distance instead
//# (i.e. remove the sqrt) to gain a little performance
return Math.sqrt(dx*dx+dy*dy);}/** @inheritDoc */},{key:"getArrowData",value:function getArrowData(ctx,position,viaNode,_selected,_hover,values){// set lets
var angle;var arrowPoint;var node1;var node2;var reversed;var scaleFactor;var type;var lineWidth=values.width;if(position==="from"){node1=this.from;node2=this.to;reversed=values.fromArrowScale<0;scaleFactor=Math.abs(values.fromArrowScale);type=values.fromArrowType;}else if(position==="to"){node1=this.to;node2=this.from;reversed=values.toArrowScale<0;scaleFactor=Math.abs(values.toArrowScale);type=values.toArrowType;}else{node1=this.to;node2=this.from;reversed=values.middleArrowScale<0;scaleFactor=Math.abs(values.middleArrowScale);type=values.middleArrowType;}var length=15*scaleFactor+3*lineWidth;// 3* lineWidth is the width of the edge.
// if not connected to itself
if(node1!=node2){var approximateEdgeLength=hypot(node1.x-node2.x,node1.y-node2.y);var relativeLength=length/approximateEdgeLength;if(position!=="middle"){// draw arrow head
if(this.options.smooth.enabled===true){var pointT=this._findBorderPosition(node1,ctx,{via:viaNode});var guidePos=this.getPoint(pointT.t+relativeLength*(position==="from"?1:-1),viaNode);angle=Math.atan2(pointT.y-guidePos.y,pointT.x-guidePos.x);arrowPoint=pointT;}else{angle=Math.atan2(node1.y-node2.y,node1.x-node2.x);arrowPoint=this._findBorderPosition(node1,ctx);}}else{// Negative half length reverses arrow direction.
var halfLength=(reversed?-relativeLength:relativeLength)/2;var guidePos1=this.getPoint(0.5+halfLength,viaNode);var guidePos2=this.getPoint(0.5-halfLength,viaNode);angle=Math.atan2(guidePos1.y-guidePos2.y,guidePos1.x-guidePos2.x);arrowPoint=this.getPoint(0.5,viaNode);}}else{// draw circle
var _this$_getCircleData9=this._getCircleData(ctx),_this$_getCircleData10=_slicedToArray(_this$_getCircleData9,3),x=_this$_getCircleData10[0],y=_this$_getCircleData10[1],radius=_this$_getCircleData10[2];if(position==="from"){var low=this.options.selfReference.angle;var high=this.options.selfReference.angle+Math.PI;var _pointT=this._findBorderPositionCircle(this.from,ctx,{x:x,y:y,low:low,high:high,direction:-1});angle=_pointT.t*-2*Math.PI+1.5*Math.PI+0.1*Math.PI;arrowPoint=_pointT;}else if(position==="to"){var _low=this.options.selfReference.angle;var _high=this.options.selfReference.angle+Math.PI;var _pointT2=this._findBorderPositionCircle(this.from,ctx,{x:x,y:y,low:_low,high:_high,direction:1});angle=_pointT2.t*-2*Math.PI+1.5*Math.PI-1.1*Math.PI;arrowPoint=_pointT2;}else{var pos=this.options.selfReference.angle/(2*Math.PI);arrowPoint=this._pointOnCircle(x,y,radius,pos);angle=pos*-2*Math.PI+1.5*Math.PI+0.1*Math.PI;}}var xi=arrowPoint.x-length*0.9*Math.cos(angle);var yi=arrowPoint.y-length*0.9*Math.sin(angle);var arrowCore={x:xi,y:yi};return{point:arrowPoint,core:arrowCore,angle:angle,length:length,type:type};}/** @inheritDoc */},{key:"drawArrowHead",value:function drawArrowHead(ctx,values,_selected,_hover,arrowData){// set style
ctx.strokeStyle=this.getColor(ctx,values);ctx.fillStyle=ctx.strokeStyle;ctx.lineWidth=values.width;var canFill=EndPoints.draw(ctx,arrowData);if(canFill){// draw shadow if enabled
this.enableShadow(ctx,values);fill(ctx).call(ctx);// disable shadows for other elements.
this.disableShadow(ctx,values);}}/**
     * Set the shadow formatting values in the context if enabled, do nothing otherwise.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values for the shadow.
     */},{key:"enableShadow",value:function enableShadow(ctx,values){if(values.shadow===true){ctx.shadowColor=values.shadowColor;ctx.shadowBlur=values.shadowSize;ctx.shadowOffsetX=values.shadowX;ctx.shadowOffsetY=values.shadowY;}}/**
     * Reset the shadow formatting values in the context if enabled, do nothing otherwise.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values for the shadow.
     */},{key:"disableShadow",value:function disableShadow(ctx,values){if(values.shadow===true){ctx.shadowColor="rgba(0,0,0,0)";ctx.shadowBlur=0;ctx.shadowOffsetX=0;ctx.shadowOffsetY=0;}}/**
     * Render the background according to the formatting values.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Formatting values for the background.
     */},{key:"drawBackground",value:function drawBackground(ctx,values){if(values.background!==false){// save original line attrs
var origCtxAttr={strokeStyle:ctx.strokeStyle,lineWidth:ctx.lineWidth,dashes:ctx.dashes};ctx.strokeStyle=values.backgroundColor;ctx.lineWidth=values.backgroundSize;this.setStrokeDashed(ctx,values.backgroundDashes);ctx.stroke();// restore original line attrs
ctx.strokeStyle=origCtxAttr.strokeStyle;ctx.lineWidth=origCtxAttr.lineWidth;ctx.dashes=origCtxAttr.dashes;this.setStrokeDashed(ctx,values.dashes);}}/**
     * Set the line dash pattern if supported. Logs a warning to the console if it isn't supported.
     *
     * @param ctx - The context that will be used for rendering.
     * @param dashes - The pattern [line, space, line…], true for default dashed line or false for normal line.
     */},{key:"setStrokeDashed",value:function setStrokeDashed(ctx,dashes){if(dashes!==false){if(ctx.setLineDash!==undefined){var pattern=isArray(dashes)?dashes:[5,5];ctx.setLineDash(pattern);}else{console.warn("setLineDash is not supported in this browser. The dashed stroke cannot be used.");}}else{if(ctx.setLineDash!==undefined){ctx.setLineDash([]);}else{console.warn("setLineDash is not supported in this browser. The dashed stroke cannot be used.");}}}}]);return EdgeBase;}();function ownKeys(object,enumerableOnly){var keys=keys$3(object);if(getOwnPropertySymbols){var symbols=getOwnPropertySymbols(object);if(enumerableOnly){symbols=filter(symbols).call(symbols,function(sym){return getOwnPropertyDescriptor$2(object,sym).enumerable;});}keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){var _context;forEach$2(_context=ownKeys(Object(source),true)).call(_context,function(key){_defineProperty(target,key,source[key]);});}else if(getOwnPropertyDescriptors){defineProperties(target,getOwnPropertyDescriptors(source));}else{var _context2;forEach$2(_context2=ownKeys(Object(source))).call(_context2,function(key){defineProperty$4(target,key,getOwnPropertyDescriptor$2(source,key));});}}return target;}function _createSuper$9(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$9();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$9(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * The Base Class for all Bezier edges.
 * Bezier curves are used to model smooth gradual curves in paths between nodes.
 */var BezierEdgeBase=/*#__PURE__*/function(_EdgeBase){_inherits(BezierEdgeBase,_EdgeBase);var _super=_createSuper$9(BezierEdgeBase);/**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */function BezierEdgeBase(options,body,labelModule){_classCallCheck(this,BezierEdgeBase);return _super.call(this,options,body,labelModule);}/**
   * Find the intersection between the border of the node and the edge.
   *
   * @remarks
   * This function uses binary search to look for the point where the bezier curve crosses the border of the node.
   *
   * @param nearNode - The node (either from or to node of the edge).
   * @param ctx - The context that will be used for rendering.
   * @param viaNode - Additional node(s) the edge passes through.
   *
   * @returns Cartesian coordinates of the intersection between the border of the node and the edge.
   */_createClass(BezierEdgeBase,[{key:"_findBorderPositionBezier",value:function _findBorderPositionBezier(nearNode,ctx){var viaNode=arguments.length>2&&arguments[2]!==undefined?arguments[2]:this._getViaCoordinates();var maxIterations=10;var threshold=0.2;var from=false;var high=1;var low=0;var node=this.to;var pos;var middle;var endPointOffset=this.options.endPointOffset?this.options.endPointOffset.to:0;if(nearNode.id===this.from.id){node=this.from;from=true;endPointOffset=this.options.endPointOffset?this.options.endPointOffset.from:0;}if(this.options.arrowStrikethrough===false){endPointOffset=0;}var iteration=0;do{middle=(low+high)*0.5;pos=this.getPoint(middle,viaNode);var angle=Math.atan2(node.y-pos.y,node.x-pos.x);var distanceToBorder=node.distanceToBorder(ctx,angle)+endPointOffset;var distanceToPoint=Math.sqrt(Math.pow(pos.x-node.x,2)+Math.pow(pos.y-node.y,2));var difference=distanceToBorder-distanceToPoint;if(Math.abs(difference)<threshold){break;// found
}else if(difference<0){// distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.
if(from===false){low=middle;}else{high=middle;}}else{if(from===false){high=middle;}else{low=middle;}}++iteration;}while(low<=high&&iteration<maxIterations);return _objectSpread(_objectSpread({},pos),{},{t:middle});}/**
     * Calculate the distance between a point (x3,y3) and a line segment from (x1,y1) to (x2,y2).
     *
     * @remarks
     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
     *
     * @param x1 - First end of the line segment on the x axis.
     * @param y1 - First end of the line segment on the y axis.
     * @param x2 - Second end of the line segment on the x axis.
     * @param y2 - Second end of the line segment on the y axis.
     * @param x3 - Position of the point on the x axis.
     * @param y3 - Position of the point on the y axis.
     * @param via - The control point for the edge.
     *
     * @returns The distance between the line segment and the point.
     */},{key:"_getDistanceToBezierEdge",value:function _getDistanceToBezierEdge(x1,y1,x2,y2,x3,y3,via){// x3,y3 is the point
var minDistance=1e9;var distance;var i,t,x,y;var lastX=x1;var lastY=y1;for(i=1;i<10;i++){t=0.1*i;x=Math.pow(1-t,2)*x1+2*t*(1-t)*via.x+Math.pow(t,2)*x2;y=Math.pow(1-t,2)*y1+2*t*(1-t)*via.y+Math.pow(t,2)*y2;if(i>0){distance=this._getDistanceToLine(lastX,lastY,x,y,x3,y3);minDistance=distance<minDistance?distance:minDistance;}lastX=x;lastY=y;}return minDistance;}/**
     * Render a bezier curve between two nodes.
     *
     * @remarks
     * The method accepts zero, one or two control points.
     * Passing zero control points just draws a straight line.
     *
     * @param ctx - The context that will be used for rendering.
     * @param values - Style options for edge drawing.
     * @param viaNode1 - First control point for curve drawing.
     * @param viaNode2 - Second control point for curve drawing.
     */},{key:"_bezierCurve",value:function _bezierCurve(ctx,values,viaNode1,viaNode2){ctx.beginPath();ctx.moveTo(this.fromPoint.x,this.fromPoint.y);if(viaNode1!=null&&viaNode1.x!=null){if(viaNode2!=null&&viaNode2.x!=null){ctx.bezierCurveTo(viaNode1.x,viaNode1.y,viaNode2.x,viaNode2.y,this.toPoint.x,this.toPoint.y);}else{ctx.quadraticCurveTo(viaNode1.x,viaNode1.y,this.toPoint.x,this.toPoint.y);}}else{// fallback to normal straight edge
ctx.lineTo(this.toPoint.x,this.toPoint.y);}// draw a background
this.drawBackground(ctx,values);// draw shadow if enabled
this.enableShadow(ctx,values);ctx.stroke();this.disableShadow(ctx,values);}/** @inheritDoc */},{key:"getViaNode",value:function getViaNode(){return this._getViaCoordinates();}}]);return BezierEdgeBase;}(EdgeBase);function _createSuper$8(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$8();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$8(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * A Dynamic Bezier Edge. Bezier curves are used to model smooth gradual
 * curves in paths between nodes. The Dynamic piece refers to how the curve
 * reacts to physics changes.
 *
 * @augments BezierEdgeBase
 */var BezierEdgeDynamic=/*#__PURE__*/function(_BezierEdgeBase){_inherits(BezierEdgeDynamic,_BezierEdgeBase);var _super=_createSuper$8(BezierEdgeDynamic);/**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */function BezierEdgeDynamic(options,body,labelModule){var _this;_classCallCheck(this,BezierEdgeDynamic);//this.via = undefined; // Here for completeness but not allowed to defined before super() is invoked.
_this=_super.call(this,options,body,labelModule);// --> this calls the setOptions below
_this.via=_this.via;// constructor → super → super → setOptions → setupSupportNode
_this._boundFunction=function(){_this.positionBezierNode();};_this._body.emitter.on("_repositionBezierNodes",_this._boundFunction);return _this;}/** @inheritDoc */_createClass(BezierEdgeDynamic,[{key:"setOptions",value:function setOptions(options){_get(_getPrototypeOf(BezierEdgeDynamic.prototype),"setOptions",this).call(this,options);// check if the physics has changed.
var physicsChange=false;if(this.options.physics!==options.physics){physicsChange=true;}// set the options and the to and from nodes
this.options=options;this.id=this.options.id;this.from=this._body.nodes[this.options.from];this.to=this._body.nodes[this.options.to];// setup the support node and connect
this.setupSupportNode();this.connect();// when we change the physics state of the edge, we reposition the support node.
if(physicsChange===true){this.via.setOptions({physics:this.options.physics});this.positionBezierNode();}}/** @inheritDoc */},{key:"connect",value:function connect(){this.from=this._body.nodes[this.options.from];this.to=this._body.nodes[this.options.to];if(this.from===undefined||this.to===undefined||this.options.physics===false){this.via.setOptions({physics:false});}else{// fix weird behaviour where a self referencing node has physics enabled
if(this.from.id===this.to.id){this.via.setOptions({physics:false});}else{this.via.setOptions({physics:true});}}}/** @inheritDoc */},{key:"cleanup",value:function cleanup(){this._body.emitter.off("_repositionBezierNodes",this._boundFunction);if(this.via!==undefined){delete this._body.nodes[this.via.id];this.via=undefined;return true;}return false;}/**
     * Create and add a support node if not already present.
     *
     * @remarks
     * Bezier curves require an anchor point to calculate the smooth flow.
     * These points are nodes.
     * These nodes are invisible but are used for the force calculation.
     *
     * The changed data is not called, if needed, it is returned by the main edge constructor.
     */},{key:"setupSupportNode",value:function setupSupportNode(){if(this.via===undefined){var nodeId="edgeId:"+this.id;var node=this._body.functions.createNode({id:nodeId,shape:"circle",physics:true,hidden:true});this._body.nodes[nodeId]=node;this.via=node;this.via.parentEdgeId=this.id;this.positionBezierNode();}}/**
     * Position bezier node.
     */},{key:"positionBezierNode",value:function positionBezierNode(){if(this.via!==undefined&&this.from!==undefined&&this.to!==undefined){this.via.x=0.5*(this.from.x+this.to.x);this.via.y=0.5*(this.from.y+this.to.y);}else if(this.via!==undefined){this.via.x=0;this.via.y=0;}}/** @inheritDoc */},{key:"_line",value:function _line(ctx,values,viaNode){this._bezierCurve(ctx,values,viaNode);}/** @inheritDoc */},{key:"_getViaCoordinates",value:function _getViaCoordinates(){return this.via;}/** @inheritDoc */},{key:"getViaNode",value:function getViaNode(){return this.via;}/** @inheritDoc */},{key:"getPoint",value:function getPoint(position){var viaNode=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.via;if(this.from===this.to){var _this$_getCircleData=this._getCircleData(),_this$_getCircleData2=_slicedToArray(_this$_getCircleData,3),cx=_this$_getCircleData2[0],cy=_this$_getCircleData2[1],cr=_this$_getCircleData2[2];var a=2*Math.PI*(1-position);return{x:cx+cr*Math.sin(a),y:cy+cr-cr*(1-Math.cos(a))};}else{return{x:Math.pow(1-position,2)*this.fromPoint.x+2*position*(1-position)*viaNode.x+Math.pow(position,2)*this.toPoint.x,y:Math.pow(1-position,2)*this.fromPoint.y+2*position*(1-position)*viaNode.y+Math.pow(position,2)*this.toPoint.y};}}/** @inheritDoc */},{key:"_findBorderPosition",value:function _findBorderPosition(nearNode,ctx){return this._findBorderPositionBezier(nearNode,ctx,this.via);}/** @inheritDoc */},{key:"_getDistanceToEdge",value:function _getDistanceToEdge(x1,y1,x2,y2,x3,y3){// x3,y3 is the point
return this._getDistanceToBezierEdge(x1,y1,x2,y2,x3,y3,this.via);}}]);return BezierEdgeDynamic;}(BezierEdgeBase);function _createSuper$7(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$7();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$7(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * A Static Bezier Edge. Bezier curves are used to model smooth gradual curves in paths between nodes.
 */var BezierEdgeStatic=/*#__PURE__*/function(_BezierEdgeBase){_inherits(BezierEdgeStatic,_BezierEdgeBase);var _super=_createSuper$7(BezierEdgeStatic);/**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */function BezierEdgeStatic(options,body,labelModule){_classCallCheck(this,BezierEdgeStatic);return _super.call(this,options,body,labelModule);}/** @inheritDoc */_createClass(BezierEdgeStatic,[{key:"_line",value:function _line(ctx,values,viaNode){this._bezierCurve(ctx,values,viaNode);}/** @inheritDoc */},{key:"getViaNode",value:function getViaNode(){return this._getViaCoordinates();}/**
     * Compute the coordinates of the via node.
     *
     * @remarks
     * We do not use the to and fromPoints here to make the via nodes the same as edges without arrows.
     *
     * @returns Cartesian coordinates of the via node.
     */},{key:"_getViaCoordinates",value:function _getViaCoordinates(){// Assumption: x/y coordinates in from/to always defined
var factor=this.options.smooth.roundness;var type=this.options.smooth.type;var dx=Math.abs(this.from.x-this.to.x);var dy=Math.abs(this.from.y-this.to.y);if(type==="discrete"||type==="diagonalCross"){var stepX;var stepY;if(dx<=dy){stepX=stepY=factor*dy;}else{stepX=stepY=factor*dx;}if(this.from.x>this.to.x){stepX=-stepX;}if(this.from.y>=this.to.y){stepY=-stepY;}var xVia=this.from.x+stepX;var yVia=this.from.y+stepY;if(type==="discrete"){if(dx<=dy){xVia=dx<factor*dy?this.from.x:xVia;}else{yVia=dy<factor*dx?this.from.y:yVia;}}return{x:xVia,y:yVia};}else if(type==="straightCross"){var _stepX=(1-factor)*dx;var _stepY=(1-factor)*dy;if(dx<=dy){// up - down
_stepX=0;if(this.from.y<this.to.y){_stepY=-_stepY;}}else{// left - right
if(this.from.x<this.to.x){_stepX=-_stepX;}_stepY=0;}return{x:this.to.x+_stepX,y:this.to.y+_stepY};}else if(type==="horizontal"){var _stepX2=(1-factor)*dx;if(this.from.x<this.to.x){_stepX2=-_stepX2;}return{x:this.to.x+_stepX2,y:this.from.y};}else if(type==="vertical"){var _stepY2=(1-factor)*dy;if(this.from.y<this.to.y){_stepY2=-_stepY2;}return{x:this.from.x,y:this.to.y+_stepY2};}else if(type==="curvedCW"){dx=this.to.x-this.from.x;dy=this.from.y-this.to.y;var radius=Math.sqrt(dx*dx+dy*dy);var pi=Math.PI;var originalAngle=Math.atan2(dy,dx);var myAngle=(originalAngle+(factor*0.5+0.5)*pi)%(2*pi);return{x:this.from.x+(factor*0.5+0.5)*radius*Math.sin(myAngle),y:this.from.y+(factor*0.5+0.5)*radius*Math.cos(myAngle)};}else if(type==="curvedCCW"){dx=this.to.x-this.from.x;dy=this.from.y-this.to.y;var _radius=Math.sqrt(dx*dx+dy*dy);var _pi=Math.PI;var _originalAngle=Math.atan2(dy,dx);var _myAngle=(_originalAngle+(-factor*0.5+0.5)*_pi)%(2*_pi);return{x:this.from.x+(factor*0.5+0.5)*_radius*Math.sin(_myAngle),y:this.from.y+(factor*0.5+0.5)*_radius*Math.cos(_myAngle)};}else{// continuous
var _stepX3;var _stepY3;if(dx<=dy){_stepX3=_stepY3=factor*dy;}else{_stepX3=_stepY3=factor*dx;}if(this.from.x>this.to.x){_stepX3=-_stepX3;}if(this.from.y>=this.to.y){_stepY3=-_stepY3;}var _xVia=this.from.x+_stepX3;var _yVia=this.from.y+_stepY3;if(dx<=dy){if(this.from.x<=this.to.x){_xVia=this.to.x<_xVia?this.to.x:_xVia;}else{_xVia=this.to.x>_xVia?this.to.x:_xVia;}}else{if(this.from.y>=this.to.y){_yVia=this.to.y>_yVia?this.to.y:_yVia;}else{_yVia=this.to.y<_yVia?this.to.y:_yVia;}}return{x:_xVia,y:_yVia};}}/** @inheritDoc */},{key:"_findBorderPosition",value:function _findBorderPosition(nearNode,ctx){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};return this._findBorderPositionBezier(nearNode,ctx,options.via);}/** @inheritDoc */},{key:"_getDistanceToEdge",value:function _getDistanceToEdge(x1,y1,x2,y2,x3,y3){var viaNode=arguments.length>6&&arguments[6]!==undefined?arguments[6]:this._getViaCoordinates();// x3,y3 is the point
return this._getDistanceToBezierEdge(x1,y1,x2,y2,x3,y3,viaNode);}/** @inheritDoc */},{key:"getPoint",value:function getPoint(position){var viaNode=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this._getViaCoordinates();var t=position;var x=Math.pow(1-t,2)*this.fromPoint.x+2*t*(1-t)*viaNode.x+Math.pow(t,2)*this.toPoint.x;var y=Math.pow(1-t,2)*this.fromPoint.y+2*t*(1-t)*viaNode.y+Math.pow(t,2)*this.toPoint.y;return{x:x,y:y};}}]);return BezierEdgeStatic;}(BezierEdgeBase);function _createSuper$6(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$6();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$6(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * A Base Class for all Cubic Bezier Edges. Bezier curves are used to model
 * smooth gradual curves in paths between nodes.
 *
 * @augments BezierEdgeBase
 */var CubicBezierEdgeBase=/*#__PURE__*/function(_BezierEdgeBase){_inherits(CubicBezierEdgeBase,_BezierEdgeBase);var _super=_createSuper$6(CubicBezierEdgeBase);/**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */function CubicBezierEdgeBase(options,body,labelModule){_classCallCheck(this,CubicBezierEdgeBase);return _super.call(this,options,body,labelModule);}/**
   * Calculate the distance between a point (x3,y3) and a line segment from (x1,y1) to (x2,y2).
   *
   * @remarks
   * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment
   * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
   *
   * @param x1 - First end of the line segment on the x axis.
   * @param y1 - First end of the line segment on the y axis.
   * @param x2 - Second end of the line segment on the x axis.
   * @param y2 - Second end of the line segment on the y axis.
   * @param x3 - Position of the point on the x axis.
   * @param y3 - Position of the point on the y axis.
   * @param via1 - The first point this edge passes through.
   * @param via2 - The second point this edge passes through.
   *
   * @returns The distance between the line segment and the point.
   */_createClass(CubicBezierEdgeBase,[{key:"_getDistanceToBezierEdge2",value:function _getDistanceToBezierEdge2(x1,y1,x2,y2,x3,y3,via1,via2){// x3,y3 is the point
var minDistance=1e9;var lastX=x1;var lastY=y1;var vec=[0,0,0,0];for(var i=1;i<10;i++){var t=0.1*i;vec[0]=Math.pow(1-t,3);vec[1]=3*t*Math.pow(1-t,2);vec[2]=3*Math.pow(t,2)*(1-t);vec[3]=Math.pow(t,3);var x=vec[0]*x1+vec[1]*via1.x+vec[2]*via2.x+vec[3]*x2;var y=vec[0]*y1+vec[1]*via1.y+vec[2]*via2.y+vec[3]*y2;if(i>0){var distance=this._getDistanceToLine(lastX,lastY,x,y,x3,y3);minDistance=distance<minDistance?distance:minDistance;}lastX=x;lastY=y;}return minDistance;}}]);return CubicBezierEdgeBase;}(BezierEdgeBase);function _createSuper$5(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$5();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$5(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * A Cubic Bezier Edge. Bezier curves are used to model smooth gradual curves in paths between nodes.
 */var CubicBezierEdge=/*#__PURE__*/function(_CubicBezierEdgeBase){_inherits(CubicBezierEdge,_CubicBezierEdgeBase);var _super=_createSuper$5(CubicBezierEdge);/**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */function CubicBezierEdge(options,body,labelModule){_classCallCheck(this,CubicBezierEdge);return _super.call(this,options,body,labelModule);}/** @inheritDoc */_createClass(CubicBezierEdge,[{key:"_line",value:function _line(ctx,values,viaNodes){// get the coordinates of the support points.
var via1=viaNodes[0];var via2=viaNodes[1];this._bezierCurve(ctx,values,via1,via2);}/**
     * Compute the additional points the edge passes through.
     *
     * @returns Cartesian coordinates of the points the edge passes through.
     */},{key:"_getViaCoordinates",value:function _getViaCoordinates(){var dx=this.from.x-this.to.x;var dy=this.from.y-this.to.y;var x1;var y1;var x2;var y2;var roundness=this.options.smooth.roundness;// horizontal if x > y or if direction is forced or if direction is horizontal
if((Math.abs(dx)>Math.abs(dy)||this.options.smooth.forceDirection===true||this.options.smooth.forceDirection==="horizontal")&&this.options.smooth.forceDirection!=="vertical"){y1=this.from.y;y2=this.to.y;x1=this.from.x-roundness*dx;x2=this.to.x+roundness*dx;}else{y1=this.from.y-roundness*dy;y2=this.to.y+roundness*dy;x1=this.from.x;x2=this.to.x;}return[{x:x1,y:y1},{x:x2,y:y2}];}/** @inheritDoc */},{key:"getViaNode",value:function getViaNode(){return this._getViaCoordinates();}/** @inheritDoc */},{key:"_findBorderPosition",value:function _findBorderPosition(nearNode,ctx){return this._findBorderPositionBezier(nearNode,ctx);}/** @inheritDoc */},{key:"_getDistanceToEdge",value:function _getDistanceToEdge(x1,y1,x2,y2,x3,y3){var _ref=arguments.length>6&&arguments[6]!==undefined?arguments[6]:this._getViaCoordinates(),_ref2=_slicedToArray(_ref,2),via1=_ref2[0],via2=_ref2[1];// x3,y3 is the point
return this._getDistanceToBezierEdge2(x1,y1,x2,y2,x3,y3,via1,via2);}/** @inheritDoc */},{key:"getPoint",value:function getPoint(position){var _ref3=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this._getViaCoordinates(),_ref4=_slicedToArray(_ref3,2),via1=_ref4[0],via2=_ref4[1];var t=position;var vec=[Math.pow(1-t,3),3*t*Math.pow(1-t,2),3*Math.pow(t,2)*(1-t),Math.pow(t,3)];var x=vec[0]*this.fromPoint.x+vec[1]*via1.x+vec[2]*via2.x+vec[3]*this.toPoint.x;var y=vec[0]*this.fromPoint.y+vec[1]*via1.y+vec[2]*via2.y+vec[3]*this.toPoint.y;return{x:x,y:y};}}]);return CubicBezierEdge;}(CubicBezierEdgeBase);function _createSuper$4(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$4();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$4(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * A Straight Edge.
 */var StraightEdge=/*#__PURE__*/function(_EdgeBase){_inherits(StraightEdge,_EdgeBase);var _super=_createSuper$4(StraightEdge);/**
   * Create a new instance.
   *
   * @param options - The options object of given edge.
   * @param body - The body of the network.
   * @param labelModule - Label module.
   */function StraightEdge(options,body,labelModule){_classCallCheck(this,StraightEdge);return _super.call(this,options,body,labelModule);}/** @inheritDoc */_createClass(StraightEdge,[{key:"_line",value:function _line(ctx,values){// draw a straight line
ctx.beginPath();ctx.moveTo(this.fromPoint.x,this.fromPoint.y);ctx.lineTo(this.toPoint.x,this.toPoint.y);// draw shadow if enabled
this.enableShadow(ctx,values);ctx.stroke();this.disableShadow(ctx,values);}/** @inheritDoc */},{key:"getViaNode",value:function getViaNode(){return undefined;}/** @inheritDoc */},{key:"getPoint",value:function getPoint(position){return{x:(1-position)*this.fromPoint.x+position*this.toPoint.x,y:(1-position)*this.fromPoint.y+position*this.toPoint.y};}/** @inheritDoc */},{key:"_findBorderPosition",value:function _findBorderPosition(nearNode,ctx){var node1=this.to;var node2=this.from;if(nearNode.id===this.from.id){node1=this.from;node2=this.to;}var angle=Math.atan2(node1.y-node2.y,node1.x-node2.x);var dx=node1.x-node2.x;var dy=node1.y-node2.y;var edgeSegmentLength=Math.sqrt(dx*dx+dy*dy);var toBorderDist=nearNode.distanceToBorder(ctx,angle);var toBorderPoint=(edgeSegmentLength-toBorderDist)/edgeSegmentLength;return{x:(1-toBorderPoint)*node2.x+toBorderPoint*node1.x,y:(1-toBorderPoint)*node2.y+toBorderPoint*node1.y,t:0};}/** @inheritDoc */},{key:"_getDistanceToEdge",value:function _getDistanceToEdge(x1,y1,x2,y2,x3,y3){// x3,y3 is the point
return this._getDistanceToLine(x1,y1,x2,y2,x3,y3);}}]);return StraightEdge;}(EdgeBase);/**
 * An edge connects two nodes and has a specific direction.
 */var Edge=/*#__PURE__*/function(){/**
   * @param {object} options        values specific to this edge, must contain at least 'from' and 'to'
   * @param {object} body           shared state from Network instance
   * @param {Network.Images} imagelist  A list with images. Only needed when the edge has image arrows.
   * @param {object} globalOptions  options from the EdgesHandler instance
   * @param {object} defaultOptions default options from the EdgeHandler instance. Value and reference are constant
   */function Edge(options,body,imagelist,globalOptions,defaultOptions){_classCallCheck(this,Edge);if(body===undefined){throw new Error("No body provided");}// Since globalOptions is constant in values as well as reference,
// Following needs to be done only once.
this.options=bridgeObject(globalOptions);this.globalOptions=globalOptions;this.defaultOptions=defaultOptions;this.body=body;this.imagelist=imagelist;// initialize variables
this.id=undefined;this.fromId=undefined;this.toId=undefined;this.selected=false;this.hover=false;this.labelDirty=true;this.baseWidth=this.options.width;this.baseFontSize=this.options.font.size;this.from=undefined;// a node
this.to=undefined;// a node
this.edgeType=undefined;this.connected=false;this.labelModule=new Label(this.body,this.options,true/* It's an edge label */);this.setOptions(options);}/**
   * Set or overwrite options for the edge
   *
   * @param {object} options  an object with options
   * @returns {undefined|boolean} undefined if no options, true if layout affecting data changed, false otherwise.
   */_createClass(Edge,[{key:"setOptions",value:function setOptions(options){if(!options){return;}// Following options if changed affect the layout.
var affectsLayout=typeof options.physics!=="undefined"&&this.options.physics!==options.physics||typeof options.hidden!=="undefined"&&(this.options.hidden||false)!==(options.hidden||false)||typeof options.from!=="undefined"&&this.options.from!==options.from||typeof options.to!=="undefined"&&this.options.to!==options.to;Edge.parseOptions(this.options,options,true,this.globalOptions);if(options.id!==undefined){this.id=options.id;}if(options.from!==undefined){this.fromId=options.from;}if(options.to!==undefined){this.toId=options.to;}if(options.title!==undefined){this.title=options.title;}if(options.value!==undefined){options.value=_parseFloat(options.value);}var pile=[options,this.options,this.defaultOptions];this.chooser=choosify("edge",pile);// update label Module
this.updateLabelModule(options);// Update edge type, this if changed affects the layout.
affectsLayout=this.updateEdgeType()||affectsLayout;// if anything has been updates, reset the selection width and the hover width
this._setInteractionWidths();// A node is connected when it has a from and to node that both exist in the network.body.nodes.
this.connect();return affectsLayout;}/**
     *
     * @param {object} parentOptions
     * @param {object} newOptions
     * @param {boolean} [allowDeletion=false]
     * @param {object} [globalOptions={}]
     * @param {boolean} [copyFromGlobals=false]
     */},{key:"getFormattingValues",value:/**
     *
     * @returns {ArrowOptions}
     */function getFormattingValues(){var toArrow=this.options.arrows.to===true||this.options.arrows.to.enabled===true;var fromArrow=this.options.arrows.from===true||this.options.arrows.from.enabled===true;var middleArrow=this.options.arrows.middle===true||this.options.arrows.middle.enabled===true;var inheritsColor=this.options.color.inherit;var values={toArrow:toArrow,toArrowScale:this.options.arrows.to.scaleFactor,toArrowType:this.options.arrows.to.type,toArrowSrc:this.options.arrows.to.src,toArrowImageWidth:this.options.arrows.to.imageWidth,toArrowImageHeight:this.options.arrows.to.imageHeight,middleArrow:middleArrow,middleArrowScale:this.options.arrows.middle.scaleFactor,middleArrowType:this.options.arrows.middle.type,middleArrowSrc:this.options.arrows.middle.src,middleArrowImageWidth:this.options.arrows.middle.imageWidth,middleArrowImageHeight:this.options.arrows.middle.imageHeight,fromArrow:fromArrow,fromArrowScale:this.options.arrows.from.scaleFactor,fromArrowType:this.options.arrows.from.type,fromArrowSrc:this.options.arrows.from.src,fromArrowImageWidth:this.options.arrows.from.imageWidth,fromArrowImageHeight:this.options.arrows.from.imageHeight,arrowStrikethrough:this.options.arrowStrikethrough,color:inheritsColor?undefined:this.options.color.color,inheritsColor:inheritsColor,opacity:this.options.color.opacity,hidden:this.options.hidden,length:this.options.length,shadow:this.options.shadow.enabled,shadowColor:this.options.shadow.color,shadowSize:this.options.shadow.size,shadowX:this.options.shadow.x,shadowY:this.options.shadow.y,dashes:this.options.dashes,width:this.options.width,background:this.options.background.enabled,backgroundColor:this.options.background.color,backgroundSize:this.options.background.size,backgroundDashes:this.options.background.dashes};if(this.selected||this.hover){if(this.chooser===true){if(this.selected){var selectedWidth=this.options.selectionWidth;if(typeof selectedWidth==="function"){values.width=selectedWidth(values.width);}else if(typeof selectedWidth==="number"){values.width+=selectedWidth;}values.width=Math.max(values.width,0.3/this.body.view.scale);values.color=this.options.color.highlight;values.shadow=this.options.shadow.enabled;}else if(this.hover){var hoverWidth=this.options.hoverWidth;if(typeof hoverWidth==="function"){values.width=hoverWidth(values.width);}else if(typeof hoverWidth==="number"){values.width+=hoverWidth;}values.width=Math.max(values.width,0.3/this.body.view.scale);values.color=this.options.color.hover;values.shadow=this.options.shadow.enabled;}}else if(typeof this.chooser==="function"){this.chooser(values,this.options.id,this.selected,this.hover);if(values.color!==undefined){values.inheritsColor=false;}if(values.shadow===false){if(values.shadowColor!==this.options.shadow.color||values.shadowSize!==this.options.shadow.size||values.shadowX!==this.options.shadow.x||values.shadowY!==this.options.shadow.y){values.shadow=true;}}}}else{values.shadow=this.options.shadow.enabled;values.width=Math.max(values.width,0.3/this.body.view.scale);}return values;}/**
     * update the options in the label module
     *
     * @param {object} options
     */},{key:"updateLabelModule",value:function updateLabelModule(options){var pile=[options,this.options,this.globalOptions,// Currently set global edge options
this.defaultOptions];this.labelModule.update(this.options,pile);if(this.labelModule.baseSize!==undefined){this.baseFontSize=this.labelModule.baseSize;}}/**
     * update the edge type, set the options
     *
     * @returns {boolean}
     */},{key:"updateEdgeType",value:function updateEdgeType(){var smooth=this.options.smooth;var dataChanged=false;var changeInType=true;if(this.edgeType!==undefined){if(this.edgeType instanceof BezierEdgeDynamic&&smooth.enabled===true&&smooth.type==="dynamic"||this.edgeType instanceof CubicBezierEdge&&smooth.enabled===true&&smooth.type==="cubicBezier"||this.edgeType instanceof BezierEdgeStatic&&smooth.enabled===true&&smooth.type!=="dynamic"&&smooth.type!=="cubicBezier"||this.edgeType instanceof StraightEdge&&smooth.type.enabled===false){changeInType=false;}if(changeInType===true){dataChanged=this.cleanup();}}if(changeInType===true){if(smooth.enabled===true){if(smooth.type==="dynamic"){dataChanged=true;this.edgeType=new BezierEdgeDynamic(this.options,this.body,this.labelModule);}else if(smooth.type==="cubicBezier"){this.edgeType=new CubicBezierEdge(this.options,this.body,this.labelModule);}else{this.edgeType=new BezierEdgeStatic(this.options,this.body,this.labelModule);}}else{this.edgeType=new StraightEdge(this.options,this.body,this.labelModule);}}else{// if nothing changes, we just set the options.
this.edgeType.setOptions(this.options);}return dataChanged;}/**
     * Connect an edge to its nodes
     */},{key:"connect",value:function connect(){this.disconnect();this.from=this.body.nodes[this.fromId]||undefined;this.to=this.body.nodes[this.toId]||undefined;this.connected=this.from!==undefined&&this.to!==undefined;if(this.connected===true){this.from.attachEdge(this);this.to.attachEdge(this);}else{if(this.from){this.from.detachEdge(this);}if(this.to){this.to.detachEdge(this);}}this.edgeType.connect();}/**
     * Disconnect an edge from its nodes
     */},{key:"disconnect",value:function disconnect(){if(this.from){this.from.detachEdge(this);this.from=undefined;}if(this.to){this.to.detachEdge(this);this.to=undefined;}this.connected=false;}/**
     * get the title of this edge.
     *
     * @returns {string} title    The title of the edge, or undefined when no title
     *                           has been set.
     */},{key:"getTitle",value:function getTitle(){return this.title;}/**
     * check if this node is selecte
     *
     * @returns {boolean} selected   True if node is selected, else false
     */},{key:"isSelected",value:function isSelected(){return this.selected;}/**
     * Retrieve the value of the edge. Can be undefined
     *
     * @returns {number} value
     */},{key:"getValue",value:function getValue(){return this.options.value;}/**
     * Adjust the value range of the edge. The edge will adjust it's width
     * based on its value.
     *
     * @param {number} min
     * @param {number} max
     * @param {number} total
     */},{key:"setValueRange",value:function setValueRange(min,max,total){if(this.options.value!==undefined){var scale=this.options.scaling.customScalingFunction(min,max,total,this.options.value);var widthDiff=this.options.scaling.max-this.options.scaling.min;if(this.options.scaling.label.enabled===true){var fontDiff=this.options.scaling.label.max-this.options.scaling.label.min;this.options.font.size=this.options.scaling.label.min+scale*fontDiff;}this.options.width=this.options.scaling.min+scale*widthDiff;}else{this.options.width=this.baseWidth;this.options.font.size=this.baseFontSize;}this._setInteractionWidths();this.updateLabelModule();}/**
     *
     * @private
     */},{key:"_setInteractionWidths",value:function _setInteractionWidths(){if(typeof this.options.hoverWidth==="function"){this.edgeType.hoverWidth=this.options.hoverWidth(this.options.width);}else{this.edgeType.hoverWidth=this.options.hoverWidth+this.options.width;}if(typeof this.options.selectionWidth==="function"){this.edgeType.selectionWidth=this.options.selectionWidth(this.options.width);}else{this.edgeType.selectionWidth=this.options.selectionWidth+this.options.width;}}/**
     * Redraw a edge
     * Draw this edge in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     *
     * @param {CanvasRenderingContext2D}   ctx
     */},{key:"draw",value:function draw(ctx){var values=this.getFormattingValues();if(values.hidden){return;}// get the via node from the edge type
var viaNode=this.edgeType.getViaNode();// draw line and label
this.edgeType.drawLine(ctx,values,this.selected,this.hover,viaNode);this.drawLabel(ctx,viaNode);}/**
     * Redraw arrows
     * Draw this arrows in the given canvas
     * The 2d context of a HTML canvas can be retrieved by canvas.getContext("2d");
     *
     * @param {CanvasRenderingContext2D}   ctx
     */},{key:"drawArrows",value:function drawArrows(ctx){var values=this.getFormattingValues();if(values.hidden){return;}// get the via node from the edge type
var viaNode=this.edgeType.getViaNode();var arrowData={};// restore edge targets to defaults
this.edgeType.fromPoint=this.edgeType.from;this.edgeType.toPoint=this.edgeType.to;// from and to arrows give a different end point for edges. we set them here
if(values.fromArrow){arrowData.from=this.edgeType.getArrowData(ctx,"from",viaNode,this.selected,this.hover,values);if(values.arrowStrikethrough===false)this.edgeType.fromPoint=arrowData.from.core;if(values.fromArrowSrc){arrowData.from.image=this.imagelist.load(values.fromArrowSrc);}if(values.fromArrowImageWidth){arrowData.from.imageWidth=values.fromArrowImageWidth;}if(values.fromArrowImageHeight){arrowData.from.imageHeight=values.fromArrowImageHeight;}}if(values.toArrow){arrowData.to=this.edgeType.getArrowData(ctx,"to",viaNode,this.selected,this.hover,values);if(values.arrowStrikethrough===false)this.edgeType.toPoint=arrowData.to.core;if(values.toArrowSrc){arrowData.to.image=this.imagelist.load(values.toArrowSrc);}if(values.toArrowImageWidth){arrowData.to.imageWidth=values.toArrowImageWidth;}if(values.toArrowImageHeight){arrowData.to.imageHeight=values.toArrowImageHeight;}}// the middle arrow depends on the line, which can depend on the to and from arrows so we do this one lastly.
if(values.middleArrow){arrowData.middle=this.edgeType.getArrowData(ctx,"middle",viaNode,this.selected,this.hover,values);if(values.middleArrowSrc){arrowData.middle.image=this.imagelist.load(values.middleArrowSrc);}if(values.middleArrowImageWidth){arrowData.middle.imageWidth=values.middleArrowImageWidth;}if(values.middleArrowImageHeight){arrowData.middle.imageHeight=values.middleArrowImageHeight;}}if(values.fromArrow){this.edgeType.drawArrowHead(ctx,values,this.selected,this.hover,arrowData.from);}if(values.middleArrow){this.edgeType.drawArrowHead(ctx,values,this.selected,this.hover,arrowData.middle);}if(values.toArrow){this.edgeType.drawArrowHead(ctx,values,this.selected,this.hover,arrowData.to);}}/**
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {Node} viaNode
     */},{key:"drawLabel",value:function drawLabel(ctx,viaNode){if(this.options.label!==undefined){// set style
var node1=this.from;var node2=this.to;if(this.labelModule.differentState(this.selected,this.hover)){this.labelModule.getTextSize(ctx,this.selected,this.hover);}var point;if(node1.id!=node2.id){this.labelModule.pointToSelf=false;point=this.edgeType.getPoint(0.5,viaNode);ctx.save();var rotationPoint=this._getRotation(ctx);if(rotationPoint.angle!=0){ctx.translate(rotationPoint.x,rotationPoint.y);ctx.rotate(rotationPoint.angle);}// draw the label
this.labelModule.draw(ctx,point.x,point.y,this.selected,this.hover);/*
          // Useful debug code: draw a border around the label
          // This should **not** be enabled in production!
          var size = this.labelModule.getSize();; // ;; intentional so lint catches it
          ctx.strokeStyle = "#ff0000";
          ctx.strokeRect(size.left, size.top, size.width, size.height);
          // End  debug code
          */ctx.restore();}else{// Ignore the orientations.
this.labelModule.pointToSelf=true;// get circle coordinates
var coordinates=getSelfRefCoordinates(ctx,this.options.selfReference.angle,this.options.selfReference.size,node1);point=this._pointOnCircle(coordinates.x,coordinates.y,this.options.selfReference.size,this.options.selfReference.angle);this.labelModule.draw(ctx,point.x,point.y,this.selected,this.hover);}}}/**
     * Determine all visual elements of this edge instance, in which the given
     * point falls within the bounding shape.
     *
     * @param {point} point
     * @returns {Array.<edgeClickItem|edgeLabelClickItem>} list with the items which are on the point
     */},{key:"getItemsOnPoint",value:function getItemsOnPoint(point){var ret=[];if(this.labelModule.visible()){var rotationPoint=this._getRotation();if(pointInRect(this.labelModule.getSize(),point,rotationPoint)){ret.push({edgeId:this.id,labelId:0});}}var obj={left:point.x,top:point.y};if(this.isOverlappingWith(obj)){ret.push({edgeId:this.id});}return ret;}/**
     * Check if this object is overlapping with the provided object
     *
     * @param {object} obj   an object with parameters left, top
     * @returns {boolean}     True if location is located on the edge
     */},{key:"isOverlappingWith",value:function isOverlappingWith(obj){if(this.connected){var distMax=10;var xFrom=this.from.x;var yFrom=this.from.y;var xTo=this.to.x;var yTo=this.to.y;var xObj=obj.left;var yObj=obj.top;var dist=this.edgeType.getDistanceToEdge(xFrom,yFrom,xTo,yTo,xObj,yObj);return dist<distMax;}else{return false;}}/**
     * Determine the rotation point, if any.
     *
     * @param {CanvasRenderingContext2D} [ctx] if passed, do a recalculation of the label size
     * @returns {rotationPoint} the point to rotate around and the angle in radians to rotate
     * @private
     */},{key:"_getRotation",value:function _getRotation(ctx){var viaNode=this.edgeType.getViaNode();var point=this.edgeType.getPoint(0.5,viaNode);if(ctx!==undefined){this.labelModule.calculateLabelSize(ctx,this.selected,this.hover,point.x,point.y);}var ret={x:point.x,y:this.labelModule.size.yLine,angle:0};if(!this.labelModule.visible()){return ret;// Don't even bother doing the atan2, there's nothing to draw
}if(this.options.font.align==="horizontal"){return ret;// No need to calculate angle
}var dy=this.from.y-this.to.y;var dx=this.from.x-this.to.x;var angle=Math.atan2(dy,dx);// radians
// rotate so that label is readable
if(angle<-1&&dx<0||angle>0&&dx<0){angle+=Math.PI;}ret.angle=angle;return ret;}/**
     * Get a point on a circle
     *
     * @param {number} x
     * @param {number} y
     * @param {number} radius
     * @param {number} angle
     * @returns {object} point
     * @private
     */},{key:"_pointOnCircle",value:function _pointOnCircle(x,y,radius,angle){return{x:x+radius*Math.cos(angle),y:y-radius*Math.sin(angle)};}/**
     * Sets selected state to true
     */},{key:"select",value:function select(){this.selected=true;}/**
     * Sets selected state to false
     */},{key:"unselect",value:function unselect(){this.selected=false;}/**
     * cleans all required things on delete
     *
     * @returns {*}
     */},{key:"cleanup",value:function cleanup(){return this.edgeType.cleanup();}/**
     * Remove edge from the list and perform necessary cleanup.
     */},{key:"remove",value:function remove(){this.cleanup();this.disconnect();delete this.body.edges[this.id];}/**
     * Check if both connecting nodes exist
     *
     * @returns {boolean}
     */},{key:"endPointsValid",value:function endPointsValid(){return this.body.nodes[this.fromId]!==undefined&&this.body.nodes[this.toId]!==undefined;}}],[{key:"parseOptions",value:function parseOptions(parentOptions,newOptions){var allowDeletion=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var globalOptions=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};var copyFromGlobals=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;var fields=["endPointOffset","arrowStrikethrough","id","from","hidden","hoverWidth","labelHighlightBold","length","line","opacity","physics","scaling","selectionWidth","selfReferenceSize","selfReference","to","title","value","width","font","chosen","widthConstraint"];// only deep extend the items in the field array. These do not have shorthand.
selectiveDeepExtend(fields,parentOptions,newOptions,allowDeletion);// Only use endPointOffset values (from and to) if it's valid values
if(newOptions.endPointOffset!==undefined&&newOptions.endPointOffset.from!==undefined){if(_isFinite(newOptions.endPointOffset.from)){parentOptions.endPointOffset.from=newOptions.endPointOffset.from;}else{parentOptions.endPointOffset.from=globalOptions.endPointOffset.from!==undefined?globalOptions.endPointOffset.from:0;console.error("endPointOffset.from is not a valid number");}}if(newOptions.endPointOffset!==undefined&&newOptions.endPointOffset.to!==undefined){if(_isFinite(newOptions.endPointOffset.to)){parentOptions.endPointOffset.to=newOptions.endPointOffset.to;}else{parentOptions.endPointOffset.to=globalOptions.endPointOffset.to!==undefined?globalOptions.endPointOffset.to:0;console.error("endPointOffset.to is not a valid number");}}// Only copy label if it's a legal value.
if(isValidLabel(newOptions.label)){parentOptions.label=newOptions.label;}else if(!isValidLabel(parentOptions.label)){parentOptions.label=undefined;}mergeOptions(parentOptions,newOptions,"smooth",globalOptions);mergeOptions(parentOptions,newOptions,"shadow",globalOptions);mergeOptions(parentOptions,newOptions,"background",globalOptions);if(newOptions.dashes!==undefined&&newOptions.dashes!==null){parentOptions.dashes=newOptions.dashes;}else if(allowDeletion===true&&newOptions.dashes===null){parentOptions.dashes=create$2(globalOptions.dashes);// this sets the pointer of the option back to the global option.
}// set the scaling newOptions
if(newOptions.scaling!==undefined&&newOptions.scaling!==null){if(newOptions.scaling.min!==undefined){parentOptions.scaling.min=newOptions.scaling.min;}if(newOptions.scaling.max!==undefined){parentOptions.scaling.max=newOptions.scaling.max;}mergeOptions(parentOptions.scaling,newOptions.scaling,"label",globalOptions.scaling);}else if(allowDeletion===true&&newOptions.scaling===null){parentOptions.scaling=create$2(globalOptions.scaling);// this sets the pointer of the option back to the global option.
}// handle multiple input cases for arrows
if(newOptions.arrows!==undefined&&newOptions.arrows!==null){if(typeof newOptions.arrows==="string"){var arrows=newOptions.arrows.toLowerCase();parentOptions.arrows.to.enabled=indexOf(arrows).call(arrows,"to")!=-1;parentOptions.arrows.middle.enabled=indexOf(arrows).call(arrows,"middle")!=-1;parentOptions.arrows.from.enabled=indexOf(arrows).call(arrows,"from")!=-1;}else if(_typeof(newOptions.arrows)==="object"){mergeOptions(parentOptions.arrows,newOptions.arrows,"to",globalOptions.arrows);mergeOptions(parentOptions.arrows,newOptions.arrows,"middle",globalOptions.arrows);mergeOptions(parentOptions.arrows,newOptions.arrows,"from",globalOptions.arrows);}else{throw new Error("The arrow newOptions can only be an object or a string. Refer to the documentation. You used:"+stringify$1(newOptions.arrows));}}else if(allowDeletion===true&&newOptions.arrows===null){parentOptions.arrows=create$2(globalOptions.arrows);// this sets the pointer of the option back to the global option.
}// handle multiple input cases for color
if(newOptions.color!==undefined&&newOptions.color!==null){var fromColor=isString(newOptions.color)?{color:newOptions.color,highlight:newOptions.color,hover:newOptions.color,inherit:false,opacity:1}:newOptions.color;var toColor=parentOptions.color;// If passed, fill in values from default options - required in the case of no prototype bridging
if(copyFromGlobals){deepExtend(toColor,globalOptions.color,false,allowDeletion);}else{// Clear local properties - need to do it like this in order to retain prototype bridges
for(var i in toColor){if(Object.prototype.hasOwnProperty.call(toColor,i)){delete toColor[i];}}}if(isString(toColor)){toColor.color=toColor;toColor.highlight=toColor;toColor.hover=toColor;toColor.inherit=false;if(fromColor.opacity===undefined){toColor.opacity=1.0;// set default
}}else{var colorsDefined=false;if(fromColor.color!==undefined){toColor.color=fromColor.color;colorsDefined=true;}if(fromColor.highlight!==undefined){toColor.highlight=fromColor.highlight;colorsDefined=true;}if(fromColor.hover!==undefined){toColor.hover=fromColor.hover;colorsDefined=true;}if(fromColor.inherit!==undefined){toColor.inherit=fromColor.inherit;}if(fromColor.opacity!==undefined){toColor.opacity=Math.min(1,Math.max(0,fromColor.opacity));}if(colorsDefined===true){toColor.inherit=false;}else{if(toColor.inherit===undefined){toColor.inherit="from";// Set default
}}}}else if(allowDeletion===true&&newOptions.color===null){parentOptions.color=bridgeObject(globalOptions.color);// set the object back to the global options
}if(allowDeletion===true&&newOptions.font===null){parentOptions.font=bridgeObject(globalOptions.font);// set the object back to the global options
}if(Object.prototype.hasOwnProperty.call(newOptions,"selfReferenceSize")){console.warn("The selfReferenceSize property has been deprecated. Please use selfReference property instead. The selfReference can be set like thise selfReference:{size:30, angle:Math.PI / 4}");parentOptions.selfReference.size=newOptions.selfReferenceSize;}}}]);return Edge;}();/**
 * Handler for Edges
 */var EdgesHandler=/*#__PURE__*/function(){/**
   * @param {object} body
   * @param {Array.<Image>} images
   * @param {Array.<Group>} groups
   */function EdgesHandler(body,images,groups){var _context,_this=this;_classCallCheck(this,EdgesHandler);this.body=body;this.images=images;this.groups=groups;// create the edge API in the body container
this.body.functions.createEdge=bind(_context=this.create).call(_context,this);this.edgesListeners={add:function add(event,params){_this.add(params.items);},update:function update(event,params){_this.update(params.items);},remove:function remove(event,params){_this.remove(params.items);}};this.options={};this.defaultOptions={arrows:{to:{enabled:false,scaleFactor:1,type:"arrow"},// boolean / {arrowScaleFactor:1} / {enabled: false, arrowScaleFactor:1}
middle:{enabled:false,scaleFactor:1,type:"arrow"},from:{enabled:false,scaleFactor:1,type:"arrow"}},endPointOffset:{from:0,to:0},arrowStrikethrough:true,color:{color:"#848484",highlight:"#848484",hover:"#848484",inherit:"from",opacity:1.0},dashes:false,font:{color:"#343434",size:14,// px
face:"arial",background:"none",strokeWidth:2,// px
strokeColor:"#ffffff",align:"horizontal",multi:false,vadjust:0,bold:{mod:"bold"},boldital:{mod:"bold italic"},ital:{mod:"italic"},mono:{mod:"",size:15,// px
face:"courier new",vadjust:2}},hidden:false,hoverWidth:1.5,label:undefined,labelHighlightBold:true,length:undefined,physics:true,scaling:{min:1,max:15,label:{enabled:true,min:14,max:30,maxVisible:30,drawThreshold:5},customScalingFunction:function customScalingFunction(min,max,total,value){if(max===min){return 0.5;}else{var scale=1/(max-min);return Math.max(0,(value-min)*scale);}}},selectionWidth:1.5,selfReference:{size:20,angle:Math.PI/4,renderBehindTheNode:true},shadow:{enabled:false,color:"rgba(0,0,0,0.5)",size:10,x:5,y:5},background:{enabled:false,color:"rgba(111,111,111,1)",size:10,dashes:false},smooth:{enabled:true,type:"dynamic",forceDirection:"none",roundness:0.5},title:undefined,width:1,value:undefined};deepExtend(this.options,this.defaultOptions);this.bindEventListeners();}/**
   * Binds event listeners
   */_createClass(EdgesHandler,[{key:"bindEventListeners",value:function bindEventListeners(){var _this2=this,_context2,_context3;// this allows external modules to force all dynamic curves to turn static.
this.body.emitter.on("_forceDisableDynamicCurves",function(type){var emit=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;if(type==="dynamic"){type="continuous";}var dataChanged=false;for(var edgeId in _this2.body.edges){if(Object.prototype.hasOwnProperty.call(_this2.body.edges,edgeId)){var edge=_this2.body.edges[edgeId];var edgeData=_this2.body.data.edges.get(edgeId);// only forcibly remove the smooth curve if the data has been set of the edge has the smooth curves defined.
// this is because a change in the global would not affect these curves.
if(edgeData!=null){var smoothOptions=edgeData.smooth;if(smoothOptions!==undefined){if(smoothOptions.enabled===true&&smoothOptions.type==="dynamic"){if(type===undefined){edge.setOptions({smooth:false});}else{edge.setOptions({smooth:{type:type}});}dataChanged=true;}}}}}if(emit===true&&dataChanged===true){_this2.body.emitter.emit("_dataChanged");}});// this is called when options of EXISTING nodes or edges have changed.
//
// NOTE: Not true, called when options have NOT changed, for both existing as well as new nodes.
//       See update() for logic.
// TODO: Verify and examine the consequences of this. It might still trigger when
//       non-option fields have changed, but then reconnecting edges is still useless.
//       Alternatively, it might also be called when edges are removed.
//
this.body.emitter.on("_dataUpdated",function(){_this2.reconnectEdges();});// refresh the edges. Used when reverting from hierarchical layout
this.body.emitter.on("refreshEdges",bind(_context2=this.refresh).call(_context2,this));this.body.emitter.on("refresh",bind(_context3=this.refresh).call(_context3,this));this.body.emitter.on("destroy",function(){forEach$1(_this2.edgesListeners,function(callback,event){if(_this2.body.data.edges)_this2.body.data.edges.off(event,callback);});delete _this2.body.functions.createEdge;delete _this2.edgesListeners.add;delete _this2.edgesListeners.update;delete _this2.edgesListeners.remove;delete _this2.edgesListeners;});}/**
     *
     * @param {object} options
     */},{key:"setOptions",value:function setOptions(options){if(options!==undefined){// use the parser from the Edge class to fill in all shorthand notations
Edge.parseOptions(this.options,options,true,this.defaultOptions,true);// update smooth settings in all edges
var dataChanged=false;if(options.smooth!==undefined){for(var edgeId in this.body.edges){if(Object.prototype.hasOwnProperty.call(this.body.edges,edgeId)){dataChanged=this.body.edges[edgeId].updateEdgeType()||dataChanged;}}}// update fonts in all edges
if(options.font!==undefined){for(var _edgeId in this.body.edges){if(Object.prototype.hasOwnProperty.call(this.body.edges,_edgeId)){this.body.edges[_edgeId].updateLabelModule();}}}// update the state of the variables if needed
if(options.hidden!==undefined||options.physics!==undefined||dataChanged===true){this.body.emitter.emit("_dataChanged");}}}/**
     * Load edges by reading the data table
     *
     * @param {Array | DataSet | DataView} edges    The data containing the edges.
     * @param {boolean} [doNotEmit=false] - Suppress data changed event.
     * @private
     */},{key:"setData",value:function setData(edges){var _this3=this;var doNotEmit=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var oldEdgesData=this.body.data.edges;if(isDataViewLike("id",edges)){this.body.data.edges=edges;}else if(isArray(edges)){this.body.data.edges=new DataSet();this.body.data.edges.add(edges);}else if(!edges){this.body.data.edges=new DataSet();}else{throw new TypeError("Array or DataSet expected");}// TODO: is this null or undefined or false?
if(oldEdgesData){// unsubscribe from old dataset
forEach$1(this.edgesListeners,function(callback,event){oldEdgesData.off(event,callback);});}// remove drawn edges
this.body.edges={};// TODO: is this null or undefined or false?
if(this.body.data.edges){// subscribe to new dataset
forEach$1(this.edgesListeners,function(callback,event){_this3.body.data.edges.on(event,callback);});// draw all new nodes
var ids=this.body.data.edges.getIds();this.add(ids,true);}this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");if(doNotEmit===false){this.body.emitter.emit("_dataChanged");}}/**
     * Add edges
     *
     * @param {number[] | string[]} ids
     * @param {boolean} [doNotEmit=false]
     * @private
     */},{key:"add",value:function add(ids){var doNotEmit=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var edges=this.body.edges;var edgesData=this.body.data.edges;for(var i=0;i<ids.length;i++){var id=ids[i];var oldEdge=edges[id];if(oldEdge){oldEdge.disconnect();}var data=edgesData.get(id,{showInternalIds:true});edges[id]=this.create(data);}this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");if(doNotEmit===false){this.body.emitter.emit("_dataChanged");}}/**
     * Update existing edges, or create them when not yet existing
     *
     * @param {number[] | string[]} ids
     * @private
     */},{key:"update",value:function update(ids){var edges=this.body.edges;var edgesData=this.body.data.edges;var dataChanged=false;for(var i=0;i<ids.length;i++){var id=ids[i];var data=edgesData.get(id);var edge=edges[id];if(edge!==undefined){// update edge
edge.disconnect();dataChanged=edge.setOptions(data)||dataChanged;// if a support node is added, data can be changed.
edge.connect();}else{// create edge
this.body.edges[id]=this.create(data);dataChanged=true;}}if(dataChanged===true){this.body.emitter.emit("_adjustEdgesForHierarchicalLayout");this.body.emitter.emit("_dataChanged");}else{this.body.emitter.emit("_dataUpdated");}}/**
     * Remove existing edges. Non existing ids will be ignored
     *
     * @param {number[] | string[]} ids
     * @param {boolean} [emit=true]
     * @private
     */},{key:"remove",value:function remove(ids){var emit=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;if(ids.length===0)return;// early out
var edges=this.body.edges;forEach$1(ids,function(id){var edge=edges[id];if(edge!==undefined){edge.remove();}});if(emit){this.body.emitter.emit("_dataChanged");}}/**
     * Refreshes Edge Handler
     */},{key:"refresh",value:function refresh(){var _this4=this;forEach$1(this.body.edges,function(edge,edgeId){var data=_this4.body.data.edges.get(edgeId);if(data!==undefined){edge.setOptions(data);}});}/**
     *
     * @param {object} properties
     * @returns {Edge}
     */},{key:"create",value:function create(properties){return new Edge(properties,this.body,this.images,this.options,this.defaultOptions);}/**
     * Reconnect all edges
     *
     * @private
     */},{key:"reconnectEdges",value:function reconnectEdges(){var id;var nodes=this.body.nodes;var edges=this.body.edges;for(id in nodes){if(Object.prototype.hasOwnProperty.call(nodes,id)){nodes[id].edges=[];}}for(id in edges){if(Object.prototype.hasOwnProperty.call(edges,id)){var edge=edges[id];edge.from=null;edge.to=null;edge.connect();}}}/**
     *
     * @param {Edge.id} edgeId
     * @returns {Array}
     */},{key:"getConnectedNodes",value:function getConnectedNodes(edgeId){var nodeList=[];if(this.body.edges[edgeId]!==undefined){var edge=this.body.edges[edgeId];if(edge.fromId!==undefined){nodeList.push(edge.fromId);}if(edge.toId!==undefined){nodeList.push(edge.toId);}}return nodeList;}/**
     * There is no direct relation between the nodes and the edges DataSet,
     * so the right place to do call this is in the handler for event `_dataUpdated`.
     */},{key:"_updateState",value:function _updateState(){this._addMissingEdges();this._removeInvalidEdges();}/**
     * Scan for missing nodes and remove corresponding edges, if any.
     *
     * @private
     */},{key:"_removeInvalidEdges",value:function _removeInvalidEdges(){var _this5=this;var edgesToDelete=[];forEach$1(this.body.edges,function(edge,id){var toNode=_this5.body.nodes[edge.toId];var fromNode=_this5.body.nodes[edge.fromId];// Skip clustering edges here, let the Clustering module handle those
if(toNode!==undefined&&toNode.isCluster===true||fromNode!==undefined&&fromNode.isCluster===true){return;}if(toNode===undefined||fromNode===undefined){edgesToDelete.push(id);}});this.remove(edgesToDelete,false);}/**
     * add all edges from dataset that are not in the cached state
     *
     * @private
     */},{key:"_addMissingEdges",value:function _addMissingEdges(){var edgesData=this.body.data.edges;if(edgesData===undefined||edgesData===null){return;// No edges DataSet yet; can happen on startup
}var edges=this.body.edges;var addIds=[];forEach$2(edgesData).call(edgesData,function(edgeData,edgeId){var edge=edges[edgeId];if(edge===undefined){addIds.push(edgeId);}});this.add(addIds,true);}}]);return EdgesHandler;}();/**
 * Barnes Hut Solver
 */var BarnesHutSolver=/*#__PURE__*/function(){/**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */function BarnesHutSolver(body,physicsBody,options){_classCallCheck(this,BarnesHutSolver);this.body=body;this.physicsBody=physicsBody;this.barnesHutTree;this.setOptions(options);this._rng=Alea("BARNES HUT SOLVER");// debug: show grid
// this.body.emitter.on("afterDrawing", (ctx) => {this._debug(ctx,'#ff0000')})
}/**
   *
   * @param {object} options
   */_createClass(BarnesHutSolver,[{key:"setOptions",value:function setOptions(options){this.options=options;this.thetaInversed=1/this.options.theta;// if 1 then min distance = 0.5, if 0.5 then min distance = 0.5 + 0.5*node.shape.radius
this.overlapAvoidanceFactor=1-Math.max(0,Math.min(1,this.options.avoidOverlap));}/**
     * This function calculates the forces the nodes apply on each other based on a gravitational model.
     * The Barnes Hut method is used to speed up this N-body simulation.
     *
     * @private
     */},{key:"solve",value:function solve(){if(this.options.gravitationalConstant!==0&&this.physicsBody.physicsNodeIndices.length>0){var node;var nodes=this.body.nodes;var nodeIndices=this.physicsBody.physicsNodeIndices;var nodeCount=nodeIndices.length;// create the tree
var barnesHutTree=this._formBarnesHutTree(nodes,nodeIndices);// for debugging
this.barnesHutTree=barnesHutTree;// place the nodes one by one recursively
for(var i=0;i<nodeCount;i++){node=nodes[nodeIndices[i]];if(node.options.mass>0){// starting with root is irrelevant, it never passes the BarnesHutSolver condition
this._getForceContributions(barnesHutTree.root,node);}}}}/**
     * @param {object} parentBranch
     * @param {Node} node
     * @private
     */},{key:"_getForceContributions",value:function _getForceContributions(parentBranch,node){this._getForceContribution(parentBranch.children.NW,node);this._getForceContribution(parentBranch.children.NE,node);this._getForceContribution(parentBranch.children.SW,node);this._getForceContribution(parentBranch.children.SE,node);}/**
     * This function traverses the barnesHutTree. It checks when it can approximate distant nodes with their center of mass.
     * If a region contains a single node, we check if it is not itself, then we apply the force.
     *
     * @param {object} parentBranch
     * @param {Node} node
     * @private
     */},{key:"_getForceContribution",value:function _getForceContribution(parentBranch,node){// we get no force contribution from an empty region
if(parentBranch.childrenCount>0){// get the distance from the center of mass to the node.
var dx=parentBranch.centerOfMass.x-node.x;var dy=parentBranch.centerOfMass.y-node.y;var distance=Math.sqrt(dx*dx+dy*dy);// BarnesHutSolver condition
// original condition : s/d < theta = passed  ===  d/s > 1/theta = passed
// calcSize = 1/s --> d * 1/s > 1/theta = passed
if(distance*parentBranch.calcSize>this.thetaInversed){this._calculateForces(distance,dx,dy,node,parentBranch);}else{// Did not pass the condition, go into children if available
if(parentBranch.childrenCount===4){this._getForceContributions(parentBranch,node);}else{// parentBranch must have only one node, if it was empty we wouldnt be here
if(parentBranch.children.data.id!=node.id){// if it is not self
this._calculateForces(distance,dx,dy,node,parentBranch);}}}}}/**
     * Calculate the forces based on the distance.
     *
     * @param {number} distance
     * @param {number} dx
     * @param {number} dy
     * @param {Node} node
     * @param {object} parentBranch
     * @private
     */},{key:"_calculateForces",value:function _calculateForces(distance,dx,dy,node,parentBranch){if(distance===0){distance=0.1;dx=distance;}if(this.overlapAvoidanceFactor<1&&node.shape.radius){distance=Math.max(0.1+this.overlapAvoidanceFactor*node.shape.radius,distance-node.shape.radius);}// the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines
// it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce
var gravityForce=this.options.gravitationalConstant*parentBranch.mass*node.options.mass/Math.pow(distance,3);var fx=dx*gravityForce;var fy=dy*gravityForce;this.physicsBody.forces[node.id].x+=fx;this.physicsBody.forces[node.id].y+=fy;}/**
     * This function constructs the barnesHut tree recursively. It creates the root, splits it and starts placing the nodes.
     *
     * @param {Array.<Node>} nodes
     * @param {Array.<number>} nodeIndices
     * @returns {{root: {centerOfMass: {x: number, y: number}, mass: number, range: {minX: number, maxX: number, minY: number, maxY: number}, size: number, calcSize: number, children: {data: null}, maxWidth: number, level: number, childrenCount: number}}} BarnesHutTree
     * @private
     */},{key:"_formBarnesHutTree",value:function _formBarnesHutTree(nodes,nodeIndices){var node;var nodeCount=nodeIndices.length;var minX=nodes[nodeIndices[0]].x;var minY=nodes[nodeIndices[0]].y;var maxX=nodes[nodeIndices[0]].x;var maxY=nodes[nodeIndices[0]].y;// get the range of the nodes
for(var i=1;i<nodeCount;i++){var _node=nodes[nodeIndices[i]];var x=_node.x;var y=_node.y;if(_node.options.mass>0){if(x<minX){minX=x;}if(x>maxX){maxX=x;}if(y<minY){minY=y;}if(y>maxY){maxY=y;}}}// make the range a square
var sizeDiff=Math.abs(maxX-minX)-Math.abs(maxY-minY);// difference between X and Y
if(sizeDiff>0){minY-=0.5*sizeDiff;maxY+=0.5*sizeDiff;}// xSize > ySize
else{minX+=0.5*sizeDiff;maxX-=0.5*sizeDiff;}// xSize < ySize
var minimumTreeSize=1e-5;var rootSize=Math.max(minimumTreeSize,Math.abs(maxX-minX));var halfRootSize=0.5*rootSize;var centerX=0.5*(minX+maxX),centerY=0.5*(minY+maxY);// construct the barnesHutTree
var barnesHutTree={root:{centerOfMass:{x:0,y:0},mass:0,range:{minX:centerX-halfRootSize,maxX:centerX+halfRootSize,minY:centerY-halfRootSize,maxY:centerY+halfRootSize},size:rootSize,calcSize:1/rootSize,children:{data:null},maxWidth:0,level:0,childrenCount:4}};this._splitBranch(barnesHutTree.root);// place the nodes one by one recursively
for(var _i=0;_i<nodeCount;_i++){node=nodes[nodeIndices[_i]];if(node.options.mass>0){this._placeInTree(barnesHutTree.root,node);}}// make global
return barnesHutTree;}/**
     * this updates the mass of a branch. this is increased by adding a node.
     *
     * @param {object} parentBranch
     * @param {Node} node
     * @private
     */},{key:"_updateBranchMass",value:function _updateBranchMass(parentBranch,node){var centerOfMass=parentBranch.centerOfMass;var totalMass=parentBranch.mass+node.options.mass;var totalMassInv=1/totalMass;centerOfMass.x=centerOfMass.x*parentBranch.mass+node.x*node.options.mass;centerOfMass.x*=totalMassInv;centerOfMass.y=centerOfMass.y*parentBranch.mass+node.y*node.options.mass;centerOfMass.y*=totalMassInv;parentBranch.mass=totalMass;var biggestSize=Math.max(Math.max(node.height,node.radius),node.width);parentBranch.maxWidth=parentBranch.maxWidth<biggestSize?biggestSize:parentBranch.maxWidth;}/**
     * determine in which branch the node will be placed.
     *
     * @param {object} parentBranch
     * @param {Node} node
     * @param {boolean} skipMassUpdate
     * @private
     */},{key:"_placeInTree",value:function _placeInTree(parentBranch,node,skipMassUpdate){if(skipMassUpdate!=true||skipMassUpdate===undefined){// update the mass of the branch.
this._updateBranchMass(parentBranch,node);}var range=parentBranch.children.NW.range;var region;if(range.maxX>node.x){// in NW or SW
if(range.maxY>node.y){region="NW";}else{region="SW";}}else{// in NE or SE
if(range.maxY>node.y){region="NE";}else{region="SE";}}this._placeInRegion(parentBranch,node,region);}/**
     * actually place the node in a region (or branch)
     *
     * @param {object} parentBranch
     * @param {Node} node
     * @param {'NW'| 'NE' | 'SW' | 'SE'} region
     * @private
     */},{key:"_placeInRegion",value:function _placeInRegion(parentBranch,node,region){var children=parentBranch.children[region];switch(children.childrenCount){case 0:// place node here
children.children.data=node;children.childrenCount=1;this._updateBranchMass(children,node);break;case 1:// convert into children
// if there are two nodes exactly overlapping (on init, on opening of cluster etc.)
// we move one node a little bit and we do not put it in the tree.
if(children.children.data.x===node.x&&children.children.data.y===node.y){node.x+=this._rng();node.y+=this._rng();}else{this._splitBranch(children);this._placeInTree(children,node);}break;case 4:// place in branch
this._placeInTree(children,node);break;}}/**
     * this function splits a branch into 4 sub branches. If the branch contained a node, we place it in the subbranch
     * after the split is complete.
     *
     * @param {object} parentBranch
     * @private
     */},{key:"_splitBranch",value:function _splitBranch(parentBranch){// if the branch is shaded with a node, replace the node in the new subset.
var containedNode=null;if(parentBranch.childrenCount===1){containedNode=parentBranch.children.data;parentBranch.mass=0;parentBranch.centerOfMass.x=0;parentBranch.centerOfMass.y=0;}parentBranch.childrenCount=4;parentBranch.children.data=null;this._insertRegion(parentBranch,"NW");this._insertRegion(parentBranch,"NE");this._insertRegion(parentBranch,"SW");this._insertRegion(parentBranch,"SE");if(containedNode!=null){this._placeInTree(parentBranch,containedNode);}}/**
     * This function subdivides the region into four new segments.
     * Specifically, this inserts a single new segment.
     * It fills the children section of the parentBranch
     *
     * @param {object} parentBranch
     * @param {'NW'| 'NE' | 'SW' | 'SE'} region
     * @private
     */},{key:"_insertRegion",value:function _insertRegion(parentBranch,region){var minX,maxX,minY,maxY;var childSize=0.5*parentBranch.size;switch(region){case"NW":minX=parentBranch.range.minX;maxX=parentBranch.range.minX+childSize;minY=parentBranch.range.minY;maxY=parentBranch.range.minY+childSize;break;case"NE":minX=parentBranch.range.minX+childSize;maxX=parentBranch.range.maxX;minY=parentBranch.range.minY;maxY=parentBranch.range.minY+childSize;break;case"SW":minX=parentBranch.range.minX;maxX=parentBranch.range.minX+childSize;minY=parentBranch.range.minY+childSize;maxY=parentBranch.range.maxY;break;case"SE":minX=parentBranch.range.minX+childSize;maxX=parentBranch.range.maxX;minY=parentBranch.range.minY+childSize;maxY=parentBranch.range.maxY;break;}parentBranch.children[region]={centerOfMass:{x:0,y:0},mass:0,range:{minX:minX,maxX:maxX,minY:minY,maxY:maxY},size:0.5*parentBranch.size,calcSize:2*parentBranch.calcSize,children:{data:null},maxWidth:0,level:parentBranch.level+1,childrenCount:0};}//---------------------------  DEBUGGING BELOW  ---------------------------//
/**
     * This function is for debugging purposed, it draws the tree.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @param {string} color
     * @private
     */},{key:"_debug",value:function _debug(ctx,color){if(this.barnesHutTree!==undefined){ctx.lineWidth=1;this._drawBranch(this.barnesHutTree.root,ctx,color);}}/**
     * This function is for debugging purposes. It draws the branches recursively.
     *
     * @param {object} branch
     * @param {CanvasRenderingContext2D} ctx
     * @param {string} color
     * @private
     */},{key:"_drawBranch",value:function _drawBranch(branch,ctx,color){if(color===undefined){color="#FF0000";}if(branch.childrenCount===4){this._drawBranch(branch.children.NW,ctx);this._drawBranch(branch.children.NE,ctx);this._drawBranch(branch.children.SE,ctx);this._drawBranch(branch.children.SW,ctx);}ctx.strokeStyle=color;ctx.beginPath();ctx.moveTo(branch.range.minX,branch.range.minY);ctx.lineTo(branch.range.maxX,branch.range.minY);ctx.stroke();ctx.beginPath();ctx.moveTo(branch.range.maxX,branch.range.minY);ctx.lineTo(branch.range.maxX,branch.range.maxY);ctx.stroke();ctx.beginPath();ctx.moveTo(branch.range.maxX,branch.range.maxY);ctx.lineTo(branch.range.minX,branch.range.maxY);ctx.stroke();ctx.beginPath();ctx.moveTo(branch.range.minX,branch.range.maxY);ctx.lineTo(branch.range.minX,branch.range.minY);ctx.stroke();/*
       if (branch.mass > 0) {
       ctx.circle(branch.centerOfMass.x, branch.centerOfMass.y, 3*branch.mass);
       ctx.stroke();
       }
       */}}]);return BarnesHutSolver;}();/**
 * Repulsion Solver
 */var RepulsionSolver=/*#__PURE__*/function(){/**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */function RepulsionSolver(body,physicsBody,options){_classCallCheck(this,RepulsionSolver);this._rng=Alea("REPULSION SOLVER");this.body=body;this.physicsBody=physicsBody;this.setOptions(options);}/**
   *
   * @param {object} options
   */_createClass(RepulsionSolver,[{key:"setOptions",value:function setOptions(options){this.options=options;}/**
     * Calculate the forces the nodes apply on each other based on a repulsion field.
     * This field is linearly approximated.
     *
     * @private
     */},{key:"solve",value:function solve(){var dx,dy,distance,fx,fy,repulsingForce,node1,node2;var nodes=this.body.nodes;var nodeIndices=this.physicsBody.physicsNodeIndices;var forces=this.physicsBody.forces;// repulsing forces between nodes
var nodeDistance=this.options.nodeDistance;// approximation constants
var a=-2/3/nodeDistance;var b=4/3;// we loop from i over all but the last entree in the array
// j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j
for(var i=0;i<nodeIndices.length-1;i++){node1=nodes[nodeIndices[i]];for(var j=i+1;j<nodeIndices.length;j++){node2=nodes[nodeIndices[j]];dx=node2.x-node1.x;dy=node2.y-node1.y;distance=Math.sqrt(dx*dx+dy*dy);// same condition as BarnesHutSolver, making sure nodes are never 100% overlapping.
if(distance===0){distance=0.1*this._rng();dx=distance;}if(distance<2*nodeDistance){if(distance<0.5*nodeDistance){repulsingForce=1.0;}else{repulsingForce=a*distance+b;// linear approx of  1 / (1 + Math.exp((distance / nodeDistance - 1) * steepness))
}repulsingForce=repulsingForce/distance;fx=dx*repulsingForce;fy=dy*repulsingForce;forces[node1.id].x-=fx;forces[node1.id].y-=fy;forces[node2.id].x+=fx;forces[node2.id].y+=fy;}}}}}]);return RepulsionSolver;}();/**
 * Hierarchical Repulsion Solver
 */var HierarchicalRepulsionSolver=/*#__PURE__*/function(){/**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */function HierarchicalRepulsionSolver(body,physicsBody,options){_classCallCheck(this,HierarchicalRepulsionSolver);this.body=body;this.physicsBody=physicsBody;this.setOptions(options);}/**
   *
   * @param {object} options
   */_createClass(HierarchicalRepulsionSolver,[{key:"setOptions",value:function setOptions(options){this.options=options;this.overlapAvoidanceFactor=Math.max(0,Math.min(1,this.options.avoidOverlap||0));}/**
     * Calculate the forces the nodes apply on each other based on a repulsion field.
     * This field is linearly approximated.
     *
     * @private
     */},{key:"solve",value:function solve(){var nodes=this.body.nodes;var nodeIndices=this.physicsBody.physicsNodeIndices;var forces=this.physicsBody.forces;// repulsing forces between nodes
var nodeDistance=this.options.nodeDistance;// we loop from i over all but the last entree in the array
// j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j
for(var i=0;i<nodeIndices.length-1;i++){var node1=nodes[nodeIndices[i]];for(var j=i+1;j<nodeIndices.length;j++){var node2=nodes[nodeIndices[j]];// nodes only affect nodes on their level
if(node1.level===node2.level){var theseNodesDistance=nodeDistance+this.overlapAvoidanceFactor*((node1.shape.radius||0)/2+(node2.shape.radius||0)/2);var dx=node2.x-node1.x;var dy=node2.y-node1.y;var distance=Math.sqrt(dx*dx+dy*dy);var steepness=0.05;var repulsingForce=void 0;if(distance<theseNodesDistance){repulsingForce=-Math.pow(steepness*distance,2)+Math.pow(steepness*theseNodesDistance,2);}else{repulsingForce=0;}// normalize force with
if(distance!==0){repulsingForce=repulsingForce/distance;}var fx=dx*repulsingForce;var fy=dy*repulsingForce;forces[node1.id].x-=fx;forces[node1.id].y-=fy;forces[node2.id].x+=fx;forces[node2.id].y+=fy;}}}}}]);return HierarchicalRepulsionSolver;}();/**
 * Spring Solver
 */var SpringSolver=/*#__PURE__*/function(){/**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */function SpringSolver(body,physicsBody,options){_classCallCheck(this,SpringSolver);this.body=body;this.physicsBody=physicsBody;this.setOptions(options);}/**
   *
   * @param {object} options
   */_createClass(SpringSolver,[{key:"setOptions",value:function setOptions(options){this.options=options;}/**
     * This function calculates the springforces on the nodes, accounting for the support nodes.
     *
     * @private
     */},{key:"solve",value:function solve(){var edgeLength,edge;var edgeIndices=this.physicsBody.physicsEdgeIndices;var edges=this.body.edges;var node1,node2,node3;// forces caused by the edges, modelled as springs
for(var i=0;i<edgeIndices.length;i++){edge=edges[edgeIndices[i]];if(edge.connected===true&&edge.toId!==edge.fromId){// only calculate forces if nodes are in the same sector
if(this.body.nodes[edge.toId]!==undefined&&this.body.nodes[edge.fromId]!==undefined){if(edge.edgeType.via!==undefined){edgeLength=edge.options.length===undefined?this.options.springLength:edge.options.length;node1=edge.to;node2=edge.edgeType.via;node3=edge.from;this._calculateSpringForce(node1,node2,0.5*edgeLength);this._calculateSpringForce(node2,node3,0.5*edgeLength);}else{// the * 1.5 is here so the edge looks as large as a smooth edge. It does not initially because the smooth edges use
// the support nodes which exert a repulsive force on the to and from nodes, making the edge appear larger.
edgeLength=edge.options.length===undefined?this.options.springLength*1.5:edge.options.length;this._calculateSpringForce(edge.from,edge.to,edgeLength);}}}}}/**
     * This is the code actually performing the calculation for the function above.
     *
     * @param {Node} node1
     * @param {Node} node2
     * @param {number} edgeLength
     * @private
     */},{key:"_calculateSpringForce",value:function _calculateSpringForce(node1,node2,edgeLength){var dx=node1.x-node2.x;var dy=node1.y-node2.y;var distance=Math.max(Math.sqrt(dx*dx+dy*dy),0.01);// the 1/distance is so the fx and fy can be calculated without sine or cosine.
var springForce=this.options.springConstant*(edgeLength-distance)/distance;var fx=dx*springForce;var fy=dy*springForce;// handle the case where one node is not part of the physcis
if(this.physicsBody.forces[node1.id]!==undefined){this.physicsBody.forces[node1.id].x+=fx;this.physicsBody.forces[node1.id].y+=fy;}if(this.physicsBody.forces[node2.id]!==undefined){this.physicsBody.forces[node2.id].x-=fx;this.physicsBody.forces[node2.id].y-=fy;}}}]);return SpringSolver;}();/**
 * Hierarchical Spring Solver
 */var HierarchicalSpringSolver=/*#__PURE__*/function(){/**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */function HierarchicalSpringSolver(body,physicsBody,options){_classCallCheck(this,HierarchicalSpringSolver);this.body=body;this.physicsBody=physicsBody;this.setOptions(options);}/**
   *
   * @param {object} options
   */_createClass(HierarchicalSpringSolver,[{key:"setOptions",value:function setOptions(options){this.options=options;}/**
     * This function calculates the springforces on the nodes, accounting for the support nodes.
     *
     * @private
     */},{key:"solve",value:function solve(){var edgeLength,edge;var dx,dy,fx,fy,springForce,distance;var edges=this.body.edges;var factor=0.5;var edgeIndices=this.physicsBody.physicsEdgeIndices;var nodeIndices=this.physicsBody.physicsNodeIndices;var forces=this.physicsBody.forces;// initialize the spring force counters
for(var i=0;i<nodeIndices.length;i++){var nodeId=nodeIndices[i];forces[nodeId].springFx=0;forces[nodeId].springFy=0;}// forces caused by the edges, modelled as springs
for(var _i=0;_i<edgeIndices.length;_i++){edge=edges[edgeIndices[_i]];if(edge.connected===true){edgeLength=edge.options.length===undefined?this.options.springLength:edge.options.length;dx=edge.from.x-edge.to.x;dy=edge.from.y-edge.to.y;distance=Math.sqrt(dx*dx+dy*dy);distance=distance===0?0.01:distance;// the 1/distance is so the fx and fy can be calculated without sine or cosine.
springForce=this.options.springConstant*(edgeLength-distance)/distance;fx=dx*springForce;fy=dy*springForce;if(edge.to.level!=edge.from.level){if(forces[edge.toId]!==undefined){forces[edge.toId].springFx-=fx;forces[edge.toId].springFy-=fy;}if(forces[edge.fromId]!==undefined){forces[edge.fromId].springFx+=fx;forces[edge.fromId].springFy+=fy;}}else{if(forces[edge.toId]!==undefined){forces[edge.toId].x-=factor*fx;forces[edge.toId].y-=factor*fy;}if(forces[edge.fromId]!==undefined){forces[edge.fromId].x+=factor*fx;forces[edge.fromId].y+=factor*fy;}}}}// normalize spring forces
springForce=1;var springFx,springFy;for(var _i2=0;_i2<nodeIndices.length;_i2++){var _nodeId=nodeIndices[_i2];springFx=Math.min(springForce,Math.max(-springForce,forces[_nodeId].springFx));springFy=Math.min(springForce,Math.max(-springForce,forces[_nodeId].springFy));forces[_nodeId].x+=springFx;forces[_nodeId].y+=springFy;}// retain energy balance
var totalFx=0;var totalFy=0;for(var _i3=0;_i3<nodeIndices.length;_i3++){var _nodeId2=nodeIndices[_i3];totalFx+=forces[_nodeId2].x;totalFy+=forces[_nodeId2].y;}var correctionFx=totalFx/nodeIndices.length;var correctionFy=totalFy/nodeIndices.length;for(var _i4=0;_i4<nodeIndices.length;_i4++){var _nodeId3=nodeIndices[_i4];forces[_nodeId3].x-=correctionFx;forces[_nodeId3].y-=correctionFy;}}}]);return HierarchicalSpringSolver;}();/**
 * Central Gravity Solver
 */var CentralGravitySolver=/*#__PURE__*/function(){/**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */function CentralGravitySolver(body,physicsBody,options){_classCallCheck(this,CentralGravitySolver);this.body=body;this.physicsBody=physicsBody;this.setOptions(options);}/**
   *
   * @param {object} options
   */_createClass(CentralGravitySolver,[{key:"setOptions",value:function setOptions(options){this.options=options;}/**
     * Calculates forces for each node
     */},{key:"solve",value:function solve(){var dx,dy,distance,node;var nodes=this.body.nodes;var nodeIndices=this.physicsBody.physicsNodeIndices;var forces=this.physicsBody.forces;for(var i=0;i<nodeIndices.length;i++){var nodeId=nodeIndices[i];node=nodes[nodeId];dx=-node.x;dy=-node.y;distance=Math.sqrt(dx*dx+dy*dy);this._calculateForces(distance,dx,dy,forces,node);}}/**
     * Calculate the forces based on the distance.
     *
     * @param {number} distance
     * @param {number} dx
     * @param {number} dy
     * @param {object<Node.id, vis.Node>} forces
     * @param {Node} node
     * @private
     */},{key:"_calculateForces",value:function _calculateForces(distance,dx,dy,forces,node){var gravityForce=distance===0?0:this.options.centralGravity/distance;forces[node.id].x=dx*gravityForce;forces[node.id].y=dy*gravityForce;}}]);return CentralGravitySolver;}();function _createSuper$3(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$3();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$3(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * @augments BarnesHutSolver
 */var ForceAtlas2BasedRepulsionSolver=/*#__PURE__*/function(_BarnesHutSolver){_inherits(ForceAtlas2BasedRepulsionSolver,_BarnesHutSolver);var _super=_createSuper$3(ForceAtlas2BasedRepulsionSolver);/**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */function ForceAtlas2BasedRepulsionSolver(body,physicsBody,options){var _this;_classCallCheck(this,ForceAtlas2BasedRepulsionSolver);_this=_super.call(this,body,physicsBody,options);_this._rng=Alea("FORCE ATLAS 2 BASED REPULSION SOLVER");return _this;}/**
   * Calculate the forces based on the distance.
   *
   * @param {number} distance
   * @param {number} dx
   * @param {number} dy
   * @param {Node} node
   * @param {object} parentBranch
   * @private
   */_createClass(ForceAtlas2BasedRepulsionSolver,[{key:"_calculateForces",value:function _calculateForces(distance,dx,dy,node,parentBranch){if(distance===0){distance=0.1*this._rng();dx=distance;}if(this.overlapAvoidanceFactor<1&&node.shape.radius){distance=Math.max(0.1+this.overlapAvoidanceFactor*node.shape.radius,distance-node.shape.radius);}var degree=node.edges.length+1;// the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines
// it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce
var gravityForce=this.options.gravitationalConstant*parentBranch.mass*node.options.mass*degree/Math.pow(distance,2);var fx=dx*gravityForce;var fy=dy*gravityForce;this.physicsBody.forces[node.id].x+=fx;this.physicsBody.forces[node.id].y+=fy;}}]);return ForceAtlas2BasedRepulsionSolver;}(BarnesHutSolver);function _createSuper$2(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$2();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$2(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * @augments CentralGravitySolver
 */var ForceAtlas2BasedCentralGravitySolver=/*#__PURE__*/function(_CentralGravitySolver){_inherits(ForceAtlas2BasedCentralGravitySolver,_CentralGravitySolver);var _super=_createSuper$2(ForceAtlas2BasedCentralGravitySolver);/**
   * @param {object} body
   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody
   * @param {object} options
   */function ForceAtlas2BasedCentralGravitySolver(body,physicsBody,options){_classCallCheck(this,ForceAtlas2BasedCentralGravitySolver);return _super.call(this,body,physicsBody,options);}/**
   * Calculate the forces based on the distance.
   *
   * @param {number} distance
   * @param {number} dx
   * @param {number} dy
   * @param {object<Node.id, Node>} forces
   * @param {Node} node
   * @private
   */_createClass(ForceAtlas2BasedCentralGravitySolver,[{key:"_calculateForces",value:function _calculateForces(distance,dx,dy,forces,node){if(distance>0){var degree=node.edges.length+1;var gravityForce=this.options.centralGravity*degree*node.options.mass;forces[node.id].x=dx*gravityForce;forces[node.id].y=dy*gravityForce;}}}]);return ForceAtlas2BasedCentralGravitySolver;}(CentralGravitySolver);/**
 * The physics engine
 */var PhysicsEngine=/*#__PURE__*/function(){/**
   * @param {object} body
   */function PhysicsEngine(body){_classCallCheck(this,PhysicsEngine);this.body=body;this.physicsBody={physicsNodeIndices:[],physicsEdgeIndices:[],forces:{},velocities:{}};this.physicsEnabled=true;this.simulationInterval=1000/60;this.requiresTimeout=true;this.previousStates={};this.referenceState={};this.freezeCache={};this.renderTimer=undefined;// parameters for the adaptive timestep
this.adaptiveTimestep=false;this.adaptiveTimestepEnabled=false;this.adaptiveCounter=0;this.adaptiveInterval=3;this.stabilized=false;this.startedStabilization=false;this.stabilizationIterations=0;this.ready=false;// will be set to true if the stabilize
// default options
this.options={};this.defaultOptions={enabled:true,barnesHut:{theta:0.5,gravitationalConstant:-2000,centralGravity:0.3,springLength:95,springConstant:0.04,damping:0.09,avoidOverlap:0},forceAtlas2Based:{theta:0.5,gravitationalConstant:-50,centralGravity:0.01,springConstant:0.08,springLength:100,damping:0.4,avoidOverlap:0},repulsion:{centralGravity:0.2,springLength:200,springConstant:0.05,nodeDistance:100,damping:0.09,avoidOverlap:0},hierarchicalRepulsion:{centralGravity:0.0,springLength:100,springConstant:0.01,nodeDistance:120,damping:0.09},maxVelocity:50,minVelocity:0.75,// px/s
solver:"barnesHut",stabilization:{enabled:true,iterations:1000,// maximum number of iteration to stabilize
updateInterval:50,onlyDynamicEdges:false,fit:true},timestep:0.5,adaptiveTimestep:true,wind:{x:0,y:0}};assign$2(this.options,this.defaultOptions);this.timestep=0.5;this.layoutFailed=false;this.bindEventListeners();}/**
   * Binds event listeners
   */_createClass(PhysicsEngine,[{key:"bindEventListeners",value:function bindEventListeners(){var _this=this;this.body.emitter.on("initPhysics",function(){_this.initPhysics();});this.body.emitter.on("_layoutFailed",function(){_this.layoutFailed=true;});this.body.emitter.on("resetPhysics",function(){_this.stopSimulation();_this.ready=false;});this.body.emitter.on("disablePhysics",function(){_this.physicsEnabled=false;_this.stopSimulation();});this.body.emitter.on("restorePhysics",function(){_this.setOptions(_this.options);if(_this.ready===true){_this.startSimulation();}});this.body.emitter.on("startSimulation",function(){if(_this.ready===true){_this.startSimulation();}});this.body.emitter.on("stopSimulation",function(){_this.stopSimulation();});this.body.emitter.on("destroy",function(){_this.stopSimulation(false);_this.body.emitter.off();});this.body.emitter.on("_dataChanged",function(){// Nodes and/or edges have been added or removed, update shortcut lists.
_this.updatePhysicsData();});// debug: show forces
// this.body.emitter.on("afterDrawing", (ctx) => {this._drawForces(ctx);});
}/**
     * set the physics options
     *
     * @param {object} options
     */},{key:"setOptions",value:function setOptions(options){if(options!==undefined){if(options===false){this.options.enabled=false;this.physicsEnabled=false;this.stopSimulation();}else if(options===true){this.options.enabled=true;this.physicsEnabled=true;this.startSimulation();}else{this.physicsEnabled=true;selectiveNotDeepExtend(["stabilization"],this.options,options);mergeOptions(this.options,options,"stabilization");if(options.enabled===undefined){this.options.enabled=true;}if(this.options.enabled===false){this.physicsEnabled=false;this.stopSimulation();}var wind=this.options.wind;if(wind){if(typeof wind.x!=="number"||isNan(wind.x)){wind.x=0;}if(typeof wind.y!=="number"||isNan(wind.y)){wind.y=0;}}// set the timestep
this.timestep=this.options.timestep;}}this.init();}/**
     * configure the engine.
     */},{key:"init",value:function init(){var options;if(this.options.solver==="forceAtlas2Based"){options=this.options.forceAtlas2Based;this.nodesSolver=new ForceAtlas2BasedRepulsionSolver(this.body,this.physicsBody,options);this.edgesSolver=new SpringSolver(this.body,this.physicsBody,options);this.gravitySolver=new ForceAtlas2BasedCentralGravitySolver(this.body,this.physicsBody,options);}else if(this.options.solver==="repulsion"){options=this.options.repulsion;this.nodesSolver=new RepulsionSolver(this.body,this.physicsBody,options);this.edgesSolver=new SpringSolver(this.body,this.physicsBody,options);this.gravitySolver=new CentralGravitySolver(this.body,this.physicsBody,options);}else if(this.options.solver==="hierarchicalRepulsion"){options=this.options.hierarchicalRepulsion;this.nodesSolver=new HierarchicalRepulsionSolver(this.body,this.physicsBody,options);this.edgesSolver=new HierarchicalSpringSolver(this.body,this.physicsBody,options);this.gravitySolver=new CentralGravitySolver(this.body,this.physicsBody,options);}else{// barnesHut
options=this.options.barnesHut;this.nodesSolver=new BarnesHutSolver(this.body,this.physicsBody,options);this.edgesSolver=new SpringSolver(this.body,this.physicsBody,options);this.gravitySolver=new CentralGravitySolver(this.body,this.physicsBody,options);}this.modelOptions=options;}/**
     * initialize the engine
     */},{key:"initPhysics",value:function initPhysics(){if(this.physicsEnabled===true&&this.options.enabled===true){if(this.options.stabilization.enabled===true){this.stabilize();}else{this.stabilized=false;this.ready=true;this.body.emitter.emit("fit",{},this.layoutFailed);// if the layout failed, we use the approximation for the zoom
this.startSimulation();}}else{this.ready=true;this.body.emitter.emit("fit");}}/**
     * Start the simulation
     */},{key:"startSimulation",value:function startSimulation(){if(this.physicsEnabled===true&&this.options.enabled===true){this.stabilized=false;// when visible, adaptivity is disabled.
this.adaptiveTimestep=false;// this sets the width of all nodes initially which could be required for the avoidOverlap
this.body.emitter.emit("_resizeNodes");if(this.viewFunction===undefined){var _context;this.viewFunction=bind(_context=this.simulationStep).call(_context,this);this.body.emitter.on("initRedraw",this.viewFunction);this.body.emitter.emit("_startRendering");}}else{this.body.emitter.emit("_redraw");}}/**
     * Stop the simulation, force stabilization.
     *
     * @param {boolean} [emit=true]
     */},{key:"stopSimulation",value:function stopSimulation(){var emit=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;this.stabilized=true;if(emit===true){this._emitStabilized();}if(this.viewFunction!==undefined){this.body.emitter.off("initRedraw",this.viewFunction);this.viewFunction=undefined;if(emit===true){this.body.emitter.emit("_stopRendering");}}}/**
     * The viewFunction inserts this step into each render loop. It calls the physics tick and handles the cleanup at stabilized.
     *
     */},{key:"simulationStep",value:function simulationStep(){// check if the physics have settled
var startTime=now$1();this.physicsTick();var physicsTime=now$1()-startTime;// run double speed if it is a little graph
if((physicsTime<0.4*this.simulationInterval||this.runDoubleSpeed===true)&&this.stabilized===false){this.physicsTick();// this makes sure there is no jitter. The decision is taken once to run it at double speed.
this.runDoubleSpeed=true;}if(this.stabilized===true){this.stopSimulation();}}/**
     * trigger the stabilized event.
     *
     * @param {number} [amountOfIterations=this.stabilizationIterations]
     * @private
     */},{key:"_emitStabilized",value:function _emitStabilized(){var _this2=this;var amountOfIterations=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.stabilizationIterations;if(this.stabilizationIterations>1||this.startedStabilization===true){setTimeout$1(function(){_this2.body.emitter.emit("stabilized",{iterations:amountOfIterations});_this2.startedStabilization=false;_this2.stabilizationIterations=0;},0);}}/**
     * Calculate the forces for one physics iteration and move the nodes.
     *
     * @private
     */},{key:"physicsStep",value:function physicsStep(){this.gravitySolver.solve();this.nodesSolver.solve();this.edgesSolver.solve();this.moveNodes();}/**
     * Make dynamic adjustments to the timestep, based on current state.
     *
     * Helper function for physicsTick().
     *
     * @private
     */},{key:"adjustTimeStep",value:function adjustTimeStep(){var factor=1.2;// Factor for increasing the timestep on success.
// we compare the two steps. if it is acceptable we double the step.
if(this._evaluateStepQuality()===true){this.timestep=factor*this.timestep;}else{// if not, we decrease the step to a minimum of the options timestep.
// if the decreased timestep is smaller than the options step, we do not reset the counter
// we assume that the options timestep is stable enough.
if(this.timestep/factor<this.options.timestep){this.timestep=this.options.timestep;}else{// if the timestep was larger than 2 times the option one we check the adaptivity again to ensure
// that large instabilities do not form.
this.adaptiveCounter=-1;// check again next iteration
this.timestep=Math.max(this.options.timestep,this.timestep/factor);}}}/**
     * A single simulation step (or 'tick') in the physics simulation
     *
     * @private
     */},{key:"physicsTick",value:function physicsTick(){this._startStabilizing();// this ensures that there is no start event when the network is already stable.
if(this.stabilized===true)return;// adaptivity means the timestep adapts to the situation, only applicable for stabilization
if(this.adaptiveTimestep===true&&this.adaptiveTimestepEnabled===true){// timestep remains stable for "interval" iterations.
var doAdaptive=this.adaptiveCounter%this.adaptiveInterval===0;if(doAdaptive){// first the big step and revert.
this.timestep=2*this.timestep;this.physicsStep();this.revert();// saves the reference state
// now the normal step. Since this is the last step, it is the more stable one and we will take this.
this.timestep=0.5*this.timestep;// since it's half the step, we do it twice.
this.physicsStep();this.physicsStep();this.adjustTimeStep();}else{this.physicsStep();// normal step, keeping timestep constant
}this.adaptiveCounter+=1;}else{// case for the static timestep, we reset it to the one in options and take a normal step.
this.timestep=this.options.timestep;this.physicsStep();}if(this.stabilized===true)this.revert();this.stabilizationIterations++;}/**
     * Nodes and edges can have the physics toggles on or off. A collection of indices is created here so we can skip the check all the time.
     *
     * @private
     */},{key:"updatePhysicsData",value:function updatePhysicsData(){this.physicsBody.forces={};this.physicsBody.physicsNodeIndices=[];this.physicsBody.physicsEdgeIndices=[];var nodes=this.body.nodes;var edges=this.body.edges;// get node indices for physics
for(var nodeId in nodes){if(Object.prototype.hasOwnProperty.call(nodes,nodeId)){if(nodes[nodeId].options.physics===true){this.physicsBody.physicsNodeIndices.push(nodes[nodeId].id);}}}// get edge indices for physics
for(var edgeId in edges){if(Object.prototype.hasOwnProperty.call(edges,edgeId)){if(edges[edgeId].options.physics===true){this.physicsBody.physicsEdgeIndices.push(edges[edgeId].id);}}}// get the velocity and the forces vector
for(var i=0;i<this.physicsBody.physicsNodeIndices.length;i++){var _nodeId=this.physicsBody.physicsNodeIndices[i];this.physicsBody.forces[_nodeId]={x:0,y:0};// forces can be reset because they are recalculated. Velocities have to persist.
if(this.physicsBody.velocities[_nodeId]===undefined){this.physicsBody.velocities[_nodeId]={x:0,y:0};}}// clean deleted nodes from the velocity vector
for(var _nodeId2 in this.physicsBody.velocities){if(nodes[_nodeId2]===undefined){delete this.physicsBody.velocities[_nodeId2];}}}/**
     * Revert the simulation one step. This is done so after stabilization, every new start of the simulation will also say stabilized.
     */},{key:"revert",value:function revert(){var nodeIds=keys$3(this.previousStates);var nodes=this.body.nodes;var velocities=this.physicsBody.velocities;this.referenceState={};for(var i=0;i<nodeIds.length;i++){var nodeId=nodeIds[i];if(nodes[nodeId]!==undefined){if(nodes[nodeId].options.physics===true){this.referenceState[nodeId]={positions:{x:nodes[nodeId].x,y:nodes[nodeId].y}};velocities[nodeId].x=this.previousStates[nodeId].vx;velocities[nodeId].y=this.previousStates[nodeId].vy;nodes[nodeId].x=this.previousStates[nodeId].x;nodes[nodeId].y=this.previousStates[nodeId].y;}}else{delete this.previousStates[nodeId];}}}/**
     * This compares the reference state to the current state
     *
     * @returns {boolean}
     * @private
     */},{key:"_evaluateStepQuality",value:function _evaluateStepQuality(){var dx,dy,dpos;var nodes=this.body.nodes;var reference=this.referenceState;var posThreshold=0.3;for(var nodeId in this.referenceState){if(Object.prototype.hasOwnProperty.call(this.referenceState,nodeId)&&nodes[nodeId]!==undefined){dx=nodes[nodeId].x-reference[nodeId].positions.x;dy=nodes[nodeId].y-reference[nodeId].positions.y;dpos=Math.sqrt(Math.pow(dx,2)+Math.pow(dy,2));if(dpos>posThreshold){return false;}}}return true;}/**
     * move the nodes one timestep and check if they are stabilized
     */},{key:"moveNodes",value:function moveNodes(){var nodeIndices=this.physicsBody.physicsNodeIndices;var maxNodeVelocity=0;var averageNodeVelocity=0;// the velocity threshold (energy in the system) for the adaptivity toggle
var velocityAdaptiveThreshold=5;for(var i=0;i<nodeIndices.length;i++){var nodeId=nodeIndices[i];var nodeVelocity=this._performStep(nodeId);// stabilized is true if stabilized is true and velocity is smaller than vmin --> all nodes must be stabilized
maxNodeVelocity=Math.max(maxNodeVelocity,nodeVelocity);averageNodeVelocity+=nodeVelocity;}// evaluating the stabilized and adaptiveTimestepEnabled conditions
this.adaptiveTimestepEnabled=averageNodeVelocity/nodeIndices.length<velocityAdaptiveThreshold;this.stabilized=maxNodeVelocity<this.options.minVelocity;}/**
     * Calculate new velocity for a coordinate direction
     *
     * @param {number} v  velocity for current coordinate
     * @param {number} f  regular force for current coordinate
     * @param {number} m  mass of current node
     * @returns {number} new velocity for current coordinate
     * @private
     */},{key:"calculateComponentVelocity",value:function calculateComponentVelocity(v,f,m){var df=this.modelOptions.damping*v;// damping force
var a=(f-df)/m;// acceleration
v+=a*this.timestep;// Put a limit on the velocities if it is really high
var maxV=this.options.maxVelocity||1e9;if(Math.abs(v)>maxV){v=v>0?maxV:-maxV;}return v;}/**
     * Perform the actual step
     *
     * @param {Node.id} nodeId
     * @returns {number} the new velocity of given node
     * @private
     */},{key:"_performStep",value:function _performStep(nodeId){var node=this.body.nodes[nodeId];var force=this.physicsBody.forces[nodeId];if(this.options.wind){force.x+=this.options.wind.x;force.y+=this.options.wind.y;}var velocity=this.physicsBody.velocities[nodeId];// store the state so we can revert
this.previousStates[nodeId]={x:node.x,y:node.y,vx:velocity.x,vy:velocity.y};if(node.options.fixed.x===false){velocity.x=this.calculateComponentVelocity(velocity.x,force.x,node.options.mass);node.x+=velocity.x*this.timestep;}else{force.x=0;velocity.x=0;}if(node.options.fixed.y===false){velocity.y=this.calculateComponentVelocity(velocity.y,force.y,node.options.mass);node.y+=velocity.y*this.timestep;}else{force.y=0;velocity.y=0;}var totalVelocity=Math.sqrt(Math.pow(velocity.x,2)+Math.pow(velocity.y,2));return totalVelocity;}/**
     * When initializing and stabilizing, we can freeze nodes with a predefined position.
     * This greatly speeds up stabilization because only the supportnodes for the smoothCurves have to settle.
     *
     * @private
     */},{key:"_freezeNodes",value:function _freezeNodes(){var nodes=this.body.nodes;for(var id in nodes){if(Object.prototype.hasOwnProperty.call(nodes,id)){if(nodes[id].x&&nodes[id].y){var fixed=nodes[id].options.fixed;this.freezeCache[id]={x:fixed.x,y:fixed.y};fixed.x=true;fixed.y=true;}}}}/**
     * Unfreezes the nodes that have been frozen by _freezeDefinedNodes.
     *
     * @private
     */},{key:"_restoreFrozenNodes",value:function _restoreFrozenNodes(){var nodes=this.body.nodes;for(var id in nodes){if(Object.prototype.hasOwnProperty.call(nodes,id)){if(this.freezeCache[id]!==undefined){nodes[id].options.fixed.x=this.freezeCache[id].x;nodes[id].options.fixed.y=this.freezeCache[id].y;}}}this.freezeCache={};}/**
     * Find a stable position for all nodes
     *
     * @param {number} [iterations=this.options.stabilization.iterations]
     */},{key:"stabilize",value:function stabilize(){var _this3=this;var iterations=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.options.stabilization.iterations;if(typeof iterations!=="number"){iterations=this.options.stabilization.iterations;console.error("The stabilize method needs a numeric amount of iterations. Switching to default: ",iterations);}if(this.physicsBody.physicsNodeIndices.length===0){this.ready=true;return;}// enable adaptive timesteps
this.adaptiveTimestep=this.options.adaptiveTimestep;// this sets the width of all nodes initially which could be required for the avoidOverlap
this.body.emitter.emit("_resizeNodes");this.stopSimulation();// stop the render loop
this.stabilized=false;// block redraw requests
this.body.emitter.emit("_blockRedraw");this.targetIterations=iterations;// start the stabilization
if(this.options.stabilization.onlyDynamicEdges===true){this._freezeNodes();}this.stabilizationIterations=0;setTimeout$1(function(){return _this3._stabilizationBatch();},0);}/**
     * If not already stabilizing, start it and emit a start event.
     *
     * @returns {boolean} true if stabilization started with this call
     * @private
     */},{key:"_startStabilizing",value:function _startStabilizing(){if(this.startedStabilization===true)return false;this.body.emitter.emit("startStabilizing");this.startedStabilization=true;return true;}/**
     * One batch of stabilization
     *
     * @private
     */},{key:"_stabilizationBatch",value:function _stabilizationBatch(){var _this4=this;var running=function running(){return _this4.stabilized===false&&_this4.stabilizationIterations<_this4.targetIterations;};var sendProgress=function sendProgress(){_this4.body.emitter.emit("stabilizationProgress",{iterations:_this4.stabilizationIterations,total:_this4.targetIterations});};if(this._startStabilizing()){sendProgress();// Ensure that there is at least one start event.
}var count=0;while(running()&&count<this.options.stabilization.updateInterval){this.physicsTick();count++;}sendProgress();if(running()){var _context2;setTimeout$1(bind(_context2=this._stabilizationBatch).call(_context2,this),0);}else{this._finalizeStabilization();}}/**
     * Wrap up the stabilization, fit and emit the events.
     *
     * @private
     */},{key:"_finalizeStabilization",value:function _finalizeStabilization(){this.body.emitter.emit("_allowRedraw");if(this.options.stabilization.fit===true){this.body.emitter.emit("fit");}if(this.options.stabilization.onlyDynamicEdges===true){this._restoreFrozenNodes();}this.body.emitter.emit("stabilizationIterationsDone");this.body.emitter.emit("_requestRedraw");if(this.stabilized===true){this._emitStabilized();}else{this.startSimulation();}this.ready=true;}//---------------------------  DEBUGGING BELOW  ---------------------------//
/**
     * Debug function that display arrows for the forces currently active in the network.
     *
     * Use this when debugging only.
     *
     * @param {CanvasRenderingContext2D} ctx
     * @private
     */},{key:"_drawForces",value:function _drawForces(ctx){for(var i=0;i<this.physicsBody.physicsNodeIndices.length;i++){var index=this.physicsBody.physicsNodeIndices[i];var node=this.body.nodes[index];var force=this.physicsBody.forces[index];var factor=20;var colorFactor=0.03;var forceSize=Math.sqrt(Math.pow(force.x,2)+Math.pow(force.x,2));var size=Math.min(Math.max(5,forceSize),15);var arrowSize=3*size;var color=HSVToHex((180-Math.min(1,Math.max(0,colorFactor*forceSize))*180)/360,1,1);var point={x:node.x+factor*force.x,y:node.y+factor*force.y};ctx.lineWidth=size;ctx.strokeStyle=color;ctx.beginPath();ctx.moveTo(node.x,node.y);ctx.lineTo(point.x,point.y);ctx.stroke();var angle=Math.atan2(force.y,force.x);ctx.fillStyle=color;EndPoints.draw(ctx,{type:"arrow",point:point,angle:angle,length:arrowSize});fill(ctx).call(ctx);}}}]);return PhysicsEngine;}();/**
 * Utility Class
 */var NetworkUtil=/*#__PURE__*/function(){/**
   * @ignore
   */function NetworkUtil(){_classCallCheck(this,NetworkUtil);}/**
   * Find the center position of the network considering the bounding boxes
   *
   * @param {Array.<Node>} allNodes
   * @param {Array.<Node>} [specificNodes=[]]
   * @returns {{minX: number, maxX: number, minY: number, maxY: number}}
   * @static
   */_createClass(NetworkUtil,null,[{key:"getRange",value:function getRange(allNodes){var specificNodes=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];var minY=1e9,maxY=-1e9,minX=1e9,maxX=-1e9,node;if(specificNodes.length>0){for(var i=0;i<specificNodes.length;i++){node=allNodes[specificNodes[i]];if(minX>node.shape.boundingBox.left){minX=node.shape.boundingBox.left;}if(maxX<node.shape.boundingBox.right){maxX=node.shape.boundingBox.right;}if(minY>node.shape.boundingBox.top){minY=node.shape.boundingBox.top;}// top is negative, bottom is positive
if(maxY<node.shape.boundingBox.bottom){maxY=node.shape.boundingBox.bottom;}// top is negative, bottom is positive
}}if(minX===1e9&&maxX===-1e9&&minY===1e9&&maxY===-1e9){minY=0,maxY=0,minX=0,maxX=0;}return{minX:minX,maxX:maxX,minY:minY,maxY:maxY};}/**
     * Find the center position of the network
     *
     * @param {Array.<Node>} allNodes
     * @param {Array.<Node>} [specificNodes=[]]
     * @returns {{minX: number, maxX: number, minY: number, maxY: number}}
     * @static
     */},{key:"getRangeCore",value:function getRangeCore(allNodes){var specificNodes=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];var minY=1e9,maxY=-1e9,minX=1e9,maxX=-1e9,node;if(specificNodes.length>0){for(var i=0;i<specificNodes.length;i++){node=allNodes[specificNodes[i]];if(minX>node.x){minX=node.x;}if(maxX<node.x){maxX=node.x;}if(minY>node.y){minY=node.y;}// top is negative, bottom is positive
if(maxY<node.y){maxY=node.y;}// top is negative, bottom is positive
}}if(minX===1e9&&maxX===-1e9&&minY===1e9&&maxY===-1e9){minY=0,maxY=0,minX=0,maxX=0;}return{minX:minX,maxX:maxX,minY:minY,maxY:maxY};}/**
     * @param {object} range = {minX: minX, maxX: maxX, minY: minY, maxY: maxY};
     * @returns {{x: number, y: number}}
     * @static
     */},{key:"findCenter",value:function findCenter(range){return{x:0.5*(range.maxX+range.minX),y:0.5*(range.maxY+range.minY)};}/**
     * This returns a clone of the options or options of the edge or node to be used for construction of new edges or check functions for new nodes.
     *
     * @param {vis.Item} item
     * @param {'node'|undefined} type
     * @returns {{}}
     * @static
     */},{key:"cloneOptions",value:function cloneOptions(item,type){var clonedOptions={};if(type===undefined||type==="node"){deepExtend(clonedOptions,item.options,true);clonedOptions.x=item.x;clonedOptions.y=item.y;clonedOptions.amountOfConnections=item.edges.length;}else{deepExtend(clonedOptions,item.options,true);}return clonedOptions;}}]);return NetworkUtil;}();function _createSuper$1(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct$1();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct$1(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * A Cluster is a special Node that allows a group of Nodes positioned closely together
 * to be represented by a single Cluster Node.
 *
 * @augments Node
 */var Cluster=/*#__PURE__*/function(_Node){_inherits(Cluster,_Node);var _super=_createSuper$1(Cluster);/**
   * @param {object} options
   * @param {object} body
   * @param {Array.<HTMLImageElement>}imagelist
   * @param {Array} grouplist
   * @param {object} globalOptions
   * @param {object} defaultOptions     Global default options for nodes
   */function Cluster(options,body,imagelist,grouplist,globalOptions,defaultOptions){var _this;_classCallCheck(this,Cluster);_this=_super.call(this,options,body,imagelist,grouplist,globalOptions,defaultOptions);_this.isCluster=true;_this.containedNodes={};_this.containedEdges={};return _this;}/**
   * Transfer child cluster data to current and disconnect the child cluster.
   *
   * Please consult the header comment in 'Clustering.js' for the fields set here.
   *
   * @param {string|number} childClusterId  id of child cluster to open
   */_createClass(Cluster,[{key:"_openChildCluster",value:function _openChildCluster(childClusterId){var _this2=this;var childCluster=this.body.nodes[childClusterId];if(this.containedNodes[childClusterId]===undefined){throw new Error("node with id: "+childClusterId+" not in current cluster");}if(!childCluster.isCluster){throw new Error("node with id: "+childClusterId+" is not a cluster");}// Disconnect child cluster from current cluster
delete this.containedNodes[childClusterId];forEach$1(childCluster.edges,function(edge){delete _this2.containedEdges[edge.id];});// Transfer nodes and edges
forEach$1(childCluster.containedNodes,function(node,nodeId){_this2.containedNodes[nodeId]=node;});childCluster.containedNodes={};forEach$1(childCluster.containedEdges,function(edge,edgeId){_this2.containedEdges[edgeId]=edge;});childCluster.containedEdges={};// Transfer edges within cluster edges which are clustered
forEach$1(childCluster.edges,function(clusterEdge){forEach$1(_this2.edges,function(parentClusterEdge){var _context,_context2;// Assumption: a clustered edge can only be present in a single clustering edge
// Not tested here
var index=indexOf(_context=parentClusterEdge.clusteringEdgeReplacingIds).call(_context,clusterEdge.id);if(index===-1)return;forEach$1(clusterEdge.clusteringEdgeReplacingIds,function(srcId){parentClusterEdge.clusteringEdgeReplacingIds.push(srcId);// Maintain correct bookkeeping for transferred edge
_this2.body.edges[srcId].edgeReplacedById=parentClusterEdge.id;});// Remove cluster edge from parent cluster edge
splice(_context2=parentClusterEdge.clusteringEdgeReplacingIds).call(_context2,index,1);});});childCluster.edges=[];}}]);return Cluster;}(Node);/**
 * The clustering engine
 */var ClusterEngine=/*#__PURE__*/function(){/**
   * @param {object} body
   */function ClusterEngine(body){var _this=this;_classCallCheck(this,ClusterEngine);this.body=body;this.clusteredNodes={};// key: node id, value: { clusterId: <id of cluster>, node: <node instance>}
this.clusteredEdges={};// key: edge id, value: restore information for given edge
this.options={};this.defaultOptions={};assign$2(this.options,this.defaultOptions);this.body.emitter.on("_resetData",function(){_this.clusteredNodes={};_this.clusteredEdges={};});}/**
   *
   * @param {number} hubsize
   * @param {object} options
   */_createClass(ClusterEngine,[{key:"clusterByHubsize",value:function clusterByHubsize(hubsize,options){if(hubsize===undefined){hubsize=this._getHubSize();}else if(_typeof(hubsize)==="object"){options=this._checkOptions(hubsize);hubsize=this._getHubSize();}var nodesToCluster=[];for(var i=0;i<this.body.nodeIndices.length;i++){var node=this.body.nodes[this.body.nodeIndices[i]];if(node.edges.length>=hubsize){nodesToCluster.push(node.id);}}for(var _i=0;_i<nodesToCluster.length;_i++){this.clusterByConnection(nodesToCluster[_i],options,true);}this.body.emitter.emit("_dataChanged");}/**
     * loop over all nodes, check if they adhere to the condition and cluster if needed.
     *
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */},{key:"cluster",value:function cluster(){var _this2=this;var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var refreshData=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;if(options.joinCondition===undefined){throw new Error("Cannot call clusterByNodeData without a joinCondition function in the options.");}// check if the options object is fine, append if needed
options=this._checkOptions(options);var childNodesObj={};var childEdgesObj={};// collect the nodes that will be in the cluster
forEach$1(this.body.nodes,function(node,nodeId){if(node.options&&options.joinCondition(node.options)===true){childNodesObj[nodeId]=node;// collect the edges that will be in the cluster
forEach$1(node.edges,function(edge){if(_this2.clusteredEdges[edge.id]===undefined){childEdgesObj[edge.id]=edge;}});}});this._cluster(childNodesObj,childEdgesObj,options,refreshData);}/**
     * Cluster all nodes in the network that have only X edges
     *
     * @param {number} edgeCount
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */},{key:"clusterByEdgeCount",value:function clusterByEdgeCount(edgeCount,options){var _this3=this;var refreshData=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;options=this._checkOptions(options);var clusters=[];var usedNodes={};var edge,edges,relevantEdgeCount;// collect the nodes that will be in the cluster
var _loop=function _loop(i){var childNodesObj={};var childEdgesObj={};var nodeId=_this3.body.nodeIndices[i];var node=_this3.body.nodes[nodeId];// if this node is already used in another cluster this session, we do not have to re-evaluate it.
if(usedNodes[nodeId]===undefined){relevantEdgeCount=0;edges=[];for(var j=0;j<node.edges.length;j++){edge=node.edges[j];if(_this3.clusteredEdges[edge.id]===undefined){if(edge.toId!==edge.fromId){relevantEdgeCount++;}edges.push(edge);}}// this node qualifies, we collect its neighbours to start the clustering process.
if(relevantEdgeCount===edgeCount){var checkJoinCondition=function checkJoinCondition(node){if(options.joinCondition===undefined||options.joinCondition===null){return true;}var clonedOptions=NetworkUtil.cloneOptions(node);return options.joinCondition(clonedOptions);};var gatheringSuccessful=true;for(var _j=0;_j<edges.length;_j++){edge=edges[_j];var childNodeId=_this3._getConnectedId(edge,nodeId);// add the nodes to the list by the join condition.
if(checkJoinCondition(node)){childEdgesObj[edge.id]=edge;childNodesObj[nodeId]=node;childNodesObj[childNodeId]=_this3.body.nodes[childNodeId];usedNodes[nodeId]=true;}else{// this node does not qualify after all.
gatheringSuccessful=false;break;}}// add to the cluster queue
if(keys$3(childNodesObj).length>0&&keys$3(childEdgesObj).length>0&&gatheringSuccessful===true){/**
               * Search for cluster data that contains any of the node id's
               *
               * @returns {boolean} true if no joinCondition, otherwise return value of joinCondition
               */var findClusterData=function findClusterData(){for(var n=0;n<clusters.length;++n){// Search for a cluster containing any of the node id's
for(var m in childNodesObj){if(clusters[n].nodes[m]!==undefined){return clusters[n];}}}return undefined;};// If any of the found nodes is part of a cluster found in this method,
// add the current values to that cluster
var foundCluster=findClusterData();if(foundCluster!==undefined){// Add nodes to found cluster if not present
for(var m in childNodesObj){if(foundCluster.nodes[m]===undefined){foundCluster.nodes[m]=childNodesObj[m];}}// Add edges to found cluster, if not present
for(var _m in childEdgesObj){if(foundCluster.edges[_m]===undefined){foundCluster.edges[_m]=childEdgesObj[_m];}}}else{// Create a new cluster group
clusters.push({nodes:childNodesObj,edges:childEdgesObj});}}}}};for(var i=0;i<this.body.nodeIndices.length;i++){_loop(i);}for(var _i2=0;_i2<clusters.length;_i2++){this._cluster(clusters[_i2].nodes,clusters[_i2].edges,options,false);}if(refreshData===true){this.body.emitter.emit("_dataChanged");}}/**
     * Cluster all nodes in the network that have only 1 edge
     *
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */},{key:"clusterOutliers",value:function clusterOutliers(options){var refreshData=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;this.clusterByEdgeCount(1,options,refreshData);}/**
     * Cluster all nodes in the network that have only 2 edge
     *
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */},{key:"clusterBridges",value:function clusterBridges(options){var refreshData=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;this.clusterByEdgeCount(2,options,refreshData);}/**
     * suck all connected nodes of a node into the node.
     *
     * @param {Node.id} nodeId
     * @param {object} options
     * @param {boolean} [refreshData=true]
     */},{key:"clusterByConnection",value:function clusterByConnection(nodeId,options){var _context;var refreshData=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;// kill conditions
if(nodeId===undefined){throw new Error("No nodeId supplied to clusterByConnection!");}if(this.body.nodes[nodeId]===undefined){throw new Error("The nodeId given to clusterByConnection does not exist!");}var node=this.body.nodes[nodeId];options=this._checkOptions(options,node);if(options.clusterNodeProperties.x===undefined){options.clusterNodeProperties.x=node.x;}if(options.clusterNodeProperties.y===undefined){options.clusterNodeProperties.y=node.y;}if(options.clusterNodeProperties.fixed===undefined){options.clusterNodeProperties.fixed={};options.clusterNodeProperties.fixed.x=node.options.fixed.x;options.clusterNodeProperties.fixed.y=node.options.fixed.y;}var childNodesObj={};var childEdgesObj={};var parentNodeId=node.id;var parentClonedOptions=NetworkUtil.cloneOptions(node);childNodesObj[parentNodeId]=node;// collect the nodes that will be in the cluster
for(var i=0;i<node.edges.length;i++){var edge=node.edges[i];if(this.clusteredEdges[edge.id]===undefined){var childNodeId=this._getConnectedId(edge,parentNodeId);// if the child node is not in a cluster
if(this.clusteredNodes[childNodeId]===undefined){if(childNodeId!==parentNodeId){if(options.joinCondition===undefined){childEdgesObj[edge.id]=edge;childNodesObj[childNodeId]=this.body.nodes[childNodeId];}else{// clone the options and insert some additional parameters that could be interesting.
var childClonedOptions=NetworkUtil.cloneOptions(this.body.nodes[childNodeId]);if(options.joinCondition(parentClonedOptions,childClonedOptions)===true){childEdgesObj[edge.id]=edge;childNodesObj[childNodeId]=this.body.nodes[childNodeId];}}}else{// swallow the edge if it is self-referencing.
childEdgesObj[edge.id]=edge;}}}}var childNodeIDs=map$3(_context=keys$3(childNodesObj)).call(_context,function(childNode){return childNodesObj[childNode].id;});for(var childNodeKey in childNodesObj){if(!Object.prototype.hasOwnProperty.call(childNodesObj,childNodeKey))continue;var childNode=childNodesObj[childNodeKey];for(var y=0;y<childNode.edges.length;y++){var childEdge=childNode.edges[y];if(indexOf(childNodeIDs).call(childNodeIDs,this._getConnectedId(childEdge,childNode.id))>-1){childEdgesObj[childEdge.id]=childEdge;}}}this._cluster(childNodesObj,childEdgesObj,options,refreshData);}/**
     * This function creates the edges that will be attached to the cluster
     * It looks for edges that are connected to the nodes from the "outside' of the cluster.
     *
     * @param {{Node.id: vis.Node}} childNodesObj
     * @param {{vis.Edge.id: vis.Edge}} childEdgesObj
     * @param {object} clusterNodeProperties
     * @param {object} clusterEdgeProperties
     * @private
     */},{key:"_createClusterEdges",value:function _createClusterEdges(childNodesObj,childEdgesObj,clusterNodeProperties,clusterEdgeProperties){var edge,childNodeId,childNode,toId,fromId,otherNodeId;// loop over all child nodes and their edges to find edges going out of the cluster
// these edges will be replaced by clusterEdges.
var childKeys=keys$3(childNodesObj);var createEdges=[];for(var i=0;i<childKeys.length;i++){childNodeId=childKeys[i];childNode=childNodesObj[childNodeId];// construct new edges from the cluster to others
for(var j=0;j<childNode.edges.length;j++){edge=childNode.edges[j];// we only handle edges that are visible to the system, not the disabled ones from the clustering process.
if(this.clusteredEdges[edge.id]===undefined){// self-referencing edges will be added to the "hidden" list
if(edge.toId==edge.fromId){childEdgesObj[edge.id]=edge;}else{// set up the from and to.
if(edge.toId==childNodeId){// this is a double equals because ints and strings can be interchanged here.
toId=clusterNodeProperties.id;fromId=edge.fromId;otherNodeId=fromId;}else{toId=edge.toId;fromId=clusterNodeProperties.id;otherNodeId=toId;}}// Only edges from the cluster outwards are being replaced.
if(childNodesObj[otherNodeId]===undefined){createEdges.push({edge:edge,fromId:fromId,toId:toId});}}}}//
// Here we actually create the replacement edges.
//
// We could not do this in the loop above as the creation process
// would add an edge to the edges array we are iterating over.
//
// NOTE: a clustered edge can have multiple base edges!
//
var newEdges=[];/**
       * Find a cluster edge which matches the given created edge.
       *
       * @param {vis.Edge} createdEdge
       * @returns {vis.Edge}
       */var getNewEdge=function getNewEdge(createdEdge){for(var _j2=0;_j2<newEdges.length;_j2++){var newEdge=newEdges[_j2];// We replace both to and from edges with a single cluster edge
var matchToDirection=createdEdge.fromId===newEdge.fromId&&createdEdge.toId===newEdge.toId;var matchFromDirection=createdEdge.fromId===newEdge.toId&&createdEdge.toId===newEdge.fromId;if(matchToDirection||matchFromDirection){return newEdge;}}return null;};for(var _j3=0;_j3<createEdges.length;_j3++){var createdEdge=createEdges[_j3];var _edge=createdEdge.edge;var newEdge=getNewEdge(createdEdge);if(newEdge===null){// Create a clustered edge for this connection
newEdge=this._createClusteredEdge(createdEdge.fromId,createdEdge.toId,_edge,clusterEdgeProperties);newEdges.push(newEdge);}else{newEdge.clusteringEdgeReplacingIds.push(_edge.id);}// also reference the new edge in the old edge
this.body.edges[_edge.id].edgeReplacedById=newEdge.id;// hide the replaced edge
this._backupEdgeOptions(_edge);_edge.setOptions({physics:false});}}/**
     * This function checks the options that can be supplied to the different cluster functions
     * for certain fields and inserts defaults if needed
     *
     * @param {object} options
     * @returns {*}
     * @private
     */},{key:"_checkOptions",value:function _checkOptions(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};if(options.clusterEdgeProperties===undefined){options.clusterEdgeProperties={};}if(options.clusterNodeProperties===undefined){options.clusterNodeProperties={};}return options;}/**
     *
     * @param {object}    childNodesObj         | object with node objects, id as keys, same as childNodes except it also contains a source node
     * @param {object}    childEdgesObj         | object with edge objects, id as keys
     * @param {Array}     options               | object with {clusterNodeProperties, clusterEdgeProperties, processProperties}
     * @param {boolean}   refreshData | when true, do not wrap up
     * @private
     */},{key:"_cluster",value:function _cluster(childNodesObj,childEdgesObj,options){var refreshData=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;// Remove nodes which are already clustered
var tmpNodesToRemove=[];for(var nodeId in childNodesObj){if(Object.prototype.hasOwnProperty.call(childNodesObj,nodeId)){if(this.clusteredNodes[nodeId]!==undefined){tmpNodesToRemove.push(nodeId);}}}for(var n=0;n<tmpNodesToRemove.length;++n){delete childNodesObj[tmpNodesToRemove[n]];}// kill condition: no nodes don't bother
if(keys$3(childNodesObj).length==0){return;}// allow clusters of 1 if options allow
if(keys$3(childNodesObj).length==1&&options.clusterNodeProperties.allowSingleNodeCluster!=true){return;}var clusterNodeProperties=deepExtend({},options.clusterNodeProperties);// construct the clusterNodeProperties
if(options.processProperties!==undefined){// get the childNode options
var childNodesOptions=[];for(var _nodeId in childNodesObj){if(Object.prototype.hasOwnProperty.call(childNodesObj,_nodeId)){var clonedOptions=NetworkUtil.cloneOptions(childNodesObj[_nodeId]);childNodesOptions.push(clonedOptions);}}// get cluster properties based on childNodes
var childEdgesOptions=[];for(var edgeId in childEdgesObj){if(Object.prototype.hasOwnProperty.call(childEdgesObj,edgeId)){// these cluster edges will be removed on creation of the cluster.
if(edgeId.substr(0,12)!=="clusterEdge:"){var _clonedOptions=NetworkUtil.cloneOptions(childEdgesObj[edgeId],"edge");childEdgesOptions.push(_clonedOptions);}}}clusterNodeProperties=options.processProperties(clusterNodeProperties,childNodesOptions,childEdgesOptions);if(!clusterNodeProperties){throw new Error("The processProperties function does not return properties!");}}// check if we have an unique id;
if(clusterNodeProperties.id===undefined){clusterNodeProperties.id="cluster:"+v4();}var clusterId=clusterNodeProperties.id;if(clusterNodeProperties.label===undefined){clusterNodeProperties.label="cluster";}// give the clusterNode a position if it does not have one.
var pos=undefined;if(clusterNodeProperties.x===undefined){pos=this._getClusterPosition(childNodesObj);clusterNodeProperties.x=pos.x;}if(clusterNodeProperties.y===undefined){if(pos===undefined){pos=this._getClusterPosition(childNodesObj);}clusterNodeProperties.y=pos.y;}// force the ID to remain the same
clusterNodeProperties.id=clusterId;// create the cluster Node
// Note that allowSingleNodeCluster, if present, is stored in the options as well
var clusterNode=this.body.functions.createNode(clusterNodeProperties,Cluster);clusterNode.containedNodes=childNodesObj;clusterNode.containedEdges=childEdgesObj;// cache a copy from the cluster edge properties if we have to reconnect others later on
clusterNode.clusterEdgeProperties=options.clusterEdgeProperties;// finally put the cluster node into global
this.body.nodes[clusterNodeProperties.id]=clusterNode;this._clusterEdges(childNodesObj,childEdgesObj,clusterNodeProperties,options.clusterEdgeProperties);// set ID to undefined so no duplicates arise
clusterNodeProperties.id=undefined;// wrap up
if(refreshData===true){this.body.emitter.emit("_dataChanged");}}/**
     *
     * @param {Edge} edge
     * @private
     */},{key:"_backupEdgeOptions",value:function _backupEdgeOptions(edge){if(this.clusteredEdges[edge.id]===undefined){this.clusteredEdges[edge.id]={physics:edge.options.physics};}}/**
     *
     * @param {Edge} edge
     * @private
     */},{key:"_restoreEdge",value:function _restoreEdge(edge){var originalOptions=this.clusteredEdges[edge.id];if(originalOptions!==undefined){edge.setOptions({physics:originalOptions.physics});delete this.clusteredEdges[edge.id];}}/**
     * Check if a node is a cluster.
     *
     * @param {Node.id} nodeId
     * @returns {*}
     */},{key:"isCluster",value:function isCluster(nodeId){if(this.body.nodes[nodeId]!==undefined){return this.body.nodes[nodeId].isCluster===true;}else{console.error("Node does not exist.");return false;}}/**
     * get the position of the cluster node based on what's inside
     *
     * @param {object} childNodesObj    | object with node objects, id as keys
     * @returns {{x: number, y: number}}
     * @private
     */},{key:"_getClusterPosition",value:function _getClusterPosition(childNodesObj){var childKeys=keys$3(childNodesObj);var minX=childNodesObj[childKeys[0]].x;var maxX=childNodesObj[childKeys[0]].x;var minY=childNodesObj[childKeys[0]].y;var maxY=childNodesObj[childKeys[0]].y;var node;for(var i=1;i<childKeys.length;i++){node=childNodesObj[childKeys[i]];minX=node.x<minX?node.x:minX;maxX=node.x>maxX?node.x:maxX;minY=node.y<minY?node.y:minY;maxY=node.y>maxY?node.y:maxY;}return{x:0.5*(minX+maxX),y:0.5*(minY+maxY)};}/**
     * Open a cluster by calling this function.
     *
     * @param {vis.Edge.id}  clusterNodeId | the ID of the cluster node
     * @param {object} options
     * @param {boolean} refreshData | wrap up afterwards if not true
     */},{key:"openCluster",value:function openCluster(clusterNodeId,options){var refreshData=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;// kill conditions
if(clusterNodeId===undefined){throw new Error("No clusterNodeId supplied to openCluster.");}var clusterNode=this.body.nodes[clusterNodeId];if(clusterNode===undefined){throw new Error("The clusterNodeId supplied to openCluster does not exist.");}if(clusterNode.isCluster!==true||clusterNode.containedNodes===undefined||clusterNode.containedEdges===undefined){throw new Error("The node:"+clusterNodeId+" is not a valid cluster.");}// Check if current cluster is clustered itself
var stack=this.findNode(clusterNodeId);var parentIndex=indexOf(stack).call(stack,clusterNodeId)-1;if(parentIndex>=0){// Current cluster is clustered; transfer contained nodes and edges to parent
var parentClusterNodeId=stack[parentIndex];var parentClusterNode=this.body.nodes[parentClusterNodeId];// clustering.clusteredNodes and clustering.clusteredEdges remain unchanged
parentClusterNode._openChildCluster(clusterNodeId);// All components of child cluster node have been transferred. It can die now.
delete this.body.nodes[clusterNodeId];if(refreshData===true){this.body.emitter.emit("_dataChanged");}return;}// main body
var containedNodes=clusterNode.containedNodes;var containedEdges=clusterNode.containedEdges;// allow the user to position the nodes after release.
if(options!==undefined&&options.releaseFunction!==undefined&&typeof options.releaseFunction==="function"){var positions={};var clusterPosition={x:clusterNode.x,y:clusterNode.y};for(var nodeId in containedNodes){if(Object.prototype.hasOwnProperty.call(containedNodes,nodeId)){var containedNode=this.body.nodes[nodeId];positions[nodeId]={x:containedNode.x,y:containedNode.y};}}var newPositions=options.releaseFunction(clusterPosition,positions);for(var _nodeId2 in containedNodes){if(Object.prototype.hasOwnProperty.call(containedNodes,_nodeId2)){var _containedNode=this.body.nodes[_nodeId2];if(newPositions[_nodeId2]!==undefined){_containedNode.x=newPositions[_nodeId2].x===undefined?clusterNode.x:newPositions[_nodeId2].x;_containedNode.y=newPositions[_nodeId2].y===undefined?clusterNode.y:newPositions[_nodeId2].y;}}}}else{// copy the position from the cluster
forEach$1(containedNodes,function(containedNode){// inherit position
if(containedNode.options.fixed.x===false){containedNode.x=clusterNode.x;}if(containedNode.options.fixed.y===false){containedNode.y=clusterNode.y;}});}// release nodes
for(var _nodeId3 in containedNodes){if(Object.prototype.hasOwnProperty.call(containedNodes,_nodeId3)){var _containedNode2=this.body.nodes[_nodeId3];// inherit speed
_containedNode2.vx=clusterNode.vx;_containedNode2.vy=clusterNode.vy;_containedNode2.setOptions({physics:true});delete this.clusteredNodes[_nodeId3];}}// copy the clusterNode edges because we cannot iterate over an object that we add or remove from.
var edgesToBeDeleted=[];for(var i=0;i<clusterNode.edges.length;i++){edgesToBeDeleted.push(clusterNode.edges[i]);}// actually handling the deleting.
for(var _i3=0;_i3<edgesToBeDeleted.length;_i3++){var edge=edgesToBeDeleted[_i3];var otherNodeId=this._getConnectedId(edge,clusterNodeId);var otherNode=this.clusteredNodes[otherNodeId];for(var j=0;j<edge.clusteringEdgeReplacingIds.length;j++){var transferId=edge.clusteringEdgeReplacingIds[j];var transferEdge=this.body.edges[transferId];if(transferEdge===undefined)continue;// if the other node is in another cluster, we transfer ownership of this edge to the other cluster
if(otherNode!==undefined){// transfer ownership:
var otherCluster=this.body.nodes[otherNode.clusterId];otherCluster.containedEdges[transferEdge.id]=transferEdge;// delete local reference
delete containedEdges[transferEdge.id];// get to and from
var fromId=transferEdge.fromId;var toId=transferEdge.toId;if(transferEdge.toId==otherNodeId){toId=otherNode.clusterId;}else{fromId=otherNode.clusterId;}// create new cluster edge from the otherCluster
this._createClusteredEdge(fromId,toId,transferEdge,otherCluster.clusterEdgeProperties,{hidden:false,physics:true});}else{this._restoreEdge(transferEdge);}}edge.remove();}// handle the releasing of the edges
for(var edgeId in containedEdges){if(Object.prototype.hasOwnProperty.call(containedEdges,edgeId)){this._restoreEdge(containedEdges[edgeId]);}}// remove clusterNode
delete this.body.nodes[clusterNodeId];if(refreshData===true){this.body.emitter.emit("_dataChanged");}}/**
     *
     * @param {Cluster.id} clusterId
     * @returns {Array.<Node.id>}
     */},{key:"getNodesInCluster",value:function getNodesInCluster(clusterId){var nodesArray=[];if(this.isCluster(clusterId)===true){var containedNodes=this.body.nodes[clusterId].containedNodes;for(var nodeId in containedNodes){if(Object.prototype.hasOwnProperty.call(containedNodes,nodeId)){nodesArray.push(this.body.nodes[nodeId].id);}}}return nodesArray;}/**
     * Get the stack clusterId's that a certain node resides in. cluster A -> cluster B -> cluster C -> node
     *
     * If a node can't be found in the chain, return an empty array.
     *
     * @param {string|number} nodeId
     * @returns {Array}
     */},{key:"findNode",value:function findNode(nodeId){var stack=[];var max=100;var counter=0;var node;while(this.clusteredNodes[nodeId]!==undefined&&counter<max){node=this.body.nodes[nodeId];if(node===undefined)return[];stack.push(node.id);nodeId=this.clusteredNodes[nodeId].clusterId;counter++;}node=this.body.nodes[nodeId];if(node===undefined)return[];stack.push(node.id);reverse(stack).call(stack);return stack;}/**
     * Using a clustered nodeId, update with the new options
     *
     * @param {Node.id} clusteredNodeId
     * @param {object} newOptions
     */},{key:"updateClusteredNode",value:function updateClusteredNode(clusteredNodeId,newOptions){if(clusteredNodeId===undefined){throw new Error("No clusteredNodeId supplied to updateClusteredNode.");}if(newOptions===undefined){throw new Error("No newOptions supplied to updateClusteredNode.");}if(this.body.nodes[clusteredNodeId]===undefined){throw new Error("The clusteredNodeId supplied to updateClusteredNode does not exist.");}this.body.nodes[clusteredNodeId].setOptions(newOptions);this.body.emitter.emit("_dataChanged");}/**
     * Using a base edgeId, update all related clustered edges with the new options
     *
     * @param {vis.Edge.id} startEdgeId
     * @param {object} newOptions
     */},{key:"updateEdge",value:function updateEdge(startEdgeId,newOptions){if(startEdgeId===undefined){throw new Error("No startEdgeId supplied to updateEdge.");}if(newOptions===undefined){throw new Error("No newOptions supplied to updateEdge.");}if(this.body.edges[startEdgeId]===undefined){throw new Error("The startEdgeId supplied to updateEdge does not exist.");}var allEdgeIds=this.getClusteredEdges(startEdgeId);for(var i=0;i<allEdgeIds.length;i++){var edge=this.body.edges[allEdgeIds[i]];edge.setOptions(newOptions);}this.body.emitter.emit("_dataChanged");}/**
     * Get a stack of clusterEdgeId's (+base edgeid) that a base edge is the same as. cluster edge C -> cluster edge B -> cluster edge A -> base edge(edgeId)
     *
     * @param {vis.Edge.id} edgeId
     * @returns {Array.<vis.Edge.id>}
     */},{key:"getClusteredEdges",value:function getClusteredEdges(edgeId){var stack=[];var max=100;var counter=0;while(edgeId!==undefined&&this.body.edges[edgeId]!==undefined&&counter<max){stack.push(this.body.edges[edgeId].id);edgeId=this.body.edges[edgeId].edgeReplacedById;counter++;}reverse(stack).call(stack);return stack;}/**
     * Get the base edge id of clusterEdgeId. cluster edge (clusteredEdgeId) -> cluster edge B -> cluster edge C -> base edge
     *
     * @param {vis.Edge.id} clusteredEdgeId
     * @returns {vis.Edge.id} baseEdgeId
     *
     * TODO: deprecate in 5.0.0. Method getBaseEdges() is the correct one to use.
     */},{key:"getBaseEdge",value:function getBaseEdge(clusteredEdgeId){// Just kludge this by returning the first base edge id found
return this.getBaseEdges(clusteredEdgeId)[0];}/**
     * Get all regular edges for this clustered edge id.
     *
     * @param {vis.Edge.id} clusteredEdgeId
     * @returns {Array.<vis.Edge.id>} all baseEdgeId's under this clustered edge
     */},{key:"getBaseEdges",value:function getBaseEdges(clusteredEdgeId){var IdsToHandle=[clusteredEdgeId];var doneIds=[];var foundIds=[];var max=100;var counter=0;while(IdsToHandle.length>0&&counter<max){var nextId=IdsToHandle.pop();if(nextId===undefined)continue;// Paranoia here and onwards
var nextEdge=this.body.edges[nextId];if(nextEdge===undefined)continue;counter++;var replacingIds=nextEdge.clusteringEdgeReplacingIds;if(replacingIds===undefined){// nextId is a base id
foundIds.push(nextId);}else{// Another cluster edge, unravel this one as well
for(var i=0;i<replacingIds.length;++i){var replacingId=replacingIds[i];// Don't add if already handled
// TODO: never triggers; find a test-case which does
if(indexOf(IdsToHandle).call(IdsToHandle,replacingIds)!==-1||indexOf(doneIds).call(doneIds,replacingIds)!==-1){continue;}IdsToHandle.push(replacingId);}}doneIds.push(nextId);}return foundIds;}/**
     * Get the Id the node is connected to
     *
     * @param {vis.Edge} edge
     * @param {Node.id} nodeId
     * @returns {*}
     * @private
     */},{key:"_getConnectedId",value:function _getConnectedId(edge,nodeId){if(edge.toId!=nodeId){return edge.toId;}else if(edge.fromId!=nodeId){return edge.fromId;}else{return edge.fromId;}}/**
     * We determine how many connections denote an important hub.
     * We take the mean + 2*std as the important hub size. (Assuming a normal distribution of data, ~2.2%)
     *
     * @returns {number}
     * @private
     */},{key:"_getHubSize",value:function _getHubSize(){var average=0;var averageSquared=0;var hubCounter=0;var largestHub=0;for(var i=0;i<this.body.nodeIndices.length;i++){var node=this.body.nodes[this.body.nodeIndices[i]];if(node.edges.length>largestHub){largestHub=node.edges.length;}average+=node.edges.length;averageSquared+=Math.pow(node.edges.length,2);hubCounter+=1;}average=average/hubCounter;averageSquared=averageSquared/hubCounter;var variance=averageSquared-Math.pow(average,2);var standardDeviation=Math.sqrt(variance);var hubThreshold=Math.floor(average+2*standardDeviation);// always have at least one to cluster
if(hubThreshold>largestHub){hubThreshold=largestHub;}return hubThreshold;}/**
     * Create an edge for the cluster representation.
     *
     * @param {Node.id} fromId
     * @param {Node.id} toId
     * @param {vis.Edge} baseEdge
     * @param {object} clusterEdgeProperties
     * @param {object} extraOptions
     * @returns {Edge} newly created clustered edge
     * @private
     */},{key:"_createClusteredEdge",value:function _createClusteredEdge(fromId,toId,baseEdge,clusterEdgeProperties,extraOptions){// copy the options of the edge we will replace
var clonedOptions=NetworkUtil.cloneOptions(baseEdge,"edge");// make sure the properties of clusterEdges are superimposed on it
deepExtend(clonedOptions,clusterEdgeProperties);// set up the edge
clonedOptions.from=fromId;clonedOptions.to=toId;clonedOptions.id="clusterEdge:"+v4();// apply the edge specific options to it if specified
if(extraOptions!==undefined){deepExtend(clonedOptions,extraOptions);}var newEdge=this.body.functions.createEdge(clonedOptions);newEdge.clusteringEdgeReplacingIds=[baseEdge.id];newEdge.connect();// Register the new edge
this.body.edges[newEdge.id]=newEdge;return newEdge;}/**
     * Add the passed child nodes and edges to the given cluster node.
     *
     * @param {object | Node} childNodes  hash of nodes or single node to add in cluster
     * @param {object | Edge} childEdges  hash of edges or single edge to take into account when clustering
     * @param {Node} clusterNode  cluster node to add nodes and edges to
     * @param {object} [clusterEdgeProperties]
     * @private
     */},{key:"_clusterEdges",value:function _clusterEdges(childNodes,childEdges,clusterNode,clusterEdgeProperties){if(childEdges instanceof Edge){var edge=childEdges;var obj={};obj[edge.id]=edge;childEdges=obj;}if(childNodes instanceof Node){var node=childNodes;var _obj={};_obj[node.id]=node;childNodes=_obj;}if(clusterNode===undefined||clusterNode===null){throw new Error("_clusterEdges: parameter clusterNode required");}if(clusterEdgeProperties===undefined){// Take the required properties from the cluster node
clusterEdgeProperties=clusterNode.clusterEdgeProperties;}// create the new edges that will connect to the cluster.
// All self-referencing edges will be added to childEdges here.
this._createClusterEdges(childNodes,childEdges,clusterNode,clusterEdgeProperties);// disable the childEdges
for(var edgeId in childEdges){if(Object.prototype.hasOwnProperty.call(childEdges,edgeId)){if(this.body.edges[edgeId]!==undefined){var _edge2=this.body.edges[edgeId];// cache the options before changing
this._backupEdgeOptions(_edge2);// disable physics and hide the edge
_edge2.setOptions({physics:false});}}}// disable the childNodes
for(var nodeId in childNodes){if(Object.prototype.hasOwnProperty.call(childNodes,nodeId)){this.clusteredNodes[nodeId]={clusterId:clusterNode.id,node:this.body.nodes[nodeId]};this.body.nodes[nodeId].setOptions({physics:false});}}}/**
     * Determine in which cluster given nodeId resides.
     *
     * If not in cluster, return undefined.
     *
     * NOTE: If you know a cleaner way to do this, please enlighten me (wimrijnders).
     *
     * @param {Node.id} nodeId
     * @returns {Node|undefined} Node instance for cluster, if present
     * @private
     */},{key:"_getClusterNodeForNode",value:function _getClusterNodeForNode(nodeId){if(nodeId===undefined)return undefined;var clusteredNode=this.clusteredNodes[nodeId];// NOTE: If no cluster info found, it should actually be an error
if(clusteredNode===undefined)return undefined;var clusterId=clusteredNode.clusterId;if(clusterId===undefined)return undefined;return this.body.nodes[clusterId];}/**
     * Internal helper function for conditionally removing items in array
     *
     * Done like this because Array.filter() is not fully supported by all IE's.
     *
     * @param {Array} arr
     * @param {Function} callback
     * @returns {Array}
     * @private
     */},{key:"_filter",value:function _filter(arr,callback){var ret=[];forEach$1(arr,function(item){if(callback(item)){ret.push(item);}});return ret;}/**
     * Scan all edges for changes in clustering and adjust this if necessary.
     *
     * Call this (internally) after there has been a change in node or edge data.
     *
     * Pre: States of this.body.nodes and this.body.edges consistent
     * Pre: this.clusteredNodes and this.clusteredEdge consistent with containedNodes and containedEdges
     *      of cluster nodes.
     */},{key:"_updateState",value:function _updateState(){var _this4=this;var nodeId;var deletedNodeIds=[];var deletedEdgeIds={};/**
       * Utility function to iterate over clustering nodes only
       *
       * @param {Function} callback  function to call for each cluster node
       */var eachClusterNode=function eachClusterNode(callback){forEach$1(_this4.body.nodes,function(node){if(node.isCluster===true){callback(node);}});};//
// Remove deleted regular nodes from clustering
//
// Determine the deleted nodes
for(nodeId in this.clusteredNodes){if(!Object.prototype.hasOwnProperty.call(this.clusteredNodes,nodeId))continue;var node=this.body.nodes[nodeId];if(node===undefined){deletedNodeIds.push(nodeId);}}// Remove nodes from cluster nodes
eachClusterNode(function(clusterNode){for(var n=0;n<deletedNodeIds.length;n++){delete clusterNode.containedNodes[deletedNodeIds[n]];}});// Remove nodes from cluster list
for(var n=0;n<deletedNodeIds.length;n++){delete this.clusteredNodes[deletedNodeIds[n]];}//
// Remove deleted edges from clustering
//
// Add the deleted clustered edges to the list
forEach$1(this.clusteredEdges,function(edgeId){var edge=_this4.body.edges[edgeId];if(edge===undefined||!edge.endPointsValid()){deletedEdgeIds[edgeId]=edgeId;}});// Cluster nodes can also contain edges which are not clustered,
// i.e. nodes 1-2 within cluster with an edge in between.
// So the cluster nodes also need to be scanned for invalid edges
eachClusterNode(function(clusterNode){forEach$1(clusterNode.containedEdges,function(edge,edgeId){if(!edge.endPointsValid()&&!deletedEdgeIds[edgeId]){deletedEdgeIds[edgeId]=edgeId;}});});// Also scan for cluster edges which need to be removed in the active list.
// Regular edges have been removed beforehand, so this only picks up the cluster edges.
forEach$1(this.body.edges,function(edge,edgeId){// Explicitly scan the contained edges for validity
var isValid=true;var replacedIds=edge.clusteringEdgeReplacingIds;if(replacedIds!==undefined){var numValid=0;forEach$1(replacedIds,function(containedEdgeId){var containedEdge=_this4.body.edges[containedEdgeId];if(containedEdge!==undefined&&containedEdge.endPointsValid()){numValid+=1;}});isValid=numValid>0;}if(!edge.endPointsValid()||!isValid){deletedEdgeIds[edgeId]=edgeId;}});// Remove edges from cluster nodes
eachClusterNode(function(clusterNode){forEach$1(deletedEdgeIds,function(deletedEdgeId){delete clusterNode.containedEdges[deletedEdgeId];forEach$1(clusterNode.edges,function(edge,m){if(edge.id===deletedEdgeId){clusterNode.edges[m]=null;// Don't want to directly delete here, because in the loop
return;}edge.clusteringEdgeReplacingIds=_this4._filter(edge.clusteringEdgeReplacingIds,function(id){return!deletedEdgeIds[id];});});// Clean up the nulls
clusterNode.edges=_this4._filter(clusterNode.edges,function(item){return item!==null;});});});// Remove from cluster list
forEach$1(deletedEdgeIds,function(edgeId){delete _this4.clusteredEdges[edgeId];});// Remove cluster edges from active list (this.body.edges).
// deletedEdgeIds still contains id of regular edges, but these should all
// be gone when you reach here.
forEach$1(deletedEdgeIds,function(edgeId){delete _this4.body.edges[edgeId];});//
// Check changed cluster state of edges
//
// Iterating over keys here, because edges may be removed in the loop
var ids=keys$3(this.body.edges);forEach$1(ids,function(edgeId){var edge=_this4.body.edges[edgeId];var shouldBeClustered=_this4._isClusteredNode(edge.fromId)||_this4._isClusteredNode(edge.toId);if(shouldBeClustered===_this4._isClusteredEdge(edge.id)){return;// all is well
}if(shouldBeClustered){// add edge to clustering
var clusterFrom=_this4._getClusterNodeForNode(edge.fromId);if(clusterFrom!==undefined){_this4._clusterEdges(_this4.body.nodes[edge.fromId],edge,clusterFrom);}var clusterTo=_this4._getClusterNodeForNode(edge.toId);if(clusterTo!==undefined){_this4._clusterEdges(_this4.body.nodes[edge.toId],edge,clusterTo);}// TODO: check that it works for both edges clustered
//       (This might be paranoia)
}else{delete _this4._clusterEdges[edgeId];_this4._restoreEdge(edge);// This should not be happening, the state should
// be properly updated at this point.
//
// If it *is* reached during normal operation, then we have to implement
// undo clustering for this edge here.
// throw new Error('remove edge from clustering not implemented!')
}});// Clusters may be nested to any level. Keep on opening until nothing to open
var changed=false;var continueLoop=true;var _loop2=function _loop2(){var clustersToOpen=[];// Determine the id's of clusters that need opening
eachClusterNode(function(clusterNode){var numNodes=keys$3(clusterNode.containedNodes).length;var allowSingle=clusterNode.options.allowSingleNodeCluster===true;if(allowSingle&&numNodes<1||!allowSingle&&numNodes<2){clustersToOpen.push(clusterNode.id);}});// Open them
for(var _n=0;_n<clustersToOpen.length;++_n){_this4.openCluster(clustersToOpen[_n],{},false/* Don't refresh, we're in an refresh/update already */);}continueLoop=clustersToOpen.length>0;changed=changed||continueLoop;};while(continueLoop){_loop2();}if(changed){this._updateState();// Redo this method (recursion possible! should be safe)
}}/**
     * Determine if node with given id is part of a cluster.
     *
     * @param {Node.id} nodeId
     * @returns {boolean} true if part of a cluster.
     */},{key:"_isClusteredNode",value:function _isClusteredNode(nodeId){return this.clusteredNodes[nodeId]!==undefined;}/**
     * Determine if edge with given id is not visible due to clustering.
     *
     * An edge is considered clustered if:
     * - it is directly replaced by a clustering edge
     * - any of its connecting nodes is in a cluster
     *
     * @param {vis.Edge.id} edgeId
     * @returns {boolean} true if part of a cluster.
     */},{key:"_isClusteredEdge",value:function _isClusteredEdge(edgeId){return this.clusteredEdges[edgeId]!==undefined;}}]);return ClusterEngine;}();function _createForOfIteratorHelper$5(o,allowArrayLike){var it=typeof symbol!=="undefined"&&getIteratorMethod(o)||o["@@iterator"];if(!it){if(isArray(o)||(it=_unsupportedIterableToArray$5(o))||allowArrayLike&&o&&typeof o.length==="number"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};},e:function e(_e){throw _e;},f:F};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion=true,didErr=false,err;return{s:function s(){it=it.call(o);},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e2){didErr=true;err=_e2;},f:function f(){try{if(!normalCompletion&&it.return!=null)it.return();}finally{if(didErr)throw err;}}};}function _unsupportedIterableToArray$5(o,minLen){var _context4;if(!o)return;if(typeof o==="string")return _arrayLikeToArray$5(o,minLen);var n=slice$1(_context4=Object.prototype.toString.call(o)).call(_context4,8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return from$2(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray$5(o,minLen);}function _arrayLikeToArray$5(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}/**
 * Initializes window.requestAnimationFrame() to a usable form.
 *
 * Specifically, set up this method for the case of running on node.js with jsdom enabled.
 *
 * NOTES:
 *
 * * On node.js, when calling this directly outside of this class, `window` is not defined.
 *   This happens even if jsdom is used.
 * * For node.js + jsdom, `window` is available at the moment the constructor is called.
 *   For this reason, the called is placed within the constructor.
 * * Even then, `window.requestAnimationFrame()` is not defined, so it still needs to be added.
 * * During unit testing, it happens that the window object is reset during execution, causing
 *   a runtime error due to missing `requestAnimationFrame()`. This needs to be compensated for,
 *   see `_requestNextFrame()`.
 * * Since this is a global object, it may affect other modules besides `Network`. With normal
 *   usage, this does not cause any problems. During unit testing, errors may occur. These have
 *   been compensated for, see comment block in _requestNextFrame().
 *
 * @private
 */function _initRequestAnimationFrame(){var func;if(window!==undefined){func=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;}if(func===undefined){// window or method not present, setting mock requestAnimationFrame
window.requestAnimationFrame=function(callback){//console.log("Called mock requestAnimationFrame");
callback();};}else{window.requestAnimationFrame=func;}}/**
 * The canvas renderer
 */var CanvasRenderer=/*#__PURE__*/function(){/**
   * @param {object} body
   * @param {Canvas} canvas
   */function CanvasRenderer(body,canvas){_classCallCheck(this,CanvasRenderer);_initRequestAnimationFrame();this.body=body;this.canvas=canvas;this.redrawRequested=false;this.renderTimer=undefined;this.requiresTimeout=true;this.renderingActive=false;this.renderRequests=0;this.allowRedraw=true;this.dragging=false;this.zooming=false;this.options={};this.defaultOptions={hideEdgesOnDrag:false,hideEdgesOnZoom:false,hideNodesOnDrag:false};assign$2(this.options,this.defaultOptions);this._determineBrowserMethod();this.bindEventListeners();}/**
   * Binds event listeners
   */_createClass(CanvasRenderer,[{key:"bindEventListeners",value:function bindEventListeners(){var _this=this,_context2;this.body.emitter.on("dragStart",function(){_this.dragging=true;});this.body.emitter.on("dragEnd",function(){_this.dragging=false;});this.body.emitter.on("zoom",function(){_this.zooming=true;window.clearTimeout(_this.zoomTimeoutId);_this.zoomTimeoutId=setTimeout$1(function(){var _context;_this.zooming=false;bind(_context=_this._requestRedraw).call(_context,_this)();},250);});this.body.emitter.on("_resizeNodes",function(){_this._resizeNodes();});this.body.emitter.on("_redraw",function(){if(_this.renderingActive===false){_this._redraw();}});this.body.emitter.on("_blockRedraw",function(){_this.allowRedraw=false;});this.body.emitter.on("_allowRedraw",function(){_this.allowRedraw=true;_this.redrawRequested=false;});this.body.emitter.on("_requestRedraw",bind(_context2=this._requestRedraw).call(_context2,this));this.body.emitter.on("_startRendering",function(){_this.renderRequests+=1;_this.renderingActive=true;_this._startRendering();});this.body.emitter.on("_stopRendering",function(){_this.renderRequests-=1;_this.renderingActive=_this.renderRequests>0;_this.renderTimer=undefined;});this.body.emitter.on("destroy",function(){_this.renderRequests=0;_this.allowRedraw=false;_this.renderingActive=false;if(_this.requiresTimeout===true){clearTimeout(_this.renderTimer);}else{window.cancelAnimationFrame(_this.renderTimer);}_this.body.emitter.off();});}/**
     *
     * @param {object} options
     */},{key:"setOptions",value:function setOptions(options){if(options!==undefined){var fields=["hideEdgesOnDrag","hideEdgesOnZoom","hideNodesOnDrag"];selectiveDeepExtend(fields,this.options,options);}}/**
     * Prepare the drawing of the next frame.
     *
     * Calls the callback when the next frame can or will be drawn.
     *
     * @param {Function} callback
     * @param {number} delay - timeout case only, wait this number of milliseconds
     * @returns {Function | undefined}
     * @private
     */},{key:"_requestNextFrame",value:function _requestNextFrame(callback,delay){// During unit testing, it happens that the mock window object is reset while
// the next frame is still pending. Then, either 'window' is not present, or
// 'requestAnimationFrame()' is not present because it is not defined on the
// mock window object.
//
// As a consequence, unrelated unit tests may appear to fail, even if the problem
// described happens in the current unit test.
//
// This is not something that will happen in normal operation, but we still need
// to take it into account.
//
if(typeof window==="undefined")return;// Doing `if (window === undefined)` does not work here!
var timer;var myWindow=window;// Grab a reference to reduce the possibility that 'window' is reset
// while running this method.
if(this.requiresTimeout===true){// wait given number of milliseconds and perform the animation step function
timer=setTimeout$1(callback,delay);}else{if(myWindow.requestAnimationFrame){timer=myWindow.requestAnimationFrame(callback);}}return timer;}/**
     *
     * @private
     */},{key:"_startRendering",value:function _startRendering(){if(this.renderingActive===true){if(this.renderTimer===undefined){var _context3;this.renderTimer=this._requestNextFrame(bind(_context3=this._renderStep).call(_context3,this),this.simulationInterval);}}}/**
     *
     * @private
     */},{key:"_renderStep",value:function _renderStep(){if(this.renderingActive===true){// reset the renderTimer so a new scheduled animation step can be set
this.renderTimer=undefined;if(this.requiresTimeout===true){// this schedules a new simulation step
this._startRendering();}this._redraw();if(this.requiresTimeout===false){// this schedules a new simulation step
this._startRendering();}}}/**
     * Redraw the network with the current data
     * chart will be resized too.
     */},{key:"redraw",value:function redraw(){this.body.emitter.emit("setSize");this._redraw();}/**
     * Redraw the network with the current data
     *
     * @private
     */},{key:"_requestRedraw",value:function _requestRedraw(){var _this2=this;if(this.redrawRequested!==true&&this.renderingActive===false&&this.allowRedraw===true){this.redrawRequested=true;this._requestNextFrame(function(){_this2._redraw(false);},0);}}/**
     * Redraw the network with the current data
     *
     * @param {boolean} [hidden=false] | Used to get the first estimate of the node sizes.
     *                                   Only the nodes are drawn after which they are quickly drawn over.
     * @private
     */},{key:"_redraw",value:function _redraw(){var hidden=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(this.allowRedraw===true){this.body.emitter.emit("initRedraw");this.redrawRequested=false;var drawLater={drawExternalLabels:null};// when the container div was hidden, this fixes it back up!
if(this.canvas.frame.canvas.width===0||this.canvas.frame.canvas.height===0){this.canvas.setSize();}this.canvas.setTransform();var ctx=this.canvas.getContext();// clear the canvas
var w=this.canvas.frame.canvas.clientWidth;var h=this.canvas.frame.canvas.clientHeight;ctx.clearRect(0,0,w,h);// if the div is hidden, we stop the redraw here for performance.
if(this.canvas.frame.clientWidth===0){return;}// set scaling and translation
ctx.save();ctx.translate(this.body.view.translation.x,this.body.view.translation.y);ctx.scale(this.body.view.scale,this.body.view.scale);ctx.beginPath();this.body.emitter.emit("beforeDrawing",ctx);ctx.closePath();if(hidden===false){if((this.dragging===false||this.dragging===true&&this.options.hideEdgesOnDrag===false)&&(this.zooming===false||this.zooming===true&&this.options.hideEdgesOnZoom===false)){this._drawEdges(ctx);}}if(this.dragging===false||this.dragging===true&&this.options.hideNodesOnDrag===false){var _this$_drawNodes=this._drawNodes(ctx,hidden),drawExternalLabels=_this$_drawNodes.drawExternalLabels;drawLater.drawExternalLabels=drawExternalLabels;}// draw the arrows last so they will be at the top
if(hidden===false){if((this.dragging===false||this.dragging===true&&this.options.hideEdgesOnDrag===false)&&(this.zooming===false||this.zooming===true&&this.options.hideEdgesOnZoom===false)){this._drawArrows(ctx);}}if(drawLater.drawExternalLabels!=null){drawLater.drawExternalLabels();}if(hidden===false){this._drawSelectionBox(ctx);}ctx.beginPath();this.body.emitter.emit("afterDrawing",ctx);ctx.closePath();// restore original scaling and translation
ctx.restore();if(hidden===true){ctx.clearRect(0,0,w,h);}}}/**
     * Redraw all nodes
     *
     * @param {CanvasRenderingContext2D}   ctx
     * @param {boolean} [alwaysShow]
     * @private
     */},{key:"_resizeNodes",value:function _resizeNodes(){this.canvas.setTransform();var ctx=this.canvas.getContext();ctx.save();ctx.translate(this.body.view.translation.x,this.body.view.translation.y);ctx.scale(this.body.view.scale,this.body.view.scale);var nodes=this.body.nodes;var node;// resize all nodes
for(var nodeId in nodes){if(Object.prototype.hasOwnProperty.call(nodes,nodeId)){node=nodes[nodeId];node.resize(ctx);node.updateBoundingBox(ctx,node.selected);}}// restore original scaling and translation
ctx.restore();}/**
     * Redraw all nodes
     *
     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
     * @param {boolean} [alwaysShow]
     * @private
     *
     * @returns {object} Callbacks to draw later on higher layers.
     */},{key:"_drawNodes",value:function _drawNodes(ctx){var alwaysShow=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var nodes=this.body.nodes;var nodeIndices=this.body.nodeIndices;var node;var selected=[];var hovered=[];var margin=20;var topLeft=this.canvas.DOMtoCanvas({x:-margin,y:-margin});var bottomRight=this.canvas.DOMtoCanvas({x:this.canvas.frame.canvas.clientWidth+margin,y:this.canvas.frame.canvas.clientHeight+margin});var viewableArea={top:topLeft.y,left:topLeft.x,bottom:bottomRight.y,right:bottomRight.x};var _drawExternalLabels=[];// draw unselected nodes;
for(var _i=0;_i<nodeIndices.length;_i++){node=nodes[nodeIndices[_i]];// set selected and hovered nodes aside
if(node.hover){hovered.push(nodeIndices[_i]);}else if(node.isSelected()){selected.push(nodeIndices[_i]);}else{if(alwaysShow===true){var drawLater=node.draw(ctx);if(drawLater.drawExternalLabel!=null){_drawExternalLabels.push(drawLater.drawExternalLabel);}}else if(node.isBoundingBoxOverlappingWith(viewableArea)===true){var _drawLater=node.draw(ctx);if(_drawLater.drawExternalLabel!=null){_drawExternalLabels.push(_drawLater.drawExternalLabel);}}else{node.updateBoundingBox(ctx,node.selected);}}}var i;var selectedLength=selected.length;var hoveredLength=hovered.length;// draw the selected nodes on top
for(i=0;i<selectedLength;i++){node=nodes[selected[i]];var _drawLater2=node.draw(ctx);if(_drawLater2.drawExternalLabel!=null){_drawExternalLabels.push(_drawLater2.drawExternalLabel);}}// draw hovered nodes above everything else: fixes https://github.com/visjs/vis-network/issues/226
for(i=0;i<hoveredLength;i++){node=nodes[hovered[i]];var _drawLater3=node.draw(ctx);if(_drawLater3.drawExternalLabel!=null){_drawExternalLabels.push(_drawLater3.drawExternalLabel);}}return{drawExternalLabels:function drawExternalLabels(){var _iterator=_createForOfIteratorHelper$5(_drawExternalLabels),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var draw=_step.value;draw();}}catch(err){_iterator.e(err);}finally{_iterator.f();}}};}/**
     * Redraw all edges
     *
     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
     * @private
     */},{key:"_drawEdges",value:function _drawEdges(ctx){var edges=this.body.edges;var edgeIndices=this.body.edgeIndices;for(var i=0;i<edgeIndices.length;i++){var edge=edges[edgeIndices[i]];if(edge.connected===true){edge.draw(ctx);}}}/**
     * Redraw all arrows
     *
     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
     * @private
     */},{key:"_drawArrows",value:function _drawArrows(ctx){var edges=this.body.edges;var edgeIndices=this.body.edgeIndices;for(var i=0;i<edgeIndices.length;i++){var edge=edges[edgeIndices[i]];if(edge.connected===true){edge.drawArrows(ctx);}}}/**
     * Determine if the browser requires a setTimeout or a requestAnimationFrame. This was required because
     * some implementations (safari and IE9) did not support requestAnimationFrame
     *
     * @private
     */},{key:"_determineBrowserMethod",value:function _determineBrowserMethod(){if(typeof window!=="undefined"){var browserType=navigator.userAgent.toLowerCase();this.requiresTimeout=false;if(indexOf(browserType).call(browserType,"msie 9.0")!=-1){// IE 9
this.requiresTimeout=true;}else if(indexOf(browserType).call(browserType,"safari")!=-1){// safari
if(indexOf(browserType).call(browserType,"chrome")<=-1){this.requiresTimeout=true;}}}else{this.requiresTimeout=true;}}/**
     * Redraw selection box
     *
     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas
     * @private
     */},{key:"_drawSelectionBox",value:function _drawSelectionBox(ctx){if(this.body.selectionBox.show){ctx.beginPath();var width=this.body.selectionBox.position.end.x-this.body.selectionBox.position.start.x;var height=this.body.selectionBox.position.end.y-this.body.selectionBox.position.start.y;ctx.rect(this.body.selectionBox.position.start.x,this.body.selectionBox.position.start.y,width,height);ctx.fillStyle="rgba(151, 194, 252, 0.2)";ctx.fillRect(this.body.selectionBox.position.start.x,this.body.selectionBox.position.start.y,width,height);ctx.strokeStyle="rgba(151, 194, 252, 1)";ctx.stroke();}else{ctx.closePath();}}}]);return CanvasRenderer;}();var setInterval$1=path.setInterval;var setInterval=setInterval$1;/**
 * Register a touch event, taking place before a gesture
 *
 * @param {Hammer} hammer       A hammer instance
 * @param {Function} callback   Callback, called as callback(event)
 */function onTouch(hammer,callback){callback.inputHandler=function(event){if(event.isFirst){callback(event);}};hammer.on("hammer.input",callback.inputHandler);}/**
 * Register a release event, taking place after a gesture
 *
 * @param {Hammer} hammer       A hammer instance
 * @param {Function} callback   Callback, called as callback(event)
 * @returns {*}
 */function onRelease(hammer,callback){callback.inputHandler=function(event){if(event.isFinal){callback(event);}};return hammer.on("hammer.input",callback.inputHandler);}/**
 * Create the main frame for the Network.
 * This function is executed once when a Network object is created. The frame
 * contains a canvas, and this canvas contains all objects like the axis and
 * nodes.
 */var Canvas=/*#__PURE__*/function(){/**
   * @param {object} body
   */function Canvas(body){_classCallCheck(this,Canvas);this.body=body;this.pixelRatio=1;this.cameraState={};this.initialized=false;this.canvasViewCenter={};this._cleanupCallbacks=[];this.options={};this.defaultOptions={autoResize:true,height:"100%",width:"100%"};assign$2(this.options,this.defaultOptions);this.bindEventListeners();}/**
   * Binds event listeners
   */_createClass(Canvas,[{key:"bindEventListeners",value:function bindEventListeners(){var _this=this,_context;// bind the events
this.body.emitter.once("resize",function(obj){if(obj.width!==0){_this.body.view.translation.x=obj.width*0.5;}if(obj.height!==0){_this.body.view.translation.y=obj.height*0.5;}});this.body.emitter.on("setSize",bind(_context=this.setSize).call(_context,this));this.body.emitter.on("destroy",function(){_this.hammerFrame.destroy();_this.hammer.destroy();_this._cleanUp();});}/**
     * @param {object} options
     */},{key:"setOptions",value:function setOptions(options){var _this2=this;if(options!==undefined){var fields=["width","height","autoResize"];selectiveDeepExtend(fields,this.options,options);}// Automatically adapt to changing size of the container element.
this._cleanUp();if(this.options.autoResize===true){var _context2;if(window.ResizeObserver){// decent browsers, immediate reactions
var observer=new ResizeObserver(function(){var changed=_this2.setSize();if(changed===true){_this2.body.emitter.emit("_requestRedraw");}});var frame=this.frame;observer.observe(frame);this._cleanupCallbacks.push(function(){observer.unobserve(frame);});}else{// IE11, continous polling
var resizeTimer=setInterval(function(){var changed=_this2.setSize();if(changed===true){_this2.body.emitter.emit("_requestRedraw");}},1000);this._cleanupCallbacks.push(function(){clearInterval(resizeTimer);});}// Automatically adapt to changing size of the browser.
var resizeFunction=bind(_context2=this._onResize).call(_context2,this);addEventListener(window,"resize",resizeFunction);this._cleanupCallbacks.push(function(){removeEventListener(window,"resize",resizeFunction);});}}/**
     * @private
     */},{key:"_cleanUp",value:function _cleanUp(){var _context3,_context4,_context5;forEach$2(_context3=reverse(_context4=splice(_context5=this._cleanupCallbacks).call(_context5,0)).call(_context4)).call(_context3,function(callback){try{callback();}catch(error){console.error(error);}});}/**
     * @private
     */},{key:"_onResize",value:function _onResize(){this.setSize();this.body.emitter.emit("_redraw");}/**
     * Get and store the cameraState
     *
     * @param {number} [pixelRatio=this.pixelRatio]
     * @private
     */},{key:"_getCameraState",value:function _getCameraState(){var pixelRatio=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.pixelRatio;if(this.initialized===true){this.cameraState.previousWidth=this.frame.canvas.width/pixelRatio;this.cameraState.previousHeight=this.frame.canvas.height/pixelRatio;this.cameraState.scale=this.body.view.scale;this.cameraState.position=this.DOMtoCanvas({x:0.5*this.frame.canvas.width/pixelRatio,y:0.5*this.frame.canvas.height/pixelRatio});}}/**
     * Set the cameraState
     *
     * @private
     */},{key:"_setCameraState",value:function _setCameraState(){if(this.cameraState.scale!==undefined&&this.frame.canvas.clientWidth!==0&&this.frame.canvas.clientHeight!==0&&this.pixelRatio!==0&&this.cameraState.previousWidth>0&&this.cameraState.previousHeight>0){var widthRatio=this.frame.canvas.width/this.pixelRatio/this.cameraState.previousWidth;var heightRatio=this.frame.canvas.height/this.pixelRatio/this.cameraState.previousHeight;var newScale=this.cameraState.scale;if(widthRatio!=1&&heightRatio!=1){newScale=this.cameraState.scale*0.5*(widthRatio+heightRatio);}else if(widthRatio!=1){newScale=this.cameraState.scale*widthRatio;}else if(heightRatio!=1){newScale=this.cameraState.scale*heightRatio;}this.body.view.scale=newScale;// this comes from the view module.
var currentViewCenter=this.DOMtoCanvas({x:0.5*this.frame.canvas.clientWidth,y:0.5*this.frame.canvas.clientHeight});var distanceFromCenter={// offset from view, distance view has to change by these x and y to center the node
x:currentViewCenter.x-this.cameraState.position.x,y:currentViewCenter.y-this.cameraState.position.y};this.body.view.translation.x+=distanceFromCenter.x*this.body.view.scale;this.body.view.translation.y+=distanceFromCenter.y*this.body.view.scale;}}/**
     *
     * @param {number|string} value
     * @returns {string}
     * @private
     */},{key:"_prepareValue",value:function _prepareValue(value){if(typeof value==="number"){return value+"px";}else if(typeof value==="string"){if(indexOf(value).call(value,"%")!==-1||indexOf(value).call(value,"px")!==-1){return value;}else if(indexOf(value).call(value,"%")===-1){return value+"px";}}throw new Error("Could not use the value supplied for width or height:"+value);}/**
     * Create the HTML
     */},{key:"_create",value:function _create(){// remove all elements from the container element.
while(this.body.container.hasChildNodes()){this.body.container.removeChild(this.body.container.firstChild);}this.frame=document.createElement("div");this.frame.className="vis-network";this.frame.style.position="relative";this.frame.style.overflow="hidden";this.frame.tabIndex=0;// tab index is required for keycharm to bind keystrokes to the div instead of the window
//////////////////////////////////////////////////////////////////
this.frame.canvas=document.createElement("canvas");this.frame.canvas.style.position="relative";this.frame.appendChild(this.frame.canvas);if(!this.frame.canvas.getContext){var noCanvas=document.createElement("DIV");noCanvas.style.color="red";noCanvas.style.fontWeight="bold";noCanvas.style.padding="10px";noCanvas.innerText="Error: your browser does not support HTML canvas";this.frame.canvas.appendChild(noCanvas);}else{this._setPixelRatio();this.setTransform();}// add the frame to the container element
this.body.container.appendChild(this.frame);this.body.view.scale=1;this.body.view.translation={x:0.5*this.frame.canvas.clientWidth,y:0.5*this.frame.canvas.clientHeight};this._bindHammer();}/**
     * This function binds hammer, it can be repeated over and over due to the uniqueness check.
     *
     * @private
     */},{key:"_bindHammer",value:function _bindHammer(){var _this3=this;if(this.hammer!==undefined){this.hammer.destroy();}this.drag={};this.pinch={};// init hammer
this.hammer=new Hammer$1(this.frame.canvas);this.hammer.get("pinch").set({enable:true});// enable to get better response, todo: test on mobile.
this.hammer.get("pan").set({threshold:5,direction:Hammer$1.DIRECTION_ALL});onTouch(this.hammer,function(event){_this3.body.eventListeners.onTouch(event);});this.hammer.on("tap",function(event){_this3.body.eventListeners.onTap(event);});this.hammer.on("doubletap",function(event){_this3.body.eventListeners.onDoubleTap(event);});this.hammer.on("press",function(event){_this3.body.eventListeners.onHold(event);});this.hammer.on("panstart",function(event){_this3.body.eventListeners.onDragStart(event);});this.hammer.on("panmove",function(event){_this3.body.eventListeners.onDrag(event);});this.hammer.on("panend",function(event){_this3.body.eventListeners.onDragEnd(event);});this.hammer.on("pinch",function(event){_this3.body.eventListeners.onPinch(event);});// TODO: neatly cleanup these handlers when re-creating the Canvas, IF these are done with hammer, event.stopPropagation will not work?
this.frame.canvas.addEventListener("wheel",function(event){_this3.body.eventListeners.onMouseWheel(event);});this.frame.canvas.addEventListener("mousemove",function(event){_this3.body.eventListeners.onMouseMove(event);});this.frame.canvas.addEventListener("contextmenu",function(event){_this3.body.eventListeners.onContext(event);});this.hammerFrame=new Hammer$1(this.frame);onRelease(this.hammerFrame,function(event){_this3.body.eventListeners.onRelease(event);});}/**
     * Set a new size for the network
     *
     * @param {string} width   Width in pixels or percentage (for example '800px'
     *                         or '50%')
     * @param {string} height  Height in pixels or percentage  (for example '400px'
     *                         or '30%')
     * @returns {boolean}
     */},{key:"setSize",value:function setSize(){var width=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.options.width;var height=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.options.height;width=this._prepareValue(width);height=this._prepareValue(height);var emitEvent=false;var oldWidth=this.frame.canvas.width;var oldHeight=this.frame.canvas.height;// update the pixel ratio
//
// NOTE: Comment in following is rather inconsistent; this is the ONLY place in the code
//       where it is assumed that the pixel ratio could change at runtime.
//       The only way I can think of this happening is a rotating screen or tablet; but then
//       there should be a mechanism for reloading the data (TODO: check if this is present).
//
//       If the assumption is true (i.e. pixel ratio can change at runtime), then *all* usage
//       of pixel ratio must be overhauled for this.
//
//       For the time being, I will humor the assumption here, and in the rest of the code assume it is
//       constant.
var previousRatio=this.pixelRatio;// we cache this because the camera state storage needs the old value
this._setPixelRatio();if(width!=this.options.width||height!=this.options.height||this.frame.style.width!=width||this.frame.style.height!=height){this._getCameraState(previousRatio);this.frame.style.width=width;this.frame.style.height=height;this.frame.canvas.style.width="100%";this.frame.canvas.style.height="100%";this.frame.canvas.width=Math.round(this.frame.canvas.clientWidth*this.pixelRatio);this.frame.canvas.height=Math.round(this.frame.canvas.clientHeight*this.pixelRatio);this.options.width=width;this.options.height=height;this.canvasViewCenter={x:0.5*this.frame.clientWidth,y:0.5*this.frame.clientHeight};emitEvent=true;}else{// this would adapt the width of the canvas to the width from 100% if and only if
// there is a change.
var newWidth=Math.round(this.frame.canvas.clientWidth*this.pixelRatio);var newHeight=Math.round(this.frame.canvas.clientHeight*this.pixelRatio);// store the camera if there is a change in size.
if(this.frame.canvas.width!==newWidth||this.frame.canvas.height!==newHeight){this._getCameraState(previousRatio);}if(this.frame.canvas.width!==newWidth){this.frame.canvas.width=newWidth;emitEvent=true;}if(this.frame.canvas.height!==newHeight){this.frame.canvas.height=newHeight;emitEvent=true;}}if(emitEvent===true){this.body.emitter.emit("resize",{width:Math.round(this.frame.canvas.width/this.pixelRatio),height:Math.round(this.frame.canvas.height/this.pixelRatio),oldWidth:Math.round(oldWidth/this.pixelRatio),oldHeight:Math.round(oldHeight/this.pixelRatio)});// restore the camera on change.
this._setCameraState();}// set initialized so the get and set camera will work from now on.
this.initialized=true;return emitEvent;}/**
     *
     * @returns {CanvasRenderingContext2D}
     */},{key:"getContext",value:function getContext(){return this.frame.canvas.getContext("2d");}/**
     * Determine the pixel ratio for various browsers.
     *
     * @returns {number}
     * @private
     */},{key:"_determinePixelRatio",value:function _determinePixelRatio(){var ctx=this.getContext();if(ctx===undefined){throw new Error("Could not get canvax context");}var numerator=1;if(typeof window!=="undefined"){// (window !== undefined) doesn't work here!
// Protection during unit tests, where 'window' can be missing
numerator=window.devicePixelRatio||1;}var denominator=ctx.webkitBackingStorePixelRatio||ctx.mozBackingStorePixelRatio||ctx.msBackingStorePixelRatio||ctx.oBackingStorePixelRatio||ctx.backingStorePixelRatio||1;return numerator/denominator;}/**
     * Lazy determination of pixel ratio.
     *
     * @private
     */},{key:"_setPixelRatio",value:function _setPixelRatio(){this.pixelRatio=this._determinePixelRatio();}/**
     * Set the transform in the contained context, based on its pixelRatio
     */},{key:"setTransform",value:function setTransform(){var ctx=this.getContext();if(ctx===undefined){throw new Error("Could not get canvax context");}ctx.setTransform(this.pixelRatio,0,0,this.pixelRatio,0,0);}/**
     * Convert the X coordinate in DOM-space (coordinate point in browser relative to the container div) to
     * the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon)
     *
     * @param {number} x
     * @returns {number}
     * @private
     */},{key:"_XconvertDOMtoCanvas",value:function _XconvertDOMtoCanvas(x){return(x-this.body.view.translation.x)/this.body.view.scale;}/**
     * Convert the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to
     * the X coordinate in DOM-space (coordinate point in browser relative to the container div)
     *
     * @param {number} x
     * @returns {number}
     * @private
     */},{key:"_XconvertCanvasToDOM",value:function _XconvertCanvasToDOM(x){return x*this.body.view.scale+this.body.view.translation.x;}/**
     * Convert the Y coordinate in DOM-space (coordinate point in browser relative to the container div) to
     * the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon)
     *
     * @param {number} y
     * @returns {number}
     * @private
     */},{key:"_YconvertDOMtoCanvas",value:function _YconvertDOMtoCanvas(y){return(y-this.body.view.translation.y)/this.body.view.scale;}/**
     * Convert the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to
     * the Y coordinate in DOM-space (coordinate point in browser relative to the container div)
     *
     * @param {number} y
     * @returns {number}
     * @private
     */},{key:"_YconvertCanvasToDOM",value:function _YconvertCanvasToDOM(y){return y*this.body.view.scale+this.body.view.translation.y;}/**
     * @param {point} pos
     * @returns {point}
     */},{key:"canvasToDOM",value:function canvasToDOM(pos){return{x:this._XconvertCanvasToDOM(pos.x),y:this._YconvertCanvasToDOM(pos.y)};}/**
     *
     * @param {point} pos
     * @returns {point}
     */},{key:"DOMtoCanvas",value:function DOMtoCanvas(pos){return{x:this._XconvertDOMtoCanvas(pos.x),y:this._YconvertDOMtoCanvas(pos.y)};}}]);return Canvas;}();/**
 * Validate the fit options, replace missing optional values by defaults etc.
 *
 * @param rawOptions - The raw options.
 * @param allNodeIds - All node ids that will be used if nodes are omitted in
 * the raw options.
 *
 * @returns Options with everything filled in and validated.
 */function normalizeFitOptions(rawOptions,allNodeIds){var options=assign$2({nodes:allNodeIds,minZoomLevel:Number.MIN_VALUE,maxZoomLevel:1},rawOptions!==null&&rawOptions!==void 0?rawOptions:{});if(!isArray(options.nodes)){throw new TypeError("Nodes has to be an array of ids.");}if(options.nodes.length===0){options.nodes=allNodeIds;}if(!(typeof options.minZoomLevel==="number"&&options.minZoomLevel>0)){throw new TypeError("Min zoom level has to be a number higher than zero.");}if(!(typeof options.maxZoomLevel==="number"&&options.minZoomLevel<=options.maxZoomLevel)){throw new TypeError("Max zoom level has to be a number higher than min zoom level.");}return options;}/**
 * The view
 */var View=/*#__PURE__*/function(){/**
   * @param {object} body
   * @param {Canvas} canvas
   */function View(body,canvas){var _context,_this=this,_context2;_classCallCheck(this,View);this.body=body;this.canvas=canvas;this.animationSpeed=1/this.renderRefreshRate;this.animationEasingFunction="easeInOutQuint";this.easingTime=0;this.sourceScale=0;this.targetScale=0;this.sourceTranslation=0;this.targetTranslation=0;this.lockedOnNodeId=undefined;this.lockedOnNodeOffset=undefined;this.touchTime=0;this.viewFunction=undefined;this.body.emitter.on("fit",bind(_context=this.fit).call(_context,this));this.body.emitter.on("animationFinished",function(){_this.body.emitter.emit("_stopRendering");});this.body.emitter.on("unlockNode",bind(_context2=this.releaseNode).call(_context2,this));}/**
   *
   * @param {object} [options={}]
   */_createClass(View,[{key:"setOptions",value:function setOptions(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.options=options;}/**
     * This function zooms out to fit all data on screen based on amount of nodes
     *
     * @param {object} [options={{nodes=Array}}]
     * @param options
     * @param {boolean} [initialZoom=false]  | zoom based on fitted formula or range, true = fitted, default = false;
     */},{key:"fit",value:function fit(options){var initialZoom=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;options=normalizeFitOptions(options,this.body.nodeIndices);var canvasWidth=this.canvas.frame.canvas.clientWidth;var canvasHeight=this.canvas.frame.canvas.clientHeight;var range;var zoomLevel;if(canvasWidth===0||canvasHeight===0){// There's no point in trying to fit into zero sized canvas. This could
// potentially even result in invalid values being computed. For example
// for network without nodes and zero sized canvas the zoom level would
// end up being computed as 0/0 which results in NaN. In any other case
// this would be 0/something which is again pointless to compute.
zoomLevel=1;range=NetworkUtil.getRange(this.body.nodes,options.nodes);}else if(initialZoom===true){// check if more than half of the nodes have a predefined position. If so, we use the range, not the approximation.
var positionDefined=0;for(var nodeId in this.body.nodes){if(Object.prototype.hasOwnProperty.call(this.body.nodes,nodeId)){var node=this.body.nodes[nodeId];if(node.predefinedPosition===true){positionDefined+=1;}}}if(positionDefined>0.5*this.body.nodeIndices.length){this.fit(options,false);return;}range=NetworkUtil.getRange(this.body.nodes,options.nodes);var numberOfNodes=this.body.nodeIndices.length;zoomLevel=12.662/(numberOfNodes+7.4147)+0.0964822;// this is obtained from fitting a dataset from 5 points with scale levels that looked good.
// correct for larger canvasses.
var factor=Math.min(canvasWidth/600,canvasHeight/600);zoomLevel*=factor;}else{this.body.emitter.emit("_resizeNodes");range=NetworkUtil.getRange(this.body.nodes,options.nodes);var xDistance=Math.abs(range.maxX-range.minX)*1.1;var yDistance=Math.abs(range.maxY-range.minY)*1.1;var xZoomLevel=canvasWidth/xDistance;var yZoomLevel=canvasHeight/yDistance;zoomLevel=xZoomLevel<=yZoomLevel?xZoomLevel:yZoomLevel;}if(zoomLevel>options.maxZoomLevel){zoomLevel=options.maxZoomLevel;}else if(zoomLevel<options.minZoomLevel){zoomLevel=options.minZoomLevel;}var center=NetworkUtil.findCenter(range);var animationOptions={position:center,scale:zoomLevel,animation:options.animation};this.moveTo(animationOptions);}// animation
/**
     * Center a node in view.
     *
     * @param {number} nodeId
     * @param {number} [options]
     */},{key:"focus",value:function focus(nodeId){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(this.body.nodes[nodeId]!==undefined){var nodePosition={x:this.body.nodes[nodeId].x,y:this.body.nodes[nodeId].y};options.position=nodePosition;options.lockedOnNode=nodeId;this.moveTo(options);}else{console.error("Node: "+nodeId+" cannot be found.");}}/**
     *
     * @param {object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels
     *                          |  options.scale    = number                 // scale to move to
     *                          |  options.position = {x:number, y:number}   // position to move to
     *                          |  options.animation = {duration:number, easingFunction:String} || Boolean   // position to move to
     */},{key:"moveTo",value:function moveTo(options){if(options===undefined){options={};return;}if(options.offset!=null){if(options.offset.x!=null){// Coerce and verify that x is valid.
options.offset.x=+options.offset.x;if(!_isFinite(options.offset.x)){throw new TypeError('The option "offset.x" has to be a finite number.');}}else{options.offset.x=0;}if(options.offset.y!=null){// Coerce and verify that y is valid.
options.offset.y=+options.offset.y;if(!_isFinite(options.offset.y)){throw new TypeError('The option "offset.y" has to be a finite number.');}}else{options.offset.x=0;}}else{options.offset={x:0,y:0};}if(options.position!=null){if(options.position.x!=null){// Coerce and verify that x is valid.
options.position.x=+options.position.x;if(!_isFinite(options.position.x)){throw new TypeError('The option "position.x" has to be a finite number.');}}else{options.position.x=0;}if(options.position.y!=null){// Coerce and verify that y is valid.
options.position.y=+options.position.y;if(!_isFinite(options.position.y)){throw new TypeError('The option "position.y" has to be a finite number.');}}else{options.position.x=0;}}else{options.position=this.getViewPosition();}if(options.scale!=null){// Coerce and verify that the scale is valid.
options.scale=+options.scale;if(!(options.scale>0)){throw new TypeError('The option "scale" has to be a number greater than zero.');}}else{options.scale=this.body.view.scale;}if(options.animation===undefined){options.animation={duration:0};}if(options.animation===false){options.animation={duration:0};}if(options.animation===true){options.animation={};}if(options.animation.duration===undefined){options.animation.duration=1000;}// default duration
if(options.animation.easingFunction===undefined){options.animation.easingFunction="easeInOutQuad";}// default easing function
this.animateView(options);}/**
     *
     * @param {object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels
     *                          |  options.time     = number                 // animation time in milliseconds
     *                          |  options.scale    = number                 // scale to animate to
     *                          |  options.position = {x:number, y:number}   // position to animate to
     *                          |  options.easingFunction = String           // linear, easeInQuad, easeOutQuad, easeInOutQuad,
     *                                                                       // easeInCubic, easeOutCubic, easeInOutCubic,
     *                                                                       // easeInQuart, easeOutQuart, easeInOutQuart,
     *                                                                       // easeInQuint, easeOutQuint, easeInOutQuint
     */},{key:"animateView",value:function animateView(options){if(options===undefined){return;}this.animationEasingFunction=options.animation.easingFunction;// release if something focussed on the node
this.releaseNode();if(options.locked===true){this.lockedOnNodeId=options.lockedOnNode;this.lockedOnNodeOffset=options.offset;}// forcefully complete the old animation if it was still running
if(this.easingTime!=0){this._transitionRedraw(true);// by setting easingtime to 1, we finish the animation.
}this.sourceScale=this.body.view.scale;this.sourceTranslation=this.body.view.translation;this.targetScale=options.scale;// set the scale so the viewCenter is based on the correct zoom level. This is overridden in the transitionRedraw
// but at least then we'll have the target transition
this.body.view.scale=this.targetScale;var viewCenter=this.canvas.DOMtoCanvas({x:0.5*this.canvas.frame.canvas.clientWidth,y:0.5*this.canvas.frame.canvas.clientHeight});var distanceFromCenter={// offset from view, distance view has to change by these x and y to center the node
x:viewCenter.x-options.position.x,y:viewCenter.y-options.position.y};this.targetTranslation={x:this.sourceTranslation.x+distanceFromCenter.x*this.targetScale+options.offset.x,y:this.sourceTranslation.y+distanceFromCenter.y*this.targetScale+options.offset.y};// if the time is set to 0, don't do an animation
if(options.animation.duration===0){if(this.lockedOnNodeId!=undefined){var _context3;this.viewFunction=bind(_context3=this._lockedRedraw).call(_context3,this);this.body.emitter.on("initRedraw",this.viewFunction);}else{this.body.view.scale=this.targetScale;this.body.view.translation=this.targetTranslation;this.body.emitter.emit("_requestRedraw");}}else{var _context4;this.animationSpeed=1/(60*options.animation.duration*0.001)||1/60;// 60 for 60 seconds, 0.001 for milli's
this.animationEasingFunction=options.animation.easingFunction;this.viewFunction=bind(_context4=this._transitionRedraw).call(_context4,this);this.body.emitter.on("initRedraw",this.viewFunction);this.body.emitter.emit("_startRendering");}}/**
     * used to animate smoothly by hijacking the redraw function.
     *
     * @private
     */},{key:"_lockedRedraw",value:function _lockedRedraw(){var nodePosition={x:this.body.nodes[this.lockedOnNodeId].x,y:this.body.nodes[this.lockedOnNodeId].y};var viewCenter=this.canvas.DOMtoCanvas({x:0.5*this.canvas.frame.canvas.clientWidth,y:0.5*this.canvas.frame.canvas.clientHeight});var distanceFromCenter={// offset from view, distance view has to change by these x and y to center the node
x:viewCenter.x-nodePosition.x,y:viewCenter.y-nodePosition.y};var sourceTranslation=this.body.view.translation;var targetTranslation={x:sourceTranslation.x+distanceFromCenter.x*this.body.view.scale+this.lockedOnNodeOffset.x,y:sourceTranslation.y+distanceFromCenter.y*this.body.view.scale+this.lockedOnNodeOffset.y};this.body.view.translation=targetTranslation;}/**
     * Resets state of a locked on Node
     */},{key:"releaseNode",value:function releaseNode(){if(this.lockedOnNodeId!==undefined&&this.viewFunction!==undefined){this.body.emitter.off("initRedraw",this.viewFunction);this.lockedOnNodeId=undefined;this.lockedOnNodeOffset=undefined;}}/**
     * @param {boolean} [finished=false]
     * @private
     */},{key:"_transitionRedraw",value:function _transitionRedraw(){var finished=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;this.easingTime+=this.animationSpeed;this.easingTime=finished===true?1.0:this.easingTime;var progress=easingFunctions[this.animationEasingFunction](this.easingTime);this.body.view.scale=this.sourceScale+(this.targetScale-this.sourceScale)*progress;this.body.view.translation={x:this.sourceTranslation.x+(this.targetTranslation.x-this.sourceTranslation.x)*progress,y:this.sourceTranslation.y+(this.targetTranslation.y-this.sourceTranslation.y)*progress};// cleanup
if(this.easingTime>=1.0){this.body.emitter.off("initRedraw",this.viewFunction);this.easingTime=0;if(this.lockedOnNodeId!=undefined){var _context5;this.viewFunction=bind(_context5=this._lockedRedraw).call(_context5,this);this.body.emitter.on("initRedraw",this.viewFunction);}this.body.emitter.emit("animationFinished");}}/**
     *
     * @returns {number}
     */},{key:"getScale",value:function getScale(){return this.body.view.scale;}/**
     *
     * @returns {{x: number, y: number}}
     */},{key:"getViewPosition",value:function getViewPosition(){return this.canvas.DOMtoCanvas({x:0.5*this.canvas.frame.canvas.clientWidth,y:0.5*this.canvas.frame.canvas.clientHeight});}}]);return View;}();var css_248z$1="div.vis-network div.vis-navigation div.vis-button {\n  width: 34px;\n  height: 34px;\n  -moz-border-radius: 17px;\n  border-radius: 17px;\n  position: absolute;\n  display: inline-block;\n  background-position: 2px 2px;\n  background-repeat: no-repeat;\n  cursor: pointer;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\ndiv.vis-network div.vis-navigation div.vis-button:hover {\n  box-shadow: 0 0 3px 3px rgba(56, 207, 21, 0.3);\n}\n\ndiv.vis-network div.vis-navigation div.vis-button:active {\n  box-shadow: 0 0 1px 3px rgba(56, 207, 21, 0.95);\n}\n\ndiv.vis-network div.vis-navigation div.vis-button.vis-up {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABphJREFUeNqcV2twU9cR/nbPlVTHxpKRbNnBLyEbPyJisLEcPwgwUMKQtjNJAzNJZkgNNJOmJaZAaDKlxaXDTIBAcJtOOzSYKSkdiimhAdIMjyT4bYgBYxA2BgcUQPLrCiGDR4qt2x+yXTASFt1/957d7zt3z3d39xDCMQWUfgAz/RI/T4pSTAJpAGL8rECAXX7QFQGq9wOHOxYO1oCgjAdJj1wtB095Giv9TFuZAIWHAziATMPhTAwiHgUkYPXFJu92lMP/2MTpB1AKUCVEgNAcleUo1M+2F8TO6crSTncb1QleAOj2OTSX3Ge1p+Va42m5JrnzbnsCE8Ov+EHgpa0LPLvCJjZ/whuIlN8wAcXG+e1LUn9hm238QU84p1Ld83nsXvuO7Lq+LzKYGAT6/dn58m/HJTYf4O3EShkT8Irpzab1Uz9sGevT5+tWn+j6NB4A5hp/5NSr43xjfd5rW5tT9e3OAhCBiCua5/WsDEls/hdvYklZSwDefmrT8eXmtzuDkb5YZ33p9ndylICAVjWxf39xw/5g5Luv/9H84ZWNcwNEypZT87rXjqyJB85UYDMJYN3U7UdLJ6/6JlgqV517teRqf9uTlug8e1zEk27HgD22o98WsTBh8fWxvjm6ApdONbGvse8LM5NUPOm1Cfabuz3nACAgxX0QEFTJAnjNvLJ+Sepb14KRHnN+Ev+1XJOhZs3Qu1mbG97J2NQgsXroa1dtxrGuf8cHi1mUtPTay0lv1DMJSCRVLtoX+FgGgDQNysBAcez89l9nbbsQSji7rlXkEhjPxb/QatHOcFu0M9zz419oFSRhj/3PuaHiyqasv1Con9NGxHAYUsoCxAqImbYSgCWmFbZQwdsur7N0eC4m6tT6/jUZ750Zeb82c+OZGLWh/2p/W+Kfrmy0hIp/aVKpTSIJEqu2QgFx2iE8CwDp0RbH7Ljng/4yXr+XT3QdyhYsodS0slGr0g2OrEUK7eCrKW82SqzCVz3/yfb6vRwM4xn9rN7JkRkOQRLmfJn2LBPxQjDBqp9lD7XbX7X8pKTP160zR2bdeiX5jYeU/nLSTztNkem3XL5eXbltRUkonBxdgZ2IIUmahUxERQSCVT+rK5hzQ89xQ6P8VaaK1f5VmRvqQ4G+lba+nlnlb5brMhvlk7FBiaPzuwQEmEQhg5BOxMjWTncHc2501cQLkjDTsMCWpyuRQxFP0xXIJfp5FyVW4Zy7KajC06ItbiIGg6ZITBxDxIgbrr1jTSM0fibGIHz8O9sKK0GAibEua9spANh4aY2VmcEg+DEkiBgR/L2hYFgGtcErkQQAMVJgBxyy9hboZzv32v+Kpr7qbEECTAIMAoaJa3qPTmNiiAAgJAjk6J5xhu6HDAIgQYGLmI29PocmMcI8MNYvT1ckfzD9H/ub5br4e4Me9WfOKqtyX6Ud2cwC449PRamifDm6Auc0rTXokci+Xo1EAgBckiDuYGLjpTvntcGIA+SFcp6uUAaAI879VhWrRteYAqn/edq758brXJ1327QMhgJcZjA3EBjNrgZjOG1PkAjyTGENMjZPq5ECQ0MDE9ERBqFZrk0OJ3i4x/7vyIjBxGERt3takgVJEAp9xq3f769WiPDNvSsJdT3HDOEASPelmoBRYT3Kzt5uMtwauJEgSOCpwrk1DIJCoNUMwj9v7MweP9XSQ8/hJPp496fZTAICvLqcyv2B7nRbrgCA03JN5h8ub7A8VqpB437xHvsOy3l3cyaB4L2uqxhti1WLMcSgZQCw7+bOooO3Pk4JBZIYYXISMV5sKH59UePM10GESRGpIf/bE92HU452HywSJIGIllctrhp6YAK5+fHds0lLtJFMXNwkV6fFqA29mROefqiMJj1h6um4a5vY/92dKGaBxIhU5zJTWW2cJmEgGOmeb3c8FxAfb9mdf2RzyGGv5MvU7QwuEySwKHFp/c/M71zA/2F7b1RajnYdLAqMukMVu2YcfmDYE2MD7H+7/Xlq6cRIJqm4zXM+qd3TGjVBir43KSLlXjiELe5TsX+3/yW/ST45PaAHbKmccWh12AP93JNZywj0kSABIobpiXRHjtZ6faout2tyZMadGLXBCxBcvl6NfaAz+tKdFmObpzWl2+tIIBACYy0t/yj34M7HvsKUK+CGassvicX7alYDwwq+vykIEqPVa+Q9gdYk5+V+UE7lj3+FGbuBM/X5JUT8QwIVSSSZiTgmoFR2MfiqYFFPfjpkyrfWPopwxP47AP1pK1g9/dqeAAAAAElFTkSuQmCC');\n  bottom: 50px;\n  left: 55px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-down {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABpdJREFUeNqcV21QlNcVfp5zX9ikoAvLEsAIIgsoHwpqWAQUNKLNaNv8iZ1JMkNG6/Qj/dDUyCSTtCHpmEkwVk3TToZRMjXj5MOG2KidjIkxQYSAQUAtX6IgIN8su8KCoOzbH4sk4q5g77/33uee555z7rnneYmZDB2MKcJKlyYbqOsZVIgGEOgSHQoy4AKbFFjqAo5dWn/rNAh9OpO852oeJHYxtrmEu4WALhMbxG2ZE9uFAlImDRLY/t/y0b3Ig+u+iWOKsAlgIZSb0OIf15kWtKo1NXh1d5xxiSPEN2wUAHrGOg11jirjWVtJyFnb6YgrzoYwocClu0DI5guPDb43Y2LLp/Iaqf9JCGSErGvIifxd7aqQn/TOJCvFvZ8Hf9haEH+m/6sFQgHBv1Sts/15WmJLkeyl6FuFwFPzny1/ZdE7Nfg/xhv1uUmH2w6kggQp+yqze7d5JbZ8Im+KpucSwI6EN7/cYtlxZarBCts3ptfrtq9odjaGKihE+sV0vRC3u8RqWmmbij149W+Wd5p2rnET6bsqsntyb6+pO3KqkE8FvLxo74lNUX9s9uTJb8/9fG2L81KoogJFYfCm3b9usNq0MXxzw1RsUkDqQICPqf/b/q8sQi3j4WdmtV47OFgNAO6r+DEUFAtFAc9YtpXmRP6hxVsI24cvhyoqnFtrK6jM7isgBa3Dl0O94TeGb255MvzXpUIFjVrhxo/dzgoARBuwFQJkBK9reCnurxfvXX8CRW3yW1G749vT2Br7ysW0oNX1pKDTPG+rm1gHRbibAHLm/7522sKnQCZqFgCUaBCqaS/bEw9vqtWoQROf3dBBiT6KTACImZ3YueqhDdOWjDbFQ4IzIl4elNUX5begU1HD6lPRmULKeghhDcpqnUmZuD3+nkgTH6gZEE9ctlZSoGmG9UIynSCsQVndMyX+IZGiBoHMjHh2SreCglClaSBiSEG8cYnD24bv7CWms/3FocO3hnw13plTggAFb196NdlPM44tC0zrSg5ItXmyEz070UEKCMRqQgkkBQ9NvL2eSJ+revoJTORSpoT6do4/7/7UShBFHQexM+HdfyUHWO8iN/uaRzX3/QjUSLlnqM72F4cCRIY5u9Zf+Y+BAv4AvzpkQ7WAIBRujA/7Vg6cia9xlId6InafVEAAGnQMUCSkb6zTMPdBy8hU3JjrphIq+CrD+Mvxeyumrr+4IH9y7o2GF5eDghuuGx4L2zbWZ9Dc0RoQRbkkFNRdP2/0BH7EtLJLKCjr+zqh2l5u8haZ847vTBW24kRFQXKAtcsT5oqz3igQENIoECkjBJUDZSGewBlBj/ammjLrdX1c/t70ero34gMte9IByLLAjPrUwKweT5jawQshdIuGMiF5XEBU2koivBl9NeEfJeYHwuxtI81zPrn2z6ip60c6DkV1jLTOCTaE2HNjd5Z4s9MwWBOhqEHp/I9cWDtUrJNoHm4KO9P7hdnTBoMYXI8Gb6gVCg63FS53jg9O5tA57tSOdHywnCAygrJrfcTgUe5U2cvNHSPtYYoKCWlrTgsIneB2AfFR+4F4b6f9ZdTzF6P8Ytud407/dy/nL7k9X9i8J9l5y+Ef6RfbnjPvWa8N5suez+KFCgqyPY95Lnd3stv2AcBZ2+mFbze+lui1xc3dXCUUlPafXNx4/aKxcajWWNp/MklRw8/mPFntbd+h1oLE847KhQQxejVg36QQqD0MPTzHv42Ux+uGasJNBnPfwllJd71kkX7RQ3WDNf7dox3BLcNNs6vt34bbbvYHJhlTGp6O+JVHb0/2HJtX1PH+aqECqG/5YN1nlXcokGvvO6vCc4x+QskotxVHB/qa+xbOWuzw8NB3nuo+Ht0z2hHsuGU3GrWAoZfi3jrxgHpw3BPpobaCH7vbqOw6mHI836vYW3Eqcq9AtioqbJy7ufQ3lhfu8sR+s9+3vL8klACsQSu7AnxMY1MxH7YXJp7oPpLulrrj+9575Ni2aeVt1teWfEWfHQLCaspseHzOU7VWU+aM5G2NoyL4i+6j8XWDNQsmGsKu/cv+nTtjQb/mm7hfENyvqEAK5v8opjPJaL26KGBpd5TfguuBvuZRgBgY6zO0jlyZXXe9JqR+8MK8ntHOMHfHIkhu2b/0yIH7/oXJ0yFlxYnPUdRbvuILgO7+y+91l6Ka6M+cnCf4fMSypXvymHf/vzBTD3CuNGUFKT8lmK5Rs5ASqKiBlAGBXFaiSuni0fkp1pJ7Ed4e/xsAqLk46EWsG1EAAAAASUVORK5CYII=');\n  bottom: 10px;\n  left: 55px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-left {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABt5JREFUeNqsl2lUlOcVx//3Pi9DZRsGBgYiS2RYBQKIjAhEJW4pNrXNMbZpWtTGNkttYmJMG5soSZckRk+0p+dYPYY0Gk0ihlhRj63GhVUgBhDD5oIOy8AAMwzD4lCYtx+GqCQKuNyP7/Pc+3u2+7/3JUzEZFBYLh62S7yIZDmVBEIBqOwsQ4DNdtBFASq2A4cuZAwVgCCPF5LGHM0Chz+E1XamzUyAzCMO7IhMI+5MDCK+HpCANd+U2rYgC/Y7BoflYgVA2RAOoNYtyjDTe45+hk96e5QywaJR+NsAwDhocK61VCjLTYWaclNB0OW+en8mhl22g8C/rn7U+uGEwdov+C0i+Q0mIFWzoD7zwVU1czQ/6pjIreR3HPX5VL9jalHXiQgmBoH+XLHAtH5csDaXtxDLLzIBv5jyfOmG2H9U4S7snbpX43KaPpgBIhDx1rPzOlbfPC5GQT/nd1mS1zABa6PfPf5y5F/rcJeWpp7fPkly6f7KXBRCoOSATFfXll19x74HDsvFCghsJAG8HrvlvytCXm7EPVqc5wyzp5NX15muE1omKXXyMnd9yy5r5Q3wPghvJzrLAlimXV38+7D1DbhPFq1M6O4b6rPVWKsCBfHi5EWWv9TkQBYAEPpLvERMC9N8FtRvjt9dPl6wwo5jPvuas7WV5jNqEjz8wA+CBsaan+w9x1hrrXJtuaZX97ooLfqPLCUEGRR+iOwAsF2X98Uc30W3fb02u41frVqeVmo6FUkkwCAwCWxJ2Ls/0TPFNBb8TNdp9WvnVz4OAKdmX2QOzcMsAAjziDGMBd3asCF6SXHyknJTfqQTK+zpvhnVKT5zawCgzFTgN94pJXvP7gxxjTAIkpB+MnSWRMQZYEDnPVt/K4ejbZ/77726Lb6h95tAAiPELaJ1bcTbRfGeM8xv1azWSeyEa0P9igk+Nr1+oNFfkpwzJCJKIQA679ntN08yDXYo3qh+LuUrc0E4EcNL4dP7VNDzpU8FP3vpekoQQ5CEw4bPdEfa9+sAgEZUmkmAAAS5hLQ9p11XGO+pM8V5JLUfMeQARDMlEMKIGFOVCZYb0C7Fz0oeXmIZ6nZzYoV9od/jVS+GbahUOnn9b7T6sEOviUGyA8bMDlUa0W79wBW/bZf+lrY98cDBUI8YCxGDgHCJiVVEDN8R7QWAE8Z/+1mGut2i3eP1r0S+XRztkdBzq6NbF7WpbF3UprKxjvfHxbrfttla/QBArVDbJJIAQCURMRg8ugrKIAKBSNxzHtN3VdmxY0iQYSZmTeegwTlgknYAAB7RZBh2Nm7urbeeC1r19ROT52kWn3shfH2Fu1AO3RxjY/0fdac7/hPPJMDE11GC+HpBJmIEuAS3Oa6w01lybMbMgvgCE6O255zy24DeCr/Bvckn9+u8ZjXYIYvjxoMJy8oeXZrT9GHIqMWTwA2oI6cFMeDIcAiSEOyibXsmZG0hAFzuq1OyY6xBAnMJgdPOmks08zU/bbsB9x18P37PqS/b8+o/a96ZcLm3PmBH46Z5x40HW1eFvl4Uq0w0MwiCBOb7/qTsd6GvVY537DXWas1Iw1AiNJnOgwJi+bXhAbE08OnvaXSIW0TvYw88eaF/uM/WNdju3m5r9TlhPBzVNNDoPGC/5tRma/GJ80xqjPPUjVuvP2narrMOWd1Jlv/E1fN782UiNPZf9C/qOKa+ndOz2j+cz046sn+6KrVOsODirpOxld0lUxmEBK/ktvGgFd2l6taBZn9BAtEz5xYIvAn4/8rFKkgstAyZ6Yf+S67ezlkiSU73XXRV6xqh93TyssR4JF75efBvymLdE03jgT/Wb5tutLWpGbTm7wHZxQQAT+yDuKLyHRIk4cnAZ4pfCF9/HvfR9uh3xBxtz00BANsVDylnac6wAICaHMiBmW5NRLy4trcq0MtZ3RnpHme5H9AvjYeCc1t3pzMJgOSVnyw4eHZUB9Kyu68iMFPpysSppab8UJVC3Rnp/pDlXqF7mnYsdKQbv7cr6fDGW/Zczbt6jgUtV6kIlFxuyg/tH+6zJXmlGe8G+mlzdsyB1j3pTAwZ9q3/Sspbc9tmDwD0H3UffXCFlyuTlFpnPRdYb612c5c8+idPCu6fCLDKUubzsf6fSaWm0wmO9hbvZU8fDR2zoZ97OuppAu0UJEDEmOISZohT6q7Gek5rD3GN6FEp1DaAYB7sdNYPXPao7anS1Fmrg402g7+jYhGIaOXOaQc+uONfmCwZXJIf8xKx2KRgxYgOS+CROuyoyQKCxIhkOr4T6JWgxGnvZ1HWnf/CfHcBXxcnpRHxYwRKkUjSErFKkAQiNjP4kmBRTHbKm5KkKxwL+K39fwDX1XGF8ct++QAAAABJRU5ErkJggg==');\n  bottom: 10px;\n  left: 15px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-right {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABs1JREFUeNqsl3tQlOcVxp9z3m+XygK7C4sLxkW5o4CAkYssFSkRjabjJEOSJm1IbZx2krapiZdeprW0NVVJ0pqMM0kYJQlqkoZImGioE1ItiCAgIsFwE4Es99vCslwChf36xy5EW1A0Pn9+73fO772e93kJC5EMCszFd20SbyFZNpJAAACtjWUI8KAN1CRAJTbg9LXNU+dBkG+Xkm7Zmg4OWoUdNqZXmQCZHQFsz0yOcCYGEc8mJGDnl2UTh5AO2x2DA3OxDaAsCDvQ32VF11qP9aZYz6SeFeooi17pPQEAvZNdTnWWKnWFuVhfYT7v0zza4M3EsMk2EPgnNZusby8Y7P8x/5lI/gMTYNSnNKQt/0Xtev1DfQtZlaK+M54fmDJXXhg4G8zEINBfqlLMe28L9s/lQ8Tyr5iAJ32fK/tj+OFq3IUO1O+JyGk7GgsiEPFrlQ/07bixXdwEPckHWZJ3MgG7Qw9+/mLIS/W4SyXoNvQskpyHLg1e8CNQ3NI0laoje7Tg/8CBudgGgQwSwO/DD322ze/FFnxLRWhiBzUK94GLA2f9mSTjfU+7mjqyrVe+AX8I4aGgShbA0/47Sn4ZuLcR90ih6qih0anRiVprtUEQb43bYtlXmwNZAEDAj/ACMW1M8ExpeDXyWMVCEl4yF7vntR/zLeov8JJlWfZR+Y3N92+cx/reOmu1quNrk27EWW0xvWspJcigoNNkA4C3Yk59vH7xltvu3ktDxe7PX34ilQCQfeci1j2xfn94ZrGCneY8uxcHCnW/vbr9EQD4d2ITc8AprAOAQLewroVAAaB8oMiLiRHvmVy7znNTjWCFrXKoJOSHFQ+kvnF9f+jco07s91MFdwmSkHQuYB0T8WYwIcYj0bTQdRufGlFKJMFVaCb/GvZW6aGI4yeXOwd2mr/u05zsyDY+W5X64Nm+fO85NpuJiCFJTpslIoonADEeiT2zIzIXuh+o25PQNtbsNVMOBUn2g08MiSTHN3uZjNTEDr4dnX/6H+1H/XPasmKvW+sMGfW/MXzende4K3h/ibvSYxIAItyie/K7cgCitQxCIBFjpTrKMgM+WPfrhLbxFi9iMQtlYjAJSCSBSYBAIPBNI3p86TPXj8bk56R4PVylFE626uFLQc9efiTVPDmgBIAAtzALEYNBQRITa4kYix21FwBax655CVagPLk7806Pj1qo/7MraF/FQ14/aMhszYhvGqn3KTef89rklWrSKXUTkn3mtJK9Bzf3XJA0e/PcrdgxIwSCDPmbZMQgABJkDBKzvn+yy2npIv9xAPB1Ceo2jTZ7Gc8afipIgEhAkACDwcSQQZBIIGnx5it7gg+U3wgcnbZKR1r+FnW+v2DVtDwtXCXNSKz797oAwDzZ7ySRAIBBFsTXmBh1w1+oZ4J3h+wv9lUFdbMDOrO+5IAqWIGZthuV13nC77nKRx8r7PssyibLIkoT1/h65HsfzWyu5tF6NYNB4EYJzKUETqgcLNVv0D/cDQBrNAnm9+LOfTLfNB5u2hf5z+6TMexYji+tVdrM5leMbWOtSwQx/F1C2rcuebIqwSO568a4WmuN3mEYSiUi+pRl2l1pLvYBsKArUKVwnZRYgdHpMWVG4+/WXhwoDBXE7OmkHzJ6JNemLfv51bniGqzVPoIkyLbpfK7ZMFIkE6FlrMn7Ql+BbiHg+zXGbgLjylDpyosD58KZmKM0cfWHI9//aD5o1VCZrnO83VuQQOja5PMCfwK8n3K2ChIbLVOD9KB36le3A+u/s2Q81C2yRavQmQNdVnamLnmq4nHD9jpB0rwm77jpjTW9E906Bu18fWlWCQHAox9CtGoXTwmS8IThZyXPB+29inuoE6bMsDM9ufEAMNHqJuU8ljMtAKA2B7IhzaWNiLfWjVQb3J10/SGuEZZ7Af1X7+lluZ3HkpgEQPL291M+qbzJgXQcG60ypKlVTGwsMxcFaJW6/hDXVZZvCz3RlrmRiQHwy9nRn2bM6bnas4cLfH6s1RIorsJcFDA2PToR7Z7QezfQD9qzwvI6TyTZC47ttXeiT+2c1+wBgOndoTPLt7mrmCRjvfULQ4O1xsVVchu7b9GysYUAqy3lnsdNb0aXmQuj7PYWL2etuRl6S0OfXLjiGQIdEY6K5esc2BWhjvkqXLO6x08VPKxV6iYAwuBkv5NpvNmtbrhaX2+tWdY70eVNINhtLW0/sjrv6B0/YdJlcGlR2AvE4hUlKwHQ7BU5cz8LRx0HaPY7gXb53L/67+mUfudPmP/twOWS6AQi/j6B4iWS/IlYK+yGYJDB1wWLErLRKd/omOJbAWf03wEAyO9m+/TtS3AAAAAASUVORK5CYII=');\n  bottom: 10px;\n  left: 95px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-zoomIn {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABiBJREFUeNqkV2tQlOcVfp7zvgvDRe66y8htXUBR1GoFI+BtFJvRtjPJBGeaH2a8DGmbttgSTWbSJEw6TWOsrbbpTIeJZGqaTipTa6LJZDTVUTYQdNAohoso6qLucnERN0Axcb/8+HaJUHDX9Pz6vnnPe57vXJ5zzkeEIwaYcwBL/VrW0TCKqZANINEvBhSk3w9eUmC9HzjcsfarOhBGKJN84GkVJHcetvqFu4SAIYELYlpm4LpQQMqoQQKVnzeO7EYV/A8NnHMAGwHWQJmAjtg895LkFa7FU1d258UvGLBGpI4AQM9dd2TrwNn4016n9bS3LqNzsD1VKPAbfhCyqflR31thAzv+La+QxotCoNi6pn1D1s9aVli/3xtOVk72fjT1XVf17E9uHZspFBD8zdk13pdCAjsOyG6KUSEEnrT/tPHluW+cw7eQ19q2z6/t2rsYJEjZ07S6d+ukwI5/yQ7RxnYC2DZnx8dbHNs6xxs85T2R9GprZcmVwYs2BYWsmBzP83m7nIVJS73jdfdd+7PjjUu/XWUCGTtPre7ZHjxTY3Kq8DoV8Ou5u49snPGrKxN58syZ9aVXBztsigoUBd+Xt2NbfZ8llaVvah+vOz9hcX+CJenWp7eOOYS6ePpTU1w39vk+AwCzFPdDQbFGFPCUY2v9hqxfXJ0shNeHLtsUFc6UequbVvdVkwLX0GXbZPpl6Zuu/ij9x/VCBU1dU7bfdFYAIDsSFRCgeOqa9hfy/nDhwfwTKOrRd0U95n0iqch9+cKS5JVtpMCdkllhAhugCHcRwAb7z1tCEp8CCXAWAJRoCFXIYnti+sYWTQ0tll0wQMk+hGUAkBOX714xbV1IyuhxHhIMC/iR5OV9M2JmuhU1Vh7PXiakrIUQhcnLXeHQxPT4GyAtFqgwgAPF5iIFWkeu1SSLCKAweXn3/ZR5rXV7SddQpy3YDoNems9qTI5hGCitm1MOAAx0aaFCerTd84zjBed3Egq9ADA/rqD7Q3ctQC4REDmkYHb8goGgsR2tz5V0DV+xUdQoqAQ81RybU4IgFWgACgpaLLCIBUo0bv63y/aXy6+WBHWz4/IHSIGAuVooiaRgWqD3AsDVoQ6bEgtOrfJUhwrf0WUtk+r8sL6wvHvk5ijVUiJSRrQZuURtfoGMuaCoRyfP/yMy0XykgAA0DPRTxNp31x2ZFuUYBgB7bK7HNdhpKz6WXq6oQCooKghMKhkgji77vBoA1jkXlAvVfRQjFMUcmxSkRWd6gpjeu32R2kxTvyhKh1DQeud8fFBh26zfOe0xuR4JgAbzywCoRSzfeDUKatJKUQK+CjKiHZ6nZ2xzBnU7B9vixTy7qCHSQEhJU3+DtdT6mAcAFiWUeP/xyPH3Jwrfo3XzysemRcEA8F5RY8h6aPE1WwMLQ4OQ/EBANHmdGWHlzZyxk3ayB0m771yGooYy+KE0l35x0iBxZehS6ie9R1PCMaDvCzWDXA4hZ283ptwcvp6qqDBnyao6AWEQrBQQ/7y+d3YoA+NBTAaElo973p8tVFCQyipW+c3pdNu7BwBOe+tm/eniK/kPFWowpMfvuKrzzw80zSKIkWsJe0bHYu163BNwMwDsv7G36ODNtzMnM5IWZfeQgscbisvLPl1aDhLTo7I8k+n/p+dw5pGeg0WKGiS31K6vvTdmA7nx9uDZ9A3xMUIpbvSezE6MSOmbNWXewHhD6dH23o7BlqQvvrwTK6KQFpXl2WyvcE6LTB2eCPSdrurvmcUnO/cVfPD6pMteyfGs3QKpUFQoS9tU/xPH8xe+Tdd693pN/pHug0Xmqntvz1uLDo9Z9v5nnrn+dvujrI1JMUJd3OY7n97ua46douOGpkdlDoUDeG7g1NS/u/5a0Og9scCsB+ysWXSoMuyFftWJvM0E31SBjmWPznHPjy+8NjdhYfeMmJl3EiNSRgCi/25fpGu4M671zjlrm685s2fEnUoQ5lrLLW8uPLj3oX9hqgxIw8n8X1LU7yMkItCHzREZrGQV6ONmy5TggHk247sL/1jFqof/hRn/AWfqC0pI+QHBIk3tICXRrFTpF8hlJaqefh6yFxQ6HwQYlK8HAKyt3WsWxl7fAAAAAElFTkSuQmCC');\n  bottom: 10px;\n  right: 15px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-zoomOut {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABV5JREFUeNq0l2tQVVUYht/3W/vACMr16IFRQDiAgChpgiikMqY1WjnN9KsfGOXYTOVgkvbDUsZuXrK0qZmGUSvNspjI8TZOmo6AGBoZYly8YB6Qw80DBwQ6jJ3dj30OZZmiwvtv77XW96y91l7v9y1iMNLBuCI84tZkIXU9gwqxAILdokNBOtzgJQWWuYEDFxfcLAGh3y0k79iaD4mfjOVu4WYhoItngBiR6RkuFJAyEJBA3m/lri3Ih/uewXFFyAG4A8oAWkcm2meEzrFNH53Vkhg4xWnxCXcBQGu/3bfGeTbwjKPUcsZRElnfUxcuFLh1Nwh5vurx7s8GDbZ+L+tI/U0hkGGZX5c9/pXqOZYn2gazK8Vth0fvsRUknbx+bIJQQPCts/Mda+4KthbJFoqeKwSejX6pfO2kjytxH1pfuyqlsGH7dJAgZWvFo23L/9muboF+JxtE0/OEwMqJG46uSHinFvepTPO8lhGaX+fPHSdjCKaPy/b3v7az58h/wHFFyIHCRirgjUlbfsiJWXEFD6iUoOkdQaaQ6z9dP2YVahljF4+yXdvZ/evf4G+hQk2sEAUsti4vWxa35gKGSBMDp3T23OxxVXdXRijKovSFzrerC6ELAMT6IhcCZIyeX7c68YPzGGLlxq89PyM0q5YU2M1RuQAg0EERbiaA7Ohl1RgmPTM2p1qjBk1Mm6GDErsfswAgLiDZPmfMwrbhAqeHzm6P8Z9gV9SQdTx2lpCyAEKkhc62YZiVEjTdRgo0zXeBRnImAaSFzm7xdjjtOBGyvmZVZkNvfZjXDhU14+BToFEDKRAQpAJ0HRTjP6XHpYUKEX7RzS9bV5c+FJTmAICUgNSWQ/ZCgJwhIOJIQVLgFKcXvKHm9cyGvithFDUAFQqECho1CBUIggYapAJ1QEFBExNMYoISDU1/NIR9cvndTG/c2IBkp2fC8ZpQgknBGI/3AsDvvRfDlJhwem5zwYMs7VNlaUtbXE1h3mezj9mlGSsXrBkzkFsGKGoDmedBJLfLjxQQgAYdHRSxtPfbfceNsPYBQPTI+GZbT31YxrGIpYoKpIKigkAgFOggNBrbQBBCBaEM2L+iGGmTgnF+Uc1epqO/3VejAoAOUZSLQkFN17lAb4eVCe+VRvvHN4sH6t1feqAmMUGoPHvvhdLzTjzfKoj0sza/GLOy1Bu3vqc20Pgl5YIGkVOEZFZ0nLLMszzdDADTgjIdX6Uf3zfUx6m6u8riKRhOCcmDAqLCURo53Oe4rrsyUlGD0nlIqubdKNZJXOm9FH6y7Yh5uKBnO8vNTX2N4YoKE2fMLREQOsE8AfFN4/ak4QIfbd2XJFRQkLx85ruN7NTp2AoAZxwlCR9dWJc81NDdtoLkc86KBIJwXQ3aOpCPqwuhR2SPbCBlUc2NyogQX3N7wqgU51BAf2w9EFXUtCtLqADqS76ev6/ilgrk2q6esxHZgf5CySh3FMcG+5jbE0ZNdj4odHdDwWPGcZNNO1MPbrxtzdW4s+tI5HPBwQTTzziKY3v/7HGlhmS23g90T+OO5L1Nu7MMw3Fv/Tx1f97/FnsAYPui8/D4nBB/oZZR230uoq67auQoLaB37Iio3sEAK52nR39p+zS13HFiilHeYtOOabdC71jQzz2R+ALBbcrjWNF+cfaUwLSrk4KmtsT4T+gK9jG7AKKjv93X1lcfUNNVaantropqddnDCcIoa7lk29S92+/5CpOvQ04VJ79KUe/7iI/Hh40U6c3PyuPjhmWKN8G8Fvnw1A/zmX/vV5h/T+CXstRMUp4kOFOjZiUlWBkFQYdALitRZXRzf3RqWumdgF79NQDBOa2V/iYSHAAAAABJRU5ErkJggg==');\n  bottom: 10px;\n  right: 55px;\n}\ndiv.vis-network div.vis-navigation div.vis-button.vis-zoomExtends {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABptJREFUeNqsl21QlNcVx///cx9hIipuAJHasgHlRdw0xay7yK7smg6sb2DSdtqZduLUNENmOk1tQuM4U7UzTvshSRlFZzoNCWSSSTJp+6VNkLCAeQHBoCCgqNBE0wUqL+KuwIiiZZ9+eHa3aAS3Sf8zO8/L3nt+95x7z7n3YWlpKUQEJAEgch9+Jola9xEC2ADBVgAOKqwCYAqKDgUJBIHPBWwFWQNdbyZFBwAC0GGIAHQSj3/8HHRdhzYbdDfwg4IjAsGvICgXAroYBiCEDkBBACBZoyST4gDwQqh7mQ4cEkhQD0EBIIggRMQAh2EiEvEYAGrdR3YSqIYCIEDaotVDeYnu/ryEjSOr43PHl8WmTBPA6PRQ7IWJrvhT/ubkU/7m1EvX+1KEUh7Ug+WkPEXgdUSkR+xrd0NJ4qjr8AEI9pGAI7mo78mHfnF+Y/K2K7iHUheuvJG6cOUNz/LvDwPobrpSl/Ruf2VOy9UPs4RSTSANwH4Y449EVdnt9ojHIeghCHYLgR+n/7zt4Np32tIWZU4hSpnjVk1t/caPfOO3/f++MNH5TVJcisoEoo4ksgbsXwYfdR1+kQplQuCFNS82Pp/9+158RTkTC0ce0OKutQeOp5PME0qcUBqyBmwGOC8vz4AWVOyE4CUqYO/Dh+p3pj//Bb6mHllqCyxd8ODVT69+uFKoOYTSnzFg7SJpzHFNQYWiQrUIsCN9V+uOh375zz179pSGI1FSUuK12+2+aGDt7e3muro6T/h57969lZdvDrT+ZbA6n0B1nfPVN7e0PjMjIgIIdkEAR1JR329yDvaE0+l/hQKA1Wr1bd682SsikUW7K+O3PesTNvaSAiXaLhGBvO86RFEoJ4Adac+eDxsgiZKSEm9NTY3n5MmT5mjBHR0d5vr6es+mTZu8SqnI+x+s+Ol5jRo0auX1jtepQaEAADKWWIbcy7ZGUmb79u1eu93uI+mtra31HLj5TGDs9rBJICCNn1GRCKGCUJAUuzzw6CfbTB6Px7t27VofAG/YXl6Ceyw9LmvIN3UxZUafKRACWyCELcHVP3vk4fDabDZf+2N/D9g+fsLEEFSooFGDogZNFkBRgSCsTcWm066jgRAU4et/F5u9nxRosmCLRmE+QdgSXCNzhW/s9rDJ63wVJx77V+V8YS6UNaW8BdOcqzx+3Ujt0F8Bcr1GMIMU5CzJHZ+rg6IGCYV2PimoyIK6lzIWrxkPTVGmRoqJFCyLTZmeq4MB5f3BVADnbpcQkzStUQMAk0YKBPfzxlhA95NQQe43QBotBECAFFyZHo6dz6CKCizAPFPivzUWqxm2AqIgnwkFvZNn4uczGK3Hah7wpet98UZ85R8aKScIcXYEWpMLkx8fvleHpNjlAWtTsakQa0pVKGcJQqMGUqCHBvfdjp/gTP6xwFzg85PdyaH2J4SUowKiw3889e4KBACnT582W5uKTV2uusAdUFlgzBcFQoFGDT35HwW+82mhqaenxwwA4WtYfRNnUkMZUqsJpEkn8cXU5yktYw2JjsTCMQDwer0ekt6GhgZPUVGRd3fu7qjqdU9Mj7mlpcVD0tvS0uKxWCyVANB5rS3x8s3BFEUFgTTLtuZndQHLBMSfB6pyZtfqMDQ3NzfqTcJisficTqc3BI+8bxh9L8corarM3fnDoIT+rACAU/7m7MOfHbCEwQDQ2Njo6erqinqTOHfuXNjjiI23+ystZ8c7smmkWgVJcN++fRARfLDhlacEUqVEQ1nm77xPrHjSh/+Djo3WmN/s/6OHEOgIPr2h63tVuq5Dud1ukETWoK3zorkzTiiONn/TKlNM4lj24m+Pf13o2wOVHqGA5MsAXjKPrDaqnMvlQnjTzhy0Nlw0d5oI5p3yN62amrk+ve5B5+hXgb47WGX52+V3NgoFOvQKAGUkkTqcbZy5XC7XHYf4zEFr3aXU7jih5uidPPOtvsmzixZr8VMrHjBHddLsHj+Z9Fb/n9a1+T/JDaXey0IpEzEKkHnU8Jj79++PeEwSSimQRGP+Gz8j5DVFBVKQtjBj6JGlNt/D8Y+OpMdlTphiEqcB4tqtsVjfjUtLLkx0J/dOnjWPTg+lEARIEHwaQJVQIYggACC/qxi6rn8ZHL4XETSsf0MU1HOk/CFGYgAwskUqY5eBitRxzn7/a0V1EEBwdqkN6jPI7y4xPmHmC5unbWdQRMqP2d86qANOksU6gvmArNQRNClqABnQgYuK0krI+wCOAyH3DK/vqOXhaf3PAO7mIRjDNV25AAAAAElFTkSuQmCC');\n  bottom: 50px;\n  right: 15px;\n}\n";styleInject(css_248z$1);/**
 * Created by Alex on 11/6/2014.
 */function keycharm(options){var preventDefault=options&&options.preventDefault||false;var container=options&&options.container||window;var _exportFunctions={};var _bound={keydown:{},keyup:{}};var _keys={};var i;// a - z
for(i=97;i<=122;i++){_keys[String.fromCharCode(i)]={code:65+(i-97),shift:false};}// A - Z
for(i=65;i<=90;i++){_keys[String.fromCharCode(i)]={code:i,shift:true};}// 0 - 9
for(i=0;i<=9;i++){_keys[''+i]={code:48+i,shift:false};}// F1 - F12
for(i=1;i<=12;i++){_keys['F'+i]={code:111+i,shift:false};}// num0 - num9
for(i=0;i<=9;i++){_keys['num'+i]={code:96+i,shift:false};}// numpad misc
_keys['num*']={code:106,shift:false};_keys['num+']={code:107,shift:false};_keys['num-']={code:109,shift:false};_keys['num/']={code:111,shift:false};_keys['num.']={code:110,shift:false};// arrows
_keys['left']={code:37,shift:false};_keys['up']={code:38,shift:false};_keys['right']={code:39,shift:false};_keys['down']={code:40,shift:false};// extra keys
_keys['space']={code:32,shift:false};_keys['enter']={code:13,shift:false};_keys['shift']={code:16,shift:undefined};_keys['esc']={code:27,shift:false};_keys['backspace']={code:8,shift:false};_keys['tab']={code:9,shift:false};_keys['ctrl']={code:17,shift:false};_keys['alt']={code:18,shift:false};_keys['delete']={code:46,shift:false};_keys['pageup']={code:33,shift:false};_keys['pagedown']={code:34,shift:false};// symbols
_keys['=']={code:187,shift:false};_keys['-']={code:189,shift:false};_keys[']']={code:221,shift:false};_keys['[']={code:219,shift:false};var down=function(event){handleEvent(event,'keydown');};var up=function(event){handleEvent(event,'keyup');};// handle the actualy bound key with the event
var handleEvent=function(event,type){if(_bound[type][event.keyCode]!==undefined){var bound=_bound[type][event.keyCode];for(var i=0;i<bound.length;i++){if(bound[i].shift===undefined){bound[i].fn(event);}else if(bound[i].shift==true&&event.shiftKey==true){bound[i].fn(event);}else if(bound[i].shift==false&&event.shiftKey==false){bound[i].fn(event);}}if(preventDefault==true){event.preventDefault();}}};// bind a key to a callback
_exportFunctions.bind=function(key,callback,type){if(type===undefined){type='keydown';}if(_keys[key]===undefined){throw new Error("unsupported key: "+key);}if(_bound[type][_keys[key].code]===undefined){_bound[type][_keys[key].code]=[];}_bound[type][_keys[key].code].push({fn:callback,shift:_keys[key].shift});};// bind all keys to a call back (demo purposes)
_exportFunctions.bindAll=function(callback,type){if(type===undefined){type='keydown';}for(var key in _keys){if(_keys.hasOwnProperty(key)){_exportFunctions.bind(key,callback,type);}}};// get the key label from an event
_exportFunctions.getKey=function(event){for(var key in _keys){if(_keys.hasOwnProperty(key)){if(event.shiftKey==true&&_keys[key].shift==true&&event.keyCode==_keys[key].code){return key;}else if(event.shiftKey==false&&_keys[key].shift==false&&event.keyCode==_keys[key].code){return key;}else if(event.keyCode==_keys[key].code&&key=='shift'){return key;}}}return"unknown key, currently not supported";};// unbind either a specific callback from a key or all of them (by leaving callback undefined)
_exportFunctions.unbind=function(key,callback,type){if(type===undefined){type='keydown';}if(_keys[key]===undefined){throw new Error("unsupported key: "+key);}if(callback!==undefined){var newBindings=[];var bound=_bound[type][_keys[key].code];if(bound!==undefined){for(var i=0;i<bound.length;i++){if(!(bound[i].fn==callback&&bound[i].shift==_keys[key].shift)){newBindings.push(_bound[type][_keys[key].code][i]);}}}_bound[type][_keys[key].code]=newBindings;}else{_bound[type][_keys[key].code]=[];}};// reset all bound variables.
_exportFunctions.reset=function(){_bound={keydown:{},keyup:{}};};// unbind all listeners and reset all variables.
_exportFunctions.destroy=function(){_bound={keydown:{},keyup:{}};container.removeEventListener('keydown',down,true);container.removeEventListener('keyup',up,true);};// create listeners.
container.addEventListener('keydown',down,true);container.addEventListener('keyup',up,true);// return the public functions.
return _exportFunctions;}/**
 * Navigation Handler
 */var NavigationHandler=/*#__PURE__*/function(){/**
   * @param {object} body
   * @param {Canvas} canvas
   */function NavigationHandler(body,canvas){var _this=this;_classCallCheck(this,NavigationHandler);this.body=body;this.canvas=canvas;this.iconsCreated=false;this.navigationHammers=[];this.boundFunctions={};this.touchTime=0;this.activated=false;this.body.emitter.on("activate",function(){_this.activated=true;_this.configureKeyboardBindings();});this.body.emitter.on("deactivate",function(){_this.activated=false;_this.configureKeyboardBindings();});this.body.emitter.on("destroy",function(){if(_this.keycharm!==undefined){_this.keycharm.destroy();}});this.options={};}/**
   *
   * @param {object} options
   */_createClass(NavigationHandler,[{key:"setOptions",value:function setOptions(options){if(options!==undefined){this.options=options;this.create();}}/**
     * Creates or refreshes navigation and sets key bindings
     */},{key:"create",value:function create(){if(this.options.navigationButtons===true){if(this.iconsCreated===false){this.loadNavigationElements();}}else if(this.iconsCreated===true){this.cleanNavigation();}this.configureKeyboardBindings();}/**
     * Cleans up previous navigation items
     */},{key:"cleanNavigation",value:function cleanNavigation(){// clean hammer bindings
if(this.navigationHammers.length!=0){for(var i=0;i<this.navigationHammers.length;i++){this.navigationHammers[i].destroy();}this.navigationHammers=[];}// clean up previous navigation items
if(this.navigationDOM&&this.navigationDOM["wrapper"]&&this.navigationDOM["wrapper"].parentNode){this.navigationDOM["wrapper"].parentNode.removeChild(this.navigationDOM["wrapper"]);}this.iconsCreated=false;}/**
     * Creation of the navigation controls nodes. They are drawn over the rest of the nodes and are not affected by scale and translation
     * they have a triggerFunction which is called on click. If the position of the navigation controls is dependent
     * on this.frame.canvas.clientWidth or this.frame.canvas.clientHeight, we flag horizontalAlignLeft and verticalAlignTop false.
     * This means that the location will be corrected by the _relocateNavigation function on a size change of the canvas.
     *
     * @private
     */},{key:"loadNavigationElements",value:function loadNavigationElements(){var _this2=this;this.cleanNavigation();this.navigationDOM={};var navigationDivs=["up","down","left","right","zoomIn","zoomOut","zoomExtends"];var navigationDivActions=["_moveUp","_moveDown","_moveLeft","_moveRight","_zoomIn","_zoomOut","_fit"];this.navigationDOM["wrapper"]=document.createElement("div");this.navigationDOM["wrapper"].className="vis-navigation";this.canvas.frame.appendChild(this.navigationDOM["wrapper"]);for(var i=0;i<navigationDivs.length;i++){this.navigationDOM[navigationDivs[i]]=document.createElement("div");this.navigationDOM[navigationDivs[i]].className="vis-button vis-"+navigationDivs[i];this.navigationDOM["wrapper"].appendChild(this.navigationDOM[navigationDivs[i]]);var hammer=new Hammer$1(this.navigationDOM[navigationDivs[i]]);if(navigationDivActions[i]==="_fit"){var _context;onTouch(hammer,bind(_context=this._fit).call(_context,this));}else{var _context2;onTouch(hammer,bind(_context2=this.bindToRedraw).call(_context2,this,navigationDivActions[i]));}this.navigationHammers.push(hammer);}// use a hammer for the release so we do not require the one used in the rest of the network
// the one the rest uses can be overloaded by the manipulation system.
var hammerFrame=new Hammer$1(this.canvas.frame);onRelease(hammerFrame,function(){_this2._stopMovement();});this.navigationHammers.push(hammerFrame);this.iconsCreated=true;}/**
     *
     * @param {string} action
     */},{key:"bindToRedraw",value:function bindToRedraw(action){if(this.boundFunctions[action]===undefined){var _context3;this.boundFunctions[action]=bind(_context3=this[action]).call(_context3,this);this.body.emitter.on("initRedraw",this.boundFunctions[action]);this.body.emitter.emit("_startRendering");}}/**
     *
     * @param {string} action
     */},{key:"unbindFromRedraw",value:function unbindFromRedraw(action){if(this.boundFunctions[action]!==undefined){this.body.emitter.off("initRedraw",this.boundFunctions[action]);this.body.emitter.emit("_stopRendering");delete this.boundFunctions[action];}}/**
     * this stops all movement induced by the navigation buttons
     *
     * @private
     */},{key:"_fit",value:function _fit(){if(new Date().valueOf()-this.touchTime>700){// TODO: fix ugly hack to avoid hammer's double fireing of event (because we use release?)
this.body.emitter.emit("fit",{duration:700});this.touchTime=new Date().valueOf();}}/**
     * this stops all movement induced by the navigation buttons
     *
     * @private
     */},{key:"_stopMovement",value:function _stopMovement(){for(var boundAction in this.boundFunctions){if(Object.prototype.hasOwnProperty.call(this.boundFunctions,boundAction)){this.body.emitter.off("initRedraw",this.boundFunctions[boundAction]);this.body.emitter.emit("_stopRendering");}}this.boundFunctions={};}/**
     *
     * @private
     */},{key:"_moveUp",value:function _moveUp(){this.body.view.translation.y+=this.options.keyboard.speed.y;}/**
     *
     * @private
     */},{key:"_moveDown",value:function _moveDown(){this.body.view.translation.y-=this.options.keyboard.speed.y;}/**
     *
     * @private
     */},{key:"_moveLeft",value:function _moveLeft(){this.body.view.translation.x+=this.options.keyboard.speed.x;}/**
     *
     * @private
     */},{key:"_moveRight",value:function _moveRight(){this.body.view.translation.x-=this.options.keyboard.speed.x;}/**
     *
     * @private
     */},{key:"_zoomIn",value:function _zoomIn(){var scaleOld=this.body.view.scale;var scale=this.body.view.scale*(1+this.options.keyboard.speed.zoom);var translation=this.body.view.translation;var scaleFrac=scale/scaleOld;var tx=(1-scaleFrac)*this.canvas.canvasViewCenter.x+translation.x*scaleFrac;var ty=(1-scaleFrac)*this.canvas.canvasViewCenter.y+translation.y*scaleFrac;this.body.view.scale=scale;this.body.view.translation={x:tx,y:ty};this.body.emitter.emit("zoom",{direction:"+",scale:this.body.view.scale,pointer:null});}/**
     *
     * @private
     */},{key:"_zoomOut",value:function _zoomOut(){var scaleOld=this.body.view.scale;var scale=this.body.view.scale/(1+this.options.keyboard.speed.zoom);var translation=this.body.view.translation;var scaleFrac=scale/scaleOld;var tx=(1-scaleFrac)*this.canvas.canvasViewCenter.x+translation.x*scaleFrac;var ty=(1-scaleFrac)*this.canvas.canvasViewCenter.y+translation.y*scaleFrac;this.body.view.scale=scale;this.body.view.translation={x:tx,y:ty};this.body.emitter.emit("zoom",{direction:"-",scale:this.body.view.scale,pointer:null});}/**
     * bind all keys using keycharm.
     */},{key:"configureKeyboardBindings",value:function configureKeyboardBindings(){var _this3=this;if(this.keycharm!==undefined){this.keycharm.destroy();}if(this.options.keyboard.enabled===true){if(this.options.keyboard.bindToWindow===true){this.keycharm=keycharm({container:window,preventDefault:true});}else{this.keycharm=keycharm({container:this.canvas.frame,preventDefault:true});}this.keycharm.reset();if(this.activated===true){var _context4,_context5,_context6,_context7,_context8,_context9,_context10,_context11,_context12,_context13,_context14,_context15,_context16,_context17,_context18,_context19,_context20,_context21,_context22,_context23,_context24,_context25,_context26,_context27;bind(_context4=this.keycharm).call(_context4,"up",function(){_this3.bindToRedraw("_moveUp");},"keydown");bind(_context5=this.keycharm).call(_context5,"down",function(){_this3.bindToRedraw("_moveDown");},"keydown");bind(_context6=this.keycharm).call(_context6,"left",function(){_this3.bindToRedraw("_moveLeft");},"keydown");bind(_context7=this.keycharm).call(_context7,"right",function(){_this3.bindToRedraw("_moveRight");},"keydown");bind(_context8=this.keycharm).call(_context8,"=",function(){_this3.bindToRedraw("_zoomIn");},"keydown");bind(_context9=this.keycharm).call(_context9,"num+",function(){_this3.bindToRedraw("_zoomIn");},"keydown");bind(_context10=this.keycharm).call(_context10,"num-",function(){_this3.bindToRedraw("_zoomOut");},"keydown");bind(_context11=this.keycharm).call(_context11,"-",function(){_this3.bindToRedraw("_zoomOut");},"keydown");bind(_context12=this.keycharm).call(_context12,"[",function(){_this3.bindToRedraw("_zoomOut");},"keydown");bind(_context13=this.keycharm).call(_context13,"]",function(){_this3.bindToRedraw("_zoomIn");},"keydown");bind(_context14=this.keycharm).call(_context14,"pageup",function(){_this3.bindToRedraw("_zoomIn");},"keydown");bind(_context15=this.keycharm).call(_context15,"pagedown",function(){_this3.bindToRedraw("_zoomOut");},"keydown");bind(_context16=this.keycharm).call(_context16,"up",function(){_this3.unbindFromRedraw("_moveUp");},"keyup");bind(_context17=this.keycharm).call(_context17,"down",function(){_this3.unbindFromRedraw("_moveDown");},"keyup");bind(_context18=this.keycharm).call(_context18,"left",function(){_this3.unbindFromRedraw("_moveLeft");},"keyup");bind(_context19=this.keycharm).call(_context19,"right",function(){_this3.unbindFromRedraw("_moveRight");},"keyup");bind(_context20=this.keycharm).call(_context20,"=",function(){_this3.unbindFromRedraw("_zoomIn");},"keyup");bind(_context21=this.keycharm).call(_context21,"num+",function(){_this3.unbindFromRedraw("_zoomIn");},"keyup");bind(_context22=this.keycharm).call(_context22,"num-",function(){_this3.unbindFromRedraw("_zoomOut");},"keyup");bind(_context23=this.keycharm).call(_context23,"-",function(){_this3.unbindFromRedraw("_zoomOut");},"keyup");bind(_context24=this.keycharm).call(_context24,"[",function(){_this3.unbindFromRedraw("_zoomOut");},"keyup");bind(_context25=this.keycharm).call(_context25,"]",function(){_this3.unbindFromRedraw("_zoomIn");},"keyup");bind(_context26=this.keycharm).call(_context26,"pageup",function(){_this3.unbindFromRedraw("_zoomIn");},"keyup");bind(_context27=this.keycharm).call(_context27,"pagedown",function(){_this3.unbindFromRedraw("_zoomOut");},"keyup");}}}}]);return NavigationHandler;}();function _createForOfIteratorHelper$4(o,allowArrayLike){var it=typeof symbol!=="undefined"&&getIteratorMethod(o)||o["@@iterator"];if(!it){if(isArray(o)||(it=_unsupportedIterableToArray$4(o))||allowArrayLike&&o&&typeof o.length==="number"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};},e:function e(_e){throw _e;},f:F};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion=true,didErr=false,err;return{s:function s(){it=it.call(o);},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e2){didErr=true;err=_e2;},f:function f(){try{if(!normalCompletion&&it.return!=null)it.return();}finally{if(didErr)throw err;}}};}function _unsupportedIterableToArray$4(o,minLen){var _context15;if(!o)return;if(typeof o==="string")return _arrayLikeToArray$4(o,minLen);var n=slice$1(_context15=Object.prototype.toString.call(o)).call(_context15,8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return from$2(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray$4(o,minLen);}function _arrayLikeToArray$4(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}/**
 * Handler for interactions
 */var InteractionHandler=/*#__PURE__*/function(){/**
   * @param {object} body
   * @param {Canvas} canvas
   * @param {SelectionHandler} selectionHandler
   */function InteractionHandler(body,canvas,selectionHandler){var _context,_context2,_context3,_context4,_context5,_context6,_context7,_context8,_context9,_context10,_context11,_context12,_context13;_classCallCheck(this,InteractionHandler);this.body=body;this.canvas=canvas;this.selectionHandler=selectionHandler;this.navigationHandler=new NavigationHandler(body,canvas);// bind the events from hammer to functions in this object
this.body.eventListeners.onTap=bind(_context=this.onTap).call(_context,this);this.body.eventListeners.onTouch=bind(_context2=this.onTouch).call(_context2,this);this.body.eventListeners.onDoubleTap=bind(_context3=this.onDoubleTap).call(_context3,this);this.body.eventListeners.onHold=bind(_context4=this.onHold).call(_context4,this);this.body.eventListeners.onDragStart=bind(_context5=this.onDragStart).call(_context5,this);this.body.eventListeners.onDrag=bind(_context6=this.onDrag).call(_context6,this);this.body.eventListeners.onDragEnd=bind(_context7=this.onDragEnd).call(_context7,this);this.body.eventListeners.onMouseWheel=bind(_context8=this.onMouseWheel).call(_context8,this);this.body.eventListeners.onPinch=bind(_context9=this.onPinch).call(_context9,this);this.body.eventListeners.onMouseMove=bind(_context10=this.onMouseMove).call(_context10,this);this.body.eventListeners.onRelease=bind(_context11=this.onRelease).call(_context11,this);this.body.eventListeners.onContext=bind(_context12=this.onContext).call(_context12,this);this.touchTime=0;this.drag={};this.pinch={};this.popup=undefined;this.popupObj=undefined;this.popupTimer=undefined;this.body.functions.getPointer=bind(_context13=this.getPointer).call(_context13,this);this.options={};this.defaultOptions={dragNodes:true,dragView:true,hover:false,keyboard:{enabled:false,speed:{x:10,y:10,zoom:0.02},bindToWindow:true},navigationButtons:false,tooltipDelay:300,zoomView:true,zoomSpeed:1};assign$2(this.options,this.defaultOptions);this.bindEventListeners();}/**
   * Binds event listeners
   */_createClass(InteractionHandler,[{key:"bindEventListeners",value:function bindEventListeners(){var _this=this;this.body.emitter.on("destroy",function(){clearTimeout(_this.popupTimer);delete _this.body.functions.getPointer;});}/**
     *
     * @param {object} options
     */},{key:"setOptions",value:function setOptions(options){if(options!==undefined){// extend all but the values in fields
var fields=["hideEdgesOnDrag","hideEdgesOnZoom","hideNodesOnDrag","keyboard","multiselect","selectable","selectConnectedEdges"];selectiveNotDeepExtend(fields,this.options,options);// merge the keyboard options in.
mergeOptions(this.options,options,"keyboard");if(options.tooltip){assign$2(this.options.tooltip,options.tooltip);if(options.tooltip.color){this.options.tooltip.color=parseColor(options.tooltip.color);}}}this.navigationHandler.setOptions(this.options);}/**
     * Get the pointer location from a touch location
     *
     * @param {{x: number, y: number}} touch
     * @returns {{x: number, y: number}} pointer
     * @private
     */},{key:"getPointer",value:function getPointer(touch){return{x:touch.x-getAbsoluteLeft(this.canvas.frame.canvas),y:touch.y-getAbsoluteTop(this.canvas.frame.canvas)};}/**
     * On start of a touch gesture, store the pointer
     *
     * @param {Event}  event   The event
     * @private
     */},{key:"onTouch",value:function onTouch(event){if(new Date().valueOf()-this.touchTime>50){this.drag.pointer=this.getPointer(event.center);this.drag.pinched=false;this.pinch.scale=this.body.view.scale;// to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)
this.touchTime=new Date().valueOf();}}/**
     * handle tap/click event: select/unselect a node
     *
     * @param {Event} event
     * @private
     */},{key:"onTap",value:function onTap(event){var pointer=this.getPointer(event.center);var multiselect=this.selectionHandler.options.multiselect&&(event.changedPointers[0].ctrlKey||event.changedPointers[0].metaKey);this.checkSelectionChanges(pointer,multiselect);this.selectionHandler.commitAndEmit(pointer,event);this.selectionHandler.generateClickEvent("click",event,pointer);}/**
     * handle doubletap event
     *
     * @param {Event} event
     * @private
     */},{key:"onDoubleTap",value:function onDoubleTap(event){var pointer=this.getPointer(event.center);this.selectionHandler.generateClickEvent("doubleClick",event,pointer);}/**
     * handle long tap event: multi select nodes
     *
     * @param {Event} event
     * @private
     */},{key:"onHold",value:function onHold(event){var pointer=this.getPointer(event.center);var multiselect=this.selectionHandler.options.multiselect;this.checkSelectionChanges(pointer,multiselect);this.selectionHandler.commitAndEmit(pointer,event);this.selectionHandler.generateClickEvent("click",event,pointer);this.selectionHandler.generateClickEvent("hold",event,pointer);}/**
     * handle the release of the screen
     *
     * @param {Event} event
     * @private
     */},{key:"onRelease",value:function onRelease(event){if(new Date().valueOf()-this.touchTime>10){var pointer=this.getPointer(event.center);this.selectionHandler.generateClickEvent("release",event,pointer);// to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)
this.touchTime=new Date().valueOf();}}/**
     *
     * @param {Event} event
     */},{key:"onContext",value:function onContext(event){var pointer=this.getPointer({x:event.clientX,y:event.clientY});this.selectionHandler.generateClickEvent("oncontext",event,pointer);}/**
     * Select and deselect nodes depending current selection change.
     *
     * @param {{x: number, y: number}} pointer
     * @param {boolean} [add=false]
     */},{key:"checkSelectionChanges",value:function checkSelectionChanges(pointer){var add=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;if(add===true){this.selectionHandler.selectAdditionalOnPoint(pointer);}else{this.selectionHandler.selectOnPoint(pointer);}}/**
     * Remove all node and edge id's from the first set that are present in the second one.
     *
     * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} firstSet
     * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} secondSet
     * @returns {{nodes: Array.<Node>, edges: Array.<vis.Edge>}}
     * @private
     */},{key:"_determineDifference",value:function _determineDifference(firstSet,secondSet){var arrayDiff=function arrayDiff(firstArr,secondArr){var result=[];for(var i=0;i<firstArr.length;i++){var value=firstArr[i];if(indexOf(secondArr).call(secondArr,value)===-1){result.push(value);}}return result;};return{nodes:arrayDiff(firstSet.nodes,secondSet.nodes),edges:arrayDiff(firstSet.edges,secondSet.edges)};}/**
     * This function is called by onDragStart.
     * It is separated out because we can then overload it for the datamanipulation system.
     *
     * @param {Event} event
     * @private
     */},{key:"onDragStart",value:function onDragStart(event){// if already dragging, do not start
// this can happen on touch screens with multiple fingers
if(this.drag.dragging){return;}//in case the touch event was triggered on an external div, do the initial touch now.
if(this.drag.pointer===undefined){this.onTouch(event);}// note: drag.pointer is set in onTouch to get the initial touch location
var node=this.selectionHandler.getNodeAt(this.drag.pointer);this.drag.dragging=true;this.drag.selection=[];this.drag.translation=assign$2({},this.body.view.translation);// copy the object
this.drag.nodeId=undefined;if(event.srcEvent.shiftKey){this.body.selectionBox.show=true;var pointer=this.getPointer(event.center);this.body.selectionBox.position.start={x:this.canvas._XconvertDOMtoCanvas(pointer.x),y:this.canvas._YconvertDOMtoCanvas(pointer.y)};this.body.selectionBox.position.end={x:this.canvas._XconvertDOMtoCanvas(pointer.x),y:this.canvas._YconvertDOMtoCanvas(pointer.y)};}if(node!==undefined&&this.options.dragNodes===true){this.drag.nodeId=node.id;// select the clicked node if not yet selected
if(node.isSelected()===false){this.selectionHandler.unselectAll();this.selectionHandler.selectObject(node);}// after select to contain the node
this.selectionHandler.generateClickEvent("dragStart",event,this.drag.pointer);// create an array with the selected nodes and their original location and status
var _iterator=_createForOfIteratorHelper$4(this.selectionHandler.getSelectedNodes()),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var _node=_step.value;var s={id:_node.id,node:_node,// store original x, y, xFixed and yFixed, make the node temporarily Fixed
x:_node.x,y:_node.y,xFixed:_node.options.fixed.x,yFixed:_node.options.fixed.y};_node.options.fixed.x=true;_node.options.fixed.y=true;this.drag.selection.push(s);}}catch(err){_iterator.e(err);}finally{_iterator.f();}}else{// fallback if no node is selected and thus the view is dragged.
this.selectionHandler.generateClickEvent("dragStart",event,this.drag.pointer,undefined,true);}}/**
     * handle drag event
     *
     * @param {Event} event
     * @private
     */},{key:"onDrag",value:function onDrag(event){var _this2=this;if(this.drag.pinched===true){return;}// remove the focus on node if it is focussed on by the focusOnNode
this.body.emitter.emit("unlockNode");var pointer=this.getPointer(event.center);var selection=this.drag.selection;if(selection&&selection.length&&this.options.dragNodes===true){this.selectionHandler.generateClickEvent("dragging",event,pointer);// calculate delta's and new location
var deltaX=pointer.x-this.drag.pointer.x;var deltaY=pointer.y-this.drag.pointer.y;// update position of all selected nodes
forEach$2(selection).call(selection,function(selection){var node=selection.node;// only move the node if it was not fixed initially
if(selection.xFixed===false){node.x=_this2.canvas._XconvertDOMtoCanvas(_this2.canvas._XconvertCanvasToDOM(selection.x)+deltaX);}// only move the node if it was not fixed initially
if(selection.yFixed===false){node.y=_this2.canvas._YconvertDOMtoCanvas(_this2.canvas._YconvertCanvasToDOM(selection.y)+deltaY);}});// start the simulation of the physics
this.body.emitter.emit("startSimulation");}else{// create selection box
if(event.srcEvent.shiftKey){this.selectionHandler.generateClickEvent("dragging",event,pointer,undefined,true);// if the drag was not started properly because the click started outside the network div, start it now.
if(this.drag.pointer===undefined){this.onDragStart(event);return;}this.body.selectionBox.position.end={x:this.canvas._XconvertDOMtoCanvas(pointer.x),y:this.canvas._YconvertDOMtoCanvas(pointer.y)};this.body.emitter.emit("_requestRedraw");}// move the network
if(this.options.dragView===true&&!event.srcEvent.shiftKey){this.selectionHandler.generateClickEvent("dragging",event,pointer,undefined,true);// if the drag was not started properly because the click started outside the network div, start it now.
if(this.drag.pointer===undefined){this.onDragStart(event);return;}var diffX=pointer.x-this.drag.pointer.x;var diffY=pointer.y-this.drag.pointer.y;this.body.view.translation={x:this.drag.translation.x+diffX,y:this.drag.translation.y+diffY};this.body.emitter.emit("_requestRedraw");}}}/**
     * handle drag start event
     *
     * @param {Event} event
     * @private
     */},{key:"onDragEnd",value:function onDragEnd(event){var _this3=this;this.drag.dragging=false;if(this.body.selectionBox.show){var _context14;this.body.selectionBox.show=false;var selectionBoxPosition=this.body.selectionBox.position;var selectionBoxPositionMinMax={minX:Math.min(selectionBoxPosition.start.x,selectionBoxPosition.end.x),minY:Math.min(selectionBoxPosition.start.y,selectionBoxPosition.end.y),maxX:Math.max(selectionBoxPosition.start.x,selectionBoxPosition.end.x),maxY:Math.max(selectionBoxPosition.start.y,selectionBoxPosition.end.y)};var toBeSelectedNodes=filter(_context14=this.body.nodeIndices).call(_context14,function(nodeId){var node=_this3.body.nodes[nodeId];return node.x>=selectionBoxPositionMinMax.minX&&node.x<=selectionBoxPositionMinMax.maxX&&node.y>=selectionBoxPositionMinMax.minY&&node.y<=selectionBoxPositionMinMax.maxY;});forEach$2(toBeSelectedNodes).call(toBeSelectedNodes,function(nodeId){return _this3.selectionHandler.selectObject(_this3.body.nodes[nodeId]);});var pointer=this.getPointer(event.center);this.selectionHandler.commitAndEmit(pointer,event);this.selectionHandler.generateClickEvent("dragEnd",event,this.getPointer(event.center),undefined,true);this.body.emitter.emit("_requestRedraw");}else{var selection=this.drag.selection;if(selection&&selection.length){forEach$2(selection).call(selection,function(s){// restore original xFixed and yFixed
s.node.options.fixed.x=s.xFixed;s.node.options.fixed.y=s.yFixed;});this.selectionHandler.generateClickEvent("dragEnd",event,this.getPointer(event.center));this.body.emitter.emit("startSimulation");}else{this.selectionHandler.generateClickEvent("dragEnd",event,this.getPointer(event.center),undefined,true);this.body.emitter.emit("_requestRedraw");}}}/**
     * Handle pinch event
     *
     * @param {Event}  event   The event
     * @private
     */},{key:"onPinch",value:function onPinch(event){var pointer=this.getPointer(event.center);this.drag.pinched=true;if(this.pinch["scale"]===undefined){this.pinch.scale=1;}// TODO: enabled moving while pinching?
var scale=this.pinch.scale*event.scale;this.zoom(scale,pointer);}/**
     * Zoom the network in or out
     *
     * @param {number} scale a number around 1, and between 0.01 and 10
     * @param {{x: number, y: number}} pointer    Position on screen
     * @private
     */},{key:"zoom",value:function zoom(scale,pointer){if(this.options.zoomView===true){var scaleOld=this.body.view.scale;if(scale<0.00001){scale=0.00001;}if(scale>10){scale=10;}var preScaleDragPointer=undefined;if(this.drag!==undefined){if(this.drag.dragging===true){preScaleDragPointer=this.canvas.DOMtoCanvas(this.drag.pointer);}}// + this.canvas.frame.canvas.clientHeight / 2
var translation=this.body.view.translation;var scaleFrac=scale/scaleOld;var tx=(1-scaleFrac)*pointer.x+translation.x*scaleFrac;var ty=(1-scaleFrac)*pointer.y+translation.y*scaleFrac;this.body.view.scale=scale;this.body.view.translation={x:tx,y:ty};if(preScaleDragPointer!=undefined){var postScaleDragPointer=this.canvas.canvasToDOM(preScaleDragPointer);this.drag.pointer.x=postScaleDragPointer.x;this.drag.pointer.y=postScaleDragPointer.y;}this.body.emitter.emit("_requestRedraw");if(scaleOld<scale){this.body.emitter.emit("zoom",{direction:"+",scale:this.body.view.scale,pointer:pointer});}else{this.body.emitter.emit("zoom",{direction:"-",scale:this.body.view.scale,pointer:pointer});}}}/**
     * Event handler for mouse wheel event, used to zoom the timeline
     * See http://adomas.org/javascript-mouse-wheel/
     *     https://github.com/EightMedia/hammer.js/issues/256
     *
     * @param {MouseEvent}  event
     * @private
     */},{key:"onMouseWheel",value:function onMouseWheel(event){if(this.options.zoomView===true){// If delta is nonzero, handle it.
// Basically, delta is now positive if wheel was scrolled up,
// and negative, if wheel was scrolled down.
if(event.deltaY!==0){// calculate the new scale
var scale=this.body.view.scale;scale*=1+(event.deltaY<0?1:-1)*(this.options.zoomSpeed*0.1);// calculate the pointer location
var pointer=this.getPointer({x:event.clientX,y:event.clientY});// apply the new scale
this.zoom(scale,pointer);}// Prevent default actions caused by mouse wheel.
event.preventDefault();}}/**
     * Mouse move handler for checking whether the title moves over a node with a title.
     *
     * @param  {Event} event
     * @private
     */},{key:"onMouseMove",value:function onMouseMove(event){var _this4=this;var pointer=this.getPointer({x:event.clientX,y:event.clientY});var popupVisible=false;// check if the previously selected node is still selected
if(this.popup!==undefined){if(this.popup.hidden===false){this._checkHidePopup(pointer);}// if the popup was not hidden above
if(this.popup.hidden===false){popupVisible=true;this.popup.setPosition(pointer.x+3,pointer.y-5);this.popup.show();}}// if we bind the keyboard to the div, we have to highlight it to use it. This highlights it on mouse over.
if(this.options.keyboard.bindToWindow===false&&this.options.keyboard.enabled===true){this.canvas.frame.focus();}// start a timeout that will check if the mouse is positioned above an element
if(popupVisible===false){if(this.popupTimer!==undefined){clearInterval(this.popupTimer);// stop any running calculationTimer
this.popupTimer=undefined;}if(!this.drag.dragging){this.popupTimer=setTimeout$1(function(){return _this4._checkShowPopup(pointer);},this.options.tooltipDelay);}}// adding hover highlights
if(this.options.hover===true){this.selectionHandler.hoverObject(event,pointer);}}/**
     * Check if there is an element on the given position in the network
     * (a node or edge). If so, and if this element has a title,
     * show a popup window with its title.
     *
     * @param {{x:number, y:number}} pointer
     * @private
     */},{key:"_checkShowPopup",value:function _checkShowPopup(pointer){var x=this.canvas._XconvertDOMtoCanvas(pointer.x);var y=this.canvas._YconvertDOMtoCanvas(pointer.y);var pointerObj={left:x,top:y,right:x,bottom:y};var previousPopupObjId=this.popupObj===undefined?undefined:this.popupObj.id;var nodeUnderCursor=false;var popupType="node";// check if a node is under the cursor.
if(this.popupObj===undefined){// search the nodes for overlap, select the top one in case of multiple nodes
var nodeIndices=this.body.nodeIndices;var nodes=this.body.nodes;var node;var overlappingNodes=[];for(var i=0;i<nodeIndices.length;i++){node=nodes[nodeIndices[i]];if(node.isOverlappingWith(pointerObj)===true){nodeUnderCursor=true;if(node.getTitle()!==undefined){overlappingNodes.push(nodeIndices[i]);}}}if(overlappingNodes.length>0){// if there are overlapping nodes, select the last one, this is the one which is drawn on top of the others
this.popupObj=nodes[overlappingNodes[overlappingNodes.length-1]];// if you hover over a node, the title of the edge is not supposed to be shown.
nodeUnderCursor=true;}}if(this.popupObj===undefined&&nodeUnderCursor===false){// search the edges for overlap
var edgeIndices=this.body.edgeIndices;var edges=this.body.edges;var edge;var overlappingEdges=[];for(var _i=0;_i<edgeIndices.length;_i++){edge=edges[edgeIndices[_i]];if(edge.isOverlappingWith(pointerObj)===true){if(edge.connected===true&&edge.getTitle()!==undefined){overlappingEdges.push(edgeIndices[_i]);}}}if(overlappingEdges.length>0){this.popupObj=edges[overlappingEdges[overlappingEdges.length-1]];popupType="edge";}}if(this.popupObj!==undefined){// show popup message window
if(this.popupObj.id!==previousPopupObjId){if(this.popup===undefined){this.popup=new Popup$1(this.canvas.frame);}this.popup.popupTargetType=popupType;this.popup.popupTargetId=this.popupObj.id;// adjust a small offset such that the mouse cursor is located in the
// bottom left location of the popup, and you can easily move over the
// popup area
this.popup.setPosition(pointer.x+3,pointer.y-5);this.popup.setText(this.popupObj.getTitle());this.popup.show();this.body.emitter.emit("showPopup",this.popupObj.id);}}else{if(this.popup!==undefined){this.popup.hide();this.body.emitter.emit("hidePopup");}}}/**
     * Check if the popup must be hidden, which is the case when the mouse is no
     * longer hovering on the object
     *
     * @param {{x:number, y:number}} pointer
     * @private
     */},{key:"_checkHidePopup",value:function _checkHidePopup(pointer){var pointerObj=this.selectionHandler._pointerToPositionObject(pointer);var stillOnObj=false;if(this.popup.popupTargetType==="node"){if(this.body.nodes[this.popup.popupTargetId]!==undefined){stillOnObj=this.body.nodes[this.popup.popupTargetId].isOverlappingWith(pointerObj);// if the mouse is still one the node, we have to check if it is not also on one that is drawn on top of it.
// we initially only check stillOnObj because this is much faster.
if(stillOnObj===true){var overNode=this.selectionHandler.getNodeAt(pointer);stillOnObj=overNode===undefined?false:overNode.id===this.popup.popupTargetId;}}}else{if(this.selectionHandler.getNodeAt(pointer)===undefined){if(this.body.edges[this.popup.popupTargetId]!==undefined){stillOnObj=this.body.edges[this.popup.popupTargetId].isOverlappingWith(pointerObj);}}}if(stillOnObj===false){this.popupObj=undefined;this.popup.hide();this.body.emitter.emit("hidePopup");}}}]);return InteractionHandler;}();var getWeakData=internalMetadata.getWeakData;var setInternalState=internalState.set;var internalStateGetterFor=internalState.getterFor;var find=arrayIteration.find;var findIndex=arrayIteration.findIndex;var id=0;// fallback for uncaught frozen keys
var uncaughtFrozenStore=function(store){return store.frozen||(store.frozen=new UncaughtFrozenStore());};var UncaughtFrozenStore=function(){this.entries=[];};var findUncaughtFrozen=function(store,key){return find(store.entries,function(it){return it[0]===key;});};UncaughtFrozenStore.prototype={get:function(key){var entry=findUncaughtFrozen(this,key);if(entry)return entry[1];},has:function(key){return!!findUncaughtFrozen(this,key);},set:function(key,value){var entry=findUncaughtFrozen(this,key);if(entry)entry[1]=value;else this.entries.push([key,value]);},'delete':function(key){var index=findIndex(this.entries,function(it){return it[0]===key;});if(~index)this.entries.splice(index,1);return!!~index;}};var collectionWeak={getConstructor:function(wrapper,CONSTRUCTOR_NAME,IS_MAP,ADDER){var C=wrapper(function(that,iterable){anInstance(that,C,CONSTRUCTOR_NAME);setInternalState(that,{type:CONSTRUCTOR_NAME,id:id++,frozen:undefined});if(iterable!=undefined)iterate(iterable,that[ADDER],{that:that,AS_ENTRIES:IS_MAP});});var getInternalState=internalStateGetterFor(CONSTRUCTOR_NAME);var define=function(that,key,value){var state=getInternalState(that);var data=getWeakData(anObject(key),true);if(data===true)uncaughtFrozenStore(state).set(key,value);else data[state.id]=value;return that;};redefineAll(C.prototype,{// `{ WeakMap, WeakSet }.prototype.delete(key)` methods
// https://tc39.es/ecma262/#sec-weakmap.prototype.delete
// https://tc39.es/ecma262/#sec-weakset.prototype.delete
'delete':function(key){var state=getInternalState(this);if(!isObject$1(key))return false;var data=getWeakData(key);if(data===true)return uncaughtFrozenStore(state)['delete'](key);return data&&has$1(data,state.id)&&delete data[state.id];},// `{ WeakMap, WeakSet }.prototype.has(key)` methods
// https://tc39.es/ecma262/#sec-weakmap.prototype.has
// https://tc39.es/ecma262/#sec-weakset.prototype.has
has:function has(key){var state=getInternalState(this);if(!isObject$1(key))return false;var data=getWeakData(key);if(data===true)return uncaughtFrozenStore(state).has(key);return data&&has$1(data,state.id);}});redefineAll(C.prototype,IS_MAP?{// `WeakMap.prototype.get(key)` method
// https://tc39.es/ecma262/#sec-weakmap.prototype.get
get:function get(key){var state=getInternalState(this);if(isObject$1(key)){var data=getWeakData(key);if(data===true)return uncaughtFrozenStore(state).get(key);return data?data[state.id]:undefined;}},// `WeakMap.prototype.set(key, value)` method
// https://tc39.es/ecma262/#sec-weakmap.prototype.set
set:function set(key,value){return define(this,key,value);}}:{// `WeakSet.prototype.add(value)` method
// https://tc39.es/ecma262/#sec-weakset.prototype.add
add:function add(value){return define(this,value,true);}});return C;}};createCommonjsModule(function(module){var enforceIternalState=internalState.enforce;var IS_IE11=!global$1.ActiveXObject&&'ActiveXObject'in global$1;// eslint-disable-next-line es/no-object-isextensible -- safe
var isExtensible=Object.isExtensible;var InternalWeakMap;var wrapper=function(init){return function WeakMap(){return init(this,arguments.length?arguments[0]:undefined);};};// `WeakMap` constructor
// https://tc39.es/ecma262/#sec-weakmap-constructor
var $WeakMap=module.exports=collection('WeakMap',wrapper,collectionWeak);// IE11 WeakMap frozen keys fix
// We can't use feature detection because it crash some old IE builds
// https://github.com/zloirock/core-js/issues/485
if(nativeWeakMap&&IS_IE11){InternalWeakMap=collectionWeak.getConstructor(wrapper,'WeakMap',true);internalMetadata.REQUIRED=true;var WeakMapPrototype=$WeakMap.prototype;var nativeDelete=WeakMapPrototype['delete'];var nativeHas=WeakMapPrototype.has;var nativeGet=WeakMapPrototype.get;var nativeSet=WeakMapPrototype.set;redefineAll(WeakMapPrototype,{'delete':function(key){if(isObject$1(key)&&!isExtensible(key)){var state=enforceIternalState(this);if(!state.frozen)state.frozen=new InternalWeakMap();return nativeDelete.call(this,key)||state.frozen['delete'](key);}return nativeDelete.call(this,key);},has:function has(key){if(isObject$1(key)&&!isExtensible(key)){var state=enforceIternalState(this);if(!state.frozen)state.frozen=new InternalWeakMap();return nativeHas.call(this,key)||state.frozen.has(key);}return nativeHas.call(this,key);},get:function get(key){if(isObject$1(key)&&!isExtensible(key)){var state=enforceIternalState(this);if(!state.frozen)state.frozen=new InternalWeakMap();return nativeHas.call(this,key)?nativeGet.call(this,key):state.frozen.get(key);}return nativeGet.call(this,key);},set:function set(key,value){if(isObject$1(key)&&!isExtensible(key)){var state=enforceIternalState(this);if(!state.frozen)state.frozen=new InternalWeakMap();nativeHas.call(this,key)?nativeSet.call(this,key,value):state.frozen.set(key,value);}else nativeSet.call(this,key,value);return this;}});}});var weakMap$2=path.WeakMap;var weakMap$1=weakMap$2;var weakMap=weakMap$1;/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function __classPrivateFieldGet(receiver,state,kind,f){if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a getter");if(typeof state==="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot read private member from an object whose class did not declare it");return kind==="m"?f:kind==="a"?f.call(receiver):f?f.value:state.get(receiver);}function __classPrivateFieldSet(receiver,state,value,kind,f){if(kind==="m")throw new TypeError("Private method is not writable");if(kind==="a"&&!f)throw new TypeError("Private accessor was defined without a setter");if(typeof state==="function"?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot write private member to an object whose class did not declare it");return kind==="a"?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value;}function _createForOfIteratorHelper$3(o,allowArrayLike){var it=typeof symbol!=="undefined"&&getIteratorMethod(o)||o["@@iterator"];if(!it){if(isArray(o)||(it=_unsupportedIterableToArray$3(o))||allowArrayLike&&o&&typeof o.length==="number"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};},e:function e(_e){throw _e;},f:F};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion=true,didErr=false,err;return{s:function s(){it=it.call(o);},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e2){didErr=true;err=_e2;},f:function f(){try{if(!normalCompletion&&it.return!=null)it.return();}finally{if(didErr)throw err;}}};}function _unsupportedIterableToArray$3(o,minLen){var _context2;if(!o)return;if(typeof o==="string")return _arrayLikeToArray$3(o,minLen);var n=slice$1(_context2=Object.prototype.toString.call(o)).call(_context2,8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return from$2(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray$3(o,minLen);}function _arrayLikeToArray$3(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}var _SingleTypeSelectionAccumulator_previousSelection,_SingleTypeSelectionAccumulator_selection,_SelectionAccumulator_nodes,_SelectionAccumulator_edges,_SelectionAccumulator_commitHandler;/**
 * @param prev
 * @param next
 */function diffSets(prev,next){var diff=new set();var _iterator=_createForOfIteratorHelper$3(next),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var item=_step.value;if(!prev.has(item)){diff.add(item);}}}catch(err){_iterator.e(err);}finally{_iterator.f();}return diff;}var SingleTypeSelectionAccumulator=/*#__PURE__*/function(){function SingleTypeSelectionAccumulator(){_classCallCheck(this,SingleTypeSelectionAccumulator);_SingleTypeSelectionAccumulator_previousSelection.set(this,new set());_SingleTypeSelectionAccumulator_selection.set(this,new set());}_createClass(SingleTypeSelectionAccumulator,[{key:"size",get:function get(){return __classPrivateFieldGet(this,_SingleTypeSelectionAccumulator_selection,"f").size;}},{key:"add",value:function add(){for(var _len=arguments.length,items=new Array(_len),_key=0;_key<_len;_key++){items[_key]=arguments[_key];}for(var _i=0,_items=items;_i<_items.length;_i++){var item=_items[_i];__classPrivateFieldGet(this,_SingleTypeSelectionAccumulator_selection,"f").add(item);}}},{key:"delete",value:function _delete(){for(var _len2=arguments.length,items=new Array(_len2),_key2=0;_key2<_len2;_key2++){items[_key2]=arguments[_key2];}for(var _i2=0,_items2=items;_i2<_items2.length;_i2++){var item=_items2[_i2];__classPrivateFieldGet(this,_SingleTypeSelectionAccumulator_selection,"f").delete(item);}}},{key:"clear",value:function clear(){__classPrivateFieldGet(this,_SingleTypeSelectionAccumulator_selection,"f").clear();}},{key:"getSelection",value:function getSelection(){return _toConsumableArray(__classPrivateFieldGet(this,_SingleTypeSelectionAccumulator_selection,"f"));}},{key:"getChanges",value:function getChanges(){return{added:_toConsumableArray(diffSets(__classPrivateFieldGet(this,_SingleTypeSelectionAccumulator_previousSelection,"f"),__classPrivateFieldGet(this,_SingleTypeSelectionAccumulator_selection,"f"))),deleted:_toConsumableArray(diffSets(__classPrivateFieldGet(this,_SingleTypeSelectionAccumulator_selection,"f"),__classPrivateFieldGet(this,_SingleTypeSelectionAccumulator_previousSelection,"f"))),previous:_toConsumableArray(new set(__classPrivateFieldGet(this,_SingleTypeSelectionAccumulator_previousSelection,"f"))),current:_toConsumableArray(new set(__classPrivateFieldGet(this,_SingleTypeSelectionAccumulator_selection,"f")))};}},{key:"commit",value:function commit(){var changes=this.getChanges();__classPrivateFieldSet(this,_SingleTypeSelectionAccumulator_previousSelection,__classPrivateFieldGet(this,_SingleTypeSelectionAccumulator_selection,"f"),"f");__classPrivateFieldSet(this,_SingleTypeSelectionAccumulator_selection,new set(__classPrivateFieldGet(this,_SingleTypeSelectionAccumulator_previousSelection,"f")),"f");var _iterator2=_createForOfIteratorHelper$3(changes.added),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var item=_step2.value;item.select();}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}var _iterator3=_createForOfIteratorHelper$3(changes.deleted),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var _item=_step3.value;_item.unselect();}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}return changes;}}]);return SingleTypeSelectionAccumulator;}();_SingleTypeSelectionAccumulator_previousSelection=new weakMap(),_SingleTypeSelectionAccumulator_selection=new weakMap();var SelectionAccumulator=/*#__PURE__*/function(){function SelectionAccumulator(){var commitHandler=arguments.length>0&&arguments[0]!==undefined?arguments[0]:function(){};_classCallCheck(this,SelectionAccumulator);_SelectionAccumulator_nodes.set(this,new SingleTypeSelectionAccumulator());_SelectionAccumulator_edges.set(this,new SingleTypeSelectionAccumulator());_SelectionAccumulator_commitHandler.set(this,void 0);__classPrivateFieldSet(this,_SelectionAccumulator_commitHandler,commitHandler,"f");}_createClass(SelectionAccumulator,[{key:"sizeNodes",get:function get(){return __classPrivateFieldGet(this,_SelectionAccumulator_nodes,"f").size;}},{key:"sizeEdges",get:function get(){return __classPrivateFieldGet(this,_SelectionAccumulator_edges,"f").size;}},{key:"getNodes",value:function getNodes(){return __classPrivateFieldGet(this,_SelectionAccumulator_nodes,"f").getSelection();}},{key:"getEdges",value:function getEdges(){return __classPrivateFieldGet(this,_SelectionAccumulator_edges,"f").getSelection();}},{key:"addNodes",value:function addNodes(){var _classPrivateFieldGe;(_classPrivateFieldGe=__classPrivateFieldGet(this,_SelectionAccumulator_nodes,"f")).add.apply(_classPrivateFieldGe,arguments);}},{key:"addEdges",value:function addEdges(){var _classPrivateFieldGe2;(_classPrivateFieldGe2=__classPrivateFieldGet(this,_SelectionAccumulator_edges,"f")).add.apply(_classPrivateFieldGe2,arguments);}},{key:"deleteNodes",value:function deleteNodes(node){__classPrivateFieldGet(this,_SelectionAccumulator_nodes,"f").delete(node);}},{key:"deleteEdges",value:function deleteEdges(edge){__classPrivateFieldGet(this,_SelectionAccumulator_edges,"f").delete(edge);}},{key:"clear",value:function clear(){__classPrivateFieldGet(this,_SelectionAccumulator_nodes,"f").clear();__classPrivateFieldGet(this,_SelectionAccumulator_edges,"f").clear();}},{key:"commit",value:function commit(){var _classPrivateFieldGe3,_context;var summary={nodes:__classPrivateFieldGet(this,_SelectionAccumulator_nodes,"f").commit(),edges:__classPrivateFieldGet(this,_SelectionAccumulator_edges,"f").commit()};for(var _len3=arguments.length,rest=new Array(_len3),_key3=0;_key3<_len3;_key3++){rest[_key3]=arguments[_key3];}(_classPrivateFieldGe3=__classPrivateFieldGet(this,_SelectionAccumulator_commitHandler,"f")).call.apply(_classPrivateFieldGe3,concat(_context=[this,summary]).call(_context,rest));return summary;}}]);return SelectionAccumulator;}();_SelectionAccumulator_nodes=new weakMap(),_SelectionAccumulator_edges=new weakMap(),_SelectionAccumulator_commitHandler=new weakMap();function _createForOfIteratorHelper$2(o,allowArrayLike){var it=typeof symbol!=="undefined"&&getIteratorMethod(o)||o["@@iterator"];if(!it){if(isArray(o)||(it=_unsupportedIterableToArray$2(o))||allowArrayLike&&o&&typeof o.length==="number"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};},e:function e(_e){throw _e;},f:F};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion=true,didErr=false,err;return{s:function s(){it=it.call(o);},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e2){didErr=true;err=_e2;},f:function f(){try{if(!normalCompletion&&it.return!=null)it.return();}finally{if(didErr)throw err;}}};}function _unsupportedIterableToArray$2(o,minLen){var _context3;if(!o)return;if(typeof o==="string")return _arrayLikeToArray$2(o,minLen);var n=slice$1(_context3=Object.prototype.toString.call(o)).call(_context3,8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return from$2(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray$2(o,minLen);}function _arrayLikeToArray$2(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}/**
 * The handler for selections
 */var SelectionHandler=/*#__PURE__*/function(){/**
   * @param {object} body
   * @param {Canvas} canvas
   */function SelectionHandler(body,canvas){var _this=this;_classCallCheck(this,SelectionHandler);this.body=body;this.canvas=canvas;// TODO: Consider firing an event on any change to the selection, not
// only those caused by clicks and taps. It would be easy to implement
// now and (at least to me) it seems like something that could be
// quite useful.
this._selectionAccumulator=new SelectionAccumulator();this.hoverObj={nodes:{},edges:{}};this.options={};this.defaultOptions={multiselect:false,selectable:true,selectConnectedEdges:true,hoverConnectedEdges:true};assign$2(this.options,this.defaultOptions);this.body.emitter.on("_dataChanged",function(){_this.updateSelection();});}/**
   *
   * @param {object} [options]
   */_createClass(SelectionHandler,[{key:"setOptions",value:function setOptions(options){if(options!==undefined){var fields=["multiselect","hoverConnectedEdges","selectable","selectConnectedEdges"];selectiveDeepExtend(fields,this.options,options);}}/**
     * handles the selection part of the tap;
     *
     * @param {{x: number, y: number}} pointer
     * @returns {boolean}
     */},{key:"selectOnPoint",value:function selectOnPoint(pointer){var selected=false;if(this.options.selectable===true){var obj=this.getNodeAt(pointer)||this.getEdgeAt(pointer);// unselect after getting the objects in order to restore width and height.
this.unselectAll();if(obj!==undefined){selected=this.selectObject(obj);}this.body.emitter.emit("_requestRedraw");}return selected;}/**
     *
     * @param {{x: number, y: number}} pointer
     * @returns {boolean}
     */},{key:"selectAdditionalOnPoint",value:function selectAdditionalOnPoint(pointer){var selectionChanged=false;if(this.options.selectable===true){var obj=this.getNodeAt(pointer)||this.getEdgeAt(pointer);if(obj!==undefined){selectionChanged=true;if(obj.isSelected()===true){this.deselectObject(obj);}else{this.selectObject(obj);}this.body.emitter.emit("_requestRedraw");}}return selectionChanged;}/**
     * Create an object containing the standard fields for an event.
     *
     * @param {Event} event
     * @param {{x: number, y: number}} pointer Object with the x and y screen coordinates of the mouse
     * @returns {{}}
     * @private
     */},{key:"_initBaseEvent",value:function _initBaseEvent(event,pointer){var properties={};properties["pointer"]={DOM:{x:pointer.x,y:pointer.y},canvas:this.canvas.DOMtoCanvas(pointer)};properties["event"]=event;return properties;}/**
     * Generate an event which the user can catch.
     *
     * This adds some extra data to the event with respect to cursor position and
     * selected nodes and edges.
     *
     * @param {string} eventType                          Name of event to send
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer            Object with the x and y screen coordinates of the mouse
     * @param {object | undefined} oldSelection             If present, selection state before event occured
     * @param {boolean|undefined} [emptySelection=false]  Indicate if selection data should be passed
     */},{key:"generateClickEvent",value:function generateClickEvent(eventType,event,pointer,oldSelection){var emptySelection=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;var properties=this._initBaseEvent(event,pointer);if(emptySelection===true){properties.nodes=[];properties.edges=[];}else{var tmp=this.getSelection();properties.nodes=tmp.nodes;properties.edges=tmp.edges;}if(oldSelection!==undefined){properties["previousSelection"]=oldSelection;}if(eventType=="click"){// For the time being, restrict this functionality to
// just the click event.
properties.items=this.getClickedItems(pointer);}if(event.controlEdge!==undefined){properties.controlEdge=event.controlEdge;}this.body.emitter.emit(eventType,properties);}/**
     *
     * @param {object} obj
     * @param {boolean} [highlightEdges=this.options.selectConnectedEdges]
     * @returns {boolean}
     */},{key:"selectObject",value:function selectObject(obj){var highlightEdges=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.options.selectConnectedEdges;if(obj!==undefined){if(obj instanceof Node){if(highlightEdges===true){var _this$_selectionAccum;(_this$_selectionAccum=this._selectionAccumulator).addEdges.apply(_this$_selectionAccum,_toConsumableArray(obj.edges));}this._selectionAccumulator.addNodes(obj);}else{this._selectionAccumulator.addEdges(obj);}return true;}return false;}/**
     *
     * @param {object} obj
     */},{key:"deselectObject",value:function deselectObject(obj){if(obj.isSelected()===true){obj.selected=false;this._removeFromSelection(obj);}}/**
     * retrieve all nodes overlapping with given object
     *
     * @param {object} object  An object with parameters left, top, right, bottom
     * @returns {number[]}   An array with id's of the overlapping nodes
     * @private
     */},{key:"_getAllNodesOverlappingWith",value:function _getAllNodesOverlappingWith(object){var overlappingNodes=[];var nodes=this.body.nodes;for(var i=0;i<this.body.nodeIndices.length;i++){var nodeId=this.body.nodeIndices[i];if(nodes[nodeId].isOverlappingWith(object)){overlappingNodes.push(nodeId);}}return overlappingNodes;}/**
     * Return a position object in canvasspace from a single point in screenspace
     *
     * @param {{x: number, y: number}} pointer
     * @returns {{left: number, top: number, right: number, bottom: number}}
     * @private
     */},{key:"_pointerToPositionObject",value:function _pointerToPositionObject(pointer){var canvasPos=this.canvas.DOMtoCanvas(pointer);return{left:canvasPos.x-1,top:canvasPos.y+1,right:canvasPos.x+1,bottom:canvasPos.y-1};}/**
     * Get the top node at the passed point (like a click)
     *
     * @param {{x: number, y: number}} pointer
     * @param {boolean} [returnNode=true]
     * @returns {Node | undefined} node
     */},{key:"getNodeAt",value:function getNodeAt(pointer){var returnNode=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;// we first check if this is an navigation controls element
var positionObject=this._pointerToPositionObject(pointer);var overlappingNodes=this._getAllNodesOverlappingWith(positionObject);// if there are overlapping nodes, select the last one, this is the
// one which is drawn on top of the others
if(overlappingNodes.length>0){if(returnNode===true){return this.body.nodes[overlappingNodes[overlappingNodes.length-1]];}else{return overlappingNodes[overlappingNodes.length-1];}}else{return undefined;}}/**
     * retrieve all edges overlapping with given object, selector is around center
     *
     * @param {object} object  An object with parameters left, top, right, bottom
     * @param {number[]} overlappingEdges An array with id's of the overlapping nodes
     * @private
     */},{key:"_getEdgesOverlappingWith",value:function _getEdgesOverlappingWith(object,overlappingEdges){var edges=this.body.edges;for(var i=0;i<this.body.edgeIndices.length;i++){var edgeId=this.body.edgeIndices[i];if(edges[edgeId].isOverlappingWith(object)){overlappingEdges.push(edgeId);}}}/**
     * retrieve all nodes overlapping with given object
     *
     * @param {object} object  An object with parameters left, top, right, bottom
     * @returns {number[]}   An array with id's of the overlapping nodes
     * @private
     */},{key:"_getAllEdgesOverlappingWith",value:function _getAllEdgesOverlappingWith(object){var overlappingEdges=[];this._getEdgesOverlappingWith(object,overlappingEdges);return overlappingEdges;}/**
     * Get the edges nearest to the passed point (like a click)
     *
     * @param {{x: number, y: number}} pointer
     * @param {boolean} [returnEdge=true]
     * @returns {Edge | undefined} node
     */},{key:"getEdgeAt",value:function getEdgeAt(pointer){var returnEdge=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;// Iterate over edges, pick closest within 10
var canvasPos=this.canvas.DOMtoCanvas(pointer);var mindist=10;var overlappingEdge=null;var edges=this.body.edges;for(var i=0;i<this.body.edgeIndices.length;i++){var edgeId=this.body.edgeIndices[i];var edge=edges[edgeId];if(edge.connected){var xFrom=edge.from.x;var yFrom=edge.from.y;var xTo=edge.to.x;var yTo=edge.to.y;var dist=edge.edgeType.getDistanceToEdge(xFrom,yFrom,xTo,yTo,canvasPos.x,canvasPos.y);if(dist<mindist){overlappingEdge=edgeId;mindist=dist;}}}if(overlappingEdge!==null){if(returnEdge===true){return this.body.edges[overlappingEdge];}else{return overlappingEdge;}}else{return undefined;}}/**
     * Add object to the selection array.
     *
     * @param {object} obj
     * @private
     */},{key:"_addToHover",value:function _addToHover(obj){if(obj instanceof Node){this.hoverObj.nodes[obj.id]=obj;}else{this.hoverObj.edges[obj.id]=obj;}}/**
     * Remove a single option from selection.
     *
     * @param {object} obj
     * @private
     */},{key:"_removeFromSelection",value:function _removeFromSelection(obj){if(obj instanceof Node){var _this$_selectionAccum2;this._selectionAccumulator.deleteNodes(obj);(_this$_selectionAccum2=this._selectionAccumulator).deleteEdges.apply(_this$_selectionAccum2,_toConsumableArray(obj.edges));}else{this._selectionAccumulator.deleteEdges(obj);}}/**
     * Unselect all nodes and edges.
     */},{key:"unselectAll",value:function unselectAll(){this._selectionAccumulator.clear();}/**
     * return the number of selected nodes
     *
     * @returns {number}
     */},{key:"getSelectedNodeCount",value:function getSelectedNodeCount(){return this._selectionAccumulator.sizeNodes;}/**
     * return the number of selected edges
     *
     * @returns {number}
     */},{key:"getSelectedEdgeCount",value:function getSelectedEdgeCount(){return this._selectionAccumulator.sizeEdges;}/**
     * select the edges connected to the node that is being selected
     *
     * @param {Node} node
     * @private
     */},{key:"_hoverConnectedEdges",value:function _hoverConnectedEdges(node){for(var i=0;i<node.edges.length;i++){var edge=node.edges[i];edge.hover=true;this._addToHover(edge);}}/**
     * Remove the highlight from a node or edge, in response to mouse movement
     *
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse
     * @param {Node|vis.Edge} object
     * @private
     */},{key:"emitBlurEvent",value:function emitBlurEvent(event,pointer,object){var properties=this._initBaseEvent(event,pointer);if(object.hover===true){object.hover=false;if(object instanceof Node){properties.node=object.id;this.body.emitter.emit("blurNode",properties);}else{properties.edge=object.id;this.body.emitter.emit("blurEdge",properties);}}}/**
     * Create the highlight for a node or edge, in response to mouse movement
     *
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse
     * @param {Node|vis.Edge} object
     * @returns {boolean} hoverChanged
     * @private
     */},{key:"emitHoverEvent",value:function emitHoverEvent(event,pointer,object){var properties=this._initBaseEvent(event,pointer);var hoverChanged=false;if(object.hover===false){object.hover=true;this._addToHover(object);hoverChanged=true;if(object instanceof Node){properties.node=object.id;this.body.emitter.emit("hoverNode",properties);}else{properties.edge=object.id;this.body.emitter.emit("hoverEdge",properties);}}return hoverChanged;}/**
     * Perform actions in response to a mouse movement.
     *
     * @param {Event}  event
     * @param {{x: number, y: number}} pointer | object with the x and y screen coordinates of the mouse
     */},{key:"hoverObject",value:function hoverObject(event,pointer){var object=this.getNodeAt(pointer);if(object===undefined){object=this.getEdgeAt(pointer);}var hoverChanged=false;// remove all node hover highlights
for(var nodeId in this.hoverObj.nodes){if(Object.prototype.hasOwnProperty.call(this.hoverObj.nodes,nodeId)){if(object===undefined||object instanceof Node&&object.id!=nodeId||object instanceof Edge){this.emitBlurEvent(event,pointer,this.hoverObj.nodes[nodeId]);delete this.hoverObj.nodes[nodeId];hoverChanged=true;}}}// removing all edge hover highlights
for(var edgeId in this.hoverObj.edges){if(Object.prototype.hasOwnProperty.call(this.hoverObj.edges,edgeId)){// if the hover has been changed here it means that the node has been hovered over or off
// we then do not use the emitBlurEvent method here.
if(hoverChanged===true){this.hoverObj.edges[edgeId].hover=false;delete this.hoverObj.edges[edgeId];}// if the blur remains the same and the object is undefined (mouse off) or another
// edge has been hovered, or another node has been hovered we blur the edge.
else if(object===undefined||object instanceof Edge&&object.id!=edgeId||object instanceof Node&&!object.hover){this.emitBlurEvent(event,pointer,this.hoverObj.edges[edgeId]);delete this.hoverObj.edges[edgeId];hoverChanged=true;}}}if(object!==undefined){var hoveredEdgesCount=keys$3(this.hoverObj.edges).length;var hoveredNodesCount=keys$3(this.hoverObj.nodes).length;var newOnlyHoveredEdge=object instanceof Edge&&hoveredEdgesCount===0&&hoveredNodesCount===0;var newOnlyHoveredNode=object instanceof Node&&hoveredEdgesCount===0&&hoveredNodesCount===0;if(hoverChanged||newOnlyHoveredEdge||newOnlyHoveredNode){hoverChanged=this.emitHoverEvent(event,pointer,object);}if(object instanceof Node&&this.options.hoverConnectedEdges===true){this._hoverConnectedEdges(object);}}if(hoverChanged===true){this.body.emitter.emit("_requestRedraw");}}/**
     * Commit the selection changes but don't emit any events.
     */},{key:"commitWithoutEmitting",value:function commitWithoutEmitting(){this._selectionAccumulator.commit();}/**
     * Select and deselect nodes depending current selection change.
     *
     * For changing nodes, select/deselect events are fired.
     *
     * NOTE: For a given edge, if one connecting node is deselected and with the
     * same click the other node is selected, no events for the edge will fire. It
     * was selected and it will remain selected.
     *
     * @param {{x: number, y: number}} pointer - The x and y coordinates of the
     * click, tap, dragend… that triggered this.
     * @param {UIEvent} event - The event that triggered this.
     */},{key:"commitAndEmit",value:function commitAndEmit(pointer,event){var selected=false;var selectionChanges=this._selectionAccumulator.commit();var previousSelection={nodes:selectionChanges.nodes.previous,edges:selectionChanges.edges.previous};if(selectionChanges.edges.deleted.length>0){this.generateClickEvent("deselectEdge",event,pointer,previousSelection);selected=true;}if(selectionChanges.nodes.deleted.length>0){this.generateClickEvent("deselectNode",event,pointer,previousSelection);selected=true;}if(selectionChanges.nodes.added.length>0){this.generateClickEvent("selectNode",event,pointer);selected=true;}if(selectionChanges.edges.added.length>0){this.generateClickEvent("selectEdge",event,pointer);selected=true;}// fire the select event if anything has been selected or deselected
if(selected===true){// select or unselect
this.generateClickEvent("select",event,pointer);}}/**
     * Retrieve the currently selected node and edge ids.
     *
     * @returns {{nodes: Array.<string>, edges: Array.<string>}} Arrays with the
     * ids of the selected nodes and edges.
     */},{key:"getSelection",value:function getSelection(){return{nodes:this.getSelectedNodeIds(),edges:this.getSelectedEdgeIds()};}/**
     * Retrieve the currently selected nodes.
     *
     * @returns {Array} An array with selected nodes.
     */},{key:"getSelectedNodes",value:function getSelectedNodes(){return this._selectionAccumulator.getNodes();}/**
     * Retrieve the currently selected edges.
     *
     * @returns {Array} An array with selected edges.
     */},{key:"getSelectedEdges",value:function getSelectedEdges(){return this._selectionAccumulator.getEdges();}/**
     * Retrieve the currently selected node ids.
     *
     * @returns {Array} An array with the ids of the selected nodes.
     */},{key:"getSelectedNodeIds",value:function getSelectedNodeIds(){var _context;return map$3(_context=this._selectionAccumulator.getNodes()).call(_context,function(node){return node.id;});}/**
     * Retrieve the currently selected edge ids.
     *
     * @returns {Array} An array with the ids of the selected edges.
     */},{key:"getSelectedEdgeIds",value:function getSelectedEdgeIds(){var _context2;return map$3(_context2=this._selectionAccumulator.getEdges()).call(_context2,function(edge){return edge.id;});}/**
     * Updates the current selection
     *
     * @param {{nodes: Array.<string>, edges: Array.<string>}} selection
     * @param {object} options                                 Options
     */},{key:"setSelection",value:function setSelection(selection){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(!selection||!selection.nodes&&!selection.edges){throw new TypeError("Selection must be an object with nodes and/or edges properties");}// first unselect any selected node, if option is true or undefined
if(options.unselectAll||options.unselectAll===undefined){this.unselectAll();}if(selection.nodes){var _iterator=_createForOfIteratorHelper$2(selection.nodes),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var id=_step.value;var node=this.body.nodes[id];if(!node){throw new RangeError('Node with id "'+id+'" not found');}// don't select edges with it
this.selectObject(node,options.highlightEdges);}}catch(err){_iterator.e(err);}finally{_iterator.f();}}if(selection.edges){var _iterator2=_createForOfIteratorHelper$2(selection.edges),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var _id=_step2.value;var edge=this.body.edges[_id];if(!edge){throw new RangeError('Edge with id "'+_id+'" not found');}this.selectObject(edge);}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}}this.body.emitter.emit("_requestRedraw");this._selectionAccumulator.commit();}/**
     * select zero or more nodes with the option to highlight edges
     *
     * @param {number[] | string[]} selection     An array with the ids of the
     *                                            selected nodes.
     * @param {boolean} [highlightEdges]
     */},{key:"selectNodes",value:function selectNodes(selection){var highlightEdges=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;if(!selection||selection.length===undefined)throw"Selection must be an array with ids";this.setSelection({nodes:selection},{highlightEdges:highlightEdges});}/**
     * select zero or more edges
     *
     * @param {number[] | string[]} selection     An array with the ids of the
     *                                            selected nodes.
     */},{key:"selectEdges",value:function selectEdges(selection){if(!selection||selection.length===undefined)throw"Selection must be an array with ids";this.setSelection({edges:selection});}/**
     * Validate the selection: remove ids of nodes which no longer exist
     *
     * @private
     */},{key:"updateSelection",value:function updateSelection(){for(var node in this._selectionAccumulator.getNodes()){if(!Object.prototype.hasOwnProperty.call(this.body.nodes,node.id)){this._selectionAccumulator.deleteNodes(node);}}for(var edge in this._selectionAccumulator.getEdges()){if(!Object.prototype.hasOwnProperty.call(this.body.edges,edge.id)){this._selectionAccumulator.deleteEdges(edge);}}}/**
     * Determine all the visual elements clicked which are on the given point.
     *
     * All elements are returned; this includes nodes, edges and their labels.
     * The order returned is from highest to lowest, i.e. element 0 of the return
     * value is the topmost item clicked on.
     *
     * The return value consists of an array of the following possible elements:
     *
     * - `{nodeId:number}`             - node with given id clicked on
     * - `{nodeId:number, labelId:0}`  - label of node with given id clicked on
     * - `{edgeId:number}`             - edge with given id clicked on
     * - `{edge:number, labelId:0}`    - label of edge with given id clicked on
     *
     * ## NOTES
     *
     * - Currently, there is only one label associated with a node or an edge,
     *   but this is expected to change somewhere in the future.
     * - Since there is no z-indexing yet, it is not really possible to set the nodes and
     *   edges in the correct order. For the time being, nodes come first.
     *
     * @param {point} pointer  mouse position in screen coordinates
     * @returns {Array.<nodeClickItem|nodeLabelClickItem|edgeClickItem|edgeLabelClickItem>}
     * @private
     */},{key:"getClickedItems",value:function getClickedItems(pointer){var point=this.canvas.DOMtoCanvas(pointer);var items=[];// Note reverse order; we want the topmost clicked items to be first in the array
// Also note that selected nodes are disregarded here; these normally display on top
var nodeIndices=this.body.nodeIndices;var nodes=this.body.nodes;for(var i=nodeIndices.length-1;i>=0;i--){var node=nodes[nodeIndices[i]];var ret=node.getItemsOnPoint(point);items.push.apply(items,ret);// Append the return value to the running list.
}var edgeIndices=this.body.edgeIndices;var edges=this.body.edges;for(var _i=edgeIndices.length-1;_i>=0;_i--){var edge=edges[edgeIndices[_i]];var _ret=edge.getItemsOnPoint(point);items.push.apply(items,_ret);// Append the return value to the running list.
}return items;}}]);return SelectionHandler;}();/****
 * The MIT License
 *
 * Copyright (c) 2015 Marco Ziccardi
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 ****/var timsort$1=createCommonjsModule(function(module,exports){(function(global,factory){{factory(exports);}})(commonjsGlobal,function(exports){exports.__esModule=true;exports.sort=sort;function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError('Cannot call a class as a function');}}var DEFAULT_MIN_MERGE=32;var DEFAULT_MIN_GALLOPING=7;var DEFAULT_TMP_STORAGE_LENGTH=256;var POWERS_OF_TEN=[1e0,1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8,1e9];function log10(x){if(x<1e5){if(x<1e2){return x<1e1?0:1;}if(x<1e4){return x<1e3?2:3;}return 4;}if(x<1e7){return x<1e6?5:6;}if(x<1e9){return x<1e8?7:8;}return 9;}function alphabeticalCompare(a,b){if(a===b){return 0;}if(~~a===a&&~~b===b){if(a===0||b===0){return a<b?-1:1;}if(a<0||b<0){if(b>=0){return-1;}if(a>=0){return 1;}a=-a;b=-b;}var al=log10(a);var bl=log10(b);var t=0;if(al<bl){a*=POWERS_OF_TEN[bl-al-1];b/=10;t=-1;}else if(al>bl){b*=POWERS_OF_TEN[al-bl-1];a/=10;t=1;}if(a===b){return t;}return a<b?-1:1;}var aStr=String(a);var bStr=String(b);if(aStr===bStr){return 0;}return aStr<bStr?-1:1;}function minRunLength(n){var r=0;while(n>=DEFAULT_MIN_MERGE){r|=n&1;n>>=1;}return n+r;}function makeAscendingRun(array,lo,hi,compare){var runHi=lo+1;if(runHi===hi){return 1;}if(compare(array[runHi++],array[lo])<0){while(runHi<hi&&compare(array[runHi],array[runHi-1])<0){runHi++;}reverseRun(array,lo,runHi);}else{while(runHi<hi&&compare(array[runHi],array[runHi-1])>=0){runHi++;}}return runHi-lo;}function reverseRun(array,lo,hi){hi--;while(lo<hi){var t=array[lo];array[lo++]=array[hi];array[hi--]=t;}}function binaryInsertionSort(array,lo,hi,start,compare){if(start===lo){start++;}for(;start<hi;start++){var pivot=array[start];var left=lo;var right=start;while(left<right){var mid=left+right>>>1;if(compare(pivot,array[mid])<0){right=mid;}else{left=mid+1;}}var n=start-left;switch(n){case 3:array[left+3]=array[left+2];case 2:array[left+2]=array[left+1];case 1:array[left+1]=array[left];break;default:while(n>0){array[left+n]=array[left+n-1];n--;}}array[left]=pivot;}}function gallopLeft(value,array,start,length,hint,compare){var lastOffset=0;var maxOffset=0;var offset=1;if(compare(value,array[start+hint])>0){maxOffset=length-hint;while(offset<maxOffset&&compare(value,array[start+hint+offset])>0){lastOffset=offset;offset=(offset<<1)+1;if(offset<=0){offset=maxOffset;}}if(offset>maxOffset){offset=maxOffset;}lastOffset+=hint;offset+=hint;}else{maxOffset=hint+1;while(offset<maxOffset&&compare(value,array[start+hint-offset])<=0){lastOffset=offset;offset=(offset<<1)+1;if(offset<=0){offset=maxOffset;}}if(offset>maxOffset){offset=maxOffset;}var tmp=lastOffset;lastOffset=hint-offset;offset=hint-tmp;}lastOffset++;while(lastOffset<offset){var m=lastOffset+(offset-lastOffset>>>1);if(compare(value,array[start+m])>0){lastOffset=m+1;}else{offset=m;}}return offset;}function gallopRight(value,array,start,length,hint,compare){var lastOffset=0;var maxOffset=0;var offset=1;if(compare(value,array[start+hint])<0){maxOffset=hint+1;while(offset<maxOffset&&compare(value,array[start+hint-offset])<0){lastOffset=offset;offset=(offset<<1)+1;if(offset<=0){offset=maxOffset;}}if(offset>maxOffset){offset=maxOffset;}var tmp=lastOffset;lastOffset=hint-offset;offset=hint-tmp;}else{maxOffset=length-hint;while(offset<maxOffset&&compare(value,array[start+hint+offset])>=0){lastOffset=offset;offset=(offset<<1)+1;if(offset<=0){offset=maxOffset;}}if(offset>maxOffset){offset=maxOffset;}lastOffset+=hint;offset+=hint;}lastOffset++;while(lastOffset<offset){var m=lastOffset+(offset-lastOffset>>>1);if(compare(value,array[start+m])<0){offset=m;}else{lastOffset=m+1;}}return offset;}var TimSort=function(){function TimSort(array,compare){_classCallCheck(this,TimSort);this.array=null;this.compare=null;this.minGallop=DEFAULT_MIN_GALLOPING;this.length=0;this.tmpStorageLength=DEFAULT_TMP_STORAGE_LENGTH;this.stackLength=0;this.runStart=null;this.runLength=null;this.stackSize=0;this.array=array;this.compare=compare;this.length=array.length;if(this.length<2*DEFAULT_TMP_STORAGE_LENGTH){this.tmpStorageLength=this.length>>>1;}this.tmp=new Array(this.tmpStorageLength);this.stackLength=this.length<120?5:this.length<1542?10:this.length<119151?19:40;this.runStart=new Array(this.stackLength);this.runLength=new Array(this.stackLength);}TimSort.prototype.pushRun=function pushRun(runStart,runLength){this.runStart[this.stackSize]=runStart;this.runLength[this.stackSize]=runLength;this.stackSize+=1;};TimSort.prototype.mergeRuns=function mergeRuns(){while(this.stackSize>1){var n=this.stackSize-2;if(n>=1&&this.runLength[n-1]<=this.runLength[n]+this.runLength[n+1]||n>=2&&this.runLength[n-2]<=this.runLength[n]+this.runLength[n-1]){if(this.runLength[n-1]<this.runLength[n+1]){n--;}}else if(this.runLength[n]>this.runLength[n+1]){break;}this.mergeAt(n);}};TimSort.prototype.forceMergeRuns=function forceMergeRuns(){while(this.stackSize>1){var n=this.stackSize-2;if(n>0&&this.runLength[n-1]<this.runLength[n+1]){n--;}this.mergeAt(n);}};TimSort.prototype.mergeAt=function mergeAt(i){var compare=this.compare;var array=this.array;var start1=this.runStart[i];var length1=this.runLength[i];var start2=this.runStart[i+1];var length2=this.runLength[i+1];this.runLength[i]=length1+length2;if(i===this.stackSize-3){this.runStart[i+1]=this.runStart[i+2];this.runLength[i+1]=this.runLength[i+2];}this.stackSize--;var k=gallopRight(array[start2],array,start1,length1,0,compare);start1+=k;length1-=k;if(length1===0){return;}length2=gallopLeft(array[start1+length1-1],array,start2,length2,length2-1,compare);if(length2===0){return;}if(length1<=length2){this.mergeLow(start1,length1,start2,length2);}else{this.mergeHigh(start1,length1,start2,length2);}};TimSort.prototype.mergeLow=function mergeLow(start1,length1,start2,length2){var compare=this.compare;var array=this.array;var tmp=this.tmp;var i=0;for(i=0;i<length1;i++){tmp[i]=array[start1+i];}var cursor1=0;var cursor2=start2;var dest=start1;array[dest++]=array[cursor2++];if(--length2===0){for(i=0;i<length1;i++){array[dest+i]=tmp[cursor1+i];}return;}if(length1===1){for(i=0;i<length2;i++){array[dest+i]=array[cursor2+i];}array[dest+length2]=tmp[cursor1];return;}var minGallop=this.minGallop;while(true){var count1=0;var count2=0;var exit=false;do{if(compare(array[cursor2],tmp[cursor1])<0){array[dest++]=array[cursor2++];count2++;count1=0;if(--length2===0){exit=true;break;}}else{array[dest++]=tmp[cursor1++];count1++;count2=0;if(--length1===1){exit=true;break;}}}while((count1|count2)<minGallop);if(exit){break;}do{count1=gallopRight(array[cursor2],tmp,cursor1,length1,0,compare);if(count1!==0){for(i=0;i<count1;i++){array[dest+i]=tmp[cursor1+i];}dest+=count1;cursor1+=count1;length1-=count1;if(length1<=1){exit=true;break;}}array[dest++]=array[cursor2++];if(--length2===0){exit=true;break;}count2=gallopLeft(tmp[cursor1],array,cursor2,length2,0,compare);if(count2!==0){for(i=0;i<count2;i++){array[dest+i]=array[cursor2+i];}dest+=count2;cursor2+=count2;length2-=count2;if(length2===0){exit=true;break;}}array[dest++]=tmp[cursor1++];if(--length1===1){exit=true;break;}minGallop--;}while(count1>=DEFAULT_MIN_GALLOPING||count2>=DEFAULT_MIN_GALLOPING);if(exit){break;}if(minGallop<0){minGallop=0;}minGallop+=2;}this.minGallop=minGallop;if(minGallop<1){this.minGallop=1;}if(length1===1){for(i=0;i<length2;i++){array[dest+i]=array[cursor2+i];}array[dest+length2]=tmp[cursor1];}else if(length1===0){throw new Error('mergeLow preconditions were not respected');}else{for(i=0;i<length1;i++){array[dest+i]=tmp[cursor1+i];}}};TimSort.prototype.mergeHigh=function mergeHigh(start1,length1,start2,length2){var compare=this.compare;var array=this.array;var tmp=this.tmp;var i=0;for(i=0;i<length2;i++){tmp[i]=array[start2+i];}var cursor1=start1+length1-1;var cursor2=length2-1;var dest=start2+length2-1;var customCursor=0;var customDest=0;array[dest--]=array[cursor1--];if(--length1===0){customCursor=dest-(length2-1);for(i=0;i<length2;i++){array[customCursor+i]=tmp[i];}return;}if(length2===1){dest-=length1;cursor1-=length1;customDest=dest+1;customCursor=cursor1+1;for(i=length1-1;i>=0;i--){array[customDest+i]=array[customCursor+i];}array[dest]=tmp[cursor2];return;}var minGallop=this.minGallop;while(true){var count1=0;var count2=0;var exit=false;do{if(compare(tmp[cursor2],array[cursor1])<0){array[dest--]=array[cursor1--];count1++;count2=0;if(--length1===0){exit=true;break;}}else{array[dest--]=tmp[cursor2--];count2++;count1=0;if(--length2===1){exit=true;break;}}}while((count1|count2)<minGallop);if(exit){break;}do{count1=length1-gallopRight(tmp[cursor2],array,start1,length1,length1-1,compare);if(count1!==0){dest-=count1;cursor1-=count1;length1-=count1;customDest=dest+1;customCursor=cursor1+1;for(i=count1-1;i>=0;i--){array[customDest+i]=array[customCursor+i];}if(length1===0){exit=true;break;}}array[dest--]=tmp[cursor2--];if(--length2===1){exit=true;break;}count2=length2-gallopLeft(array[cursor1],tmp,0,length2,length2-1,compare);if(count2!==0){dest-=count2;cursor2-=count2;length2-=count2;customDest=dest+1;customCursor=cursor2+1;for(i=0;i<count2;i++){array[customDest+i]=tmp[customCursor+i];}if(length2<=1){exit=true;break;}}array[dest--]=array[cursor1--];if(--length1===0){exit=true;break;}minGallop--;}while(count1>=DEFAULT_MIN_GALLOPING||count2>=DEFAULT_MIN_GALLOPING);if(exit){break;}if(minGallop<0){minGallop=0;}minGallop+=2;}this.minGallop=minGallop;if(minGallop<1){this.minGallop=1;}if(length2===1){dest-=length1;cursor1-=length1;customDest=dest+1;customCursor=cursor1+1;for(i=length1-1;i>=0;i--){array[customDest+i]=array[customCursor+i];}array[dest]=tmp[cursor2];}else if(length2===0){throw new Error('mergeHigh preconditions were not respected');}else{customCursor=dest-(length2-1);for(i=0;i<length2;i++){array[customCursor+i]=tmp[i];}}};return TimSort;}();function sort(array,compare,lo,hi){if(!Array.isArray(array)){throw new TypeError('Can only sort arrays');}if(!compare){compare=alphabeticalCompare;}else if(typeof compare!=='function'){hi=lo;lo=compare;compare=alphabeticalCompare;}if(!lo){lo=0;}if(!hi){hi=array.length;}var remaining=hi-lo;if(remaining<2){return;}var runLength=0;if(remaining<DEFAULT_MIN_MERGE){runLength=makeAscendingRun(array,lo,hi,compare);binaryInsertionSort(array,lo,hi,lo+runLength,compare);return;}var ts=new TimSort(array,compare);var minRun=minRunLength(remaining);do{runLength=makeAscendingRun(array,lo,hi,compare);if(runLength<minRun){var force=remaining;if(force>minRun){force=minRun;}binaryInsertionSort(array,lo,lo+force,lo+runLength,compare);runLength=force;}ts.pushRun(lo,runLength);ts.mergeRuns();remaining-=runLength;lo+=runLength;}while(remaining!==0);ts.forceMergeRuns();}});});var timsort=timsort$1;function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect==="undefined"||!construct)return false;if(construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(construct(Boolean,[],function(){}));return true;}catch(e){return false;}}/**
 * Interface definition for direction strategy classes.
 *
 * This class describes the interface for the Strategy
 * pattern classes used to differentiate horizontal and vertical
 * direction of hierarchical results.
 *
 * For a given direction, one coordinate will be 'fixed', meaning that it is
 * determined by level.
 * The other coordinate is 'unfixed', meaning that the nodes on a given level
 * can still move along that coordinate. So:
 *
 * - `vertical` layout: `x` unfixed, `y` fixed per level
 * - `horizontal` layout: `x` fixed per level, `y` unfixed
 *
 * The local methods are stubs and should be regarded as abstract.
 * Derived classes **must** implement all the methods themselves.
 *
 * @private
 */var DirectionInterface=/*#__PURE__*/function(){function DirectionInterface(){_classCallCheck(this,DirectionInterface);}_createClass(DirectionInterface,[{key:"abstract",value:/**
     * @ignore
     */function abstract(){throw new Error("Can't instantiate abstract class!");}/**
     * This is a dummy call which is used to suppress the jsdoc errors of type:
     *
     *   "'param' is assigned a value but never used"
     *
     * @ignore
     **/},{key:"fake_use",value:function fake_use(){// Do nothing special
}/**
     * Type to use to translate dynamic curves to, in the case of hierarchical layout.
     * Dynamic curves do not work for these.
     *
     * The value should be perpendicular to the actual direction of the layout.
     *
     * @returns {string} Direction, either 'vertical' or 'horizontal'
     */},{key:"curveType",value:function curveType(){return this.abstract();}/**
     * Return the value of the coordinate that is not fixed for this direction.
     *
     * @param {Node} node The node to read
     * @returns {number} Value of the unfixed coordinate
     */},{key:"getPosition",value:function getPosition(node){this.fake_use(node);return this.abstract();}/**
     * Set the value of the coordinate that is not fixed for this direction.
     *
     * @param {Node} node The node to adjust
     * @param {number} position
     * @param {number} [level] if specified, the hierarchy level that this node should be fixed to
     */},{key:"setPosition",value:function setPosition(node,position){var level=arguments.length>2&&arguments[2]!==undefined?arguments[2]:undefined;this.fake_use(node,position,level);this.abstract();}/**
     * Get the width of a tree.
     *
     * A `tree` here is a subset of nodes within the network which are not connected to other nodes,
     * only among themselves. In essence, it is a sub-network.
     *
     * @param {number} index The index number of a tree
     * @returns {number} the width of a tree in the view coordinates
     */},{key:"getTreeSize",value:function getTreeSize(index){this.fake_use(index);return this.abstract();}/**
     * Sort array of nodes on the unfixed coordinates.
     *
     * **Note:** chrome has non-stable sorting implementation, which
     * has a tendency to change the order of the array items,
     * even if the custom sort function returns 0.
     *
     * For this reason, an external sort implementation is used,
     * which has the added benefit of being faster than the standard
     * platforms implementation. This has been verified on `node.js`,
     * `firefox` and `chrome` (all linux).
     *
     * @param {Array.<Node>} nodeArray array of nodes to sort
     */},{key:"sort",value:function sort(nodeArray){this.fake_use(nodeArray);this.abstract();}/**
     * Assign the fixed coordinate of the node to the given level
     *
     * @param {Node} node The node to adjust
     * @param {number} level The level to fix to
     */},{key:"fix",value:function fix(node,level){this.fake_use(node,level);this.abstract();}/**
     * Add an offset to the unfixed coordinate of the given node.
     *
     * @param {NodeId} nodeId Id of the node to adjust
     * @param {number} diff Offset to add to the unfixed coordinate
     */},{key:"shift",value:function shift(nodeId,diff){this.fake_use(nodeId,diff);this.abstract();}}]);return DirectionInterface;}();/**
 * Vertical Strategy
 *
 * Coordinate `y` is fixed on levels, coordinate `x` is unfixed.
 *
 * @augments DirectionInterface
 * @private
 */var VerticalStrategy=/*#__PURE__*/function(_DirectionInterface){_inherits(VerticalStrategy,_DirectionInterface);var _super=_createSuper(VerticalStrategy);/**
   * Constructor
   *
   * @param {object} layout reference to the parent LayoutEngine instance.
   */function VerticalStrategy(layout){var _this;_classCallCheck(this,VerticalStrategy);_this=_super.call(this);_this.layout=layout;return _this;}/** @inheritDoc */_createClass(VerticalStrategy,[{key:"curveType",value:function curveType(){return"horizontal";}/** @inheritDoc */},{key:"getPosition",value:function getPosition(node){return node.x;}/** @inheritDoc */},{key:"setPosition",value:function setPosition(node,position){var level=arguments.length>2&&arguments[2]!==undefined?arguments[2]:undefined;if(level!==undefined){this.layout.hierarchical.addToOrdering(node,level);}node.x=position;}/** @inheritDoc */},{key:"getTreeSize",value:function getTreeSize(index){var res=this.layout.hierarchical.getTreeSize(this.layout.body.nodes,index);return{min:res.min_x,max:res.max_x};}/** @inheritDoc */},{key:"sort",value:function sort(nodeArray){timsort.sort(nodeArray,function(a,b){return a.x-b.x;});}/** @inheritDoc */},{key:"fix",value:function fix(node,level){node.y=this.layout.options.hierarchical.levelSeparation*level;node.options.fixed.y=true;}/** @inheritDoc */},{key:"shift",value:function shift(nodeId,diff){this.layout.body.nodes[nodeId].x+=diff;}}]);return VerticalStrategy;}(DirectionInterface);/**
 * Horizontal Strategy
 *
 * Coordinate `x` is fixed on levels, coordinate `y` is unfixed.
 *
 * @augments DirectionInterface
 * @private
 */var HorizontalStrategy=/*#__PURE__*/function(_DirectionInterface2){_inherits(HorizontalStrategy,_DirectionInterface2);var _super2=_createSuper(HorizontalStrategy);/**
   * Constructor
   *
   * @param {object} layout reference to the parent LayoutEngine instance.
   */function HorizontalStrategy(layout){var _this2;_classCallCheck(this,HorizontalStrategy);_this2=_super2.call(this);_this2.layout=layout;return _this2;}/** @inheritDoc */_createClass(HorizontalStrategy,[{key:"curveType",value:function curveType(){return"vertical";}/** @inheritDoc */},{key:"getPosition",value:function getPosition(node){return node.y;}/** @inheritDoc */},{key:"setPosition",value:function setPosition(node,position){var level=arguments.length>2&&arguments[2]!==undefined?arguments[2]:undefined;if(level!==undefined){this.layout.hierarchical.addToOrdering(node,level);}node.y=position;}/** @inheritDoc */},{key:"getTreeSize",value:function getTreeSize(index){var res=this.layout.hierarchical.getTreeSize(this.layout.body.nodes,index);return{min:res.min_y,max:res.max_y};}/** @inheritDoc */},{key:"sort",value:function sort(nodeArray){timsort.sort(nodeArray,function(a,b){return a.y-b.y;});}/** @inheritDoc */},{key:"fix",value:function fix(node,level){node.x=this.layout.options.hierarchical.levelSeparation*level;node.options.fixed.x=true;}/** @inheritDoc */},{key:"shift",value:function shift(nodeId,diff){this.layout.body.nodes[nodeId].y+=diff;}}]);return HorizontalStrategy;}(DirectionInterface);var $every=arrayIteration.every;var STRICT_METHOD=arrayMethodIsStrict('every');// `Array.prototype.every` method
// https://tc39.es/ecma262/#sec-array.prototype.every
_export({target:'Array',proto:true,forced:!STRICT_METHOD},{every:function every(callbackfn/* , thisArg */){return $every(this,callbackfn,arguments.length>1?arguments[1]:undefined);}});var every$2=entryVirtual('Array').every;var ArrayPrototype=Array.prototype;var every_1=function(it){var own=it.every;return it===ArrayPrototype||it instanceof Array&&own===ArrayPrototype.every?every$2:own;};var every$1=every_1;var every=every$1;function _createForOfIteratorHelper$1(o,allowArrayLike){var it=typeof symbol!=="undefined"&&getIteratorMethod(o)||o["@@iterator"];if(!it){if(isArray(o)||(it=_unsupportedIterableToArray$1(o))||allowArrayLike&&o&&typeof o.length==="number"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};},e:function e(_e){throw _e;},f:F};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion=true,didErr=false,err;return{s:function s(){it=it.call(o);},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e2){didErr=true;err=_e2;},f:function f(){try{if(!normalCompletion&&it.return!=null)it.return();}finally{if(didErr)throw err;}}};}function _unsupportedIterableToArray$1(o,minLen){var _context9;if(!o)return;if(typeof o==="string")return _arrayLikeToArray$1(o,minLen);var n=slice$1(_context9=Object.prototype.toString.call(o)).call(_context9,8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return from$2(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray$1(o,minLen);}function _arrayLikeToArray$1(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}/**
 * Try to assign levels to nodes according to their positions in the cyclic “hierarchy”.
 *
 * @param nodes - Visible nodes of the graph.
 * @param levels - If present levels will be added to it, if not a new object will be created.
 *
 * @returns Populated node levels.
 */function fillLevelsByDirectionCyclic(nodes,levels){var edges=new set();forEach$2(nodes).call(nodes,function(node){var _context;forEach$2(_context=node.edges).call(_context,function(edge){if(edge.connected){edges.add(edge);}});});forEach$2(edges).call(edges,function(edge){var fromId=edge.from.id;var toId=edge.to.id;if(levels[fromId]==null){levels[fromId]=0;}if(levels[toId]==null||levels[fromId]>=levels[toId]){levels[toId]=levels[fromId]+1;}});return levels;}/**
 * Assign levels to nodes according to their positions in the hierarchy. Leaves will be lined up at the bottom and all other nodes as close to their children as possible.
 *
 * @param nodes - Visible nodes of the graph.
 *
 * @returns Populated node levels.
 */function fillLevelsByDirectionLeaves(nodes){return fillLevelsByDirection(// Pick only leaves (nodes without children).
function(node){var _context2,_context3;return every(_context2=filter(_context3=node.edges// Take only visible nodes into account.
).call(_context3,function(edge){return nodes.has(edge.toId);})// Check that all edges lead to this node (leaf).
).call(_context2,function(edge){return edge.to===node;});},// Use the lowest level.
function(newLevel,oldLevel){return oldLevel>newLevel;},// Go against the direction of the edges.
"from",nodes);}/**
 * Assign levels to nodes according to their positions in the hierarchy. Roots will be lined up at the top and all nodes as close to their parents as possible.
 *
 * @param nodes - Visible nodes of the graph.
 *
 * @returns Populated node levels.
 */function fillLevelsByDirectionRoots(nodes){return fillLevelsByDirection(// Pick only roots (nodes without parents).
function(node){var _context4,_context5;return every(_context4=filter(_context5=node.edges// Take only visible nodes into account.
).call(_context5,function(edge){return nodes.has(edge.toId);})// Check that all edges lead from this node (root).
).call(_context4,function(edge){return edge.from===node;});},// Use the highest level.
function(newLevel,oldLevel){return oldLevel<newLevel;},// Go in the direction of the edges.
"to",nodes);}/**
 * Assign levels to nodes according to their positions in the hierarchy.
 *
 * @param isEntryNode - Checks and return true if the graph should be traversed from this node.
 * @param shouldLevelBeReplaced - Checks and returns true if the level of given node should be updated to the new value.
 * @param direction - Wheter the graph should be traversed in the direction of the edges `"to"` or in the other way `"from"`.
 * @param nodes - Visible nodes of the graph.
 *
 * @returns Populated node levels.
 */function fillLevelsByDirection(isEntryNode,shouldLevelBeReplaced,direction,nodes){var _context6;var levels=create$2(null);// If acyclic, the graph can be walked through with (most likely way) fewer
// steps than the number bellow. The exact value isn't too important as long
// as it's quick to compute (doesn't impact acyclic graphs too much), is
// higher than the number of steps actually needed (doesn't cut off before
// acyclic graph is walked through) and prevents infinite loops (cuts off for
// cyclic graphs).
var limit=reduce(_context6=_toConsumableArray(values(nodes).call(nodes))).call(_context6,function(acc,node){return acc+1+node.edges.length;},0);var edgeIdProp=direction+"Id";var newLevelDiff=direction==="to"?1:-1;var _iterator=_createForOfIteratorHelper$1(nodes),_step;try{var _loop=function _loop(){var _step$value=_slicedToArray(_step.value,2),entryNodeId=_step$value[0],entryNode=_step$value[1];if(// Skip if the node is not visible.
!nodes.has(entryNodeId)||// Skip if the node is not an entry node.
!isEntryNode(entryNode)){return"continue";}// Line up all the entry nodes on level 0.
levels[entryNodeId]=0;var stack=[entryNode];var done=0;var node=void 0;var _loop2=function _loop2(){var _context7,_context8;if(!nodes.has(entryNodeId)){// Skip if the node is not visible.
return"continue";}var newLevel=levels[node.id]+newLevelDiff;forEach$2(_context7=filter(_context8=node.edges).call(_context8,function(edge){return(// Ignore disconnected edges.
edge.connected&&// Ignore circular edges.
edge.to!==edge.from&&// Ignore edges leading to the node that's currently being processed.
edge[direction]!==node&&// Ignore edges connecting to an invisible node.
nodes.has(edge.toId)&&// Ignore edges connecting from an invisible node.
nodes.has(edge.fromId));})).call(_context7,function(edge){var targetNodeId=edge[edgeIdProp];var oldLevel=levels[targetNodeId];if(oldLevel==null||shouldLevelBeReplaced(newLevel,oldLevel)){levels[targetNodeId]=newLevel;stack.push(edge[direction]);}});if(done>limit){// This would run forever on a cyclic graph.
return{v:{v:fillLevelsByDirectionCyclic(nodes,levels)}};}else{++done;}};while(node=stack.pop()){var _ret2=_loop2();if(_ret2==="continue")continue;if(_typeof(_ret2)==="object")return _ret2.v;}};for(_iterator.s();!(_step=_iterator.n()).done;){var _ret=_loop();if(_ret==="continue")continue;if(_typeof(_ret)==="object")return _ret.v;}}catch(err){_iterator.e(err);}finally{_iterator.f();}return levels;}/**
 * There's a mix-up with terms in the code. Following are the formal definitions:
 *
 *   tree   - a strict hierarchical network, i.e. every node has at most one parent
 *   forest - a collection of trees. These distinct trees are thus not connected.
 *
 * So:
 * - in a network that is not a tree, there exist nodes with multiple parents.
 * - a network consisting of unconnected sub-networks, of which at least one
 *   is not a tree, is not a forest.
 *
 * In the code, the definitions are:
 *
 *   tree   - any disconnected sub-network, strict hierarchical or not.
 *   forest - a bunch of these sub-networks
 *
 * The difference between tree and not-tree is important in the code, notably within
 * to the block-shifting algorithm. The algorithm assumes formal trees and fails
 * for not-trees, often in a spectacular manner (search for 'exploding network' in the issues).
 *
 * In order to distinguish the definitions in the following code, the adjective 'formal' is
 * used. If 'formal' is absent, you must assume the non-formal definition.
 *
 * ----------------------------------------------------------------------------------
 * NOTES
 * =====
 *
 * A hierarchical layout is a different thing from a hierarchical network.
 * The layout is a way to arrange the nodes in the view; this can be done
 * on non-hierarchical networks as well. The converse is also possible.
 */ /**
 * Container for derived data on current network, relating to hierarchy.
 *
 * @private
 */var HierarchicalStatus=/*#__PURE__*/function(){/**
   * @ignore
   */function HierarchicalStatus(){_classCallCheck(this,HierarchicalStatus);this.childrenReference={};// child id's per node id
this.parentReference={};// parent id's per node id
this.trees={};// tree id per node id; i.e. to which tree does given node id belong
this.distributionOrdering={};// The nodes per level, in the display order
this.levels={};// hierarchy level per node id
this.distributionIndex={};// The position of the node in the level sorting order, per node id.
this.isTree=false;// True if current network is a formal tree
this.treeIndex=-1;// Highest tree id in current network.
}/**
   * Add the relation between given nodes to the current state.
   *
   * @param {Node.id} parentNodeId
   * @param {Node.id} childNodeId
   */_createClass(HierarchicalStatus,[{key:"addRelation",value:function addRelation(parentNodeId,childNodeId){if(this.childrenReference[parentNodeId]===undefined){this.childrenReference[parentNodeId]=[];}this.childrenReference[parentNodeId].push(childNodeId);if(this.parentReference[childNodeId]===undefined){this.parentReference[childNodeId]=[];}this.parentReference[childNodeId].push(parentNodeId);}/**
     * Check if the current state is for a formal tree or formal forest.
     *
     * This is the case if every node has at most one parent.
     *
     * Pre: parentReference init'ed properly for current network
     */},{key:"checkIfTree",value:function checkIfTree(){for(var i in this.parentReference){if(this.parentReference[i].length>1){this.isTree=false;return;}}this.isTree=true;}/**
     * Return the number of separate trees in the current network.
     *
     * @returns {number}
     */},{key:"numTrees",value:function numTrees(){return this.treeIndex+1;// This assumes the indexes are assigned consecitively
}/**
     * Assign a tree id to a node
     *
     * @param {Node} node
     * @param {string|number} treeId
     */},{key:"setTreeIndex",value:function setTreeIndex(node,treeId){if(treeId===undefined)return;// Don't bother
if(this.trees[node.id]===undefined){this.trees[node.id]=treeId;this.treeIndex=Math.max(treeId,this.treeIndex);}}/**
     * Ensure level for given id is defined.
     *
     * Sets level to zero for given node id if not already present
     *
     * @param {Node.id} nodeId
     */},{key:"ensureLevel",value:function ensureLevel(nodeId){if(this.levels[nodeId]===undefined){this.levels[nodeId]=0;}}/**
     * get the maximum level of a branch.
     *
     * TODO: Never entered; find a test case to test this!
     *
     * @param {Node.id} nodeId
     * @returns {number}
     */},{key:"getMaxLevel",value:function getMaxLevel(nodeId){var _this=this;var accumulator={};var _getMaxLevel=function _getMaxLevel(nodeId){if(accumulator[nodeId]!==undefined){return accumulator[nodeId];}var level=_this.levels[nodeId];if(_this.childrenReference[nodeId]){var children=_this.childrenReference[nodeId];if(children.length>0){for(var i=0;i<children.length;i++){level=Math.max(level,_getMaxLevel(children[i]));}}}accumulator[nodeId]=level;return level;};return _getMaxLevel(nodeId);}/**
     *
     * @param {Node} nodeA
     * @param {Node} nodeB
     */},{key:"levelDownstream",value:function levelDownstream(nodeA,nodeB){if(this.levels[nodeB.id]===undefined){// set initial level
if(this.levels[nodeA.id]===undefined){this.levels[nodeA.id]=0;}// set level
this.levels[nodeB.id]=this.levels[nodeA.id]+1;}}/**
     * Small util method to set the minimum levels of the nodes to zero.
     *
     * @param {Array.<Node>} nodes
     */},{key:"setMinLevelToZero",value:function setMinLevelToZero(nodes){var minLevel=1e9;// get the minimum level
for(var nodeId in nodes){if(Object.prototype.hasOwnProperty.call(nodes,nodeId)){if(this.levels[nodeId]!==undefined){minLevel=Math.min(this.levels[nodeId],minLevel);}}}// subtract the minimum from the set so we have a range starting from 0
for(var _nodeId in nodes){if(Object.prototype.hasOwnProperty.call(nodes,_nodeId)){if(this.levels[_nodeId]!==undefined){this.levels[_nodeId]-=minLevel;}}}}/**
     * Get the min and max xy-coordinates of a given tree
     *
     * @param {Array.<Node>} nodes
     * @param {number} index
     * @returns {{min_x: number, max_x: number, min_y: number, max_y: number}}
     */},{key:"getTreeSize",value:function getTreeSize(nodes,index){var min_x=1e9;var max_x=-1e9;var min_y=1e9;var max_y=-1e9;for(var nodeId in this.trees){if(Object.prototype.hasOwnProperty.call(this.trees,nodeId)){if(this.trees[nodeId]===index){var node=nodes[nodeId];min_x=Math.min(node.x,min_x);max_x=Math.max(node.x,max_x);min_y=Math.min(node.y,min_y);max_y=Math.max(node.y,max_y);}}}return{min_x:min_x,max_x:max_x,min_y:min_y,max_y:max_y};}/**
     * Check if two nodes have the same parent(s)
     *
     * @param {Node} node1
     * @param {Node} node2
     * @returns {boolean} true if the two nodes have a same ancestor node, false otherwise
     */},{key:"hasSameParent",value:function hasSameParent(node1,node2){var parents1=this.parentReference[node1.id];var parents2=this.parentReference[node2.id];if(parents1===undefined||parents2===undefined){return false;}for(var i=0;i<parents1.length;i++){for(var j=0;j<parents2.length;j++){if(parents1[i]==parents2[j]){return true;}}}return false;}/**
     * Check if two nodes are in the same tree.
     *
     * @param {Node} node1
     * @param {Node} node2
     * @returns {boolean} true if this is so, false otherwise
     */},{key:"inSameSubNetwork",value:function inSameSubNetwork(node1,node2){return this.trees[node1.id]===this.trees[node2.id];}/**
     * Get a list of the distinct levels in the current network
     *
     * @returns {Array}
     */},{key:"getLevels",value:function getLevels(){return keys$3(this.distributionOrdering);}/**
     * Add a node to the ordering per level
     *
     * @param {Node} node
     * @param {number} level
     */},{key:"addToOrdering",value:function addToOrdering(node,level){if(this.distributionOrdering[level]===undefined){this.distributionOrdering[level]=[];}var isPresent=false;var curLevel=this.distributionOrdering[level];for(var n in curLevel){//if (curLevel[n].id === node.id) {
if(curLevel[n]===node){isPresent=true;break;}}if(!isPresent){this.distributionOrdering[level].push(node);this.distributionIndex[node.id]=this.distributionOrdering[level].length-1;}}}]);return HierarchicalStatus;}();/**
 * The Layout Engine
 */var LayoutEngine=/*#__PURE__*/function(){/**
   * @param {object} body
   */function LayoutEngine(body){_classCallCheck(this,LayoutEngine);this.body=body;// Make sure there always is some RNG because the setOptions method won't
// set it unless there's a seed for it.
this._resetRNG(Math.random()+":"+now$1());this.setPhysics=false;this.options={};this.optionsBackup={physics:{}};this.defaultOptions={randomSeed:undefined,improvedLayout:true,clusterThreshold:150,hierarchical:{enabled:false,levelSeparation:150,nodeSpacing:100,treeSpacing:200,blockShifting:true,edgeMinimization:true,parentCentralization:true,direction:"UD",// UD, DU, LR, RL
sortMethod:"hubsize"// hubsize, directed
}};assign$2(this.options,this.defaultOptions);this.bindEventListeners();}/**
   * Binds event listeners
   */_createClass(LayoutEngine,[{key:"bindEventListeners",value:function bindEventListeners(){var _this2=this;this.body.emitter.on("_dataChanged",function(){_this2.setupHierarchicalLayout();});this.body.emitter.on("_dataLoaded",function(){_this2.layoutNetwork();});this.body.emitter.on("_resetHierarchicalLayout",function(){_this2.setupHierarchicalLayout();});this.body.emitter.on("_adjustEdgesForHierarchicalLayout",function(){if(_this2.options.hierarchical.enabled!==true){return;}// get the type of static smooth curve in case it is required
var type=_this2.direction.curveType();// force all edges into static smooth curves.
_this2.body.emitter.emit("_forceDisableDynamicCurves",type,false);});}/**
     *
     * @param {object} options
     * @param {object} allOptions
     * @returns {object}
     */},{key:"setOptions",value:function setOptions(options,allOptions){if(options!==undefined){var hierarchical=this.options.hierarchical;var prevHierarchicalState=hierarchical.enabled;selectiveDeepExtend(["randomSeed","improvedLayout","clusterThreshold"],this.options,options);mergeOptions(this.options,options,"hierarchical");if(options.randomSeed!==undefined){this._resetRNG(options.randomSeed);}if(hierarchical.enabled===true){if(prevHierarchicalState===true){// refresh the overridden options for nodes and edges.
this.body.emitter.emit("refresh",true);}// make sure the level separation is the right way up
if(hierarchical.direction==="RL"||hierarchical.direction==="DU"){if(hierarchical.levelSeparation>0){hierarchical.levelSeparation*=-1;}}else{if(hierarchical.levelSeparation<0){hierarchical.levelSeparation*=-1;}}this.setDirectionStrategy();this.body.emitter.emit("_resetHierarchicalLayout");// because the hierarchical system needs it's own physics and smooth curve settings,
// we adapt the other options if needed.
return this.adaptAllOptionsForHierarchicalLayout(allOptions);}else{if(prevHierarchicalState===true){// refresh the overridden options for nodes and edges.
this.body.emitter.emit("refresh");return deepExtend(allOptions,this.optionsBackup);}}}return allOptions;}/**
     * Reset the random number generator with given seed.
     *
     * @param {any} seed - The seed that will be forwarded the the RNG.
     */},{key:"_resetRNG",value:function _resetRNG(seed){this.initialRandomSeed=seed;this._rng=Alea(this.initialRandomSeed);}/**
     *
     * @param {object} allOptions
     * @returns {object}
     */},{key:"adaptAllOptionsForHierarchicalLayout",value:function adaptAllOptionsForHierarchicalLayout(allOptions){if(this.options.hierarchical.enabled===true){var backupPhysics=this.optionsBackup.physics;// set the physics
if(allOptions.physics===undefined||allOptions.physics===true){allOptions.physics={enabled:backupPhysics.enabled===undefined?true:backupPhysics.enabled,solver:"hierarchicalRepulsion"};backupPhysics.enabled=backupPhysics.enabled===undefined?true:backupPhysics.enabled;backupPhysics.solver=backupPhysics.solver||"barnesHut";}else if(_typeof(allOptions.physics)==="object"){backupPhysics.enabled=allOptions.physics.enabled===undefined?true:allOptions.physics.enabled;backupPhysics.solver=allOptions.physics.solver||"barnesHut";allOptions.physics.solver="hierarchicalRepulsion";}else if(allOptions.physics!==false){backupPhysics.solver="barnesHut";allOptions.physics={solver:"hierarchicalRepulsion"};}// get the type of static smooth curve in case it is required
var type=this.direction.curveType();// disable smooth curves if nothing is defined. If smooth curves have been turned on,
// turn them into static smooth curves.
if(allOptions.edges===undefined){this.optionsBackup.edges={smooth:{enabled:true,type:"dynamic"}};allOptions.edges={smooth:false};}else if(allOptions.edges.smooth===undefined){this.optionsBackup.edges={smooth:{enabled:true,type:"dynamic"}};allOptions.edges.smooth=false;}else{if(typeof allOptions.edges.smooth==="boolean"){this.optionsBackup.edges={smooth:allOptions.edges.smooth};allOptions.edges.smooth={enabled:allOptions.edges.smooth,type:type};}else{var smooth=allOptions.edges.smooth;// allow custom types except for dynamic
if(smooth.type!==undefined&&smooth.type!=="dynamic"){type=smooth.type;}// TODO: this is options merging; see if the standard routines can be used here.
this.optionsBackup.edges={smooth:{enabled:smooth.enabled===undefined?true:smooth.enabled,type:smooth.type===undefined?"dynamic":smooth.type,roundness:smooth.roundness===undefined?0.5:smooth.roundness,forceDirection:smooth.forceDirection===undefined?false:smooth.forceDirection}};// NOTE: Copying an object to self; this is basically setting defaults for undefined variables
allOptions.edges.smooth={enabled:smooth.enabled===undefined?true:smooth.enabled,type:type,roundness:smooth.roundness===undefined?0.5:smooth.roundness,forceDirection:smooth.forceDirection===undefined?false:smooth.forceDirection};}}// Force all edges into static smooth curves.
// Only applies to edges that do not use the global options for smooth.
this.body.emitter.emit("_forceDisableDynamicCurves",type);}return allOptions;}/**
     *
     * @param {Array.<Node>} nodesArray
     */},{key:"positionInitially",value:function positionInitially(nodesArray){if(this.options.hierarchical.enabled!==true){this._resetRNG(this.initialRandomSeed);var radius=nodesArray.length+50;for(var i=0;i<nodesArray.length;i++){var node=nodesArray[i];var angle=2*Math.PI*this._rng();if(node.x===undefined){node.x=radius*Math.cos(angle);}if(node.y===undefined){node.y=radius*Math.sin(angle);}}}}/**
     * Use Kamada Kawai to position nodes. This is quite a heavy algorithm so if there are a lot of nodes we
     * cluster them first to reduce the amount.
     */},{key:"layoutNetwork",value:function layoutNetwork(){if(this.options.hierarchical.enabled!==true&&this.options.improvedLayout===true){var indices=this.body.nodeIndices;// first check if we should Kamada Kawai to layout. The threshold is if less than half of the visible
// nodes have predefined positions we use this.
var positionDefined=0;for(var i=0;i<indices.length;i++){var node=this.body.nodes[indices[i]];if(node.predefinedPosition===true){positionDefined+=1;}}// if less than half of the nodes have a predefined position we continue
if(positionDefined<0.5*indices.length){var MAX_LEVELS=10;var level=0;var clusterThreshold=this.options.clusterThreshold;//
// Define the options for the hidden cluster nodes
// These options don't propagate outside the clustering phase.
//
// Some options are explicitly disabled, because they may be set in group or default node options.
// The clusters are never displayed, so most explicit settings here serve as performance optimizations.
//
// The explicit setting of 'shape' is to avoid `shape: 'image'`; images are not passed to the hidden
// cluster nodes, leading to an exception on creation.
//
// All settings here are performance related, except when noted otherwise.
//
var clusterOptions={clusterNodeProperties:{shape:"ellipse",// Bugfix: avoid type 'image', no images supplied
label:"",// avoid label handling
group:"",// avoid group handling
font:{multi:false}// avoid font propagation
},clusterEdgeProperties:{label:"",// avoid label handling
font:{multi:false},// avoid font propagation
smooth:{enabled:false// avoid drawing penalty for complex edges
}}};// if there are a lot of nodes, we cluster before we run the algorithm.
// NOTE: this part fails to find clusters for large scale-free networks, which should
//       be easily clusterable.
// TODO: examine why this is so
if(indices.length>clusterThreshold){var startLength=indices.length;while(indices.length>clusterThreshold&&level<=MAX_LEVELS){//console.time("clustering")
level+=1;var before=indices.length;// if there are many nodes we do a hubsize cluster
if(level%3===0){this.body.modules.clustering.clusterBridges(clusterOptions);}else{this.body.modules.clustering.clusterOutliers(clusterOptions);}var after=indices.length;if(before==after&&level%3!==0){this._declusterAll();this.body.emitter.emit("_layoutFailed");console.info("This network could not be positioned by this version of the improved layout algorithm."+" Please disable improvedLayout for better performance.");return;}//console.timeEnd("clustering")
//console.log(before,level,after);
}// increase the size of the edges
this.body.modules.kamadaKawai.setOptions({springLength:Math.max(150,2*startLength)});}if(level>MAX_LEVELS){console.info("The clustering didn't succeed within the amount of interations allowed,"+" progressing with partial result.");}// position the system for these nodes and edges
this.body.modules.kamadaKawai.solve(indices,this.body.edgeIndices,true);// shift to center point
this._shiftToCenter();// perturb the nodes a little bit to force the physics to kick in
var offset=70;for(var _i=0;_i<indices.length;_i++){// Only perturb the nodes that aren't fixed
var _node=this.body.nodes[indices[_i]];if(_node.predefinedPosition===false){_node.x+=(0.5-this._rng())*offset;_node.y+=(0.5-this._rng())*offset;}}// uncluster all clusters
this._declusterAll();// reposition all bezier nodes.
this.body.emitter.emit("_repositionBezierNodes");}}}/**
     * Move all the nodes towards to the center so gravitational pull wil not move the nodes away from view
     *
     * @private
     */},{key:"_shiftToCenter",value:function _shiftToCenter(){var range=NetworkUtil.getRangeCore(this.body.nodes,this.body.nodeIndices);var center=NetworkUtil.findCenter(range);for(var i=0;i<this.body.nodeIndices.length;i++){var node=this.body.nodes[this.body.nodeIndices[i]];node.x-=center.x;node.y-=center.y;}}/**
     * Expands all clusters
     *
     * @private
     */},{key:"_declusterAll",value:function _declusterAll(){var clustersPresent=true;while(clustersPresent===true){clustersPresent=false;for(var i=0;i<this.body.nodeIndices.length;i++){if(this.body.nodes[this.body.nodeIndices[i]].isCluster===true){clustersPresent=true;this.body.modules.clustering.openCluster(this.body.nodeIndices[i],{},false);}}if(clustersPresent===true){this.body.emitter.emit("_dataChanged");}}}/**
     *
     * @returns {number|*}
     */},{key:"getSeed",value:function getSeed(){return this.initialRandomSeed;}/**
     * This is the main function to layout the nodes in a hierarchical way.
     * It checks if the node details are supplied correctly
     *
     * @private
     */},{key:"setupHierarchicalLayout",value:function setupHierarchicalLayout(){if(this.options.hierarchical.enabled===true&&this.body.nodeIndices.length>0){// get the size of the largest hubs and check if the user has defined a level for a node.
var node,nodeId;var definedLevel=false;var undefinedLevel=false;this.lastNodeOnLevel={};this.hierarchical=new HierarchicalStatus();for(nodeId in this.body.nodes){if(Object.prototype.hasOwnProperty.call(this.body.nodes,nodeId)){node=this.body.nodes[nodeId];if(node.options.level!==undefined){definedLevel=true;this.hierarchical.levels[nodeId]=node.options.level;}else{undefinedLevel=true;}}}// if the user defined some levels but not all, alert and run without hierarchical layout
if(undefinedLevel===true&&definedLevel===true){throw new Error("To use the hierarchical layout, nodes require either no predefined levels"+" or levels have to be defined for all nodes.");}else{// define levels if undefined by the users. Based on hubsize.
if(undefinedLevel===true){var sortMethod=this.options.hierarchical.sortMethod;if(sortMethod==="hubsize"){this._determineLevelsByHubsize();}else if(sortMethod==="directed"){this._determineLevelsDirected();}else if(sortMethod==="custom"){this._determineLevelsCustomCallback();}}// fallback for cases where there are nodes but no edges
for(var _nodeId2 in this.body.nodes){if(Object.prototype.hasOwnProperty.call(this.body.nodes,_nodeId2)){this.hierarchical.ensureLevel(_nodeId2);}}// check the distribution of the nodes per level.
var distribution=this._getDistribution();// get the parent children relations.
this._generateMap();// place the nodes on the canvas.
this._placeNodesByHierarchy(distribution);// condense the whitespace.
this._condenseHierarchy();// shift to center so gravity does not have to do much
this._shiftToCenter();}}}/**
     * @private
     */},{key:"_condenseHierarchy",value:function _condenseHierarchy(){var _this3=this;// Global var in this scope to define when the movement has stopped.
var stillShifting=false;var branches={};// first we have some methods to help shifting trees around.
// the main method to shift the trees
var shiftTrees=function shiftTrees(){var treeSizes=getTreeSizes();var shiftBy=0;for(var i=0;i<treeSizes.length-1;i++){var diff=treeSizes[i].max-treeSizes[i+1].min;shiftBy+=diff+_this3.options.hierarchical.treeSpacing;shiftTree(i+1,shiftBy);}};// shift a single tree by an offset
var shiftTree=function shiftTree(index,offset){var trees=_this3.hierarchical.trees;for(var nodeId in trees){if(Object.prototype.hasOwnProperty.call(trees,nodeId)){if(trees[nodeId]===index){_this3.direction.shift(nodeId,offset);}}}};// get the width of all trees
var getTreeSizes=function getTreeSizes(){var treeWidths=[];for(var i=0;i<_this3.hierarchical.numTrees();i++){treeWidths.push(_this3.direction.getTreeSize(i));}return treeWidths;};// get a map of all nodes in this branch
var getBranchNodes=function getBranchNodes(source,map){if(map[source.id]){return;}map[source.id]=true;if(_this3.hierarchical.childrenReference[source.id]){var children=_this3.hierarchical.childrenReference[source.id];if(children.length>0){for(var i=0;i<children.length;i++){getBranchNodes(_this3.body.nodes[children[i]],map);}}}};// get a min max width as well as the maximum movement space it has on either sides
// we use min max terminology because width and height can interchange depending on the direction of the layout
var getBranchBoundary=function getBranchBoundary(branchMap){var maxLevel=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1e9;var minSpace=1e9;var maxSpace=1e9;var min=1e9;var max=-1e9;for(var branchNode in branchMap){if(Object.prototype.hasOwnProperty.call(branchMap,branchNode)){var node=_this3.body.nodes[branchNode];var level=_this3.hierarchical.levels[node.id];var position=_this3.direction.getPosition(node);// get the space around the node.
var _this3$_getSpaceAroun=_this3._getSpaceAroundNode(node,branchMap),_this3$_getSpaceAroun2=_slicedToArray(_this3$_getSpaceAroun,2),minSpaceNode=_this3$_getSpaceAroun2[0],maxSpaceNode=_this3$_getSpaceAroun2[1];minSpace=Math.min(minSpaceNode,minSpace);maxSpace=Math.min(maxSpaceNode,maxSpace);// the width is only relevant for the levels two nodes have in common. This is why we filter on this.
if(level<=maxLevel){min=Math.min(position,min);max=Math.max(position,max);}}}return[min,max,minSpace,maxSpace];};// check what the maximum level is these nodes have in common.
var getCollisionLevel=function getCollisionLevel(node1,node2){var maxLevel1=_this3.hierarchical.getMaxLevel(node1.id);var maxLevel2=_this3.hierarchical.getMaxLevel(node2.id);return Math.min(maxLevel1,maxLevel2);};/**
       * Condense elements. These can be nodes or branches depending on the callback.
       *
       * @param {Function} callback
       * @param {Array.<number>} levels
       * @param {*} centerParents
       */var shiftElementsCloser=function shiftElementsCloser(callback,levels,centerParents){var hier=_this3.hierarchical;for(var i=0;i<levels.length;i++){var level=levels[i];var levelNodes=hier.distributionOrdering[level];if(levelNodes.length>1){for(var j=0;j<levelNodes.length-1;j++){var node1=levelNodes[j];var node2=levelNodes[j+1];// NOTE: logic maintained as it was; if nodes have same ancestor,
//       then of course they are in the same sub-network.
if(hier.hasSameParent(node1,node2)&&hier.inSameSubNetwork(node1,node2)){callback(node1,node2,centerParents);}}}}};// callback for shifting branches
var branchShiftCallback=function branchShiftCallback(node1,node2){var centerParent=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;//window.CALLBACKS.push(() => {
var pos1=_this3.direction.getPosition(node1);var pos2=_this3.direction.getPosition(node2);var diffAbs=Math.abs(pos2-pos1);var nodeSpacing=_this3.options.hierarchical.nodeSpacing;//console.log("NOW CHECKING:", node1.id, node2.id, diffAbs);
if(diffAbs>nodeSpacing){var branchNodes1={};var branchNodes2={};getBranchNodes(node1,branchNodes1);getBranchNodes(node2,branchNodes2);// check the largest distance between the branches
var maxLevel=getCollisionLevel(node1,node2);var branchNodeBoundary1=getBranchBoundary(branchNodes1,maxLevel);var branchNodeBoundary2=getBranchBoundary(branchNodes2,maxLevel);var max1=branchNodeBoundary1[1];var min2=branchNodeBoundary2[0];var minSpace2=branchNodeBoundary2[2];//console.log(node1.id, getBranchBoundary(branchNodes1, maxLevel), node2.id,
//            getBranchBoundary(branchNodes2, maxLevel), maxLevel);
var diffBranch=Math.abs(max1-min2);if(diffBranch>nodeSpacing){var offset=max1-min2+nodeSpacing;if(offset<-minSpace2+nodeSpacing){offset=-minSpace2+nodeSpacing;//console.log("RESETTING OFFSET", max1 - min2 + this.options.hierarchical.nodeSpacing, -minSpace2, offset);
}if(offset<0){//console.log("SHIFTING", node2.id, offset);
_this3._shiftBlock(node2.id,offset);stillShifting=true;if(centerParent===true)_this3._centerParent(node2);}}}//this.body.emitter.emit("_redraw");})
};var minimizeEdgeLength=function minimizeEdgeLength(iterations,node){//window.CALLBACKS.push(() => {
//  console.log("ts",node.id);
var nodeId=node.id;var allEdges=node.edges;var nodeLevel=_this3.hierarchical.levels[node.id];// gather constants
var C2=_this3.options.hierarchical.levelSeparation*_this3.options.hierarchical.levelSeparation;var referenceNodes={};var aboveEdges=[];for(var i=0;i<allEdges.length;i++){var edge=allEdges[i];if(edge.toId!=edge.fromId){var otherNode=edge.toId==nodeId?edge.from:edge.to;referenceNodes[allEdges[i].id]=otherNode;if(_this3.hierarchical.levels[otherNode.id]<nodeLevel){aboveEdges.push(edge);}}}// differentiated sum of lengths based on only moving one node over one axis
var getFx=function getFx(point,edges){var sum=0;for(var _i2=0;_i2<edges.length;_i2++){if(referenceNodes[edges[_i2].id]!==undefined){var a=_this3.direction.getPosition(referenceNodes[edges[_i2].id])-point;sum+=a/Math.sqrt(a*a+C2);}}return sum;};// doubly differentiated sum of lengths based on only moving one node over one axis
var getDFx=function getDFx(point,edges){var sum=0;for(var _i3=0;_i3<edges.length;_i3++){if(referenceNodes[edges[_i3].id]!==undefined){var a=_this3.direction.getPosition(referenceNodes[edges[_i3].id])-point;sum-=C2*Math.pow(a*a+C2,-1.5);}}return sum;};var getGuess=function getGuess(iterations,edges){var guess=_this3.direction.getPosition(node);// Newton's method for optimization
var guessMap={};for(var _i4=0;_i4<iterations;_i4++){var fx=getFx(guess,edges);var dfx=getDFx(guess,edges);// we limit the movement to avoid instability.
var limit=40;var ratio=Math.max(-limit,Math.min(limit,Math.round(fx/dfx)));guess=guess-ratio;// reduce duplicates
if(guessMap[guess]!==undefined){break;}guessMap[guess]=_i4;}return guess;};var moveBranch=function moveBranch(guess){// position node if there is space
var nodePosition=_this3.direction.getPosition(node);// check movable area of the branch
if(branches[node.id]===undefined){var branchNodes={};getBranchNodes(node,branchNodes);branches[node.id]=branchNodes;}var branchBoundary=getBranchBoundary(branches[node.id]);var minSpaceBranch=branchBoundary[2];var maxSpaceBranch=branchBoundary[3];var diff=guess-nodePosition;// check if we are allowed to move the node:
var branchOffset=0;if(diff>0){branchOffset=Math.min(diff,maxSpaceBranch-_this3.options.hierarchical.nodeSpacing);}else if(diff<0){branchOffset=-Math.min(-diff,minSpaceBranch-_this3.options.hierarchical.nodeSpacing);}if(branchOffset!=0){//console.log("moving branch:",branchOffset, maxSpaceBranch, minSpaceBranch)
_this3._shiftBlock(node.id,branchOffset);//this.body.emitter.emit("_redraw");
stillShifting=true;}};var moveNode=function moveNode(guess){var nodePosition=_this3.direction.getPosition(node);// position node if there is space
var _this3$_getSpaceAroun3=_this3._getSpaceAroundNode(node),_this3$_getSpaceAroun4=_slicedToArray(_this3$_getSpaceAroun3,2),minSpace=_this3$_getSpaceAroun4[0],maxSpace=_this3$_getSpaceAroun4[1];var diff=guess-nodePosition;// check if we are allowed to move the node:
var newPosition=nodePosition;if(diff>0){newPosition=Math.min(nodePosition+(maxSpace-_this3.options.hierarchical.nodeSpacing),guess);}else if(diff<0){newPosition=Math.max(nodePosition-(minSpace-_this3.options.hierarchical.nodeSpacing),guess);}if(newPosition!==nodePosition){//console.log("moving Node:",diff, minSpace, maxSpace);
_this3.direction.setPosition(node,newPosition);//this.body.emitter.emit("_redraw");
stillShifting=true;}};var guess=getGuess(iterations,aboveEdges);moveBranch(guess);guess=getGuess(iterations,allEdges);moveNode(guess);//})
};// method to remove whitespace between branches. Because we do bottom up, we can center the parents.
var minimizeEdgeLengthBottomUp=function minimizeEdgeLengthBottomUp(iterations){var levels=_this3.hierarchical.getLevels();levels=reverse(levels).call(levels);for(var i=0;i<iterations;i++){stillShifting=false;for(var j=0;j<levels.length;j++){var level=levels[j];var levelNodes=_this3.hierarchical.distributionOrdering[level];for(var k=0;k<levelNodes.length;k++){minimizeEdgeLength(1000,levelNodes[k]);}}if(stillShifting!==true){//console.log("FINISHED minimizeEdgeLengthBottomUp IN " + i);
break;}}};// method to remove whitespace between branches. Because we do bottom up, we can center the parents.
var shiftBranchesCloserBottomUp=function shiftBranchesCloserBottomUp(iterations){var levels=_this3.hierarchical.getLevels();levels=reverse(levels).call(levels);for(var i=0;i<iterations;i++){stillShifting=false;shiftElementsCloser(branchShiftCallback,levels,true);if(stillShifting!==true){//console.log("FINISHED shiftBranchesCloserBottomUp IN " + (i+1));
break;}}};// center all parents
var centerAllParents=function centerAllParents(){for(var nodeId in _this3.body.nodes){if(Object.prototype.hasOwnProperty.call(_this3.body.nodes,nodeId))_this3._centerParent(_this3.body.nodes[nodeId]);}};// center all parents
var centerAllParentsBottomUp=function centerAllParentsBottomUp(){var levels=_this3.hierarchical.getLevels();levels=reverse(levels).call(levels);for(var i=0;i<levels.length;i++){var level=levels[i];var levelNodes=_this3.hierarchical.distributionOrdering[level];for(var j=0;j<levelNodes.length;j++){_this3._centerParent(levelNodes[j]);}}};// the actual work is done here.
if(this.options.hierarchical.blockShifting===true){shiftBranchesCloserBottomUp(5);centerAllParents();}// minimize edge length
if(this.options.hierarchical.edgeMinimization===true){minimizeEdgeLengthBottomUp(20);}if(this.options.hierarchical.parentCentralization===true){centerAllParentsBottomUp();}shiftTrees();}/**
     * This gives the space around the node. IF a map is supplied, it will only check against nodes NOT in the map.
     * This is used to only get the distances to nodes outside of a branch.
     *
     * @param {Node} node
     * @param {{Node.id: vis.Node}} map
     * @returns {number[]}
     * @private
     */},{key:"_getSpaceAroundNode",value:function _getSpaceAroundNode(node,map){var useMap=true;if(map===undefined){useMap=false;}var level=this.hierarchical.levels[node.id];if(level!==undefined){var index=this.hierarchical.distributionIndex[node.id];var position=this.direction.getPosition(node);var ordering=this.hierarchical.distributionOrdering[level];var minSpace=1e9;var maxSpace=1e9;if(index!==0){var prevNode=ordering[index-1];if(useMap===true&&map[prevNode.id]===undefined||useMap===false){var prevPos=this.direction.getPosition(prevNode);minSpace=position-prevPos;}}if(index!=ordering.length-1){var nextNode=ordering[index+1];if(useMap===true&&map[nextNode.id]===undefined||useMap===false){var nextPos=this.direction.getPosition(nextNode);maxSpace=Math.min(maxSpace,nextPos-position);}}return[minSpace,maxSpace];}else{return[0,0];}}/**
     * We use this method to center a parent node and check if it does not cross other nodes when it does.
     *
     * @param {Node} node
     * @private
     */},{key:"_centerParent",value:function _centerParent(node){if(this.hierarchical.parentReference[node.id]){var parents=this.hierarchical.parentReference[node.id];for(var i=0;i<parents.length;i++){var parentId=parents[i];var parentNode=this.body.nodes[parentId];var children=this.hierarchical.childrenReference[parentId];if(children!==undefined){// get the range of the children
var newPosition=this._getCenterPosition(children);var position=this.direction.getPosition(parentNode);var _this$_getSpaceAround=this._getSpaceAroundNode(parentNode),_this$_getSpaceAround2=_slicedToArray(_this$_getSpaceAround,2),minSpace=_this$_getSpaceAround2[0],maxSpace=_this$_getSpaceAround2[1];var diff=position-newPosition;if(diff<0&&Math.abs(diff)<maxSpace-this.options.hierarchical.nodeSpacing||diff>0&&Math.abs(diff)<minSpace-this.options.hierarchical.nodeSpacing){this.direction.setPosition(parentNode,newPosition);}}}}}/**
     * This function places the nodes on the canvas based on the hierarchial distribution.
     *
     * @param {object} distribution | obtained by the function this._getDistribution()
     * @private
     */},{key:"_placeNodesByHierarchy",value:function _placeNodesByHierarchy(distribution){this.positionedNodes={};// start placing all the level 0 nodes first. Then recursively position their branches.
for(var level in distribution){if(Object.prototype.hasOwnProperty.call(distribution,level)){var _context;// sort nodes in level by position:
var nodeArray=keys$3(distribution[level]);nodeArray=this._indexArrayToNodes(nodeArray);sort(_context=this.direction).call(_context,nodeArray);var handledNodeCount=0;for(var i=0;i<nodeArray.length;i++){var node=nodeArray[i];if(this.positionedNodes[node.id]===undefined){var spacing=this.options.hierarchical.nodeSpacing;var pos=spacing*handledNodeCount;// We get the X or Y values we need and store them in pos and previousPos.
// The get and set make sure we get X or Y
if(handledNodeCount>0){pos=this.direction.getPosition(nodeArray[i-1])+spacing;}this.direction.setPosition(node,pos,level);this._validatePositionAndContinue(node,level,pos);handledNodeCount++;}}}}}/**
     * This is a recursively called function to enumerate the branches from the largest hubs and place the nodes
     * on a X position that ensures there will be no overlap.
     *
     * @param {Node.id} parentId
     * @param {number} parentLevel
     * @private
     */},{key:"_placeBranchNodes",value:function _placeBranchNodes(parentId,parentLevel){var _context2;var childRef=this.hierarchical.childrenReference[parentId];// if this is not a parent, cancel the placing. This can happen with multiple parents to one child.
if(childRef===undefined){return;}// get a list of childNodes
var childNodes=[];for(var i=0;i<childRef.length;i++){childNodes.push(this.body.nodes[childRef[i]]);}// use the positions to order the nodes.
sort(_context2=this.direction).call(_context2,childNodes);// position the childNodes
for(var _i5=0;_i5<childNodes.length;_i5++){var childNode=childNodes[_i5];var childNodeLevel=this.hierarchical.levels[childNode.id];// check if the child node is below the parent node and if it has already been positioned.
if(childNodeLevel>parentLevel&&this.positionedNodes[childNode.id]===undefined){// get the amount of space required for this node. If parent the width is based on the amount of children.
var spacing=this.options.hierarchical.nodeSpacing;var pos=void 0;// we get the X or Y values we need and store them in pos and previousPos.
// The get and set make sure we get X or Y
if(_i5===0){pos=this.direction.getPosition(this.body.nodes[parentId]);}else{pos=this.direction.getPosition(childNodes[_i5-1])+spacing;}this.direction.setPosition(childNode,pos,childNodeLevel);this._validatePositionAndContinue(childNode,childNodeLevel,pos);}else{return;}}// center the parent nodes.
var center=this._getCenterPosition(childNodes);this.direction.setPosition(this.body.nodes[parentId],center,parentLevel);}/**
     * This method checks for overlap and if required shifts the branch. It also keeps records of positioned nodes.
     * Finally it will call _placeBranchNodes to place the branch nodes.
     *
     * @param {Node} node
     * @param {number} level
     * @param {number} pos
     * @private
     */},{key:"_validatePositionAndContinue",value:function _validatePositionAndContinue(node,level,pos){// This method only works for formal trees and formal forests
// Early exit if this is not the case
if(!this.hierarchical.isTree)return;// if overlap has been detected, we shift the branch
if(this.lastNodeOnLevel[level]!==undefined){var previousPos=this.direction.getPosition(this.body.nodes[this.lastNodeOnLevel[level]]);if(pos-previousPos<this.options.hierarchical.nodeSpacing){var diff=previousPos+this.options.hierarchical.nodeSpacing-pos;var sharedParent=this._findCommonParent(this.lastNodeOnLevel[level],node.id);this._shiftBlock(sharedParent.withChild,diff);}}this.lastNodeOnLevel[level]=node.id;// store change in position.
this.positionedNodes[node.id]=true;this._placeBranchNodes(node.id,level);}/**
     * Receives an array with node indices and returns an array with the actual node references.
     * Used for sorting based on node properties.
     *
     * @param {Array.<Node.id>} idArray
     * @returns {Array.<Node>}
     */},{key:"_indexArrayToNodes",value:function _indexArrayToNodes(idArray){var array=[];for(var i=0;i<idArray.length;i++){array.push(this.body.nodes[idArray[i]]);}return array;}/**
     * This function get the distribution of levels based on hubsize
     *
     * @returns {object}
     * @private
     */},{key:"_getDistribution",value:function _getDistribution(){var distribution={};var nodeId,node;// we fix Y because the hierarchy is vertical,
// we fix X so we do not give a node an x position for a second time.
// the fix of X is removed after the x value has been set.
for(nodeId in this.body.nodes){if(Object.prototype.hasOwnProperty.call(this.body.nodes,nodeId)){node=this.body.nodes[nodeId];var level=this.hierarchical.levels[nodeId]===undefined?0:this.hierarchical.levels[nodeId];this.direction.fix(node,level);if(distribution[level]===undefined){distribution[level]={};}distribution[level][nodeId]=node;}}return distribution;}/**
     * Return the active (i.e. visible) edges for this node
     *
     * @param {Node} node
     * @returns {Array.<vis.Edge>} Array of edge instances
     * @private
     */},{key:"_getActiveEdges",value:function _getActiveEdges(node){var _this4=this;var result=[];forEach$1(node.edges,function(edge){var _context3;if(indexOf(_context3=_this4.body.edgeIndices).call(_context3,edge.id)!==-1){result.push(edge);}});return result;}/**
     * Get the hubsizes for all active nodes.
     *
     * @returns {number}
     * @private
     */},{key:"_getHubSizes",value:function _getHubSizes(){var _this5=this;var hubSizes={};var nodeIds=this.body.nodeIndices;forEach$1(nodeIds,function(nodeId){var node=_this5.body.nodes[nodeId];var hubSize=_this5._getActiveEdges(node).length;hubSizes[hubSize]=true;});// Make an array of the size sorted descending
var result=[];forEach$1(hubSizes,function(size){result.push(Number(size));});sort(timsort).call(timsort,result,function(a,b){return b-a;});return result;}/**
     * this function allocates nodes in levels based on the recursive branching from the largest hubs.
     *
     * @private
     */},{key:"_determineLevelsByHubsize",value:function _determineLevelsByHubsize(){var _this6=this;var levelDownstream=function levelDownstream(nodeA,nodeB){_this6.hierarchical.levelDownstream(nodeA,nodeB);};var hubSizes=this._getHubSizes();var _loop=function _loop(i){var hubSize=hubSizes[i];if(hubSize===0)return"break";forEach$1(_this6.body.nodeIndices,function(nodeId){var node=_this6.body.nodes[nodeId];if(hubSize===_this6._getActiveEdges(node).length){_this6._crawlNetwork(levelDownstream,nodeId);}});};for(var i=0;i<hubSizes.length;++i){var _ret=_loop(i);if(_ret==="break")break;}}/**
     * TODO: release feature
     * TODO: Determine if this feature is needed at all
     *
     * @private
     */},{key:"_determineLevelsCustomCallback",value:function _determineLevelsCustomCallback(){var _this7=this;var minLevel=100000;// TODO: this should come from options.
// eslint-disable-next-line no-unused-vars -- This should eventually be implemented with these parameters used.
var customCallback=function customCallback(nodeA,nodeB,edge){};// TODO: perhaps move to HierarchicalStatus.
//       But I currently don't see the point, this method is not used.
var levelByDirection=function levelByDirection(nodeA,nodeB,edge){var levelA=_this7.hierarchical.levels[nodeA.id];// set initial level
if(levelA===undefined){levelA=_this7.hierarchical.levels[nodeA.id]=minLevel;}var diff=customCallback(NetworkUtil.cloneOptions(nodeA,"node"),NetworkUtil.cloneOptions(nodeB,"node"),NetworkUtil.cloneOptions(edge,"edge"));_this7.hierarchical.levels[nodeB.id]=levelA+diff;};this._crawlNetwork(levelByDirection);this.hierarchical.setMinLevelToZero(this.body.nodes);}/**
     * Allocate nodes in levels based on the direction of the edges.
     *
     * @private
     */},{key:"_determineLevelsDirected",value:function _determineLevelsDirected(){var _context4,_this8=this;var nodes=reduce(_context4=this.body.nodeIndices).call(_context4,function(acc,id){acc.set(id,_this8.body.nodes[id]);return acc;},new map());if(this.options.hierarchical.shakeTowards==="roots"){this.hierarchical.levels=fillLevelsByDirectionRoots(nodes);}else{this.hierarchical.levels=fillLevelsByDirectionLeaves(nodes);}this.hierarchical.setMinLevelToZero(this.body.nodes);}/**
     * Update the bookkeeping of parent and child.
     *
     * @private
     */},{key:"_generateMap",value:function _generateMap(){var _this9=this;var fillInRelations=function fillInRelations(parentNode,childNode){if(_this9.hierarchical.levels[childNode.id]>_this9.hierarchical.levels[parentNode.id]){_this9.hierarchical.addRelation(parentNode.id,childNode.id);}};this._crawlNetwork(fillInRelations);this.hierarchical.checkIfTree();}/**
     * Crawl over the entire network and use a callback on each node couple that is connected to each other.
     *
     * @param {Function} [callback=function(){}]          | will receive nodeA, nodeB and the connecting edge. A and B are distinct.
     * @param {Node.id} startingNodeId
     * @private
     */},{key:"_crawlNetwork",value:function _crawlNetwork(){var _this10=this;var callback=arguments.length>0&&arguments[0]!==undefined?arguments[0]:function(){};var startingNodeId=arguments.length>1?arguments[1]:undefined;var progress={};var crawler=function crawler(node,tree){if(progress[node.id]===undefined){_this10.hierarchical.setTreeIndex(node,tree);progress[node.id]=true;var childNode;var edges=_this10._getActiveEdges(node);for(var i=0;i<edges.length;i++){var edge=edges[i];if(edge.connected===true){if(edge.toId==node.id){// Not '===' because id's can be string and numeric
childNode=edge.from;}else{childNode=edge.to;}if(node.id!=childNode.id){// Not '!==' because id's can be string and numeric
callback(node,childNode,edge);crawler(childNode,tree);}}}}};if(startingNodeId===undefined){// Crawl over all nodes
var treeIndex=0;// Serves to pass a unique id for the current distinct tree
for(var i=0;i<this.body.nodeIndices.length;i++){var nodeId=this.body.nodeIndices[i];if(progress[nodeId]===undefined){var node=this.body.nodes[nodeId];crawler(node,treeIndex);treeIndex+=1;}}}else{// Crawl from the given starting node
var _node2=this.body.nodes[startingNodeId];if(_node2===undefined){console.error("Node not found:",startingNodeId);return;}crawler(_node2);}}/**
     * Shift a branch a certain distance
     *
     * @param {Node.id} parentId
     * @param {number} diff
     * @private
     */},{key:"_shiftBlock",value:function _shiftBlock(parentId,diff){var _this11=this;var progress={};var shifter=function shifter(parentId){if(progress[parentId]){return;}progress[parentId]=true;_this11.direction.shift(parentId,diff);var childRef=_this11.hierarchical.childrenReference[parentId];if(childRef!==undefined){for(var i=0;i<childRef.length;i++){shifter(childRef[i]);}}};shifter(parentId);}/**
     * Find a common parent between branches.
     *
     * @param {Node.id} childA
     * @param {Node.id} childB
     * @returns {{foundParent, withChild}}
     * @private
     */},{key:"_findCommonParent",value:function _findCommonParent(childA,childB){var _this12=this;var parents={};var iterateParents=function iterateParents(parents,child){var parentRef=_this12.hierarchical.parentReference[child];if(parentRef!==undefined){for(var i=0;i<parentRef.length;i++){var parent=parentRef[i];parents[parent]=true;iterateParents(parents,parent);}}};var findParent=function findParent(parents,child){var parentRef=_this12.hierarchical.parentReference[child];if(parentRef!==undefined){for(var i=0;i<parentRef.length;i++){var parent=parentRef[i];if(parents[parent]!==undefined){return{foundParent:parent,withChild:child};}var branch=findParent(parents,parent);if(branch.foundParent!==null){return branch;}}}return{foundParent:null,withChild:child};};iterateParents(parents,childA);return findParent(parents,childB);}/**
     * Set the strategy pattern for handling the coordinates given the current direction.
     *
     * The individual instances contain all the operations and data specific to a layout direction.
     *
     * @param {Node} node
     * @param {{x: number, y: number}} position
     * @param {number} level
     * @param {boolean} [doNotUpdate=false]
     * @private
     */},{key:"setDirectionStrategy",value:function setDirectionStrategy(){var isVertical=this.options.hierarchical.direction==="UD"||this.options.hierarchical.direction==="DU";if(isVertical){this.direction=new VerticalStrategy(this);}else{this.direction=new HorizontalStrategy(this);}}/**
     * Determine the center position of a branch from the passed list of child nodes
     *
     * This takes into account the positions of all the child nodes.
     *
     * @param {Array.<Node|vis.Node.id>} childNodes  Array of either child nodes or node id's
     * @returns {number}
     * @private
     */},{key:"_getCenterPosition",value:function _getCenterPosition(childNodes){var minPos=1e9;var maxPos=-1e9;for(var i=0;i<childNodes.length;i++){var childNode=void 0;if(childNodes[i].id!==undefined){childNode=childNodes[i];}else{var childNodeId=childNodes[i];childNode=this.body.nodes[childNodeId];}var position=this.direction.getPosition(childNode);minPos=Math.min(minPos,position);maxPos=Math.max(maxPos,position);}return 0.5*(minPos+maxPos);}}]);return LayoutEngine;}();var css_248z="div.vis-network div.vis-manipulation {\n  box-sizing: content-box;\n\n  border-width: 0;\n  border-bottom: 1px;\n  border-style: solid;\n  border-color: #d6d9d8;\n  background: #ffffff; /* Old browsers */\n  background: -moz-linear-gradient(\n    top,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* FF3.6+ */\n  background: -webkit-gradient(\n    linear,\n    left top,\n    left bottom,\n    color-stop(0%, #ffffff),\n    color-stop(48%, #fcfcfc),\n    color-stop(50%, #fafafa),\n    color-stop(100%, #fcfcfc)\n  ); /* Chrome,Safari4+ */\n  background: -webkit-linear-gradient(\n    top,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* Chrome10+,Safari5.1+ */\n  background: -o-linear-gradient(\n    top,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* Opera 11.10+ */\n  background: -ms-linear-gradient(\n    top,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* IE10+ */\n  background: linear-gradient(\n    to bottom,\n    #ffffff 0%,\n    #fcfcfc 48%,\n    #fafafa 50%,\n    #fcfcfc 100%\n  ); /* W3C */\n  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#ffffff', endColorstr='#fcfcfc',GradientType=0 ); /* IE6-9 */\n\n  padding-top: 4px;\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 28px;\n}\n\ndiv.vis-network div.vis-edit-mode,\ndiv.vis-network button.vis-edit-mode {\n  position: absolute;\n  left: 0;\n  top: 5px;\n  height: 30px;\n}\n\n/* FIXME: shouldn't the vis-close button be a child of the vis-manipulation div? */\n\ndiv.vis-network button.vis-close {\n  position: absolute;\n  right: 0;\n  top: 0;\n  width: 30px;\n  height: 30px;\n\n  background-color: transparent;\n  background-position: 20px 3px;\n  background-repeat: no-repeat;\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAADvGaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICAgICAgICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgICAgICAgICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA8eG1wOkNyZWF0b3JUb29sPkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3htcDpDcmVhdG9yVG9vbD4KICAgICAgICAgPHhtcDpDcmVhdGVEYXRlPjIwMTQtMDItMTRUMTE6NTU6MzUrMDE6MDA8L3htcDpDcmVhdGVEYXRlPgogICAgICAgICA8eG1wOk1ldGFkYXRhRGF0ZT4yMDE0LTAyLTE0VDEyOjA1OjE3KzAxOjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICAgICA8eG1wOk1vZGlmeURhdGU+MjAxNC0wMi0xNFQxMjowNToxNyswMTowMDwveG1wOk1vZGlmeURhdGU+CiAgICAgICAgIDx4bXBNTTpJbnN0YW5jZUlEPnhtcC5paWQ6NjU0YmM5YmQtMWI2Yi1jYjRhLTllOWQtNWY2MzgxNDVjZjk0PC94bXBNTTpJbnN0YW5jZUlEPgogICAgICAgICA8eG1wTU06RG9jdW1lbnRJRD54bXAuZGlkOjk4MmM2MGIwLWUzZjMtMDk0MC04MjU0LTFiZTliNWE0ZTE4MzwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjk4MmM2MGIwLWUzZjMtMDk0MC04MjU0LTFiZTliNWE0ZTE4MzwveG1wTU06T3JpZ2luYWxEb2N1bWVudElEPgogICAgICAgICA8eG1wTU06SGlzdG9yeT4KICAgICAgICAgICAgPHJkZjpTZXE+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmNyZWF0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo5ODJjNjBiMC1lM2YzLTA5NDAtODI1NC0xYmU5YjVhNGUxODM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMTRUMTE6NTU6MzUrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjIxODYxNmM2LTM1MWMtNDI0OS04YWFkLWJkZDQ2ZTczNWE0NDwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0xNFQxMTo1NTozNSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6NjU0YmM5YmQtMWI2Yi1jYjRhLTllOWQtNWY2MzgxNDVjZjk0PC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAyLTE0VDEyOjA1OjE3KzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogICAgICAgICA8L3htcE1NOkhpc3Rvcnk+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzpmb3JtYXQ+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDAwMC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDAwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjc8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+NzwvZXhpZjpQaXhlbFlEaW1lbnNpb24+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+cZUZMwAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAA2ElEQVR42gDLADT/AS0tLUQFBQUVFxcXtPHx8fPl5eUNCAgITCkpKesEHx8fGgYGBjH+/v4a+Pj4qgQEBFU6OjodMTExzwQUFBSvEBAQEfX19SD19fVqNDQ0CElJSd/9/f2vAwEBAfrn5+fkBwcHLRYWFgsXFxfz29vbo9LS0uwDDQ0NDfPz81orKysXIyMj+ODg4Avh4eEa/f391gMkJCRYPz8/KUhISOMCAgKh8fHxHRsbGx4UFBQQBDk5OeY7Ozv7CAgItPb29vMEBASaJSUlTQ0NDesDAEwpT0Ko8Ri2AAAAAElFTkSuQmCC');\n  border: none;\n  cursor: pointer;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\ndiv.vis-network button.vis-close:hover {\n  opacity: 0.6;\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button,\ndiv.vis-network div.vis-edit-mode button.vis-button {\n  float: left;\n  font-family: verdana;\n  font-size: 12px;\n  border: none;\n  box-sizing: content-box;\n  -moz-border-radius: 15px;\n  border-radius: 15px;\n  background-color: transparent;\n  background-position: 0px 0px;\n  background-repeat: no-repeat;\n  height: 24px;\n  margin-left: 10px;\n  cursor: pointer;\n  padding: 0px 8px 0px 8px;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button:hover {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.2);\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button:active {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0.5);\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-back {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNTowMTowOSswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTU6MDE6MDkrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOmI2YjQwMjVkLTAxNjQtMzU0OC1hOTdlLTQ4ZmYxMWM3NTYzMzwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDpmOWQ3OGY4ZC1lNzY0LTc1NDgtODZiNy1iNmQ1OGMzZDg2OTc8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTU6MDE6MDkrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOmI2YjQwMjVkLTAxNjQtMzU0OC1hOTdlLTQ4ZmYxMWM3NTYzMzwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNTowMTowOSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOmY5ZDc4ZjhkLWU3NjQtNzU0OC04NmI3LWI2ZDU4YzNkODY5Nzwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4jq1U/AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAVTSURBVHjanFVfTFNnFP+d77ve8qeVFbBrpcVgRrCRFikFByLxwSAaE32oRCHD6JMxxhhn8G2RxxH3MsOTbyYsmCAxPMmMMYtkIUYmK60OO0qAK23BFlNob0uh3x7WS5jLZPpLbm6+k/P9zrm5v9855PF4UFhYCABgjIExBgAgIqRSqRIi6gDQRkQ1RGTB3wgR0e8AHgH4Sa/XR/EBiAiJRAJ04cIF5Ofng4g2n0gkUkxENwF0c843LzHGQEQQQkCLExEA9ALotVgsUQAQQmgNQhJCbF5kjCEUCl0moj4t5na7fTU1NUpVVVXUYrEkASAcDhe8efOmxOfzWScmJqoBdBNR99LS0hWz2dynNSSEAF28eBGFhYVgjCEcDn9HRD1EhIMHD3o9Hs9kWVlZAh9BKBQqGB4edr58+dKZ+6JbJpOpBwBWV1fB6+rqIMsyIpHIFcZYL2MMra2tY5cuXRrfuXNnBtvAYDBk3G63oqpqZm5uzgrgSDKZjBoMhueZTAbc5XIhFouVEtFTxhiOHTs2dv78eS8+Efv374+oqpqZnZ21cs5PJJPJPlmWkyynnBuMMTQ0NHi7uro+mVyDx+Pxulwu71ZOlkqlSonoJhGhvb39s8k1nDx50ss5hyRJN9PpdKlERB2aWjSVaEilUvzBgwcORVEs5eXloXPnzk1sV8BkMiUdDofP7/dXZ7PZDilnIhw4cGBeS1pbW2P37t1zBwKBikQiUUREWFhYsHHO0d7evm0Ru90+/+rVq2rO+XGJiJxEhMrKyhgAjI6OWoeHh5tWVla+4JzDZrO9bW5unhwcHGzz+/32np4e+xaDbfoHAMxmc6ijo2O0oqIiJkkSNjY2HBIRmRljMJvNyWfPnln7+/tPMMZQXl6+0NbW9qK2tjYcj8floaEhqKpq+HCkbD3PzMwYBgYG0NXV9UuusFna2kEgELAQEQ4dOvSis7PzN41Ar9dnrl27NqCNkv/C3bt3zy4tLVmICJxzEBFJRBQmorLFxcWCqqqq0Pj4eO3Y2JhbUZTdra2tL2pra8OJRGLHnTt3zkqS9K+huHU4EhHMZnMoGo0W5OIh7nK5jjLGKq1W69vDhw8rRqMxMjc3t2t5eXnX5ORklc/nM+fl5SWnpqa+0uv1K/n5+Ws6nW5NluXNd15e3ppOp1uz2WyzZ86cGQ0Gg6ZAIFCZzWZ/lYjokRDiuN/vt7W0tMw3NTUpbrd78P79++5gMFgRiUTKHj58WMYYQ3V19etTp05tq6Lp6Wkb5xxCiEfc7XZPM8a6FxcXTfX19a/1en2Gcy5qamreNjY2/qGq6joRZe12+9Tp06e3JY/FYgWPHz8+mhvr3/CWlpbk+vp6PmOseWVlBS6XS9GSJUkSdrs93NDQ8Oe+ffvC/8fJIyMjddFo9Esi6pVleVjT2m0A8Hq9zqGhIefnjoknT544A4GAM/eDbxMReFNTE0pKSpKqqsaI6Pj8/LxVVdWM3W6PfCr5xMTE1zllXS0uLn6aSqXAGxsbodPpoNfrn6uqCs75EUVRrJFIZMfevXsXdTrdxseIE4mEPDIyUu/3++tynd8yGo29RIR0Og26fv06ioqKwBgD5xzv3r27zBjrIyJIkgSHwzFZWVmp7NmzJ1ZaWpoAgGg0WqgoSvHMzIw1GAw6tvjhitFo7NPW5fv370Hd3d0oKCgA53zTQMvLy+VCiKuSJH0rSdLmztZytIWv5RPRD0T0Y3Fx8dzWfby6ugopHo//w4mcc8iyPMc5v5FOp7/PZrOdQohWInIC2C2EgBBigYi8Qoifs9lsv06nWyIiaFxagXg8jr8GAGxuIe7LBeWhAAAAAElFTkSuQmCC');\n}\n\ndiv.vis-network div.vis-manipulation div.vis-none:hover {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0);\n  cursor: default;\n}\ndiv.vis-network div.vis-manipulation div.vis-none:active {\n  box-shadow: 1px 1px 8px rgba(0, 0, 0, 0);\n}\ndiv.vis-network div.vis-manipulation div.vis-none {\n  padding: 0px;\n  line-height: 23px;\n}\ndiv.vis-network div.vis-manipulation div.notification {\n  margin: 2px;\n  font-weight: bold;\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-add {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNDo0MDoyOSswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTQ6NDA6MjkrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjVkNWIwNmQwLTVmMjAtOGE0NC1hMzIwLWZmMTEzMzQwNDc0YjwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo2OWVmYWE1NS01ZTI5LTIzNGUtYTUzMy0xNDkxYjM1NDNmYmE8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTQ6NDA6MjkrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjVkNWIwNmQwLTVmMjAtOGE0NC1hMzIwLWZmMTEzMzQwNDc0Yjwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNDo0MDoyOSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjY5ZWZhYTU1LTVlMjktMjM0ZS1hNTMzLTE0OTFiMzU0M2ZiYTwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz5WKqp9AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAYXSURBVHjafFZtUFTXGX7e9z27sveuMCwYV8ElrA7YSFYHtJUPkaaI0aRqG8wP00zUzljDINNSA/2ROtpO24SxnahlxjYd7SSjmUkymcxYlDhQPzHGisEVp8HwYWCVVVgEsrsuLnL74+5uqTF9Z+7cO/d8PO95zvO851BlZSV0XQcAMDOYGQBARDhX3JRmMDYZwLPMWAzGHACYIgwS46oBNBNwtOL8CwE8EkSEUCgE2rJlC2w2G4go8Zwo/bMDgnoG6gxLfAAAYvPDMCCszKTAMIAGAhrWnf15AAAMwwARIRKJgDZv3gy73Q4iAjPjxIr9VVOMRhbAYKB8zvrO0llrfEsdKwLZek6YAPSFvtSu3GtLawu0ZJ6625SHGBQB1T88t6MxvopgMAjaunUrdF0HM+P4yv27DMYeJmB1RqW3Jnf3tQX2p0L4P9EXuqEd7PmDp+XuMU9sRbvXnnt1TxxACgoKYLVacbzsQDUJGkSATe6qi28uPtzusM6Kxie6NHLGUX3lxVUNX9StPHnn4wy3njuUYcu6n2pNi66avcEXnByP/nv8aiaIyrqz2gO5A9+9FI1GIfn5+WhZdTAdjFMkwMvZOy7uWnTAOz3L4Yk71m3t69fdfTDoUGTBeHTUfiHQ6lo7Z2OXJvpDAChKe+aOCdKRKWxZ2+1qb3yyd3GYmRkQ7GQBVs99wfv6on3eR2k4PdTkDEbH7IuS8/svld/561PJS/pDk1/bzwx94pze7xc5v/H+YPY6r5BAkdrJzODTK46lE6PeYEJt7u+8j+OZwCBiEAgAoNgKJoEQf6PvNvdrXgtZoNhSf7q0KZ3B2AQmVMze0Jmt54S/DcDCVig2NcvEUGxJAE4Pl+YOr0iv6BRSIPAmBeBZAmHlE2sH4p1uhrq1s0MnnEQMBsf8wRASAICQQCCITN1X7/sOuc0kgOVp3/fPs2WHv+coG7gQOJUnLGsUCTxEjPzUohEA+NfIWUdtx0+efzA1kSSkIGyBAQNCKgHAEBAJ3u79U7kiAcWoem/gb5Fd33nrH3kp+SMWtuAB+GllMJxMjCx9QRgA3uiqL5kwHiTlpxb3smlfMDGYGPP1hcMAkJvs8ScpfdJspdj+MK6Pf+5+u29vyb4lR4+BGEziVESAkEpw6Av1OhUpHCz4qOXbzFWz4Ncdj/v/o08Lt92ODDgZDCEFJYoUGH4mzugP92puPTf0pD3H7wvfdFZdqSxnMtWjoGAAmG9fOLxjwesdjT2/XzIQ7ks3sycYMSEwGHNtWf5bkX5NkYCJBxUBXiGV0XHvosOt54Zey33j/K+8P33++vjnbiGJbbLE+J9SANAb6nJ2B79wcUwETAwQQ7fMjPzMvfP8ja87HUIKMOiaAqMZhrGmLdAy78eZrwwsTS0eObTs+IdtgVanxBUExqGbb5VzrIISGIoUXsmqbgEhJldCQWqRf27SvPAn/o8XmgLhZsUkR4ll37mhk3n94Z4OlzY/7NLcYZfm7o1z2zT4vsvUNSXqprBCkmiTFbPX90/fh8GIT2sf+zTPdDMf4dVnNg4z+E0ixsGeBs9jd5ViSgLHjCb/peaR+MD3d4/ZJg2llyuG2Vwy7QWAs8PNnn1f7vkGSGxAzE6mk+kxkx/p/4unffSCR0hAoL1EBCYiPNdWNcwkNQTCR7feWX6g+7f/A7I8rcw/U6UEe0Ndrhc/W7mtL9ztmqlSgstSS/zTJ28dalpOpkRryrwbhwBACgsLMWPGDOT4ll3qyeqAkJTdCF7P/CrUY/GkLL1rE+2hTbSH8+0Lb/WEuhzhyaA905blf9Vd/895WnZwLHrPevir/cvOB1oLYpTtLrm6oYGIMDExAaqtrUVKSgqYGSKCk0WHq5ikkWEWtNL0imv5qUW+RclLRjJsrhBAuH1/QL8R7HR4xy5nescuP23E6hOA6mLv+sb4uTw6Ogqqq6uDpmkQkcStorX4XRcM1FjZ+kvFFjCJKU1WpkNJJUqIMtX1RyLeX3JtQ0JRhmGYZ/L27duRnJycuFGISOJ9pqh5lrB6iYgqGOxRrOaa54DcZmKvkJxk8JHC9rKh+KVhOsD4+Dj+MwADIf8n5m4xGwAAAABJRU5ErkJggg==');\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-edit,\ndiv.vis-network div.vis-edit-mode button.vis-button.vis-edit {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNVQxNDoxMjoyNSswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDVUMTQ6MTI6MjUrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjY5OTM3ZGZjLTJjNzQtYTU0YS05OTIzLTQyMmZhNDNkMjljNDwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDozOWNhNzE5ZC03YzNlLTUyNGEtYmY1NS03NGVmMmM1MzE0YTc8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDVUMTQ6MTI6MjUrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjY5OTM3ZGZjLTJjNzQtYTU0YS05OTIzLTQyMmZhNDNkMjljNDwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNVQxNDoxMjoyNSswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjM5Y2E3MTlkLTdjM2UtNTI0YS1iZjU1LTc0ZWYyYzUzMTRhNzwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4ykninAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAYpSURBVHjafFZtTFvnFX7Oea+NudiY2Hwam4CBlgQwXdKREDKUoYg0jbRJ29RJ2VZ1mjRFUxSpA3VTfkzJfkQbS7spU6rtx5Z2UtppScjaHxvLuiatWi2jLEoMIUDCh23g2gbj7+tPuPvhOurawPl1dc99n+c55z33fV46ceIEZFkGADAziAgAQERoe/9ZK4GPM/AcgbsIXAcABCgMvkfAqAa89eDoJyF8LogIqqqChoaGYDAYHr8kItS8uc8iIH6iAa9IkAo5EAQX8pqmgUVBCBggYFgDhv0/GAsBgKZpICJkMhnQ4OAgZFkGEYGZUXmp+0cS+CKBwWA0DVRPOg5Zl2q6zaHyJlnVAMQXVTkwHrUqH0Xsvn+tdQAAMQDgpPLS2MViFY8rkGUZzIzaS/t/xqCzGggtz9e697zsnKhoLUtim4jOq/LE6x7X0nsh16dEZ5a/O3a2SCAOHjwInU6Hujd6ThJ4mCDQ+b2G232v7v6vwarPbQn8MGlMr+X0kpE3Wr5Zt5hL5HPhqYSdQIfKJ+yhxDPKWC6Xg+jt7UXD5b5KBt1kCHS85Ljd8/On3NupfnhFaZj4rWff1B98B1R/hnUmKd36bdtCNl4g0en4edNE/cXwLq8qMTMIPAQwmo/WuHvObA8+9c58k/dKtD0TyZWXN5YGA7ej7epKxspM//7SoNOdWc/Jyq2wiwhDzPxT8cP0jys3VMM7OmL0/77zn4Ydui3b8uiK0jD7RrA77c9Wd57cefPpF+2T6bWsFPWkaiPTCWvTsZpHFU+XrS+8G3AR08F6X+1FJvBxQQzHQOWk2SmrW4FPX/U2LVwPuDZj+fJKl2khPpeyAqA9rzR/YqwuiWXX8taN/CabGkrVuq9YJlkQQDjOAJ5jAhz9Vt9W4N5/rNp8I+vtMV/aZm4zLnUNNt0urdYnF68HWoJj4Wo1mLGUNRr8LEgDgNqeCh8xQIKOsgC7iAjVe83rT9zQa8uNM28u70kspessu8q8zq/V3NcZpVzb9+0zmVhOvvvrhaMVzrJg0zeq7xMVCCwdpnWSGBqjUyJwLTFgbvxie3w31uoWR1Y74r60rdxZqrR8q85t2W2MGCp12bm/KC3hyaSTiMhxuGrKcahqpbjOaDOoEhOEoFqJQCCJvqA85I6bfTdDjQlf2lbxVNlS6wt19yy7jRHZZlDnrinNj/6sHMhnNw2Ogco7O79e5fm/xQywRBBCEAuwn4gQ96bkYj4Vyuq9N1Z3Bj4Od5bs0MXt/dZZ21ctiqFan174q985P+Lfp+U1g7XDON/1ctP458WlVjLyJhOISZE0wM0S1QfuRC3lTjkJAKKEtNC9eIOhSh9xHLZOJRZTFuXDsEoStLkR/768ummsaJG9Pb9oe+9J+xaeSVokiQDSJphAo5uaBuWjiKP4QTqS1cUWU7ayesN66wu22frD1vmVW6GW6T8u9eVjGyZzs+w78Nqu0a2mbvVu1KEJQAgeZRL0liQYyx+GOmKeQpu0rMYsAJPNEFGD2dLodLIy6c9Ys7G8yeSUl3tf2/X3rcBVJSOv34l3sCBogi7z1LH/rBHjl4IJ93/ncQFAnjeImJD0Z8zuCwu9q3djDXqTlAKID5xv+9t2R8n8VcUFBljQ8Gyfe40BYBM4DwDLt8Kue79ZcFkbzfEdbUbv+oN4c9KTtsfm1MbYQqqh+2zrVZYKs/7Ef+byimt1POYiJhDhPBFBIiIEXhxfs7/dfYoIF+auBfYTE/pebx/V8hqBP2ODvD34yvuh/WCAmU75Bx6sIgaI/v5+6PV6JLqUsYr7dpDAoehs0h73pHTWrvKgThYbRSt9UmSjef3MpaUvBz4O72UmADgTOPJguGiZor+/HyUlJWBmJFz+D8xTtlUiOpbwpmrmrweeSXrT+g11k4SBN3RGKUcAVCVdFhyP1nreDbY//NPyEXUlU/Pp4XYycGT6V0Ux2WwWdO7cOZSWlkII8diX7SPPNgDaKdbxoNAxwATBAEkEEgSWCEQAqPAMwqvMdCEwMO0tVqZpWsGTT58+DaPR+PhGIYQAAAgh0P7B3ioW/B0iGiCGiwXbCuOHFSJys6AbYFye2T+xWhT3WYJEIoH/DQBMw3kes8OJPgAAAABJRU5ErkJggg==');\n}\n\ndiv.vis-network div.vis-edit-mode button.vis-button.vis-edit.vis-edit-mode {\n  background-color: #fcfcfc;\n  border: 1px solid #cccccc;\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-connect {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNDozODo1NyswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTQ6Mzg6NTcrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjlmYjUwMDU0LWE3ODEtMWQ0OC05ZTllLTU2ZWQ5YzhlYjdjNjwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo3ZWRhMjI0MC0yYTQxLTNlNDQtYWM2My1iNzNiYTE5OWI3Y2E8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTQ6Mzg6NTcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjlmYjUwMDU0LWE3ODEtMWQ0OC05ZTllLTU2ZWQ5YzhlYjdjNjwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNDozODo1NyswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjdlZGEyMjQwLTJhNDEtM2U0NC1hYzYzLWI3M2JhMTk5YjdjYTwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4ubxs+AAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAUtSURBVHjajJZ/bNT1Gcdfz/P53PV6B4W7VltLqdAaplIOiMOoyxxJCSs/Gv/yB4gzJroAosmmDklwkYWR0bQsdmkykoojTpcsWYLxD/lRZdMQkTHRtkLZRqG0tIVe7662vTu43n32x/VKZ/jh89cn38/zvN7P5/l88zwf2blzJz6fDwARQUSm1n8s31CM0/VAnbNmsUPuAsDpgEO+Bg4C7//iyv5hvmMiQiqVQpqamvB6vVNwEeG1JZtCBrYi/MrkAwDNgjhwAlbzICBLA0rDb0+/839C6XQaaWxspLCw8Dp86cbNmqVFJQddE6KzdjZ9D89g+B6fSyCOcyn1nxil+O9xKg5HqWFSHGXLjrP7W/ICqVQK2bNnDz6fDxFh65KNvxbHDhF4rJj2bXPo+IGfcW5h5xL4f99P+FCEMIAob75x9t0dAMlkElNXV4e1lteXbNqiQoMaeOFOjrdU868SD2luYyEP6dUh+sYmSHeOU6GO5Z8VLx5+NNZxIpPJ5AS2L3upROCoCvz8Lo7vnkf77cAHhpiz/zIL9vWz8L8p/NvupmM0Q7pjnAoLqz8tDrc8MnQqYVUVhVdF4LEg7b+rvDn8wDDlH0WoPpukLJImSBaMwjcJqmwWts2jPZLG/8kwYVFeVdXXZcFf4yVDc2cNKfBFmD9X+0ncCP58F48eG+Feo2CAUkvs4dl0V/uJvdXLiiV+ut++n7YLSfxPfMMG54ChzB3WIesVWB2i82bw1AR6fJR7C4VsfYiv6u/k3A9nEgP4zXke8DiYHyAOMK+QxPIgnZ9GqSHr1itQJ8DK2fTerDQ+S/bHRXQJaHSCwNIZ2Xh+7+S3VAmwNMBA/tuPZtErgKquUmdMWIFlRURvdamRNEXGwIWrlP47pTMzLiunxghGMwTLvcTWlHAp77s4QNSrYMQtss6ZMgWqCm5cHoDHO1nbk6K8zEN8+3zatv2Hn1b59EqJZdxmYUERg9P9KwpIiAOTdWUWBXuLzB/vZG3P1Un4PNp2d1MbmyD45TWCxuCsQm0x56bHGHFYEZwxok7toAA9Sfw3hCcoL/NOwi9QO5wmWO1j4JEgZxTkodmcWRGkf3pcX0r8xoAaBixKu4U5/xwndM+0tpAvS6mP+PZK2nb1UBvPEKwKMLDvPj4ESGc55lGy303sdJKQdZB2rkMdctAB/4gzN+/Q2ENNd4LyUi/xN+bTtquX2thk5nk4wI3gAF+OMNcA1nFQDfK+BY5GqbkwWabTY5QZhXWlnNx1ntrY1Rz87fuvw29m/Sn8J+PUGAFj5T19baA1IspuBZp7cx1x4SwG1cEf+lgRSROs8jGwb+Ht4QB/GSSsAhYano39LWIBxNEIbP14hPDuiyS2VtJuHXQlKKvxM/jiXDq/D/xPlwifGMkJZB2NIoKpr69nxeiZxLHicFSFVWfGqBidIP3LSjrWltD94CyufF/4kQgPuVz2Lz93+dDRa9eu5QQ8Hg8/iXee+Dy4CKMs7xqn4nwKz9IirhQqmVuB42m8ey+x7LMoD6iAON782eChhqmRuXfvXgKBAKqKqtI0/8nNKrQI4BVYXkzHgzPpC88gWuHL/caXrhLoGiN0apSKr0ZZRBZM7q2w5ZnLR1oAnHOMjY0hra2tFBQUYIyZmstvVT1Z6eDlAuEVq7merxmwueNPDXy9PvybjKP5mctHLk4/XTKZRJqbm/H7/VNw1VyEMYbW4FN3WNWnnchKoy5sHeVGBRX6VWi3ymFx7r11Ix8MTX/y5C2RSPC/AQB61erowbpqSwAAAABJRU5ErkJggg==');\n}\n\ndiv.vis-network div.vis-manipulation button.vis-button.vis-delete {\n  background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEEOaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNC0wMi0wNFQxNDo0MTowNCswMTowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMDItMDRUMTQ6NDE6MDQrMDE6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjc3NDkzYmUxLTEyZGItOTg0NC1iNDYyLTg2NGVmNGIzMzM3MTwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+Y3JlYXRlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE0LTAxLTIyVDE5OjI0OjUxKzAxOjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6RUE2MEEyNEUxOTg0RTMxMUFEQUZFRkU2RUMzMzNFMDM8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDEtMjNUMTk6MTg6MDcrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDowNmE3NWYwMy04MDdhLWUzNGYtYjk1Zi1jZGU2MjM0Mzg4OGY8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTQtMDItMDRUMTQ6NDE6MDQrMDE6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cyk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVycz4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjc3NDkzYmUxLTEyZGItOTg0NC1iNDYyLTg2NGVmNGIzMzM3MTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNC0wMi0wNFQxNDo0MTowNCswMTowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8eG1wTU06RGVyaXZlZEZyb20gcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICA8c3RSZWY6aW5zdGFuY2VJRD54bXAuaWlkOjA2YTc1ZjAzLTgwN2EtZTM0Zi1iOTVmLWNkZTYyMzQzODg4Zjwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDpFQTc2MkY5Njc0ODNFMzExOTQ4QkQxM0UyQkU3OTlBMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjczQjYyQUFEOTE4M0UzMTE5NDhCRDEzRTJCRTc5OUExPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZEZyb20+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDA5MC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDkwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWERpbWVuc2lvbj4KICAgICAgICAgPGV4aWY6UGl4ZWxZRGltZW5zaW9uPjI0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz4aYJzYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAYGSURBVHjalJZ7UJTnFcZ/73m/72PdJY1RbhoQp6lkXRAvmIYxdCUadLVOozPNtGObap1JsKipjiShbdoRbeKEiQHpQK3xj0xa03aamTbaTGyAYV1QGeqFi+JyiZFLAlmESBkWRmS3fyzslGkmnZ5/v/M873Oe75zzvqqoqAibzQaAiKCUAkApRdHIK/NFsx2NR91nOSILADDoJyzNaM4xxbtvPHh0iC+JiYkJ1OHDh4mJiUEpFSXPv/ziPC28TIiXDCOSrAClQDSEpsCwJPIhrEBRQpiSytXlQwDhcBilFPfu3UMVFxdjt9ujFTzfcLBADCoEEAFr1ZbrrNjch2vtEImPBgHob7fTcWE+bVXJNJ/NiFQlEGLvieXHKmYqGB8fRx05cgSbzYaIsPvywV8pKFaA7fGtLTzz61YWpo/xVTHQbufsq5lcez9zWuWhk5mvFwMEg0H0+vXrMU2Tn1wp3CtCiQ5DjGd3A/m/v8IDCZP8r4iNmyRrWx/j/5qktykZpXKzAjVDVxPzGqemptDr1q1jX3NRnIJarcDKK2hgR2ULXRfncv7UYv7xpovhnhiW5Mz+kefeSKO6LJ1A1xzEuk/Ojm4mRibpuZaMZW3OCtRUND60NmiICCIUShisx7a2sLMiQn4s77uEQgIabnqdfHIlgT1/qQeg8vs5dHhdCNB1wYn3RIiC995j26stjAbsNH+YiZJCESnS1Y/XxIXu8r4YIPv/VkVs3CTnTy2ms34xro1+sp9po6sxlTu34ultmsPVvy6is86FCHgO+DDs49zpjufBpCG+seYOC9OHaTidieicb9ouVAhKtouAseI710ma7pLuqwmgYfHqAFt+6WdLoQ/LBl11Lm7VudAa8vb72PCin9TlAWIsGGhLACD+kSAZnusYBii1XQAPYWDllt6ov2lrBkDBR2+6Ofuak2//3M+G/T4wAAPW7fPhKfRTVeqk9qQbFKRmDUTxS3N7QYGYmwzCkqklBGlPDEcTNv+sg9tNCbTXuvBWujE0bHrZj9JE1B/wU1Pm5PwJN6YBS9a2kVvQEcWnrh5GTFD3lxkYkqRMgYQlwVldUvDnen73LHTUuqitdKM0eAr9AFQfd1J/yo2aJn+2sn4Wdn5qEFODJskgBIjx5T0uCrQA08pnIjS9PERDjPnfOKXAMEBECUoGEIHBj+2zkt76UQ6dXheGAev3+cg74Kf6uJPqcicbfuond7cPy4SOiy7+tD9nFvZurx00KOk3CNEC+mE+vjSPBc7IWqgqTaPT60IMcO/xsXGa3HfKjRgRdbl7/KDg0jtubje6aHj7c7J3dgLQ2zoPwwQ91SooOQdAW1VKVMHty0kA5Bb48BycJn/LjWFGbLv4thvvb53kFvjJ+XEdWkPfjQVR/CcNKYgGMc8JWt5Fa2j+MIPPuyI2pa4IoHSkt6vLIuRaQ9q32khzt4GCxtNu6k46GeiIR2lIfDQQsafPzq1LGRGL9Gk9d+vrwewvfHPQOoexQVjxdB/auk/zmaUMdsfz6bVUtIalT7bxveP1ZHh6GPDPYeSzeD69kcpIfxymFWLNrka+ljhBTWkWwz2JiJT84YHnz2iPx0P20PkmRF5i6HYiwZFJsn/YzdezbzE3cQibY5xV266z6RfXohakb+xB9CjanCD9qTbW7Grk4WV38VZm0l6dhQiEw9taHSuDqrS0FIfDwXM3X9mHMsvRAk/sauDpQy38P+GtzOTGB9mEpkD0C2dS8n8zOjqK9ng8WJZFU+JTjasGvaCNXPpvJBPoMlm0OoDNMfWVxONfWNSUPUZ7TUQ56tCZlPwSgMnJSVRpaSmxsbFE1raw82ZxAZZRQUiBYUKGp5UlOX2krBzmoUVjiIKhHge9rfPo+Wcy3ZeXIYASgL1/X5RfMXMvj46OosrLy7HZbGitUUohIuzoem0RofALaOsghgWGjky0MiJTL8b0lOvI8hN1DKXKP0jd3TNTWDgcJhgMoo4ePYrD4Yi+KmaeLlprnrtXFo9h/AAlG1AqE8yFmBrC+jO0bgH9EVpO/1F2Dc5g//OAsbEx/j0Af+USsQynL1UAAAAASUVORK5CYII=');\n}\n/* top right bottom left */\ndiv.vis-network div.vis-manipulation div.vis-label,\ndiv.vis-network div.vis-edit-mode div.vis-label {\n  margin: 0 0 0 23px;\n  line-height: 25px;\n}\ndiv.vis-network div.vis-manipulation div.vis-separator-line {\n  float: left;\n  display: inline-block;\n  width: 1px;\n  height: 21px;\n  background-color: #bdbdbd;\n  margin: 0px 7px 0 15px; /*top right bottom left*/\n}\n\n/* TODO: is this redundant?\ndiv.network-navigation_wrapper {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n}\n*/\n";styleInject(css_248z);function _createForOfIteratorHelper(o,allowArrayLike){var it=typeof symbol!=="undefined"&&getIteratorMethod(o)||o["@@iterator"];if(!it){if(isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length==="number"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};},e:function e(_e){throw _e;},f:F};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion=true,didErr=false,err;return{s:function s(){it=it.call(o);},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e2){didErr=true;err=_e2;},f:function f(){try{if(!normalCompletion&&it.return!=null)it.return();}finally{if(didErr)throw err;}}};}function _unsupportedIterableToArray(o,minLen){var _context32;if(!o)return;if(typeof o==="string")return _arrayLikeToArray(o,minLen);var n=slice$1(_context32=Object.prototype.toString.call(o)).call(_context32,8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return from$2(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}/**
 * Clears the toolbar div element of children
 *
 * @private
 */var ManipulationSystem=/*#__PURE__*/function(){/**
   * @param {object} body
   * @param {Canvas} canvas
   * @param {SelectionHandler} selectionHandler
   * @param {InteractionHandler} interactionHandler
   */function ManipulationSystem(body,canvas,selectionHandler,interactionHandler){var _this=this,_context,_context2;_classCallCheck(this,ManipulationSystem);this.body=body;this.canvas=canvas;this.selectionHandler=selectionHandler;this.interactionHandler=interactionHandler;this.editMode=false;this.manipulationDiv=undefined;this.editModeDiv=undefined;this.closeDiv=undefined;this._domEventListenerCleanupQueue=[];this.temporaryUIFunctions={};this.temporaryEventFunctions=[];this.touchTime=0;this.temporaryIds={nodes:[],edges:[]};this.guiEnabled=false;this.inMode=false;this.selectedControlNode=undefined;this.options={};this.defaultOptions={enabled:false,initiallyActive:false,addNode:true,addEdge:true,editNode:undefined,editEdge:true,deleteNode:true,deleteEdge:true,controlNodeStyle:{shape:"dot",size:6,color:{background:"#ff0000",border:"#3c3c3c",highlight:{background:"#07f968",border:"#3c3c3c"}},borderWidth:2,borderWidthSelected:2}};assign$2(this.options,this.defaultOptions);this.body.emitter.on("destroy",function(){_this._clean();});this.body.emitter.on("_dataChanged",bind(_context=this._restore).call(_context,this));this.body.emitter.on("_resetData",bind(_context2=this._restore).call(_context2,this));}/**
   * If something changes in the data during editing, switch back to the initial datamanipulation state and close all edit modes.
   *
   * @private
   */_createClass(ManipulationSystem,[{key:"_restore",value:function _restore(){if(this.inMode!==false){if(this.options.initiallyActive===true){this.enableEditMode();}else{this.disableEditMode();}}}/**
     * Set the Options
     *
     * @param {object} options
     * @param {object} allOptions
     * @param {object} globalOptions
     */},{key:"setOptions",value:function setOptions(options,allOptions,globalOptions){if(allOptions!==undefined){if(allOptions.locale!==undefined){this.options.locale=allOptions.locale;}else{this.options.locale=globalOptions.locale;}if(allOptions.locales!==undefined){this.options.locales=allOptions.locales;}else{this.options.locales=globalOptions.locales;}}if(options!==undefined){if(typeof options==="boolean"){this.options.enabled=options;}else{this.options.enabled=true;deepExtend(this.options,options);}if(this.options.initiallyActive===true){this.editMode=true;}this._setup();}}/**
     * Enable or disable edit-mode. Draws the DOM required and cleans up after itself.
     *
     * @private
     */},{key:"toggleEditMode",value:function toggleEditMode(){if(this.editMode===true){this.disableEditMode();}else{this.enableEditMode();}}/**
     * Enables Edit Mode
     */},{key:"enableEditMode",value:function enableEditMode(){this.editMode=true;this._clean();if(this.guiEnabled===true){this.manipulationDiv.style.display="block";this.closeDiv.style.display="block";this.editModeDiv.style.display="none";this.showManipulatorToolbar();}}/**
     * Disables Edit Mode
     */},{key:"disableEditMode",value:function disableEditMode(){this.editMode=false;this._clean();if(this.guiEnabled===true){this.manipulationDiv.style.display="none";this.closeDiv.style.display="none";this.editModeDiv.style.display="block";this._createEditButton();}}/**
     * Creates the main toolbar. Removes functions bound to the select event. Binds all the buttons of the toolbar.
     *
     * @private
     */},{key:"showManipulatorToolbar",value:function showManipulatorToolbar(){// restore the state of any bound functions or events, remove control nodes, restore physics
this._clean();// reset global variables
this.manipulationDOM={};// if the gui is enabled, draw all elements.
if(this.guiEnabled===true){var _context3,_context4;// a _restore will hide these menus
this.editMode=true;this.manipulationDiv.style.display="block";this.closeDiv.style.display="block";var selectedNodeCount=this.selectionHandler.getSelectedNodeCount();var selectedEdgeCount=this.selectionHandler.getSelectedEdgeCount();var selectedTotalCount=selectedNodeCount+selectedEdgeCount;var locale=this.options.locales[this.options.locale];var needSeperator=false;if(this.options.addNode!==false){this._createAddNodeButton(locale);needSeperator=true;}if(this.options.addEdge!==false){if(needSeperator===true){this._createSeperator(1);}else{needSeperator=true;}this._createAddEdgeButton(locale);}if(selectedNodeCount===1&&typeof this.options.editNode==="function"){if(needSeperator===true){this._createSeperator(2);}else{needSeperator=true;}this._createEditNodeButton(locale);}else if(selectedEdgeCount===1&&selectedNodeCount===0&&this.options.editEdge!==false){if(needSeperator===true){this._createSeperator(3);}else{needSeperator=true;}this._createEditEdgeButton(locale);}// remove buttons
if(selectedTotalCount!==0){if(selectedNodeCount>0&&this.options.deleteNode!==false){if(needSeperator===true){this._createSeperator(4);}this._createDeleteButton(locale);}else if(selectedNodeCount===0&&this.options.deleteEdge!==false){if(needSeperator===true){this._createSeperator(4);}this._createDeleteButton(locale);}}// bind the close button
this._bindElementEvents(this.closeDiv,bind(_context3=this.toggleEditMode).call(_context3,this));// refresh this bar based on what has been selected
this._temporaryBindEvent("select",bind(_context4=this.showManipulatorToolbar).call(_context4,this));}// redraw to show any possible changes
this.body.emitter.emit("_redraw");}/**
     * Create the toolbar for adding Nodes
     */},{key:"addNodeMode",value:function addNodeMode(){var _context6;// when using the gui, enable edit mode if it wasnt already.
if(this.editMode!==true){this.enableEditMode();}// restore the state of any bound functions or events, remove control nodes, restore physics
this._clean();this.inMode="addNode";if(this.guiEnabled===true){var _context5;var locale=this.options.locales[this.options.locale];this.manipulationDOM={};this._createBackButton(locale);this._createSeperator();this._createDescription(locale["addDescription"]||this.options.locales["en"]["addDescription"]);// bind the close button
this._bindElementEvents(this.closeDiv,bind(_context5=this.toggleEditMode).call(_context5,this));}this._temporaryBindEvent("click",bind(_context6=this._performAddNode).call(_context6,this));}/**
     * call the bound function to handle the editing of the node. The node has to be selected.
     */},{key:"editNode",value:function editNode(){var _this2=this;// when using the gui, enable edit mode if it wasnt already.
if(this.editMode!==true){this.enableEditMode();}// restore the state of any bound functions or events, remove control nodes, restore physics
this._clean();var node=this.selectionHandler.getSelectedNodes()[0];if(node!==undefined){this.inMode="editNode";if(typeof this.options.editNode==="function"){if(node.isCluster!==true){var data=deepExtend({},node.options,false);data.x=node.x;data.y=node.y;if(this.options.editNode.length===2){this.options.editNode(data,function(finalizedData){if(finalizedData!==null&&finalizedData!==undefined&&_this2.inMode==="editNode"){// if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
_this2.body.data.nodes.getDataSet().update(finalizedData);}_this2.showManipulatorToolbar();});}else{throw new Error("The function for edit does not support two arguments (data, callback)");}}else{alert(this.options.locales[this.options.locale]["editClusterError"]||this.options.locales["en"]["editClusterError"]);}}else{throw new Error("No function has been configured to handle the editing of nodes.");}}else{this.showManipulatorToolbar();}}/**
     * create the toolbar to connect nodes
     */},{key:"addEdgeMode",value:function addEdgeMode(){var _context8,_context9,_context10,_context11,_context12;// when using the gui, enable edit mode if it wasnt already.
if(this.editMode!==true){this.enableEditMode();}// restore the state of any bound functions or events, remove control nodes, restore physics
this._clean();this.inMode="addEdge";if(this.guiEnabled===true){var _context7;var locale=this.options.locales[this.options.locale];this.manipulationDOM={};this._createBackButton(locale);this._createSeperator();this._createDescription(locale["edgeDescription"]||this.options.locales["en"]["edgeDescription"]);// bind the close button
this._bindElementEvents(this.closeDiv,bind(_context7=this.toggleEditMode).call(_context7,this));}// temporarily overload functions
this._temporaryBindUI("onTouch",bind(_context8=this._handleConnect).call(_context8,this));this._temporaryBindUI("onDragEnd",bind(_context9=this._finishConnect).call(_context9,this));this._temporaryBindUI("onDrag",bind(_context10=this._dragControlNode).call(_context10,this));this._temporaryBindUI("onRelease",bind(_context11=this._finishConnect).call(_context11,this));this._temporaryBindUI("onDragStart",bind(_context12=this._dragStartEdge).call(_context12,this));this._temporaryBindUI("onHold",function(){});}/**
     * create the toolbar to edit edges
     */},{key:"editEdgeMode",value:function editEdgeMode(){// when using the gui, enable edit mode if it wasn't already.
if(this.editMode!==true){this.enableEditMode();}// restore the state of any bound functions or events, remove control nodes, restore physics
this._clean();this.inMode="editEdge";if(_typeof(this.options.editEdge)==="object"&&typeof this.options.editEdge.editWithoutDrag==="function"){this.edgeBeingEditedId=this.selectionHandler.getSelectedEdgeIds()[0];if(this.edgeBeingEditedId!==undefined){var edge=this.body.edges[this.edgeBeingEditedId];this._performEditEdge(edge.from.id,edge.to.id);return;}}if(this.guiEnabled===true){var _context13;var locale=this.options.locales[this.options.locale];this.manipulationDOM={};this._createBackButton(locale);this._createSeperator();this._createDescription(locale["editEdgeDescription"]||this.options.locales["en"]["editEdgeDescription"]);// bind the close button
this._bindElementEvents(this.closeDiv,bind(_context13=this.toggleEditMode).call(_context13,this));}this.edgeBeingEditedId=this.selectionHandler.getSelectedEdgeIds()[0];if(this.edgeBeingEditedId!==undefined){var _context14,_context15,_context16,_context17;var _edge=this.body.edges[this.edgeBeingEditedId];// create control nodes
var controlNodeFrom=this._getNewTargetNode(_edge.from.x,_edge.from.y);var controlNodeTo=this._getNewTargetNode(_edge.to.x,_edge.to.y);this.temporaryIds.nodes.push(controlNodeFrom.id);this.temporaryIds.nodes.push(controlNodeTo.id);this.body.nodes[controlNodeFrom.id]=controlNodeFrom;this.body.nodeIndices.push(controlNodeFrom.id);this.body.nodes[controlNodeTo.id]=controlNodeTo;this.body.nodeIndices.push(controlNodeTo.id);// temporarily overload UI functions, cleaned up automatically because of _temporaryBindUI
this._temporaryBindUI("onTouch",bind(_context14=this._controlNodeTouch).call(_context14,this));// used to get the position
this._temporaryBindUI("onTap",function(){});// disabled
this._temporaryBindUI("onHold",function(){});// disabled
this._temporaryBindUI("onDragStart",bind(_context15=this._controlNodeDragStart).call(_context15,this));// used to select control node
this._temporaryBindUI("onDrag",bind(_context16=this._controlNodeDrag).call(_context16,this));// used to drag control node
this._temporaryBindUI("onDragEnd",bind(_context17=this._controlNodeDragEnd).call(_context17,this));// used to connect or revert control nodes
this._temporaryBindUI("onMouseMove",function(){});// disabled
// create function to position control nodes correctly on movement
// automatically cleaned up because we use the temporary bind
this._temporaryBindEvent("beforeDrawing",function(ctx){var positions=_edge.edgeType.findBorderPositions(ctx);if(controlNodeFrom.selected===false){controlNodeFrom.x=positions.from.x;controlNodeFrom.y=positions.from.y;}if(controlNodeTo.selected===false){controlNodeTo.x=positions.to.x;controlNodeTo.y=positions.to.y;}});this.body.emitter.emit("_redraw");}else{this.showManipulatorToolbar();}}/**
     * delete everything in the selection
     */},{key:"deleteSelected",value:function deleteSelected(){var _this3=this;// when using the gui, enable edit mode if it wasnt already.
if(this.editMode!==true){this.enableEditMode();}// restore the state of any bound functions or events, remove control nodes, restore physics
this._clean();this.inMode="delete";var selectedNodes=this.selectionHandler.getSelectedNodeIds();var selectedEdges=this.selectionHandler.getSelectedEdgeIds();var deleteFunction=undefined;if(selectedNodes.length>0){for(var i=0;i<selectedNodes.length;i++){if(this.body.nodes[selectedNodes[i]].isCluster===true){alert(this.options.locales[this.options.locale]["deleteClusterError"]||this.options.locales["en"]["deleteClusterError"]);return;}}if(typeof this.options.deleteNode==="function"){deleteFunction=this.options.deleteNode;}}else if(selectedEdges.length>0){if(typeof this.options.deleteEdge==="function"){deleteFunction=this.options.deleteEdge;}}if(typeof deleteFunction==="function"){var data={nodes:selectedNodes,edges:selectedEdges};if(deleteFunction.length===2){deleteFunction(data,function(finalizedData){if(finalizedData!==null&&finalizedData!==undefined&&_this3.inMode==="delete"){// if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
_this3.body.data.edges.getDataSet().remove(finalizedData.edges);_this3.body.data.nodes.getDataSet().remove(finalizedData.nodes);_this3.body.emitter.emit("startSimulation");_this3.showManipulatorToolbar();}else{_this3.body.emitter.emit("startSimulation");_this3.showManipulatorToolbar();}});}else{throw new Error("The function for delete does not support two arguments (data, callback)");}}else{this.body.data.edges.getDataSet().remove(selectedEdges);this.body.data.nodes.getDataSet().remove(selectedNodes);this.body.emitter.emit("startSimulation");this.showManipulatorToolbar();}}//********************************************** PRIVATE ***************************************//
/**
     * draw or remove the DOM
     *
     * @private
     */},{key:"_setup",value:function _setup(){if(this.options.enabled===true){// Enable the GUI
this.guiEnabled=true;this._createWrappers();if(this.editMode===false){this._createEditButton();}else{this.showManipulatorToolbar();}}else{this._removeManipulationDOM();// disable the gui
this.guiEnabled=false;}}/**
     * create the div overlays that contain the DOM
     *
     * @private
     */},{key:"_createWrappers",value:function _createWrappers(){// load the manipulator HTML elements. All styling done in css.
if(this.manipulationDiv===undefined){this.manipulationDiv=document.createElement("div");this.manipulationDiv.className="vis-manipulation";if(this.editMode===true){this.manipulationDiv.style.display="block";}else{this.manipulationDiv.style.display="none";}this.canvas.frame.appendChild(this.manipulationDiv);}// container for the edit button.
if(this.editModeDiv===undefined){this.editModeDiv=document.createElement("div");this.editModeDiv.className="vis-edit-mode";if(this.editMode===true){this.editModeDiv.style.display="none";}else{this.editModeDiv.style.display="block";}this.canvas.frame.appendChild(this.editModeDiv);}// container for the close div button
if(this.closeDiv===undefined){var _this$options$locales,_this$options$locales2;this.closeDiv=document.createElement("button");this.closeDiv.className="vis-close";this.closeDiv.setAttribute("aria-label",(_this$options$locales=(_this$options$locales2=this.options.locales[this.options.locale])===null||_this$options$locales2===void 0?void 0:_this$options$locales2["close"])!==null&&_this$options$locales!==void 0?_this$options$locales:this.options.locales["en"]["close"]);this.closeDiv.style.display=this.manipulationDiv.style.display;this.canvas.frame.appendChild(this.closeDiv);}}/**
     * generate a new target node. Used for creating new edges and editing edges
     *
     * @param {number} x
     * @param {number} y
     * @returns {Node}
     * @private
     */},{key:"_getNewTargetNode",value:function _getNewTargetNode(x,y){var controlNodeStyle=deepExtend({},this.options.controlNodeStyle);controlNodeStyle.id="targetNode"+v4();controlNodeStyle.hidden=false;controlNodeStyle.physics=false;controlNodeStyle.x=x;controlNodeStyle.y=y;// we have to define the bounding box in order for the nodes to be drawn immediately
var node=this.body.functions.createNode(controlNodeStyle);node.shape.boundingBox={left:x,right:x,top:y,bottom:y};return node;}/**
     * Create the edit button
     */},{key:"_createEditButton",value:function _createEditButton(){var _context18;// restore everything to it's original state (if applicable)
this._clean();// reset the manipulationDOM
this.manipulationDOM={};// empty the editModeDiv
recursiveDOMDelete(this.editModeDiv);// create the contents for the editMode button
var locale=this.options.locales[this.options.locale];var button=this._createButton("editMode","vis-edit vis-edit-mode",locale["edit"]||this.options.locales["en"]["edit"]);this.editModeDiv.appendChild(button);// bind a hammer listener to the button, calling the function toggleEditMode.
this._bindElementEvents(button,bind(_context18=this.toggleEditMode).call(_context18,this));}/**
     * this function cleans up after everything this module does. Temporary elements, functions and events are removed, physics restored, hammers removed.
     *
     * @private
     */},{key:"_clean",value:function _clean(){// not in mode
this.inMode=false;// _clean the divs
if(this.guiEnabled===true){recursiveDOMDelete(this.editModeDiv);recursiveDOMDelete(this.manipulationDiv);// removes all the bindings and overloads
this._cleanupDOMEventListeners();}// remove temporary nodes and edges
this._cleanupTemporaryNodesAndEdges();// restore overloaded UI functions
this._unbindTemporaryUIs();// remove the temporaryEventFunctions
this._unbindTemporaryEvents();// restore the physics if required
this.body.emitter.emit("restorePhysics");}/**
     * Each dom element has it's own hammer. They are stored in this.manipulationHammers. This cleans them up.
     *
     * @private
     */},{key:"_cleanupDOMEventListeners",value:function _cleanupDOMEventListeners(){var _context19;// _clean DOM event listener bindings
var _iterator=_createForOfIteratorHelper(splice(_context19=this._domEventListenerCleanupQueue).call(_context19,0)),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var callback=_step.value;callback();}}catch(err){_iterator.e(err);}finally{_iterator.f();}}/**
     * Remove all DOM elements created by this module.
     *
     * @private
     */},{key:"_removeManipulationDOM",value:function _removeManipulationDOM(){// removes all the bindings and overloads
this._clean();// empty the manipulation divs
recursiveDOMDelete(this.manipulationDiv);recursiveDOMDelete(this.editModeDiv);recursiveDOMDelete(this.closeDiv);// remove the manipulation divs
if(this.manipulationDiv){this.canvas.frame.removeChild(this.manipulationDiv);}if(this.editModeDiv){this.canvas.frame.removeChild(this.editModeDiv);}if(this.closeDiv){this.canvas.frame.removeChild(this.closeDiv);}// set the references to undefined
this.manipulationDiv=undefined;this.editModeDiv=undefined;this.closeDiv=undefined;}/**
     * create a seperator line. the index is to differentiate in the manipulation dom
     *
     * @param {number} [index=1]
     * @private
     */},{key:"_createSeperator",value:function _createSeperator(){var index=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;this.manipulationDOM["seperatorLineDiv"+index]=document.createElement("div");this.manipulationDOM["seperatorLineDiv"+index].className="vis-separator-line";this.manipulationDiv.appendChild(this.manipulationDOM["seperatorLineDiv"+index]);}// ----------------------    DOM functions for buttons    --------------------------//
/**
     *
     * @param {Locale} locale
     * @private
     */},{key:"_createAddNodeButton",value:function _createAddNodeButton(locale){var _context20;var button=this._createButton("addNode","vis-add",locale["addNode"]||this.options.locales["en"]["addNode"]);this.manipulationDiv.appendChild(button);this._bindElementEvents(button,bind(_context20=this.addNodeMode).call(_context20,this));}/**
     *
     * @param {Locale} locale
     * @private
     */},{key:"_createAddEdgeButton",value:function _createAddEdgeButton(locale){var _context21;var button=this._createButton("addEdge","vis-connect",locale["addEdge"]||this.options.locales["en"]["addEdge"]);this.manipulationDiv.appendChild(button);this._bindElementEvents(button,bind(_context21=this.addEdgeMode).call(_context21,this));}/**
     *
     * @param {Locale} locale
     * @private
     */},{key:"_createEditNodeButton",value:function _createEditNodeButton(locale){var _context22;var button=this._createButton("editNode","vis-edit",locale["editNode"]||this.options.locales["en"]["editNode"]);this.manipulationDiv.appendChild(button);this._bindElementEvents(button,bind(_context22=this.editNode).call(_context22,this));}/**
     *
     * @param {Locale} locale
     * @private
     */},{key:"_createEditEdgeButton",value:function _createEditEdgeButton(locale){var _context23;var button=this._createButton("editEdge","vis-edit",locale["editEdge"]||this.options.locales["en"]["editEdge"]);this.manipulationDiv.appendChild(button);this._bindElementEvents(button,bind(_context23=this.editEdgeMode).call(_context23,this));}/**
     *
     * @param {Locale} locale
     * @private
     */},{key:"_createDeleteButton",value:function _createDeleteButton(locale){var _context24;var deleteBtnClass;if(this.options.rtl){deleteBtnClass="vis-delete-rtl";}else{deleteBtnClass="vis-delete";}var button=this._createButton("delete",deleteBtnClass,locale["del"]||this.options.locales["en"]["del"]);this.manipulationDiv.appendChild(button);this._bindElementEvents(button,bind(_context24=this.deleteSelected).call(_context24,this));}/**
     *
     * @param {Locale} locale
     * @private
     */},{key:"_createBackButton",value:function _createBackButton(locale){var _context25;var button=this._createButton("back","vis-back",locale["back"]||this.options.locales["en"]["back"]);this.manipulationDiv.appendChild(button);this._bindElementEvents(button,bind(_context25=this.showManipulatorToolbar).call(_context25,this));}/**
     *
     * @param {number|string} id
     * @param {string} className
     * @param {label} label
     * @param {string} labelClassName
     * @returns {HTMLElement}
     * @private
     */},{key:"_createButton",value:function _createButton(id,className,label){var labelClassName=arguments.length>3&&arguments[3]!==undefined?arguments[3]:"vis-label";this.manipulationDOM[id+"Div"]=document.createElement("button");this.manipulationDOM[id+"Div"].className="vis-button "+className;this.manipulationDOM[id+"Label"]=document.createElement("div");this.manipulationDOM[id+"Label"].className=labelClassName;this.manipulationDOM[id+"Label"].innerText=label;this.manipulationDOM[id+"Div"].appendChild(this.manipulationDOM[id+"Label"]);return this.manipulationDOM[id+"Div"];}/**
     *
     * @param {Label} label
     * @private
     */},{key:"_createDescription",value:function _createDescription(label){this.manipulationDOM["descriptionLabel"]=document.createElement("div");this.manipulationDOM["descriptionLabel"].className="vis-none";this.manipulationDOM["descriptionLabel"].innerText=label;this.manipulationDiv.appendChild(this.manipulationDOM["descriptionLabel"]);}// -------------------------- End of DOM functions for buttons ------------------------------//
/**
     * this binds an event until cleanup by the clean functions.
     *
     * @param {Event}  event   The event
     * @param {Function} newFunction
     * @private
     */},{key:"_temporaryBindEvent",value:function _temporaryBindEvent(event,newFunction){this.temporaryEventFunctions.push({event:event,boundFunction:newFunction});this.body.emitter.on(event,newFunction);}/**
     * this overrides an UI function until cleanup by the clean function
     *
     * @param {string} UIfunctionName
     * @param {Function} newFunction
     * @private
     */},{key:"_temporaryBindUI",value:function _temporaryBindUI(UIfunctionName,newFunction){if(this.body.eventListeners[UIfunctionName]!==undefined){this.temporaryUIFunctions[UIfunctionName]=this.body.eventListeners[UIfunctionName];this.body.eventListeners[UIfunctionName]=newFunction;}else{throw new Error("This UI function does not exist. Typo? You tried: "+UIfunctionName+" possible are: "+stringify$1(keys$3(this.body.eventListeners)));}}/**
     * Restore the overridden UI functions to their original state.
     *
     * @private
     */},{key:"_unbindTemporaryUIs",value:function _unbindTemporaryUIs(){for(var functionName in this.temporaryUIFunctions){if(Object.prototype.hasOwnProperty.call(this.temporaryUIFunctions,functionName)){this.body.eventListeners[functionName]=this.temporaryUIFunctions[functionName];delete this.temporaryUIFunctions[functionName];}}this.temporaryUIFunctions={};}/**
     * Unbind the events created by _temporaryBindEvent
     *
     * @private
     */},{key:"_unbindTemporaryEvents",value:function _unbindTemporaryEvents(){for(var i=0;i<this.temporaryEventFunctions.length;i++){var eventName=this.temporaryEventFunctions[i].event;var boundFunction=this.temporaryEventFunctions[i].boundFunction;this.body.emitter.off(eventName,boundFunction);}this.temporaryEventFunctions=[];}/**
     * Bind an hammer instance to a DOM element.
     *
     * @param {Element} domElement
     * @param {Function} boundFunction
     */},{key:"_bindElementEvents",value:function _bindElementEvents(domElement,boundFunction){// Bind touch events.
var hammer=new Hammer$1(domElement,{});onTouch(hammer,boundFunction);this._domEventListenerCleanupQueue.push(function(){hammer.destroy();});// Bind keyboard events.
var keyupListener=function keyupListener(_ref){var keyCode=_ref.keyCode,key=_ref.key;if(key==="Enter"||key===" "||keyCode===13||keyCode===32){boundFunction();}};domElement.addEventListener("keyup",keyupListener,false);this._domEventListenerCleanupQueue.push(function(){domElement.removeEventListener("keyup",keyupListener,false);});}/**
     * Neatly clean up temporary edges and nodes
     *
     * @private
     */},{key:"_cleanupTemporaryNodesAndEdges",value:function _cleanupTemporaryNodesAndEdges(){// _clean temporary edges
for(var i=0;i<this.temporaryIds.edges.length;i++){var _context26;this.body.edges[this.temporaryIds.edges[i]].disconnect();delete this.body.edges[this.temporaryIds.edges[i]];var indexTempEdge=indexOf(_context26=this.body.edgeIndices).call(_context26,this.temporaryIds.edges[i]);if(indexTempEdge!==-1){var _context27;splice(_context27=this.body.edgeIndices).call(_context27,indexTempEdge,1);}}// _clean temporary nodes
for(var _i=0;_i<this.temporaryIds.nodes.length;_i++){var _context28;delete this.body.nodes[this.temporaryIds.nodes[_i]];var indexTempNode=indexOf(_context28=this.body.nodeIndices).call(_context28,this.temporaryIds.nodes[_i]);if(indexTempNode!==-1){var _context29;splice(_context29=this.body.nodeIndices).call(_context29,indexTempNode,1);}}this.temporaryIds={nodes:[],edges:[]};}// ------------------------------------------ EDIT EDGE FUNCTIONS -----------------------------------------//
/**
     * the touch is used to get the position of the initial click
     *
     * @param {Event}  event   The event
     * @private
     */},{key:"_controlNodeTouch",value:function _controlNodeTouch(event){this.selectionHandler.unselectAll();this.lastTouch=this.body.functions.getPointer(event.center);this.lastTouch.translation=assign$2({},this.body.view.translation);// copy the object
}/**
     * the drag start is used to mark one of the control nodes as selected.
     *
     * @private
     */},{key:"_controlNodeDragStart",value:function _controlNodeDragStart(){var pointer=this.lastTouch;var pointerObj=this.selectionHandler._pointerToPositionObject(pointer);var from=this.body.nodes[this.temporaryIds.nodes[0]];var to=this.body.nodes[this.temporaryIds.nodes[1]];var edge=this.body.edges[this.edgeBeingEditedId];this.selectedControlNode=undefined;var fromSelect=from.isOverlappingWith(pointerObj);var toSelect=to.isOverlappingWith(pointerObj);if(fromSelect===true){this.selectedControlNode=from;edge.edgeType.from=from;}else if(toSelect===true){this.selectedControlNode=to;edge.edgeType.to=to;}// we use the selection to find the node that is being dragged. We explicitly select it here.
if(this.selectedControlNode!==undefined){this.selectionHandler.selectObject(this.selectedControlNode);}this.body.emitter.emit("_redraw");}/**
     * dragging the control nodes or the canvas
     *
     * @param {Event}  event   The event
     * @private
     */},{key:"_controlNodeDrag",value:function _controlNodeDrag(event){this.body.emitter.emit("disablePhysics");var pointer=this.body.functions.getPointer(event.center);var pos=this.canvas.DOMtoCanvas(pointer);if(this.selectedControlNode!==undefined){this.selectedControlNode.x=pos.x;this.selectedControlNode.y=pos.y;}else{this.interactionHandler.onDrag(event);}this.body.emitter.emit("_redraw");}/**
     * connecting or restoring the control nodes.
     *
     * @param {Event}  event   The event
     * @private
     */},{key:"_controlNodeDragEnd",value:function _controlNodeDragEnd(event){var pointer=this.body.functions.getPointer(event.center);var pointerObj=this.selectionHandler._pointerToPositionObject(pointer);var edge=this.body.edges[this.edgeBeingEditedId];// if the node that was dragged is not a control node, return
if(this.selectedControlNode===undefined){return;}// we use the selection to find the node that is being dragged. We explicitly DEselect the control node here.
this.selectionHandler.unselectAll();var overlappingNodeIds=this.selectionHandler._getAllNodesOverlappingWith(pointerObj);var node=undefined;for(var i=overlappingNodeIds.length-1;i>=0;i--){if(overlappingNodeIds[i]!==this.selectedControlNode.id){node=this.body.nodes[overlappingNodeIds[i]];break;}}// perform the connection
if(node!==undefined&&this.selectedControlNode!==undefined){if(node.isCluster===true){alert(this.options.locales[this.options.locale]["createEdgeError"]||this.options.locales["en"]["createEdgeError"]);}else{var from=this.body.nodes[this.temporaryIds.nodes[0]];if(this.selectedControlNode.id===from.id){this._performEditEdge(node.id,edge.to.id);}else{this._performEditEdge(edge.from.id,node.id);}}}else{edge.updateEdgeType();this.body.emitter.emit("restorePhysics");}this.body.emitter.emit("_redraw");}// ------------------------------------ END OF EDIT EDGE FUNCTIONS -----------------------------------------//
// ------------------------------------------- ADD EDGE FUNCTIONS -----------------------------------------//
/**
     * the function bound to the selection event. It checks if you want to connect a cluster and changes the description
     * to walk the user through the process.
     *
     * @param {Event} event
     * @private
     */},{key:"_handleConnect",value:function _handleConnect(event){// check to avoid double fireing of this function.
if(new Date().valueOf()-this.touchTime>100){this.lastTouch=this.body.functions.getPointer(event.center);this.lastTouch.translation=assign$2({},this.body.view.translation);// copy the object
this.interactionHandler.drag.pointer=this.lastTouch;// Drag pointer is not updated when adding edges
this.interactionHandler.drag.translation=this.lastTouch.translation;var pointer=this.lastTouch;var node=this.selectionHandler.getNodeAt(pointer);if(node!==undefined){if(node.isCluster===true){alert(this.options.locales[this.options.locale]["createEdgeError"]||this.options.locales["en"]["createEdgeError"]);}else{// create a node the temporary line can look at
var targetNode=this._getNewTargetNode(node.x,node.y);this.body.nodes[targetNode.id]=targetNode;this.body.nodeIndices.push(targetNode.id);// create a temporary edge
var connectionEdge=this.body.functions.createEdge({id:"connectionEdge"+v4(),from:node.id,to:targetNode.id,physics:false,smooth:{enabled:true,type:"continuous",roundness:0.5}});this.body.edges[connectionEdge.id]=connectionEdge;this.body.edgeIndices.push(connectionEdge.id);this.temporaryIds.nodes.push(targetNode.id);this.temporaryIds.edges.push(connectionEdge.id);}}this.touchTime=new Date().valueOf();}}/**
     *
     * @param {Event} event
     * @private
     */},{key:"_dragControlNode",value:function _dragControlNode(event){var pointer=this.body.functions.getPointer(event.center);var pointerObj=this.selectionHandler._pointerToPositionObject(pointer);// remember the edge id
var connectFromId=undefined;if(this.temporaryIds.edges[0]!==undefined){connectFromId=this.body.edges[this.temporaryIds.edges[0]].fromId;}// get the overlapping node but NOT the temporary node;
var overlappingNodeIds=this.selectionHandler._getAllNodesOverlappingWith(pointerObj);var node=undefined;for(var i=overlappingNodeIds.length-1;i>=0;i--){var _context30;// if the node id is NOT a temporary node, accept the node.
if(indexOf(_context30=this.temporaryIds.nodes).call(_context30,overlappingNodeIds[i])===-1){node=this.body.nodes[overlappingNodeIds[i]];break;}}event.controlEdge={from:connectFromId,to:node?node.id:undefined};this.selectionHandler.generateClickEvent("controlNodeDragging",event,pointer);if(this.temporaryIds.nodes[0]!==undefined){var targetNode=this.body.nodes[this.temporaryIds.nodes[0]];// there is only one temp node in the add edge mode.
targetNode.x=this.canvas._XconvertDOMtoCanvas(pointer.x);targetNode.y=this.canvas._YconvertDOMtoCanvas(pointer.y);this.body.emitter.emit("_redraw");}else{this.interactionHandler.onDrag(event);}}/**
     * Connect the new edge to the target if one exists, otherwise remove temp line
     *
     * @param {Event}  event   The event
     * @private
     */},{key:"_finishConnect",value:function _finishConnect(event){var pointer=this.body.functions.getPointer(event.center);var pointerObj=this.selectionHandler._pointerToPositionObject(pointer);// remember the edge id
var connectFromId=undefined;if(this.temporaryIds.edges[0]!==undefined){connectFromId=this.body.edges[this.temporaryIds.edges[0]].fromId;}// get the overlapping node but NOT the temporary node;
var overlappingNodeIds=this.selectionHandler._getAllNodesOverlappingWith(pointerObj);var node=undefined;for(var i=overlappingNodeIds.length-1;i>=0;i--){var _context31;// if the node id is NOT a temporary node, accept the node.
if(indexOf(_context31=this.temporaryIds.nodes).call(_context31,overlappingNodeIds[i])===-1){node=this.body.nodes[overlappingNodeIds[i]];break;}}// clean temporary nodes and edges.
this._cleanupTemporaryNodesAndEdges();// perform the connection
if(node!==undefined){if(node.isCluster===true){alert(this.options.locales[this.options.locale]["createEdgeError"]||this.options.locales["en"]["createEdgeError"]);}else{if(this.body.nodes[connectFromId]!==undefined&&this.body.nodes[node.id]!==undefined){this._performAddEdge(connectFromId,node.id);}}}event.controlEdge={from:connectFromId,to:node?node.id:undefined};this.selectionHandler.generateClickEvent("controlNodeDragEnd",event,pointer);// No need to do _generateclickevent('dragEnd') here, the regular dragEnd event fires.
this.body.emitter.emit("_redraw");}/**
     *
     * @param {Event} event
     * @private
     */},{key:"_dragStartEdge",value:function _dragStartEdge(event){var pointer=this.lastTouch;this.selectionHandler.generateClickEvent("dragStart",event,pointer,undefined,true);}// --------------------------------------- END OF ADD EDGE FUNCTIONS -------------------------------------//
// ------------------------------ Performing all the actual data manipulation ------------------------//
/**
     * Adds a node on the specified location
     *
     * @param {object} clickData
     * @private
     */},{key:"_performAddNode",value:function _performAddNode(clickData){var _this4=this;var defaultData={id:v4(),x:clickData.pointer.canvas.x,y:clickData.pointer.canvas.y,label:"new"};if(typeof this.options.addNode==="function"){if(this.options.addNode.length===2){this.options.addNode(defaultData,function(finalizedData){if(finalizedData!==null&&finalizedData!==undefined&&_this4.inMode==="addNode"){// if for whatever reason the mode has changes (due to dataset change) disregard the callback
_this4.body.data.nodes.getDataSet().add(finalizedData);}_this4.showManipulatorToolbar();});}else{this.showManipulatorToolbar();throw new Error("The function for add does not support two arguments (data,callback)");}}else{this.body.data.nodes.getDataSet().add(defaultData);this.showManipulatorToolbar();}}/**
     * connect two nodes with a new edge.
     *
     * @param {Node.id} sourceNodeId
     * @param {Node.id} targetNodeId
     * @private
     */},{key:"_performAddEdge",value:function _performAddEdge(sourceNodeId,targetNodeId){var _this5=this;var defaultData={from:sourceNodeId,to:targetNodeId};if(typeof this.options.addEdge==="function"){if(this.options.addEdge.length===2){this.options.addEdge(defaultData,function(finalizedData){if(finalizedData!==null&&finalizedData!==undefined&&_this5.inMode==="addEdge"){// if for whatever reason the mode has changes (due to dataset change) disregard the callback
_this5.body.data.edges.getDataSet().add(finalizedData);_this5.selectionHandler.unselectAll();_this5.showManipulatorToolbar();}});}else{throw new Error("The function for connect does not support two arguments (data,callback)");}}else{this.body.data.edges.getDataSet().add(defaultData);this.selectionHandler.unselectAll();this.showManipulatorToolbar();}}/**
     * connect two nodes with a new edge.
     *
     * @param {Node.id} sourceNodeId
     * @param {Node.id} targetNodeId
     * @private
     */},{key:"_performEditEdge",value:function _performEditEdge(sourceNodeId,targetNodeId){var _this6=this;var defaultData={id:this.edgeBeingEditedId,from:sourceNodeId,to:targetNodeId,label:this.body.data.edges.get(this.edgeBeingEditedId).label};var eeFunct=this.options.editEdge;if(_typeof(eeFunct)==="object"){eeFunct=eeFunct.editWithoutDrag;}if(typeof eeFunct==="function"){if(eeFunct.length===2){eeFunct(defaultData,function(finalizedData){if(finalizedData===null||finalizedData===undefined||_this6.inMode!=="editEdge"){// if for whatever reason the mode has changes (due to dataset change) disregard the callback) {
_this6.body.edges[defaultData.id].updateEdgeType();_this6.body.emitter.emit("_redraw");_this6.showManipulatorToolbar();}else{_this6.body.data.edges.getDataSet().update(finalizedData);_this6.selectionHandler.unselectAll();_this6.showManipulatorToolbar();}});}else{throw new Error("The function for edit does not support two arguments (data, callback)");}}else{this.body.data.edges.getDataSet().update(defaultData);this.selectionHandler.unselectAll();this.showManipulatorToolbar();}}}]);return ManipulationSystem;}();/**
 * This object contains all possible options. It will check if the types are correct, if required if the option is one
 * of the allowed values.
 *
 * __any__ means that the name of the property does not matter.
 * __type__ is a required field for all objects and contains the allowed types of all objects
 */var string="string";var bool="boolean";var number="number";var array="array";var object="object";// should only be in a __type__ property
var dom="dom";var any="any";// List of endpoints
var endPoints=["arrow","bar","box","circle","crow","curve","diamond","image","inv_curve","inv_triangle","triangle","vee"];/* eslint-disable @typescript-eslint/naming-convention -- The __*__ format is used to prevent collisions with actual option names. */var nodeOptions={borderWidth:{number:number},borderWidthSelected:{number:number,undefined:"undefined"},brokenImage:{string:string,undefined:"undefined"},chosen:{label:{boolean:bool,function:"function"},node:{boolean:bool,function:"function"},__type__:{object:object,boolean:bool}},color:{border:{string:string},background:{string:string},highlight:{border:{string:string},background:{string:string},__type__:{object:object,string:string}},hover:{border:{string:string},background:{string:string},__type__:{object:object,string:string}},__type__:{object:object,string:string}},opacity:{number:number,undefined:"undefined"},fixed:{x:{boolean:bool},y:{boolean:bool},__type__:{object:object,boolean:bool}},font:{align:{string:string},color:{string:string},size:{number:number},face:{string:string},background:{string:string},strokeWidth:{number:number},strokeColor:{string:string},vadjust:{number:number},multi:{boolean:bool,string:string},bold:{color:{string:string},size:{number:number},face:{string:string},mod:{string:string},vadjust:{number:number},__type__:{object:object,string:string}},boldital:{color:{string:string},size:{number:number},face:{string:string},mod:{string:string},vadjust:{number:number},__type__:{object:object,string:string}},ital:{color:{string:string},size:{number:number},face:{string:string},mod:{string:string},vadjust:{number:number},__type__:{object:object,string:string}},mono:{color:{string:string},size:{number:number},face:{string:string},mod:{string:string},vadjust:{number:number},__type__:{object:object,string:string}},__type__:{object:object,string:string}},group:{string:string,number:number,undefined:"undefined"},heightConstraint:{minimum:{number:number},valign:{string:string},__type__:{object:object,boolean:bool,number:number}},hidden:{boolean:bool},icon:{face:{string:string},code:{string:string},size:{number:number},color:{string:string},weight:{string:string,number:number},__type__:{object:object}},id:{string:string,number:number},image:{selected:{string:string,undefined:"undefined"},unselected:{string:string,undefined:"undefined"},__type__:{object:object,string:string}},imagePadding:{top:{number:number},right:{number:number},bottom:{number:number},left:{number:number},__type__:{object:object,number:number}},label:{string:string,undefined:"undefined"},labelHighlightBold:{boolean:bool},level:{number:number,undefined:"undefined"},margin:{top:{number:number},right:{number:number},bottom:{number:number},left:{number:number},__type__:{object:object,number:number}},mass:{number:number},physics:{boolean:bool},scaling:{min:{number:number},max:{number:number},label:{enabled:{boolean:bool},min:{number:number},max:{number:number},maxVisible:{number:number},drawThreshold:{number:number},__type__:{object:object,boolean:bool}},customScalingFunction:{function:"function"},__type__:{object:object}},shadow:{enabled:{boolean:bool},color:{string:string},size:{number:number},x:{number:number},y:{number:number},__type__:{object:object,boolean:bool}},shape:{string:["custom","ellipse","circle","database","box","text","image","circularImage","diamond","dot","star","triangle","triangleDown","square","icon","hexagon"]},ctxRenderer:{function:"function"},shapeProperties:{borderDashes:{boolean:bool,array:array},borderRadius:{number:number},interpolation:{boolean:bool},useImageSize:{boolean:bool},useBorderWithImage:{boolean:bool},coordinateOrigin:{string:["center","top-left"]},__type__:{object:object}},size:{number:number},title:{string:string,dom:dom,undefined:"undefined"},value:{number:number,undefined:"undefined"},widthConstraint:{minimum:{number:number},maximum:{number:number},__type__:{object:object,boolean:bool,number:number}},x:{number:number},y:{number:number},__type__:{object:object}};var allOptions={configure:{enabled:{boolean:bool},filter:{boolean:bool,string:string,array:array,function:"function"},container:{dom:dom},showButton:{boolean:bool},__type__:{object:object,boolean:bool,string:string,array:array,function:"function"}},edges:{arrows:{to:{enabled:{boolean:bool},scaleFactor:{number:number},type:{string:endPoints},imageHeight:{number:number},imageWidth:{number:number},src:{string:string},__type__:{object:object,boolean:bool}},middle:{enabled:{boolean:bool},scaleFactor:{number:number},type:{string:endPoints},imageWidth:{number:number},imageHeight:{number:number},src:{string:string},__type__:{object:object,boolean:bool}},from:{enabled:{boolean:bool},scaleFactor:{number:number},type:{string:endPoints},imageWidth:{number:number},imageHeight:{number:number},src:{string:string},__type__:{object:object,boolean:bool}},__type__:{string:["from","to","middle"],object:object}},endPointOffset:{from:{number:number},to:{number:number},__type__:{object:object,number:number}},arrowStrikethrough:{boolean:bool},background:{enabled:{boolean:bool},color:{string:string},size:{number:number},dashes:{boolean:bool,array:array},__type__:{object:object,boolean:bool}},chosen:{label:{boolean:bool,function:"function"},edge:{boolean:bool,function:"function"},__type__:{object:object,boolean:bool}},color:{color:{string:string},highlight:{string:string},hover:{string:string},inherit:{string:["from","to","both"],boolean:bool},opacity:{number:number},__type__:{object:object,string:string}},dashes:{boolean:bool,array:array},font:{color:{string:string},size:{number:number},face:{string:string},background:{string:string},strokeWidth:{number:number},strokeColor:{string:string},align:{string:["horizontal","top","middle","bottom"]},vadjust:{number:number},multi:{boolean:bool,string:string},bold:{color:{string:string},size:{number:number},face:{string:string},mod:{string:string},vadjust:{number:number},__type__:{object:object,string:string}},boldital:{color:{string:string},size:{number:number},face:{string:string},mod:{string:string},vadjust:{number:number},__type__:{object:object,string:string}},ital:{color:{string:string},size:{number:number},face:{string:string},mod:{string:string},vadjust:{number:number},__type__:{object:object,string:string}},mono:{color:{string:string},size:{number:number},face:{string:string},mod:{string:string},vadjust:{number:number},__type__:{object:object,string:string}},__type__:{object:object,string:string}},hidden:{boolean:bool},hoverWidth:{function:"function",number:number},label:{string:string,undefined:"undefined"},labelHighlightBold:{boolean:bool},length:{number:number,undefined:"undefined"},physics:{boolean:bool},scaling:{min:{number:number},max:{number:number},label:{enabled:{boolean:bool},min:{number:number},max:{number:number},maxVisible:{number:number},drawThreshold:{number:number},__type__:{object:object,boolean:bool}},customScalingFunction:{function:"function"},__type__:{object:object}},selectionWidth:{function:"function",number:number},selfReferenceSize:{number:number},selfReference:{size:{number:number},angle:{number:number},renderBehindTheNode:{boolean:bool},__type__:{object:object}},shadow:{enabled:{boolean:bool},color:{string:string},size:{number:number},x:{number:number},y:{number:number},__type__:{object:object,boolean:bool}},smooth:{enabled:{boolean:bool},type:{string:["dynamic","continuous","discrete","diagonalCross","straightCross","horizontal","vertical","curvedCW","curvedCCW","cubicBezier"]},roundness:{number:number},forceDirection:{string:["horizontal","vertical","none"],boolean:bool},__type__:{object:object,boolean:bool}},title:{string:string,undefined:"undefined"},width:{number:number},widthConstraint:{maximum:{number:number},__type__:{object:object,boolean:bool,number:number}},value:{number:number,undefined:"undefined"},__type__:{object:object}},groups:{useDefaultGroups:{boolean:bool},__any__:nodeOptions,__type__:{object:object}},interaction:{dragNodes:{boolean:bool},dragView:{boolean:bool},hideEdgesOnDrag:{boolean:bool},hideEdgesOnZoom:{boolean:bool},hideNodesOnDrag:{boolean:bool},hover:{boolean:bool},keyboard:{enabled:{boolean:bool},speed:{x:{number:number},y:{number:number},zoom:{number:number},__type__:{object:object}},bindToWindow:{boolean:bool},__type__:{object:object,boolean:bool}},multiselect:{boolean:bool},navigationButtons:{boolean:bool},selectable:{boolean:bool},selectConnectedEdges:{boolean:bool},hoverConnectedEdges:{boolean:bool},tooltipDelay:{number:number},zoomView:{boolean:bool},zoomSpeed:{number:number},__type__:{object:object}},layout:{randomSeed:{undefined:"undefined",number:number,string:string},improvedLayout:{boolean:bool},clusterThreshold:{number:number},hierarchical:{enabled:{boolean:bool},levelSeparation:{number:number},nodeSpacing:{number:number},treeSpacing:{number:number},blockShifting:{boolean:bool},edgeMinimization:{boolean:bool},parentCentralization:{boolean:bool},direction:{string:["UD","DU","LR","RL"]},sortMethod:{string:["hubsize","directed"]},shakeTowards:{string:["leaves","roots"]},__type__:{object:object,boolean:bool}},__type__:{object:object}},manipulation:{enabled:{boolean:bool},initiallyActive:{boolean:bool},addNode:{boolean:bool,function:"function"},addEdge:{boolean:bool,function:"function"},editNode:{function:"function"},editEdge:{editWithoutDrag:{function:"function"},__type__:{object:object,boolean:bool,function:"function"}},deleteNode:{boolean:bool,function:"function"},deleteEdge:{boolean:bool,function:"function"},controlNodeStyle:nodeOptions,__type__:{object:object,boolean:bool}},nodes:nodeOptions,physics:{enabled:{boolean:bool},barnesHut:{theta:{number:number},gravitationalConstant:{number:number},centralGravity:{number:number},springLength:{number:number},springConstant:{number:number},damping:{number:number},avoidOverlap:{number:number},__type__:{object:object}},forceAtlas2Based:{theta:{number:number},gravitationalConstant:{number:number},centralGravity:{number:number},springLength:{number:number},springConstant:{number:number},damping:{number:number},avoidOverlap:{number:number},__type__:{object:object}},repulsion:{centralGravity:{number:number},springLength:{number:number},springConstant:{number:number},nodeDistance:{number:number},damping:{number:number},__type__:{object:object}},hierarchicalRepulsion:{centralGravity:{number:number},springLength:{number:number},springConstant:{number:number},nodeDistance:{number:number},damping:{number:number},avoidOverlap:{number:number},__type__:{object:object}},maxVelocity:{number:number},minVelocity:{number:number},solver:{string:["barnesHut","repulsion","hierarchicalRepulsion","forceAtlas2Based"]},stabilization:{enabled:{boolean:bool},iterations:{number:number},updateInterval:{number:number},onlyDynamicEdges:{boolean:bool},fit:{boolean:bool},__type__:{object:object,boolean:bool}},timestep:{number:number},adaptiveTimestep:{boolean:bool},wind:{x:{number:number},y:{number:number},__type__:{object:object}},__type__:{object:object,boolean:bool}},//globals :
autoResize:{boolean:bool},clickToUse:{boolean:bool},locale:{string:string},locales:{__any__:{any:any},__type__:{object:object}},height:{string:string},width:{string:string},__type__:{object:object}};/* eslint-enable @typescript-eslint/naming-convention */ /**
 * This provides ranges, initial values, steps and dropdown menu choices for the
 * configuration.
 *
 * @remarks
 * Checkbox: `boolean`
 *   The value supllied will be used as the initial value.
 *
 * Text field: `string`
 *   The passed text will be used as the initial value. Any text will be
 *   accepted afterwards.
 *
 * Number range: `[number, number, number, number]`
 *   The meanings are `[initial value, min, max, step]`.
 *
 * Dropdown: `[Exclude<string, "color">, ...(string | number | boolean)[]]`
 *   Translations for people with poor understanding of TypeScript: the first
 *   value always has to be a string but never `"color"`, the rest can be any
 *   combination of strings, numbers and booleans.
 *
 * Color picker: `["color", string]`
 *   The first value says this will be a color picker not a dropdown menu. The
 *   next value is the initial color.
 */var configureOptions={nodes:{borderWidth:[1,0,10,1],borderWidthSelected:[2,0,10,1],color:{border:["color","#2B7CE9"],background:["color","#97C2FC"],highlight:{border:["color","#2B7CE9"],background:["color","#D2E5FF"]},hover:{border:["color","#2B7CE9"],background:["color","#D2E5FF"]}},opacity:[0,0,1,0.1],fixed:{x:false,y:false},font:{color:["color","#343434"],size:[14,0,100,1],face:["arial","verdana","tahoma"],background:["color","none"],strokeWidth:[0,0,50,1],strokeColor:["color","#ffffff"]},//group: 'string',
hidden:false,labelHighlightBold:true,//icon: {
//  face: 'string',  //'FontAwesome',
//  code: 'string',  //'\uf007',
//  size: [50, 0, 200, 1],  //50,
//  color: ['color','#2B7CE9']   //'#aa00ff'
//},
//image: 'string', // --> URL
physics:true,scaling:{min:[10,0,200,1],max:[30,0,200,1],label:{enabled:false,min:[14,0,200,1],max:[30,0,200,1],maxVisible:[30,0,200,1],drawThreshold:[5,0,20,1]}},shadow:{enabled:false,color:"rgba(0,0,0,0.5)",size:[10,0,20,1],x:[5,-30,30,1],y:[5,-30,30,1]},shape:["ellipse","box","circle","database","diamond","dot","square","star","text","triangle","triangleDown","hexagon"],shapeProperties:{borderDashes:false,borderRadius:[6,0,20,1],interpolation:true,useImageSize:false},size:[25,0,200,1]},edges:{arrows:{to:{enabled:false,scaleFactor:[1,0,3,0.05],type:"arrow"},middle:{enabled:false,scaleFactor:[1,0,3,0.05],type:"arrow"},from:{enabled:false,scaleFactor:[1,0,3,0.05],type:"arrow"}},endPointOffset:{from:[0,-10,10,1],to:[0,-10,10,1]},arrowStrikethrough:true,color:{color:["color","#848484"],highlight:["color","#848484"],hover:["color","#848484"],inherit:["from","to","both",true,false],opacity:[1,0,1,0.05]},dashes:false,font:{color:["color","#343434"],size:[14,0,100,1],face:["arial","verdana","tahoma"],background:["color","none"],strokeWidth:[2,0,50,1],strokeColor:["color","#ffffff"],align:["horizontal","top","middle","bottom"]},hidden:false,hoverWidth:[1.5,0,5,0.1],labelHighlightBold:true,physics:true,scaling:{min:[1,0,100,1],max:[15,0,100,1],label:{enabled:true,min:[14,0,200,1],max:[30,0,200,1],maxVisible:[30,0,200,1],drawThreshold:[5,0,20,1]}},selectionWidth:[1.5,0,5,0.1],selfReferenceSize:[20,0,200,1],selfReference:{size:[20,0,200,1],angle:[Math.PI/2,-6*Math.PI,6*Math.PI,Math.PI/8],renderBehindTheNode:true},shadow:{enabled:false,color:"rgba(0,0,0,0.5)",size:[10,0,20,1],x:[5,-30,30,1],y:[5,-30,30,1]},smooth:{enabled:true,type:["dynamic","continuous","discrete","diagonalCross","straightCross","horizontal","vertical","curvedCW","curvedCCW","cubicBezier"],forceDirection:["horizontal","vertical","none"],roundness:[0.5,0,1,0.05]},width:[1,0,30,1]},layout:{//randomSeed: [0, 0, 500, 1],
//improvedLayout: true,
hierarchical:{enabled:false,levelSeparation:[150,20,500,5],nodeSpacing:[100,20,500,5],treeSpacing:[200,20,500,5],blockShifting:true,edgeMinimization:true,parentCentralization:true,direction:["UD","DU","LR","RL"],sortMethod:["hubsize","directed"],shakeTowards:["leaves","roots"]// leaves, roots
}},interaction:{dragNodes:true,dragView:true,hideEdgesOnDrag:false,hideEdgesOnZoom:false,hideNodesOnDrag:false,hover:false,keyboard:{enabled:false,speed:{x:[10,0,40,1],y:[10,0,40,1],zoom:[0.02,0,0.1,0.005]},bindToWindow:true},multiselect:false,navigationButtons:false,selectable:true,selectConnectedEdges:true,hoverConnectedEdges:true,tooltipDelay:[300,0,1000,25],zoomView:true,zoomSpeed:[1,0.1,2,0.1]},manipulation:{enabled:false,initiallyActive:false},physics:{enabled:true,barnesHut:{theta:[0.5,0.1,1,0.05],gravitationalConstant:[-2000,-30000,0,50],centralGravity:[0.3,0,10,0.05],springLength:[95,0,500,5],springConstant:[0.04,0,1.2,0.005],damping:[0.09,0,1,0.01],avoidOverlap:[0,0,1,0.01]},forceAtlas2Based:{theta:[0.5,0.1,1,0.05],gravitationalConstant:[-50,-500,0,1],centralGravity:[0.01,0,1,0.005],springLength:[95,0,500,5],springConstant:[0.08,0,1.2,0.005],damping:[0.4,0,1,0.01],avoidOverlap:[0,0,1,0.01]},repulsion:{centralGravity:[0.2,0,10,0.05],springLength:[200,0,500,5],springConstant:[0.05,0,1.2,0.005],nodeDistance:[100,0,500,5],damping:[0.09,0,1,0.01]},hierarchicalRepulsion:{centralGravity:[0.2,0,10,0.05],springLength:[100,0,500,5],springConstant:[0.01,0,1.2,0.005],nodeDistance:[120,0,500,5],damping:[0.09,0,1,0.01],avoidOverlap:[0,0,1,0.01]},maxVelocity:[50,0,150,1],minVelocity:[0.1,0.01,0.5,0.01],solver:["barnesHut","forceAtlas2Based","repulsion","hierarchicalRepulsion"],timestep:[0.5,0.01,1,0.01],wind:{x:[0,-10,10,0.1],y:[0,-10,10,0.1]}//adaptiveTimestep: true
}};var configuratorHideOption=function configuratorHideOption(parentPath,optionName,options){var _context;if(includes(parentPath).call(parentPath,"physics")&&includes(_context=configureOptions.physics.solver).call(_context,optionName)&&options.physics.solver!==optionName&&optionName!=="wind"){return true;}return false;};var options=/*#__PURE__*/Object.freeze({__proto__:null,configuratorHideOption:configuratorHideOption,allOptions:allOptions,configureOptions:configureOptions});/**
 *  The Floyd–Warshall algorithm is an algorithm for finding shortest paths in
 *  a weighted graph with positive or negative edge weights (but with no negative
 *  cycles). - https://en.wikipedia.org/wiki/Floyd–Warshall_algorithm
 */exports.networkOptions=options;var FloydWarshall=/*#__PURE__*/function(){/**
   * @ignore
   */function FloydWarshall(){_classCallCheck(this,FloydWarshall);}/**
   *
   * @param {object} body
   * @param {Array.<Node>} nodesArray
   * @param {Array.<Edge>} edgesArray
   * @returns {{}}
   */_createClass(FloydWarshall,[{key:"getDistances",value:function getDistances(body,nodesArray,edgesArray){var D_matrix={};var edges=body.edges;// prepare matrix with large numbers
for(var i=0;i<nodesArray.length;i++){var node=nodesArray[i];var cell={};D_matrix[node]=cell;for(var j=0;j<nodesArray.length;j++){cell[nodesArray[j]]=i==j?0:1e9;}}// put the weights for the edges in. This assumes unidirectionality.
for(var _i=0;_i<edgesArray.length;_i++){var edge=edges[edgesArray[_i]];// edge has to be connected if it counts to the distances. If it is connected to inner clusters it will crash so we also check if it is in the D_matrix
if(edge.connected===true&&D_matrix[edge.fromId]!==undefined&&D_matrix[edge.toId]!==undefined){D_matrix[edge.fromId][edge.toId]=1;D_matrix[edge.toId][edge.fromId]=1;}}var nodeCount=nodesArray.length;// Adapted FloydWarshall based on unidirectionality to greatly reduce complexity.
for(var k=0;k<nodeCount;k++){var knode=nodesArray[k];var kcolm=D_matrix[knode];for(var _i2=0;_i2<nodeCount-1;_i2++){var inode=nodesArray[_i2];var icolm=D_matrix[inode];for(var _j=_i2+1;_j<nodeCount;_j++){var jnode=nodesArray[_j];var jcolm=D_matrix[jnode];var val=Math.min(icolm[jnode],icolm[knode]+kcolm[jnode]);icolm[jnode]=val;jcolm[inode]=val;}}}return D_matrix;}}]);return FloydWarshall;}();/**
 * KamadaKawai positions the nodes initially based on
 *
 * "AN ALGORITHM FOR DRAWING GENERAL UNDIRECTED GRAPHS"
 * -- Tomihisa KAMADA and Satoru KAWAI in 1989
 *
 * Possible optimizations in the distance calculation can be implemented.
 */var KamadaKawai=/*#__PURE__*/function(){/**
   * @param {object} body
   * @param {number} edgeLength
   * @param {number} edgeStrength
   */function KamadaKawai(body,edgeLength,edgeStrength){_classCallCheck(this,KamadaKawai);this.body=body;this.springLength=edgeLength;this.springConstant=edgeStrength;this.distanceSolver=new FloydWarshall();}/**
   * Not sure if needed but can be used to update the spring length and spring constant
   *
   * @param {object} options
   */_createClass(KamadaKawai,[{key:"setOptions",value:function setOptions(options){if(options){if(options.springLength){this.springLength=options.springLength;}if(options.springConstant){this.springConstant=options.springConstant;}}}/**
     * Position the system
     *
     * @param {Array.<Node>} nodesArray
     * @param {Array.<vis.Edge>} edgesArray
     * @param {boolean} [ignoreClusters=false]
     */},{key:"solve",value:function solve(nodesArray,edgesArray){var ignoreClusters=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;// get distance matrix
var D_matrix=this.distanceSolver.getDistances(this.body,nodesArray,edgesArray);// distance matrix
// get the L Matrix
this._createL_matrix(D_matrix);// get the K Matrix
this._createK_matrix(D_matrix);// initial E Matrix
this._createE_matrix();// calculate positions
var threshold=0.01;var innerThreshold=1;var iterations=0;var maxIterations=Math.max(1000,Math.min(10*this.body.nodeIndices.length,6000));var maxInnerIterations=5;var maxEnergy=1e9;var highE_nodeId=0,dE_dx=0,dE_dy=0,delta_m=0,subIterations=0;while(maxEnergy>threshold&&iterations<maxIterations){iterations+=1;var _this$_getHighestEner=this._getHighestEnergyNode(ignoreClusters);var _this$_getHighestEner2=_slicedToArray(_this$_getHighestEner,4);highE_nodeId=_this$_getHighestEner2[0];maxEnergy=_this$_getHighestEner2[1];dE_dx=_this$_getHighestEner2[2];dE_dy=_this$_getHighestEner2[3];delta_m=maxEnergy;subIterations=0;while(delta_m>innerThreshold&&subIterations<maxInnerIterations){subIterations+=1;this._moveNode(highE_nodeId,dE_dx,dE_dy);var _this$_getEnergy=this._getEnergy(highE_nodeId);var _this$_getEnergy2=_slicedToArray(_this$_getEnergy,3);delta_m=_this$_getEnergy2[0];dE_dx=_this$_getEnergy2[1];dE_dy=_this$_getEnergy2[2];}}}/**
     * get the node with the highest energy
     *
     * @param {boolean} ignoreClusters
     * @returns {number[]}
     * @private
     */},{key:"_getHighestEnergyNode",value:function _getHighestEnergyNode(ignoreClusters){var nodesArray=this.body.nodeIndices;var nodes=this.body.nodes;var maxEnergy=0;var maxEnergyNodeId=nodesArray[0];var dE_dx_max=0,dE_dy_max=0;for(var nodeIdx=0;nodeIdx<nodesArray.length;nodeIdx++){var m=nodesArray[nodeIdx];// by not evaluating nodes with predefined positions we should only move nodes that have no positions.
if(nodes[m].predefinedPosition!==true||nodes[m].isCluster===true&&ignoreClusters===true||nodes[m].options.fixed.x!==true||nodes[m].options.fixed.y!==true){var _this$_getEnergy3=this._getEnergy(m),_this$_getEnergy4=_slicedToArray(_this$_getEnergy3,3),delta_m=_this$_getEnergy4[0],dE_dx=_this$_getEnergy4[1],dE_dy=_this$_getEnergy4[2];if(maxEnergy<delta_m){maxEnergy=delta_m;maxEnergyNodeId=m;dE_dx_max=dE_dx;dE_dy_max=dE_dy;}}}return[maxEnergyNodeId,maxEnergy,dE_dx_max,dE_dy_max];}/**
     * calculate the energy of a single node
     *
     * @param {Node.id} m
     * @returns {number[]}
     * @private
     */},{key:"_getEnergy",value:function _getEnergy(m){var _this$E_sums$m=_slicedToArray(this.E_sums[m],2),dE_dx=_this$E_sums$m[0],dE_dy=_this$E_sums$m[1];var delta_m=Math.sqrt(Math.pow(dE_dx,2)+Math.pow(dE_dy,2));return[delta_m,dE_dx,dE_dy];}/**
     * move the node based on it's energy
     * the dx and dy are calculated from the linear system proposed by Kamada and Kawai
     *
     * @param {number} m
     * @param {number} dE_dx
     * @param {number} dE_dy
     * @private
     */},{key:"_moveNode",value:function _moveNode(m,dE_dx,dE_dy){var nodesArray=this.body.nodeIndices;var nodes=this.body.nodes;var d2E_dx2=0;var d2E_dxdy=0;var d2E_dy2=0;var x_m=nodes[m].x;var y_m=nodes[m].y;var km=this.K_matrix[m];var lm=this.L_matrix[m];for(var iIdx=0;iIdx<nodesArray.length;iIdx++){var i=nodesArray[iIdx];if(i!==m){var x_i=nodes[i].x;var y_i=nodes[i].y;var kmat=km[i];var lmat=lm[i];var denominator=1.0/Math.pow(Math.pow(x_m-x_i,2)+Math.pow(y_m-y_i,2),1.5);d2E_dx2+=kmat*(1-lmat*Math.pow(y_m-y_i,2)*denominator);d2E_dxdy+=kmat*(lmat*(x_m-x_i)*(y_m-y_i)*denominator);d2E_dy2+=kmat*(1-lmat*Math.pow(x_m-x_i,2)*denominator);}}// make the variable names easier to make the solving of the linear system easier to read
var A=d2E_dx2,B=d2E_dxdy,C=dE_dx,D=d2E_dy2,E=dE_dy;// solve the linear system for dx and dy
var dy=(C/A+E/B)/(B/A-D/B);var dx=-(B*dy+C)/A;// move the node
nodes[m].x+=dx;nodes[m].y+=dy;// Recalculate E_matrix (should be incremental)
this._updateE_matrix(m);}/**
     * Create the L matrix: edge length times shortest path
     *
     * @param {object} D_matrix
     * @private
     */},{key:"_createL_matrix",value:function _createL_matrix(D_matrix){var nodesArray=this.body.nodeIndices;var edgeLength=this.springLength;this.L_matrix=[];for(var i=0;i<nodesArray.length;i++){this.L_matrix[nodesArray[i]]={};for(var j=0;j<nodesArray.length;j++){this.L_matrix[nodesArray[i]][nodesArray[j]]=edgeLength*D_matrix[nodesArray[i]][nodesArray[j]];}}}/**
     * Create the K matrix: spring constants times shortest path
     *
     * @param {object} D_matrix
     * @private
     */},{key:"_createK_matrix",value:function _createK_matrix(D_matrix){var nodesArray=this.body.nodeIndices;var edgeStrength=this.springConstant;this.K_matrix=[];for(var i=0;i<nodesArray.length;i++){this.K_matrix[nodesArray[i]]={};for(var j=0;j<nodesArray.length;j++){this.K_matrix[nodesArray[i]][nodesArray[j]]=edgeStrength*Math.pow(D_matrix[nodesArray[i]][nodesArray[j]],-2);}}}/**
     *  Create matrix with all energies between nodes
     *
     *  @private
     */},{key:"_createE_matrix",value:function _createE_matrix(){var nodesArray=this.body.nodeIndices;var nodes=this.body.nodes;this.E_matrix={};this.E_sums={};for(var mIdx=0;mIdx<nodesArray.length;mIdx++){this.E_matrix[nodesArray[mIdx]]=[];}for(var _mIdx=0;_mIdx<nodesArray.length;_mIdx++){var m=nodesArray[_mIdx];var x_m=nodes[m].x;var y_m=nodes[m].y;var dE_dx=0;var dE_dy=0;for(var iIdx=_mIdx;iIdx<nodesArray.length;iIdx++){var i=nodesArray[iIdx];if(i!==m){var x_i=nodes[i].x;var y_i=nodes[i].y;var denominator=1.0/Math.sqrt(Math.pow(x_m-x_i,2)+Math.pow(y_m-y_i,2));this.E_matrix[m][iIdx]=[this.K_matrix[m][i]*(x_m-x_i-this.L_matrix[m][i]*(x_m-x_i)*denominator),this.K_matrix[m][i]*(y_m-y_i-this.L_matrix[m][i]*(y_m-y_i)*denominator)];this.E_matrix[i][_mIdx]=this.E_matrix[m][iIdx];dE_dx+=this.E_matrix[m][iIdx][0];dE_dy+=this.E_matrix[m][iIdx][1];}}//Store sum
this.E_sums[m]=[dE_dx,dE_dy];}}/**
     * Update method, just doing single column (rows are auto-updated) (update all sums)
     *
     * @param {number} m
     * @private
     */},{key:"_updateE_matrix",value:function _updateE_matrix(m){var nodesArray=this.body.nodeIndices;var nodes=this.body.nodes;var colm=this.E_matrix[m];var kcolm=this.K_matrix[m];var lcolm=this.L_matrix[m];var x_m=nodes[m].x;var y_m=nodes[m].y;var dE_dx=0;var dE_dy=0;for(var iIdx=0;iIdx<nodesArray.length;iIdx++){var i=nodesArray[iIdx];if(i!==m){//Keep old energy value for sum modification below
var cell=colm[iIdx];var oldDx=cell[0];var oldDy=cell[1];//Calc new energy:
var x_i=nodes[i].x;var y_i=nodes[i].y;var denominator=1.0/Math.sqrt(Math.pow(x_m-x_i,2)+Math.pow(y_m-y_i,2));var dx=kcolm[i]*(x_m-x_i-lcolm[i]*(x_m-x_i)*denominator);var dy=kcolm[i]*(y_m-y_i-lcolm[i]*(y_m-y_i)*denominator);colm[iIdx]=[dx,dy];dE_dx+=dx;dE_dy+=dy;//add new energy to sum of each column
var sum=this.E_sums[i];sum[0]+=dx-oldDx;sum[1]+=dy-oldDy;}}//Store sum at -1 index
this.E_sums[m]=[dE_dx,dE_dy];}}]);return KamadaKawai;}();/**
 * Create a network visualization, displaying nodes and edges.
 *
 * @param {Element} container   The DOM element in which the Network will
 *                                  be created. Normally a div element.
 * @param {object} data         An object containing parameters
 *                              {Array} nodes
 *                              {Array} edges
 * @param {object} options      Options
 * @class Network
 */function Network(container,data,options){var _context,_context2,_context3,_context4,_this=this;if(!(this instanceof Network)){throw new SyntaxError("Constructor must be called with the new operator");}// set constant values
this.options={};this.defaultOptions={locale:"en",locales:locales,clickToUse:false};assign$2(this.options,this.defaultOptions);/**
   * Containers for nodes and edges.
   *
   * 'edges' and 'nodes' contain the full definitions of all the network elements.
   * 'nodeIndices' and 'edgeIndices' contain the id's of the active elements.
   *
   * The distinction is important, because a defined node need not be active, i.e.
   * visible on the canvas. This happens in particular when clusters are defined, in
   * that case there will be nodes and edges not displayed.
   * The bottom line is that all code with actions related to visibility, *must* use
   * 'nodeIndices' and 'edgeIndices', not 'nodes' and 'edges' directly.
   */this.body={container:container,// See comment above for following fields
nodes:{},nodeIndices:[],edges:{},edgeIndices:[],emitter:{on:bind(_context=this.on).call(_context,this),off:bind(_context2=this.off).call(_context2,this),emit:bind(_context3=this.emit).call(_context3,this),once:bind(_context4=this.once).call(_context4,this)},eventListeners:{onTap:function onTap(){},onTouch:function onTouch(){},onDoubleTap:function onDoubleTap(){},onHold:function onHold(){},onDragStart:function onDragStart(){},onDrag:function onDrag(){},onDragEnd:function onDragEnd(){},onMouseWheel:function onMouseWheel(){},onPinch:function onPinch(){},onMouseMove:function onMouseMove(){},onRelease:function onRelease(){},onContext:function onContext(){}},data:{nodes:null,// A DataSet or DataView
edges:null// A DataSet or DataView
},functions:{createNode:function createNode(){},createEdge:function createEdge(){},getPointer:function getPointer(){}},modules:{},view:{scale:1,translation:{x:0,y:0}},selectionBox:{show:false,position:{start:{x:0,y:0},end:{x:0,y:0}}}};// bind the event listeners
this.bindEventListeners();// setting up all modules
this.images=new Images(function(){return _this.body.emitter.emit("_requestRedraw");});// object with images
this.groups=new Groups();// object with groups
this.canvas=new Canvas(this.body);// DOM handler
this.selectionHandler=new SelectionHandler(this.body,this.canvas);// Selection handler
this.interactionHandler=new InteractionHandler(this.body,this.canvas,this.selectionHandler);// Interaction handler handles all the hammer bindings (that are bound by canvas), key
this.view=new View(this.body,this.canvas);// camera handler, does animations and zooms
this.renderer=new CanvasRenderer(this.body,this.canvas);// renderer, starts renderloop, has events that modules can hook into
this.physics=new PhysicsEngine(this.body);// physics engine, does all the simulations
this.layoutEngine=new LayoutEngine(this.body);// layout engine for inital layout and hierarchical layout
this.clustering=new ClusterEngine(this.body);// clustering api
this.manipulation=new ManipulationSystem(this.body,this.canvas,this.selectionHandler,this.interactionHandler);// data manipulation system
this.nodesHandler=new NodesHandler(this.body,this.images,this.groups,this.layoutEngine);// Handle adding, deleting and updating of nodes as well as global options
this.edgesHandler=new EdgesHandler(this.body,this.images,this.groups);// Handle adding, deleting and updating of edges as well as global options
this.body.modules["kamadaKawai"]=new KamadaKawai(this.body,150,0.05);// Layouting algorithm.
this.body.modules["clustering"]=this.clustering;// create the DOM elements
this.canvas._create();// apply options
this.setOptions(options);// load data (the disable start variable will be the same as the enabled clustering)
this.setData(data);}// Extend Network with an Emitter mixin
componentEmitter(Network.prototype);/**
 * Set options
 *
 * @param {object} options
 */Network.prototype.setOptions=function(options){var _this2=this;if(options===null){options=undefined;// This ensures that options handling doesn't crash in the handling
}if(options!==undefined){var errorFound=Validator$1.validate(options,allOptions);if(errorFound===true){console.error("%cErrors have been found in the supplied options object.",VALIDATOR_PRINT_STYLE$1);}// copy the global fields over
var fields=["locale","locales","clickToUse"];selectiveDeepExtend(fields,this.options,options);// normalize the locale or use English
if(options.locale!==undefined){options.locale=normalizeLanguageCode(options.locales||this.options.locales,options.locale);}// the hierarchical system can adapt the edges and the physics to it's own options because not all combinations work with the hierarichical system.
options=this.layoutEngine.setOptions(options.layout,options);this.canvas.setOptions(options);// options for canvas are in globals
// pass the options to the modules
this.groups.setOptions(options.groups);this.nodesHandler.setOptions(options.nodes);this.edgesHandler.setOptions(options.edges);this.physics.setOptions(options.physics);this.manipulation.setOptions(options.manipulation,options,this.options);// manipulation uses the locales in the globals
this.interactionHandler.setOptions(options.interaction);this.renderer.setOptions(options.interaction);// options for rendering are in interaction
this.selectionHandler.setOptions(options.interaction);// options for selection are in interaction
// reload the settings of the nodes to apply changes in groups that are not referenced by pointer.
if(options.groups!==undefined){this.body.emitter.emit("refreshNodes");}// these two do not have options at the moment, here for completeness
//this.view.setOptions(options.view);
//this.clustering.setOptions(options.clustering);
if("configure"in options){if(!this.configurator){this.configurator=new Configurator$1(this,this.body.container,configureOptions,this.canvas.pixelRatio,configuratorHideOption);}this.configurator.setOptions(options.configure);}// if the configuration system is enabled, copy all options and put them into the config system
if(this.configurator&&this.configurator.options.enabled===true){var networkOptions={nodes:{},edges:{},layout:{},interaction:{},manipulation:{},physics:{},global:{}};deepExtend(networkOptions.nodes,this.nodesHandler.options);deepExtend(networkOptions.edges,this.edgesHandler.options);deepExtend(networkOptions.layout,this.layoutEngine.options);// load the selectionHandler and render default options in to the interaction group
deepExtend(networkOptions.interaction,this.selectionHandler.options);deepExtend(networkOptions.interaction,this.renderer.options);deepExtend(networkOptions.interaction,this.interactionHandler.options);deepExtend(networkOptions.manipulation,this.manipulation.options);deepExtend(networkOptions.physics,this.physics.options);// load globals into the global object
deepExtend(networkOptions.global,this.canvas.options);deepExtend(networkOptions.global,this.options);this.configurator.setModuleOptions(networkOptions);}// handle network global options
if(options.clickToUse!==undefined){if(options.clickToUse===true){if(this.activator===undefined){this.activator=new Activator$1(this.canvas.frame);this.activator.on("change",function(){_this2.body.emitter.emit("activate");});}}else{if(this.activator!==undefined){this.activator.destroy();delete this.activator;}this.body.emitter.emit("activate");}}else{this.body.emitter.emit("activate");}this.canvas.setSize();// start the physics simulation. Can be safely called multiple times.
this.body.emitter.emit("startSimulation");}};/**
 * Update the visible nodes and edges list with the most recent node state.
 *
 * Visible nodes are stored in this.body.nodeIndices.
 * Visible edges are stored in this.body.edgeIndices.
 * A node or edges is visible if it is not hidden or clustered.
 *
 * @private
 */Network.prototype._updateVisibleIndices=function(){var nodes=this.body.nodes;var edges=this.body.edges;this.body.nodeIndices=[];this.body.edgeIndices=[];for(var nodeId in nodes){if(Object.prototype.hasOwnProperty.call(nodes,nodeId)){if(!this.clustering._isClusteredNode(nodeId)&&nodes[nodeId].options.hidden===false){this.body.nodeIndices.push(nodes[nodeId].id);}}}for(var edgeId in edges){if(Object.prototype.hasOwnProperty.call(edges,edgeId)){var edge=edges[edgeId];// It can happen that this is executed *after* a node edge has been removed,
// but *before* the edge itself has been removed. Taking this into account.
var fromNode=nodes[edge.fromId];var toNode=nodes[edge.toId];var edgeNodesPresent=fromNode!==undefined&&toNode!==undefined;var isVisible=!this.clustering._isClusteredEdge(edgeId)&&edge.options.hidden===false&&edgeNodesPresent&&fromNode.options.hidden===false&&// Also hidden if any of its connecting nodes are hidden
toNode.options.hidden===false;// idem
if(isVisible){this.body.edgeIndices.push(edge.id);}}}};/**
 * Bind all events
 */Network.prototype.bindEventListeners=function(){var _this3=this;// This event will trigger a rebuilding of the cache everything.
// Used when nodes or edges have been added or removed.
this.body.emitter.on("_dataChanged",function(){_this3.edgesHandler._updateState();_this3.body.emitter.emit("_dataUpdated");});// this is called when options of EXISTING nodes or edges have changed.
this.body.emitter.on("_dataUpdated",function(){// Order important in following block
_this3.clustering._updateState();_this3._updateVisibleIndices();_this3._updateValueRange(_this3.body.nodes);_this3._updateValueRange(_this3.body.edges);// start simulation (can be called safely, even if already running)
_this3.body.emitter.emit("startSimulation");_this3.body.emitter.emit("_requestRedraw");});};/**
 * Set nodes and edges, and optionally options as well.
 *
 * @param {object} data              Object containing parameters:
 *                                   {Array | DataSet | DataView} [nodes] Array with nodes
 *                                   {Array | DataSet | DataView} [edges] Array with edges
 *                                   {String} [dot] String containing data in DOT format
 *                                   {String} [gephi] String containing data in gephi JSON format
 *                                   {Options} [options] Object with options
 */Network.prototype.setData=function(data){// reset the physics engine.
this.body.emitter.emit("resetPhysics");this.body.emitter.emit("_resetData");// unselect all to ensure no selections from old data are carried over.
this.selectionHandler.unselectAll();if(data&&data.dot&&(data.nodes||data.edges)){throw new SyntaxError('Data must contain either parameter "dot" or '+' parameter pair "nodes" and "edges", but not both.');}// set options
this.setOptions(data&&data.options);// set all data
if(data&&data.dot){console.warn("The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);");// parse DOT file
var dotData=DOTToGraph(data.dot);this.setData(dotData);return;}else if(data&&data.gephi){// parse DOT file
console.warn("The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);");var gephiData=parseGephi(data.gephi);this.setData(gephiData);return;}else{this.nodesHandler.setData(data&&data.nodes,true);this.edgesHandler.setData(data&&data.edges,true);}// emit change in data
this.body.emitter.emit("_dataChanged");// emit data loaded
this.body.emitter.emit("_dataLoaded");// find a stable position or start animating to a stable position
this.body.emitter.emit("initPhysics");};/**
 * Cleans up all bindings of the network, removing it fully from the memory IF the variable is set to null after calling this function.
 * var network = new vis.Network(..);
 * network.destroy();
 * network = null;
 */Network.prototype.destroy=function(){this.body.emitter.emit("destroy");// clear events
this.body.emitter.off();this.off();// delete modules
delete this.groups;delete this.canvas;delete this.selectionHandler;delete this.interactionHandler;delete this.view;delete this.renderer;delete this.physics;delete this.layoutEngine;delete this.clustering;delete this.manipulation;delete this.nodesHandler;delete this.edgesHandler;delete this.configurator;delete this.images;for(var nodeId in this.body.nodes){if(!Object.prototype.hasOwnProperty.call(this.body.nodes,nodeId))continue;delete this.body.nodes[nodeId];}for(var edgeId in this.body.edges){if(!Object.prototype.hasOwnProperty.call(this.body.edges,edgeId))continue;delete this.body.edges[edgeId];}// remove the container and everything inside it recursively
recursiveDOMDelete(this.body.container);};/**
 * Update the values of all object in the given array according to the current
 * value range of the objects in the array.
 *
 * @param {object} obj    An object containing a set of Edges or Nodes
 *                        The objects must have a method getValue() and
 *                        setValueRange(min, max).
 * @private
 */Network.prototype._updateValueRange=function(obj){var id;// determine the range of the objects
var valueMin=undefined;var valueMax=undefined;var valueTotal=0;for(id in obj){if(Object.prototype.hasOwnProperty.call(obj,id)){var value=obj[id].getValue();if(value!==undefined){valueMin=valueMin===undefined?value:Math.min(value,valueMin);valueMax=valueMax===undefined?value:Math.max(value,valueMax);valueTotal+=value;}}}// adjust the range of all objects
if(valueMin!==undefined&&valueMax!==undefined){for(id in obj){if(Object.prototype.hasOwnProperty.call(obj,id)){obj[id].setValueRange(valueMin,valueMax,valueTotal);}}}};/**
 * Returns true when the Network is active.
 *
 * @returns {boolean}
 */Network.prototype.isActive=function(){return!this.activator||this.activator.active;};Network.prototype.setSize=function(){return this.canvas.setSize.apply(this.canvas,arguments);};Network.prototype.canvasToDOM=function(){return this.canvas.canvasToDOM.apply(this.canvas,arguments);};Network.prototype.DOMtoCanvas=function(){return this.canvas.DOMtoCanvas.apply(this.canvas,arguments);};/**
 * Nodes can be in clusters. Clusters can also be in clusters. This function returns and array of
 * nodeIds showing where the node is.
 *
 * If any nodeId in the chain, especially the first passed in as a parameter, is not present in
 * the current nodes list, an empty array is returned.
 *
 * Example:
 * cluster 'A' contains cluster 'B',
 * cluster 'B' contains cluster 'C',
 * cluster 'C' contains node 'fred'.
 * `jsnetwork.clustering.findNode('fred')` will return `['A','B','C','fred']`.
 *
 * @param {string|number} nodeId
 * @returns {Array}
 */Network.prototype.findNode=function(){return this.clustering.findNode.apply(this.clustering,arguments);};Network.prototype.isCluster=function(){return this.clustering.isCluster.apply(this.clustering,arguments);};Network.prototype.openCluster=function(){return this.clustering.openCluster.apply(this.clustering,arguments);};Network.prototype.cluster=function(){return this.clustering.cluster.apply(this.clustering,arguments);};Network.prototype.getNodesInCluster=function(){return this.clustering.getNodesInCluster.apply(this.clustering,arguments);};Network.prototype.clusterByConnection=function(){return this.clustering.clusterByConnection.apply(this.clustering,arguments);};Network.prototype.clusterByHubsize=function(){return this.clustering.clusterByHubsize.apply(this.clustering,arguments);};Network.prototype.updateClusteredNode=function(){return this.clustering.updateClusteredNode.apply(this.clustering,arguments);};Network.prototype.getClusteredEdges=function(){return this.clustering.getClusteredEdges.apply(this.clustering,arguments);};Network.prototype.getBaseEdge=function(){return this.clustering.getBaseEdge.apply(this.clustering,arguments);};Network.prototype.getBaseEdges=function(){return this.clustering.getBaseEdges.apply(this.clustering,arguments);};Network.prototype.updateEdge=function(){return this.clustering.updateEdge.apply(this.clustering,arguments);};/**
 * This method will cluster all nodes with 1 edge with their respective connected node.
 * The options object is explained in full <a data-scroll="" data-options="{ &quot;easing&quot;: &quot;easeInCubic&quot; }" href="#optionsObject">below</a>.
 *
 * @param {object} [options]
 * @returns {undefined}
 */Network.prototype.clusterOutliers=function(){return this.clustering.clusterOutliers.apply(this.clustering,arguments);};Network.prototype.getSeed=function(){return this.layoutEngine.getSeed.apply(this.layoutEngine,arguments);};Network.prototype.enableEditMode=function(){return this.manipulation.enableEditMode.apply(this.manipulation,arguments);};Network.prototype.disableEditMode=function(){return this.manipulation.disableEditMode.apply(this.manipulation,arguments);};Network.prototype.addNodeMode=function(){return this.manipulation.addNodeMode.apply(this.manipulation,arguments);};Network.prototype.editNode=function(){return this.manipulation.editNode.apply(this.manipulation,arguments);};Network.prototype.editNodeMode=function(){console.warn("Deprecated: Please use editNode instead of editNodeMode.");return this.manipulation.editNode.apply(this.manipulation,arguments);};Network.prototype.addEdgeMode=function(){return this.manipulation.addEdgeMode.apply(this.manipulation,arguments);};Network.prototype.editEdgeMode=function(){return this.manipulation.editEdgeMode.apply(this.manipulation,arguments);};Network.prototype.deleteSelected=function(){return this.manipulation.deleteSelected.apply(this.manipulation,arguments);};Network.prototype.getPositions=function(){return this.nodesHandler.getPositions.apply(this.nodesHandler,arguments);};Network.prototype.getPosition=function(){return this.nodesHandler.getPosition.apply(this.nodesHandler,arguments);};Network.prototype.storePositions=function(){return this.nodesHandler.storePositions.apply(this.nodesHandler,arguments);};Network.prototype.moveNode=function(){return this.nodesHandler.moveNode.apply(this.nodesHandler,arguments);};Network.prototype.getBoundingBox=function(){return this.nodesHandler.getBoundingBox.apply(this.nodesHandler,arguments);};Network.prototype.getConnectedNodes=function(objectId){if(this.body.nodes[objectId]!==undefined){return this.nodesHandler.getConnectedNodes.apply(this.nodesHandler,arguments);}else{return this.edgesHandler.getConnectedNodes.apply(this.edgesHandler,arguments);}};Network.prototype.getConnectedEdges=function(){return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler,arguments);};Network.prototype.startSimulation=function(){return this.physics.startSimulation.apply(this.physics,arguments);};Network.prototype.stopSimulation=function(){return this.physics.stopSimulation.apply(this.physics,arguments);};Network.prototype.stabilize=function(){return this.physics.stabilize.apply(this.physics,arguments);};Network.prototype.getSelection=function(){return this.selectionHandler.getSelection.apply(this.selectionHandler,arguments);};Network.prototype.setSelection=function(){return this.selectionHandler.setSelection.apply(this.selectionHandler,arguments);};Network.prototype.getSelectedNodes=function(){return this.selectionHandler.getSelectedNodeIds.apply(this.selectionHandler,arguments);};Network.prototype.getSelectedEdges=function(){return this.selectionHandler.getSelectedEdgeIds.apply(this.selectionHandler,arguments);};Network.prototype.getNodeAt=function(){var node=this.selectionHandler.getNodeAt.apply(this.selectionHandler,arguments);if(node!==undefined&&node.id!==undefined){return node.id;}return node;};Network.prototype.getEdgeAt=function(){var edge=this.selectionHandler.getEdgeAt.apply(this.selectionHandler,arguments);if(edge!==undefined&&edge.id!==undefined){return edge.id;}return edge;};Network.prototype.selectNodes=function(){return this.selectionHandler.selectNodes.apply(this.selectionHandler,arguments);};Network.prototype.selectEdges=function(){return this.selectionHandler.selectEdges.apply(this.selectionHandler,arguments);};Network.prototype.unselectAll=function(){this.selectionHandler.unselectAll.apply(this.selectionHandler,arguments);this.selectionHandler.commitWithoutEmitting.apply(this.selectionHandler);this.redraw();};Network.prototype.redraw=function(){return this.renderer.redraw.apply(this.renderer,arguments);};Network.prototype.getScale=function(){return this.view.getScale.apply(this.view,arguments);};Network.prototype.getViewPosition=function(){return this.view.getViewPosition.apply(this.view,arguments);};Network.prototype.fit=function(){return this.view.fit.apply(this.view,arguments);};Network.prototype.moveTo=function(){return this.view.moveTo.apply(this.view,arguments);};Network.prototype.focus=function(){return this.view.focus.apply(this.view,arguments);};Network.prototype.releaseNode=function(){return this.view.releaseNode.apply(this.view,arguments);};Network.prototype.getOptionsFromConfigurator=function(){var options={};if(this.configurator){options=this.configurator.getOptions.apply(this.configurator);}return options;};var parseDOTNetwork=DOTToGraph;// overflow in UMD builds. They all export vis namespace therefore reexporting
// leads to loading vis to load vis to load vis…
exports.parseDOTNetwork=parseDOTNetwork;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _esm = require("./esm");

Object.keys(_esm).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _esm[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _esm[key];
    }
  });
});

},{"./esm":32}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AdaptationFinder = void 0;

const $ = require("jquery");

const utils = require("./utils"); // two values for a specific variable to use for comparisons


class ClimateVariable {
  constructor(table, variable_name, reference, value) {
    this.table = table;
    this.variable_name = variable_name;
    this.reference = reference;
    this.value = value;
    this.direction = "rising";

    if (reference > value) {
      this.direction = "falling";
    }
  }

  getDelta() {
    return this.value - this.reference;
  }

}

class AdaptationFinder {
  constructor() {
    this.variables = {};
    this.tables = ["future_year_avg", "future_summer_avg", "future_winter_avg"];
    this.variable_names = ["daily_precip", "mean_temp", //"max_temp",
    //"min_temp",
    "mean_windspeed" //"max_windspeed",
    //"min_windspeed"
    ];
  } // only works for active transport use
  // as that is the only thing we have data for


  calculateFactorChange(factor) {
    let rainDelta = -1.5; // mm/day

    let windDelta = -0.9; // km/hour

    let tempDelta = 2.6; // 1C/day
    // precip data = mm/day
    // temp data = degrees avg per day
    // wind = meters per second!
    // 1 m/s= 3.6 km/h
    // 1 km/h = 0.28 m/s

    windDelta /= 3.6;
    let v = this.variables["daily_precip"].getDelta() * rainDelta + this.variables["mean_windspeed"].getDelta() * windDelta + this.variables["mean_temp"].getDelta() * tempDelta;
    return v;
  }

  async loadVariable(table, variable_name, zones, reference_decade, value_decade) {
    // todo cache these so we don't need to reload all zones
    await $.getJSON("/api/future", {
      table: table,
      zones: zones,
      data_type: variable_name
    }, (data, status) => {
      let decades = utils.calculate_decades(data);
      this.variables[variable_name] = new ClimateVariable(table, variable_name, decades[reference_decade], decades[value_decade]); //console.log(table+" "+variable_name+"="+this.variables[variable_name].direction)
    });
  }

  async loadVariables(table, zones, variable_names, reference_decade, value_decade) {
    this.variables = {};

    for (let v of variable_names) {
      await this.loadVariable(table, v, zones, reference_decade, value_decade);
    }
  }

  causePolarityMatch(cause) {
    if (!this.variables[cause.variable]) {
      console.log("variable " + cause.variable + " not loaded");
      console.log(cause);
      return false;
    }

    if (cause.operator == "increase" && this.variables[cause.variable].direction == "rising") {
      return true;
    }

    if (cause.operator == "decrease" && this.variables[cause.variable].direction == "falling") {
      return true;
    }

    return false;
  }

  find(adaptations) {
    let ret = [];

    for (let aid in adaptations) {
      let a = adaptations[aid];
      a.variable;

      if (a.direction == "increase" && this.variables[a.variable].direction == "rising") {
        ret.push(a);
      }

      if (a.direction == "decrease" && this.variables[a.variable].direction == "falling") {
        ret.push(a);
      }
    }

    return ret;
  }

  referenceToHTML(ref) {
    if (ref.type == "link") {
      return "<a href='" + ref.link + "'>" + ref.link + "</a>";
    } else {
      let ret = "<b><a href='http://doi.org/" + ref.doi + "'>" + ref.title + "</a></b> ";
      ret += ref.authors.join(", ");
      ret += ": " + ref.journal;

      if (ref.date != "") {
        ret += " " + ref.date;
      }

      if (ref.issue != "") {
        ret += " Issue: " + ref.issue;
      }

      ret += " DOI: " + ref.doi;
      return ret;
    }
  }

  adaptationToHTML(a) {
    let s = "";

    if (a.long != "") {
      s += `<p>` + a.long + `</p>`;
    }

    s += "<ul>";

    if (a.refs.length > 0) {
      s += "<li><b>References</b>: <ol>";

      for (let ref of a.refs) {
        s += "<li>" + this.referenceToHTML(ref) + "</li>";
      }

      s += "</ol></li>";
    }

    if (a.case != "") {
      s += `<li><b>Case studies</b>: <ol>`;

      if (a.caseref != "") {
        s += `<li> <a href="` + a.caseref + `">` + a.case + `</a></li>`;
      } else {
        s += `<li>a.case</li>`;
      }

      s += `</ol></li>`;
    }

    s += "</ul>";
    return s;
  }

  updateHTML(adaptations_list) {
    // list adaptations
    let adaptations = this.find(adaptations_list);
    $("#adaptation-count").html(adaptations.length);
    $("#adaptations").empty();

    for (let a of adaptations) {
      $("#adaptations").append($('<button>').attr("class", "collapsible").html(a.short));
      $("#adaptations").append($('<div>').attr("class", "collapsible-content").html(this.adaptationToHTML(a)));
    }

    let coll = document.getElementsByClassName("collapsible");

    for (let i = 0; i < coll.length; i++) {
      coll[i].addEventListener("click", function () {
        this.classList.toggle("active");
        var content = this.nextElementSibling;
        content.classList.toggle("visible");
      });
    }
  }

}

exports.AdaptationFinder = AdaptationFinder;

},{"./utils":42,"jquery":28}],36:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.update_graph = update_graph;
exports.no_data = void 0;

// Copyright (C) 2021 Then Try This
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
const $ = require("jquery");

const svgUtil = require("./svg.js");

const utils = require("./utils.js");

const no_data = `<svg viewBox="0 0 240 80" xmlns="http://www.w3.org/2000/svg">
  <style>
    .heavy { font: bold 10px sans-serif; }
  </style>
  <text x="100" y="35" class="heavy">No Data</text>
</svg>`;
exports.no_data = no_data;
const graph_width = 650;
const graph_height = 270;
const winter_col = "#a4f9c8";
const summer_col = "#4c9f70";

function render_graph(decades_arr, scale) {
  var svg = new svgUtil.SVG(800, 300); // assume decades list all are the same size

  let bar_width = graph_width / Object.keys(decades_arr[0]).length;

  if (decades_arr.length == 1) {
    // draw the bars
    let x = 100;

    for (let dec of Object.keys(decades_arr[0])) {
      svg.add_bar(x, graph_height, bar_width - 2, decades_arr[0][dec] * scale, "20" + dec + "0", decades_arr[0][dec], summer_col);
      x += bar_width;
    }
  } else {
    let x = 100;

    for (let dec of Object.keys(decades_arr[0])) {
      svg.add_2bar(x, graph_height, bar_width - 2, decades_arr[0][dec] * scale, decades_arr[1][dec] * scale, "20" + dec + "0", decades_arr[0][dec], decades_arr[1][dec], winter_col, summer_col);
      x += bar_width;
    }
  }

  if (decades_arr.length == 2) {
    svg.add_rect(540, 0, 80, 30, summer_col);
    svg.add_rect(640, 0, 80, 30, winter_col);
    svg.add_text(545, 20, 18, "Summer");
    svg.add_text(650, 20, 18, "Winter");
  }

  svg.add_line(90, graph_height + 5, 790, graph_height + 5, 1, "#000");
  svg.add_line(90, graph_height + 5, 90, 5, 1, "#000");

  for (let i = 0; i < 5; i++) {
    let p = i * (graph_height / 5);
    svg.add_text(46, graph_height - p, 15, "" + (p / scale).toFixed(2));
  }

  let data_type = $("#graph-type").val();

  if (data_type == "daily_precip") {
    svg.add_sideways_text(30, graph_height - 50, "Millimetres per day");
  }

  if (data_type == "mean_temp" || data_type == "max_temp" || data_type == "min_temp") {
    svg.add_sideways_text(30, graph_height - 50, "Degrees celsius");
  }

  if (data_type == "mean_windspeed" || data_type == "max_windspeed" || data_type == "min_windspeed") {
    svg.add_sideways_text(30, graph_height - 50, "Metres per second");
  }

  return svg;
}

function calc_scale(graph_data, height) {
  // get the min/max for eventual graph scaling

  /*let minimum = 999999;
  let maximum = 0;
  	for (let decades of graph_data) {
  	for (let dec of Object.keys(decades)) {
  		if (minimum>decades[dec]) minimum = decades[dec]
  		if (maximum<decades[dec]) maximum = decades[dec]
  	}
  }*/
  let maximum = 0;
  let data_type = $("#graph-type").val();

  if (data_type == "daily_precip") {
    maximum = 5.5;
  }

  if (data_type == "mean_temp" || data_type == "max_temp" || data_type == "min_temp") {
    maximum = 27;
  }

  if (data_type == "mean_windspeed" || data_type == "max_windspeed" || data_type == "min_windspeed") {
    maximum = 8;
  }

  return height / maximum;
}

function redraw_graph(graph_data) {
  let decades = utils.calculate_decades(graph_data);
  $("#graph").empty();
  $("#graph").append(render_graph([decades], calc_scale([decades], graph_height - 50)).svg);
}

function redraw_graph_seasonal(winter_data, summer_data) {
  let winter_decades = utils.calculate_decades(winter_data);
  let summer_decades = utils.calculate_decades(summer_data);
  $("#graph").empty();
  $("#graph").append(render_graph([winter_decades, summer_decades], calc_scale([winter_decades, summer_decades], graph_height - 50)).svg);
}

function update_graph(lsoa_zones, time) {
  let zones = [];

  for (let zone of lsoa_zones) {
    // keep duplicates for weighted averaging
    if (zone.tile != undefined) {
      zones.push(zone.tile);
    }
  }

  if (zones.length == 0) {
    $("#graph").html(no_data);
    return;
  }

  if (time == "yearly") {
    $.getJSON("/api/future", {
      table: "future_year_avg",
      zones: zones,
      data_type: $("#graph-type").val()
    }, (data, status) => {
      redraw_graph(data);
    });
  } else {
    $.getJSON("/api/future", {
      table: "future_winter_avg",
      zones: zones,
      data_type: $("#graph-type").val()
    }, (winter_data, status) => {
      $.getJSON("/api/future", {
        table: "future_summer_avg",
        zones: zones,
        data_type: $("#graph-type").val()
      }, (summer_data, status) => {
        redraw_graph_seasonal(winter_data, summer_data);
      });
    });
  }
}

},{"./svg.js":41,"./utils.js":42,"jquery":28}],37:[function(require,module,exports){
// Copyright (C) 2021 Then Try This
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

const $ = require("jquery")
const L = require("leaflet")
const zones = require("./lsoa.js")
const graph = require("./graph.js")
const network = require("./network.js")
const esri = require("esri-leaflet")

var leaflet_map = L.map('leaflet-map').setView([50.26123046875, -5.052745342254639], 10);

var baseMaps = {
    "Terrain": L.tileLayer("http://{s}.tile.stamen.com/terrain/{z}/{x}/{y}.png", {attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="http://openstreetmap.org">OpenStreetMap</a>, under <a href="http://www.openstreetmap.org/copyright">ODbL</a>.'}),
    "OpenStreetMap": L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'}),
    "Toner": L.tileLayer("http://{s}.tile.stamen.com/toner/{z}/{x}/{y}.png", {attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="http://openstreetmap.org">OpenStreetMap</a>, under <a href="http://www.openstreetmap.org/copyright">ODbL</a>.'}),
    "Watercolor":L.tileLayer("http://{s}.tile.stamen.com/watercolor/{z}/{x}/{y}.jpg", {attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="http://openstreetmap.org">OpenStreetMap</a>, under <a href="http://creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>.'}),
    "Humanitarian": L.tileLayer("http://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png", {attribution: '©OpenStreetMap contributors. Tiles style by Humanitarian OpenStreetMap Team hosted by OpenStreetMap France. Website and API terms'}),
    "OS Open Grey": L.tileLayer("https://tiles.arcgis.com/tiles/qHLhLQrcvEnxjtPr/arcgis/rest/services/os_open_greyscale_no_labels/MapServer/tile/{z}/{x}/{y}.png")

};

L.control.layers(baseMaps).addTo(leaflet_map);
//L.tileLayer("http://{s}.tile.stamen.com/terrain/{z}/{x}/{y}.png", {attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, under <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="http://openstreetmap.org">OpenStreetMap</a>, under <a href="http://www.openstreetmap.org/copyright">ODbL</a>.'}).addTo(leaflet_map);

esri.basemapLayer("Gray").addTo(leaflet_map);
//esri.basemapLayer('DarkGrayLabels').addTo(leaflet_map);
esri.basemapLayer('ImageryLabels').addTo(leaflet_map);



//esri.basemapLayer("HumanGeography").addTo(leaflet_map);
//esri.basemapLayer('ShadedReliefLabels').addTo(leaflet_map);

async function setup() {
	const z = new zones.LSOAZones(leaflet_map)
	const net = new network.Network()
	
	leaflet_map.on("moveend", () => {
		z.update(leaflet_map,net);
	});

	$("#graph-type").on("change",() => {
		graph.update_graph(z.zones,$("#graph-time").val())
	})

	$("#graph-time").on("change",() => {
		console.log($("#graph-time").val());
		graph.update_graph(z.zones,$("#graph-time").val())
	})

/*	$("#net-type").on("change", () => {
		net.style=$("#net-type").val()
		net.buildGraph()
	})*/

	for (let t of net.types) {
		$('#'+t).on("change",() => {
			net.buildGraph()
		})
	}

	$("#climate_variables").on("change", () => {
		net.updateVariables($("#climate_variables").val());
	})
	
	$("#graph").html(graph.no_data)

	await net.loadIconCache()

	z.update(leaflet_map,net)
}

setup()

},{"./graph.js":36,"./lsoa.js":38,"./network.js":40,"esri-leaflet":5,"jquery":28,"leaflet":29}],38:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LSOAZones = void 0;

// Copyright (C) 2021 Then Try This
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
const $ = require("jquery");

const L = require("leaflet");

const graph = require("./graph.js");

const colormap = require('colormap');

const network = require("./network.js"); // helpers for map geometry


function lerp(a, b, t) {
  return a * (1 - t) + b * t;
}

function zoom_to_tol(zoom) {
  let t = zoom / 18;
  return lerp(0.001, 0.000001, t);
}

function stringify_list(l) {
  if (l.length == 0) return "";
  if (l.length == 1) return "" + l[0];
  if (l.length == 2) return l[0] + " and " + l[1];
  let c = 0;
  let ret = "";

  for (let v of l) {
    if (c == l.length - 1) {
      ret += " and " + v;
    } else {
      if (c == l.length - 2) {
        ret += v;
      } else {
        ret += v + ", ";
      }
    }

    c += 1;
  }

  return ret;
}

class LSOAZones {
  constructor(leaflet_map) {
    this.map = leaflet_map;
    this.zones = [];
    this.layer_buffer = [L.layerGroup().addTo(this.map), L.layerGroup().addTo(this.map)];
    this.current_layer_buffer = 0;
    this.other_layer_buffer = 1;
    this.cols = colormap({
      colormap: 'bathymetry',
      nshades: 100,
      format: 'hex',
      alpha: 0.5
    });
    this.cols.reverse();
    this.score_adjust = 0.7;
    var legend = L.control({
      position: 'bottomleft'
    });

    legend.onAdd = map => {
      var div = L.DomUtil.create('div', 'info legend');
      div.innerHTML += '<h3>Index of Multiple Deprivation Score</h3>';

      for (let i = 1; i < 100; i += 10) {
        div.innerHTML += '<div class="key" style="background:' + this.cols[i] + '"></div> ' + (i * this.score_adjust).toFixed(0) + "<br>";
      }

      return div;
    };

    legend.addTo(this.map);
    this.highlight_col = "#ffbc42"; //this.zone_col = "#42273b"
  }

  include(name, zones) {
    for (let zone of this.zones) {
      if (zone.name == name) return true;
    }

    return false;
  }

  remove(name) {
    let new_zones = [];

    for (let zone of this.zones) {
      if (name != zone.name) {
        new_zones.push(zone);
      }
    }

    this.zones = new_zones;
  }

  async update_list(net) {
    $('#selected-list').empty();
    let zone_names = [];

    for (let zone of this.zones) {
      zone_names.push(zone.name);
      $('#selected-list').append($("<li>").html(zone.name));
    }

    if (zone_names.length > 0) {
      $(".hidden-section").each(function (i) {
        $(this).css("display", "block");
      });
      $(".projected-regions").each(function (i) {
        $(this).html(stringify_list(zone_names));
      });
      let tiles = [];

      for (let z of this.zones) {
        tiles.push(z.tile);
      }

      net.tiles = tiles;
      await net.updateVariables();
      net.buildGraph();
    } else {
      $(".hidden-section").each(function (i) {
        $(this).css("display", "none");
      });
    }

    graph.update_graph(this.zones, $("#graph-time").val());
  }

  make_zone(feature, layer, net) {
    let col = this.cols[Math.round(feature.properties.imdscore / this.score_adjust)];

    if (this.include(feature.properties.name)) {
      layer.setStyle({
        'fillColor': this.highlight_col,
        'fillOpacity': 1
      });
    } else {
      layer.setStyle({
        'fillColor': col,
        'fillOpacity': 1
      });
    }

    layer.setStyle({
      'color': "#e6e6e6",
      'weight': 1,
      'opacity': 1,
      'fillOpacity': 1
    });
    layer.on('click', () => {
      if (!this.include(feature.properties.name)) {
        layer.setStyle({
          'fillColor': this.highlight_col,
          'fillOpacity': 1
        });
        this.zones.push({
          name: feature.properties.name,
          tile: feature.properties.zone
        });
      } else {
        layer.setStyle({
          'fillColor': col,
          'fillOpacity': 1
        });
        this.remove(feature.properties.name);
      }

      this.update_list(net);
    });
    layer.bindTooltip(feature.properties.name + "<br>IMD Score: " + feature.properties.imdscore).addTo(this.map);
    layer.on('mouseover', function (e) {
      layer.bringToFront();
      layer.setStyle({
        'weight': 3
      });
    });
    layer.on('mouseout', function (e) {
      layer.setStyle({
        'weight': 1
      });
    }); //layer.bindPopup(feature.properties.name)
  }

  swap_buffers(leaflet_map) {
    // double buffer to stop flickering
    leaflet_map.removeLayer(this.layer_buffer[this.other_layer_buffer]);
    this.layer_buffer[this.other_layer_buffer].clearLayers();
    this.layer_buffer[this.current_layer_buffer].addTo(leaflet_map);

    if (this.current_layer_buffer == 0) {
      this.current_layer_buffer = 1;
      this.other_layer_buffer = 0;
    } else {
      this.current_layer_buffer = 0;
      this.other_layer_buffer = 1;
    }
  }

  update(leaflet_map, net) {
    let b = leaflet_map.getBounds();
    $.getJSON("/api/lsoa", {
      left: b._southWest.lng,
      bottom: b._southWest.lat,
      right: b._northEast.lng,
      top: b._northEast.lat,
      tolerance: zoom_to_tol(leaflet_map.getZoom())
    }, (data, status) => {
      L.geoJSON(data, {
        onEachFeature: (feature, layer) => {
          this.make_zone(feature, layer, net);
        }
      }).addTo(this.layer_buffer[this.current_layer_buffer]);
      this.swap_buffers(leaflet_map);
    });
  }

}

exports.LSOAZones = LSOAZones;

},{"./graph.js":36,"./network.js":40,"colormap":3,"jquery":28,"leaflet":29}],39:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.net = void 0;
const net = {
  "causes": [{
    "id": 70,
    "short": "Temperature",
    "type": "+",
    "long": "In general, an increase in temperature leads to an increase in active transport use (note that in reality this will be more complex, and this is based on a single publication).",
    "factor": 24,
    "operator": "increase",
    "variable": "mean_temp",
    "refs": [{
      "type": "article",
      "doi": "10.1186/1476-069x-11-12",
      "title": "Temporal, seasonal and weather effects on cycle volume: an ecological study",
      "authors": ["Sandar Tin Tin", "Alistair Woodward", "Elizabeth Robinson", "Shanthi Ameratunga"],
      "date": "2012",
      "journal": "Environmental Health",
      "issue": "1"
    }, {
      "type": "article",
      "doi": "10.1016/j.trd.2019.09.022",
      "title": "Impacts of weather on cycling and walking on twin trails in Seattle",
      "authors": ["Jinbao Zhao", "Cong Guo", "Ruhua Zhang", "Dong Guo", "Mathew Palmer"],
      "date": "2019",
      "journal": "Transportation Research Part D: Transport and Environment",
      "issue": ""
    }],
    "unsdg": ""
  }, {
    "id": 105,
    "short": "Rain",
    "type": "-",
    "long": "In general, an increase in precipitation leads to decreased use of active transport.",
    "factor": 24,
    "operator": "increase",
    "variable": "daily_precip",
    "refs": [{
      "type": "article",
      "doi": "10.1007/s11116-012-9398-5",
      "title": "Exploring temporal fluctuations of daily cycling demand on Dutch cycle paths: the influence of weather on cycling",
      "authors": ["Tom Thomas", "Rinus Jaarsma", "Bas Tutert"],
      "date": "2013",
      "journal": "Transportation",
      "issue": "1"
    }, {
      "type": "article",
      "doi": "10.1186/1476-069x-11-12",
      "title": "Temporal, seasonal and weather effects on cycle volume: an ecological study",
      "authors": ["Sandar Tin Tin", "Alistair Woodward", "Elizabeth Robinson", "Shanthi Ameratunga"],
      "date": "2012",
      "journal": "Environmental Health",
      "issue": "1"
    }, {
      "type": "article",
      "doi": "10.1016/j.jtrangeo.2019.04.016",
      "title": "Weather and cycling in New York: The case of Citibike",
      "authors": ["Ran An", "Renee Zahnow", "Dorina Pojani", "Jonathan Corcoran"],
      "date": "2019",
      "journal": "Journal of Transport Geography",
      "issue": ""
    }, {
      "type": "article",
      "doi": "10.1186/1476-069x-11-12",
      "title": "Temporal, seasonal and weather effects on cycle volume: an ecological study",
      "authors": ["Sandar Tin Tin", "Alistair Woodward", "Elizabeth Robinson", "Shanthi Ameratunga"],
      "date": "2012",
      "journal": "Environmental Health",
      "issue": "1"
    }, {
      "type": "article",
      "doi": "10.1016/j.trd.2019.09.022",
      "title": "Impacts of weather on cycling and walking on twin trails in Seattle",
      "authors": ["Jinbao Zhao", "Cong Guo", "Ruhua Zhang", "Dong Guo", "Mathew Palmer"],
      "date": "2019",
      "journal": "Transportation Research Part D: Transport and Environment",
      "issue": ""
    }],
    "unsdg": ""
  }, {
    "id": 121,
    "short": "Wind speed",
    "type": "-",
    "long": "In general, an increase in wind speed leads to a decrease in active transport use.",
    "factor": 24,
    "operator": "increase",
    "variable": "mean_windspeed",
    "refs": [{
      "type": "article",
      "doi": "10.1186/1476-069x-11-12",
      "title": "Temporal, seasonal and weather effects on cycle volume: an ecological study",
      "authors": ["Sandar Tin Tin", "Alistair Woodward", "Elizabeth Robinson", "Shanthi Ameratunga"],
      "date": "2012",
      "journal": "Environmental Health",
      "issue": "1"
    }, {
      "type": "article",
      "doi": "10.1016/j.trd.2019.09.022",
      "title": "Impacts of weather on cycling and walking on twin trails in Seattle",
      "authors": ["Jinbao Zhao", "Cong Guo", "Ruhua Zhang", "Dong Guo", "Mathew Palmer"],
      "date": "2019",
      "journal": "Transportation Research Part D: Transport and Environment",
      "issue": ""
    }],
    "unsdg": ""
  }],
  "factors": {
    "1": {
      "id": 1,
      "short": "Access to goods & services",
      "type": "Equity",
      "overview": "Y",
      "long": "",
      "refs": [],
      "unsdg": "10.3 Equity and affordability of access to education, employment, and health-promoting goods and services by income, gender, age and ethnicity",
      "impacts": [54, 68, 85, 88, 108, 132, 143]
    },
    "2": {
      "id": 2,
      "short": "Local crime",
      "type": "Equity",
      "overview": "",
      "long": "Local crime, including violence against women and girls.",
      "refs": [],
      "unsdg": "5.2 Violence against women and girls",
      "impacts": [137, 142]
    },
    "3": {
      "id": 3,
      "short": "Proportion of people getting enough daily exercise",
      "type": "Equity",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "3.4 Proportion of people getting enough daily exercise",
      "impacts": [84]
    },
    "4": {
      "id": 4,
      "short": "Gentrification",
      "type": "Community",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "",
      "impacts": [76, 97]
    },
    "5": {
      "id": 5,
      "short": "Attractiveness of streets/parks to locals",
      "type": "Community",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "",
      "impacts": [90, 115, 116, 136]
    },
    "6": {
      "id": 6,
      "short": "Incorporation of culture & indigenous biodiversity in design",
      "type": "Equity",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "15.9 Appropriateness of design (cultural landscapes) and incorporation of indigenous biodiversity",
      "impacts": [82, 138]
    },
    "7": {
      "id": 7,
      "short": "Exposure to other people",
      "type": "Health",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "",
      "impacts": [131]
    },
    "8": {
      "id": 8,
      "short": "Cultural wellbeing & protection of cultural heritage",
      "type": "Equity",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "11.4 Cultural wellbeing and protection of cultural heritage",
      "impacts": [59]
    },
    "9": {
      "id": 9,
      "short": "Direct environmental effects from cars",
      "type": "Travel",
      "overview": "",
      "long": "- Exhaust (from internal combustion engine cars)\n- Other auto-related pollutants (e.g. microplastics from tyres)\n- Road noise",
      "refs": [],
      "unsdg": "",
      "impacts": [78, 119, 126]
    },
    "10": {
      "id": 10,
      "short": "Community action to resolve minor anti-social behaviour",
      "type": "Community",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "",
      "impacts": [60]
    },
    "11": {
      "id": 11,
      "short": "Car accidents",
      "type": "Travel",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "",
      "impacts": [106, 128]
    },
    "12": {
      "id": 12,
      "short": "Public transport use",
      "type": "Travel",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "",
      "impacts": [48, 71, 95]
    },
    "13": {
      "id": 13,
      "short": "Local sense of security",
      "type": "Community",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "",
      "impacts": [99]
    },
    "14": {
      "id": 14,
      "short": "Access to safe & inclusive public green spaces",
      "type": "Equity",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "",
      "impacts": [55, 96]
    },
    "15": {
      "id": 15,
      "short": "Place attachment",
      "type": "Community",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "",
      "impacts": [100]
    },
    "16": {
      "id": 16,
      "short": "Community capacity & empowerment",
      "type": "Community",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "",
      "impacts": [110, 111]
    },
    "17": {
      "id": 17,
      "short": "Relative local property values",
      "type": "Community",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "",
      "impacts": [114]
    },
    "18": {
      "id": 18,
      "short": "Equity in access to basic services",
      "type": "Equity",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "1.4 Equity in rights to access basic services",
      "impacts": []
    },
    "19": {
      "id": 19,
      "short": "Local air quality",
      "type": "Health",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "11.6 Local air pollution",
      "impacts": [62]
    },
    "20": {
      "id": 20,
      "short": "Public health & wellbeing",
      "type": "main element",
      "overview": "",
      "long": "Good public health is described as an absence of disease and injuries.\n\nHigh wellbeing in a community is described as the state when members of the community are feeling good and functioning well.",
      "refs": [],
      "unsdg": "3. Ensure healthy lives and promote well-being for all at all ages|5. Achieve gender equality and empower all women and girls|11. Make cities and human settlements inclusive|safe|resilient and sustainable|10. Reduce inequality within and among countries|13. Take urgent action to combat climate change and its impacts|16. Promote peaceful and inclusive societies for sustainable development|provide access to justice for all and build effective|accountable and inclusive institutions at all levels",
      "impacts": []
    },
    "21": {
      "id": 21,
      "short": "Disparities in access to education",
      "type": "Equity",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "4.5 Disparities in access to education",
      "impacts": [52]
    },
    "22": {
      "id": 22,
      "short": "Investment in walking & cycling infrastructure",
      "type": "Travel",
      "overview": "",
      "long": "Investment in further walking and cycling infrastructure to connect different areas.",
      "refs": [],
      "unsdg": "",
      "impacts": [92, 113]
    },
    "23": {
      "id": 23,
      "short": "Women's access to economic resources",
      "type": "Equity",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "5.7 Women's access to economic resources",
      "impacts": []
    },
    "24": {
      "id": 24,
      "short": "Active transport use",
      "type": "main element",
      "overview": "Y",
      "long": "Defined as the number of trips made by active transport, i.e. walking and cycling.",
      "refs": [],
      "unsdg": "",
      "impacts": [49, 72, 75, 89, 109, 133, 141]
    },
    "25": {
      "id": 25,
      "short": "Dense mixed land use",
      "type": "Sustainable-development",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "",
      "impacts": [134, 144]
    },
    "26": {
      "id": 26,
      "short": "Tenure length",
      "type": "Community",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "",
      "impacts": [130]
    },
    "27": {
      "id": 27,
      "short": "Presence of people on local streets",
      "type": "Community",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "",
      "impacts": [74, 107, 125, 129]
    },
    "28": {
      "id": 28,
      "short": "Injuries",
      "type": "Health",
      "overview": "Y",
      "long": "Among others, injuries can result from:\n- Car crashes\n- Striking the ground after falling",
      "refs": [],
      "unsdg": "3.6 Reduce injuries from road traffic accidents",
      "impacts": [66]
    },
    "29": {
      "id": 29,
      "short": "Speed of emergency ground transportation",
      "type": "Travel",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "",
      "impacts": [56]
    },
    "30": {
      "id": 30,
      "short": "Wellbeing",
      "type": "Health",
      "overview": "Y",
      "long": "Wellbeing is about feeling good and functioning well, and comprises an individual\u2019s experience of their life, and a comparison of life circumstances with social norms and values.",
      "refs": [],
      "unsdg": "https://www.gov.uk/government/publications/wellbeing-and-health",
      "impacts": [83]
    },
    "31": {
      "id": 31,
      "short": "Exposure to traffic",
      "type": "Travel",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "",
      "impacts": [81]
    },
    "32": {
      "id": 32,
      "short": "Communicable diseases",
      "type": "Health",
      "overview": "Y",
      "long": "Communicable, or infectious diseases, are caused by microorganisms such as bacteria, viruses, parasites and fungi that can be spread, directly or indirectly, from one person to another.\n\nCommunicable diseases include:\n- Influenza\n- COVID-19\n- Tuberculosis\n- HIV/AIDS\n- Hepatitis",
      "refs": [{
        "doi": "https://www.euro.who.int/en/health-topics/communicable-diseases",
        "type": "link",
        "link": "https://www.euro.who.int/en/health-topics/communicable-diseases"
      }],
      "unsdg": "",
      "impacts": [86]
    },
    "33": {
      "id": 33,
      "short": "Resilience to economic, social & environmental shocks",
      "type": "Sustainable-development",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "1.5 Resilience to economic, social and environmental shocks",
      "impacts": []
    },
    "34": {
      "id": 34,
      "short": "Private vehicle use",
      "type": "Travel",
      "overview": "Y",
      "long": "Private vehicle use is defined by the number of local trips taken by private vehicles.",
      "refs": [],
      "unsdg": "",
      "impacts": [58, 63, 87, 98, 102, 124, 127]
    },
    "35": {
      "id": 35,
      "short": "Number of local walking & cycling injuries",
      "type": "Sustainable-development",
      "overview": "Y",
      "long": "",
      "refs": [],
      "unsdg": "3.6 Number of local walking and cycling injuries",
      "impacts": [69, 112]
    },
    "36": {
      "id": 36,
      "short": "Local vehicle volumes",
      "type": "Travel",
      "overview": "",
      "long": "Local vehicle volumes are defined by the traffic congestion and traffic density in the local area.",
      "refs": [],
      "unsdg": "",
      "impacts": [53, 77, 101, 103, 118, 120]
    },
    "37": {
      "id": 37,
      "short": "Community participation in planning",
      "type": "Equity",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "16.7 Meaningful community participation in local design and planning|11.3 Enable inclusive and sustainable urbanization through participatory planning",
      "impacts": [67, 140]
    },
    "38": {
      "id": 38,
      "short": "Rate of disease spread",
      "type": "Health",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "",
      "impacts": [61]
    },
    "39": {
      "id": 39,
      "short": "Equity in access to healthcare services",
      "type": "Equity",
      "overview": "Y",
      "long": "",
      "refs": [],
      "unsdg": "3.8 Equity in access to healthcare services",
      "impacts": [79, 123]
    },
    "40": {
      "id": 40,
      "short": "Local community social connection",
      "type": "Community",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "",
      "impacts": [91, 94, 117, 139]
    },
    "41": {
      "id": 41,
      "short": "Feeling safe during active transport",
      "type": "Travel",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "",
      "impacts": [80]
    },
    "42": {
      "id": 42,
      "short": "Disparities in access to work & training",
      "type": "Equity",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "8.5 and 8.6 Disparities in access to work and training",
      "impacts": []
    },
    "43": {
      "id": 43,
      "short": "Local vehicle speeds",
      "type": "Travel",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "",
      "impacts": [93, 122]
    },
    "44": {
      "id": 44,
      "short": "Urbanization",
      "type": "Sustainable-development",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "",
      "impacts": [51]
    },
    "45": {
      "id": 45,
      "short": "Non-communicable diseases",
      "type": "Health",
      "overview": "Y",
      "long": "Non-communicable diseases, including chronic diseases, tend to be of long duration and are the result of a combination of genetic, physiological, environmental and behavioural factors.\n\nNon-communicable diseases include:\n- Cardiovascular (heart) diseases\n- Cancers\n- Diabetes\n- Chronic respiratory diseases\n- Mental health disorders\n- Dementias",
      "refs": [{
        "doi": "https://www.who.int/news-room/fact-sheets/detail/noncommunicable-diseases",
        "type": "link",
        "link": "https://www.who.int/news-room/fact-sheets/detail/noncommunicable-diseases"
      }],
      "unsdg": "3.4 Reduce non-communicable diseases",
      "impacts": [73]
    },
    "46": {
      "id": 46,
      "short": "Greenhouse gas emissions",
      "type": "Sustainable-development",
      "overview": "",
      "long": "",
      "refs": [],
      "unsdg": "13.2 Transport greenhouse gas emissions",
      "impacts": []
    },
    "47": {
      "id": 47,
      "short": "Walk/bike friendly & safe environment",
      "type": "Equity",
      "overview": "Y",
      "long": "",
      "refs": [],
      "unsdg": "",
      "impacts": [50, 57, 64, 65, 104, 135]
    }
  },
  "impacts": {
    "48": {
      "id": 48,
      "from": 12,
      "to": 24,
      "type": "-",
      "long": "Increased public transport use leads to decreased active transport use.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "49": {
      "id": 49,
      "from": 24,
      "to": 35,
      "type": "+",
      "long": "Increased active transport use leads to increased local walking and cycling injuries.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "50": {
      "id": 50,
      "from": 47,
      "to": 12,
      "type": "-",
      "long": "A less walk/bike friendly environment leads to more public transport use.\n\nIf parents perceive the environment as less safe (crime, transport infrastructure etc), their children use public transport more.",
      "refs": [{
        "type": "article",
        "doi": "10.1111/obr.13185",
        "title": "Understanding obesity\u2010related behaviors in youth from a systems dynamics perspective: The use of causal loop diagrams",
        "authors": ["Wilma E. Waterlander", "Amika Singh", "Teatske Altenburg", "Coosje Dijkstra", "Angie Luna Pinzon", "Manou Anselma", "Vincent Busch", "Lieke Houtum", "Helga Emke", "Meredith L. Overman", "Mai J.M. Chinapaw", "Karien Stronks"],
        "date": "2021",
        "journal": "Obesity Reviews",
        "issue": "7"
      }],
      "unsdg": ""
    },
    "51": {
      "id": 51,
      "from": 44,
      "to": 36,
      "type": "+",
      "long": "More urbanization leads to more traffic congestion and increased traffic density.",
      "refs": [{
        "type": "article",
        "doi": "10.1111/obr.13185",
        "title": "Understanding obesity\u2010related behaviors in youth from a systems dynamics perspective: The use of causal loop diagrams",
        "authors": ["Wilma E. Waterlander", "Amika Singh", "Teatske Altenburg", "Coosje Dijkstra", "Angie Luna Pinzon", "Manou Anselma", "Vincent Busch", "Lieke Houtum", "Helga Emke", "Meredith L. Overman", "Mai J.M. Chinapaw", "Karien Stronks"],
        "date": "2021",
        "journal": "Obesity Reviews",
        "issue": "7"
      }],
      "unsdg": ""
    },
    "52": {
      "id": 52,
      "from": 21,
      "to": 42,
      "type": "+",
      "long": "Increased disparities in access to education leads to increased disparities in access to work and training.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "53": {
      "id": 53,
      "from": 36,
      "to": 29,
      "type": "-",
      "long": "Increased traffic congestion and density leads to decreased speed of emergency ground transportation.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "54": {
      "id": 54,
      "from": 1,
      "to": 18,
      "type": "+",
      "long": "Increased access to goods and services leads to an increase in equitable access to basic services.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "55": {
      "id": 55,
      "from": 14,
      "to": 45,
      "type": "-",
      "long": "Increased access to safe and inclusive public green spaces leads to decreased non-communicable diseases in the community.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2018.03.323",
        "title": "The nexus between climate change, ecosystem services and human health: Towards a conceptual framework",
        "authors": ["Aline Chiabai", "Sonia Quiroga", "Pablo Martinez-Juarez", "Sahran Higgins", "Tim Taylor"],
        "date": "2018",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "56": {
      "id": 56,
      "from": 29,
      "to": 1,
      "type": "+",
      "long": "Increased speed of emergency ground transportation leads to increased access & equity in access to goods and services.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "57": {
      "id": 57,
      "from": 47,
      "to": 22,
      "type": "+",
      "long": "A more walk/bike friendly and safe environment leads to more investment in walking and cycling infrastructure.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "58": {
      "id": 58,
      "from": 34,
      "to": 1,
      "type": "+",
      "long": "Increased private vehicle use leads to increased access to goods and services.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "59": {
      "id": 59,
      "from": 8,
      "to": 30,
      "type": "+",
      "long": "Increased cultural wellbeing and increased protection of cultural heritage lead to increased general wellbeing of the community.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "60": {
      "id": 60,
      "from": 10,
      "to": 5,
      "type": "+",
      "long": "Increased community action to resolve minor anti-social behaviour leads to streets and parks that are more attractive to locals.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "61": {
      "id": 61,
      "from": 38,
      "to": 32,
      "type": "+",
      "long": "An increase in the rate of disease spread leads to an increase in communicable diseases.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "62": {
      "id": 62,
      "from": 19,
      "to": 45,
      "type": "-",
      "long": "A decrease in local air quality leads to an increase in non-communicable diseases.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "63": {
      "id": 63,
      "from": 34,
      "to": 9,
      "type": "+",
      "long": "Increased automobile use leads to increased direct environmental effects from automobiles (such as exhaust and other pollutants, road noise).",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "64": {
      "id": 64,
      "from": 47,
      "to": 25,
      "type": "+",
      "long": "A more walk/bike friendly and safe environment leads to more dense mixed land use.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "65": {
      "id": 65,
      "from": 47,
      "to": 1,
      "type": "+",
      "long": "A more walk/bike friendly and safe environment leads to more access to goods and services.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "66": {
      "id": 66,
      "from": 28,
      "to": 20,
      "type": "-",
      "long": "More injuries lead to a decline in public health and wellbeing.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "67": {
      "id": 67,
      "from": 37,
      "to": 6,
      "type": "+",
      "long": "Increased community participation in planning leads to increased incorporation of culture & indigenous biodiversity in design.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "68": {
      "id": 68,
      "from": 1,
      "to": 21,
      "type": "-",
      "long": "Increased access to goods and services leads to decreased disparities in access to education.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "69": {
      "id": 69,
      "from": 35,
      "to": 28,
      "type": "+",
      "long": "Increased local walking and cycling injuries mean an increase in the overall number of injuries in the community.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "71": {
      "id": 71,
      "from": 12,
      "to": 34,
      "type": "-",
      "long": "Increased public transport network usage leads to decreased individual automobile usage.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "72": {
      "id": 72,
      "from": 24,
      "to": 46,
      "type": "-",
      "long": "An increase in active transport use leads to decreased greenhouse gas emissions.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "73": {
      "id": 73,
      "from": 45,
      "to": 20,
      "type": "-",
      "long": "Increased non-communicable diseases leads to decreased public health and wellbeing.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "74": {
      "id": 74,
      "from": 27,
      "to": 13,
      "type": "+",
      "long": "Increased presence of people on local streets leads to an increased local sense of security.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "75": {
      "id": 75,
      "from": 24,
      "to": 43,
      "type": "-",
      "long": "Increased active transport use leads to a decrease in local vehicle speeds.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "76": {
      "id": 76,
      "from": 4,
      "to": 26,
      "type": "-",
      "long": "Increased gentrification leads to decreased tenure length.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "77": {
      "id": 77,
      "from": 36,
      "to": 9,
      "type": "+",
      "long": "Increased local vehicle volumes leads to increased environmental effects from cars.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "78": {
      "id": 78,
      "from": 9,
      "to": 47,
      "type": "-",
      "long": "Increased environmental effects from automobiles (such as exhaust and noise) leads to a less attractive environment for active travelers.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "79": {
      "id": 79,
      "from": 39,
      "to": 45,
      "type": "-",
      "long": "More equitable access to healthcare services leads to a decrease in non-communicable diseases.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "80": {
      "id": 80,
      "from": 41,
      "to": 24,
      "type": "+",
      "long": "More people feeling safe during active transport leads to increased use of active transport.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "81": {
      "id": 81,
      "from": 31,
      "to": 47,
      "type": "-",
      "long": "Increased exposure to traffic leads to a less walk/bike friendly and safe environment.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "82": {
      "id": 82,
      "from": 6,
      "to": 8,
      "type": "+",
      "long": "Increased incorporation of culture & indigenous biodiversity in design leads to better cultural wellbeing and the protection of cultural heritage.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "83": {
      "id": 83,
      "from": 30,
      "to": 20,
      "type": "+",
      "long": "An increase in community wellbeing leads to better public health and wellbeing.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "84": {
      "id": 84,
      "from": 3,
      "to": 45,
      "type": "-",
      "long": "Increased proportion of people getting enough daily exercise leads to a decrease in non-communicable diseases.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "85": {
      "id": 85,
      "from": 1,
      "to": 39,
      "type": "+",
      "long": "Increased access to goods and services leads to an increase in equitable access to healthcare services.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "86": {
      "id": 86,
      "from": 32,
      "to": 20,
      "type": "-",
      "long": "Increased communicable diseases lead to decreased public health and wellbeing.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "87": {
      "id": 87,
      "from": 34,
      "to": 11,
      "type": "+",
      "long": "Increased private vehicle use leads to more car accidents.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "88": {
      "id": 88,
      "from": 1,
      "to": 23,
      "type": "+",
      "long": "Increased access to goods and services leads to an increase in women's access to economic resources.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "89": {
      "id": 89,
      "from": 24,
      "to": 45,
      "type": "-",
      "long": "Increased active transport by the community leads to a decrease in non-communicable diseases.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "90": {
      "id": 90,
      "from": 5,
      "to": 15,
      "type": "+",
      "long": "Streets and parks that are more attractive to locals lead to increased place attachment.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "91": {
      "id": 91,
      "from": 40,
      "to": 33,
      "type": "+",
      "long": "Increased social connection in the local community leads to increased resilience to economic, social & environmental shocks.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "92": {
      "id": 92,
      "from": 22,
      "to": 47,
      "type": "+",
      "long": "Increased investment in walking and cycling infrastructure leads to a more walk/bike friendly and safe environment.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "93": {
      "id": 93,
      "from": 43,
      "to": 41,
      "type": "-",
      "long": "Increased local vehicle speeds leads to people feeling less safe during active transport.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "94": {
      "id": 94,
      "from": 40,
      "to": 13,
      "type": "+",
      "long": "Increased social connection in the local community leads to people feeling safer.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "95": {
      "id": 95,
      "from": 12,
      "to": 7,
      "type": "+",
      "long": "Increased public transport use leads to increased exposure to other people.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "96": {
      "id": 96,
      "from": 14,
      "to": 30,
      "type": "+",
      "long": "Increased access to safe and inclusive public green spaces leads to increased wellbeing in the community.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2018.03.323",
        "title": "The nexus between climate change, ecosystem services and human health: Towards a conceptual framework",
        "authors": ["Aline Chiabai", "Sonia Quiroga", "Pablo Martinez-Juarez", "Sahran Higgins", "Tim Taylor"],
        "date": "2018",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "97": {
      "id": 97,
      "from": 4,
      "to": 40,
      "type": "-",
      "long": "Increased gentrification leads to decreased social connection in the local community.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "98": {
      "id": 98,
      "from": 34,
      "to": 36,
      "type": "+",
      "long": "Increased individual car use causes more traffic congestion and density.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }, {
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "99": {
      "id": 99,
      "from": 13,
      "to": 24,
      "type": "+",
      "long": "Increased local sense of security (feeling safe) leads to increased active transport use.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "100": {
      "id": 100,
      "from": 15,
      "to": 26,
      "type": "+",
      "long": "Increased place attachment leads to an increase in tenure length.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "101": {
      "id": 101,
      "from": 36,
      "to": 35,
      "type": "+",
      "long": "Increased local vehicle volumes lead to increased local walking and cycling injuries.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "102": {
      "id": 102,
      "from": 34,
      "to": 7,
      "type": "-",
      "long": "Increased private vehicle use leads to decreased exposure to other people.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "103": {
      "id": 103,
      "from": 36,
      "to": 41,
      "type": "-",
      "long": "Increased local vehicle volumes lead to feeling less safe during active transport.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "104": {
      "id": 104,
      "from": 47,
      "to": 24,
      "type": "+",
      "long": "A more walk/bike friendly environment leads to more active transport (cycling, walking).\n\nIf parents perceive the environment as safer (crime, transport infrastructure etc), children use active transport more.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }, {
        "type": "article",
        "doi": "10.1111/obr.13185",
        "title": "Understanding obesity\u2010related behaviors in youth from a systems dynamics perspective: The use of causal loop diagrams",
        "authors": ["Wilma E. Waterlander", "Amika Singh", "Teatske Altenburg", "Coosje Dijkstra", "Angie Luna Pinzon", "Manou Anselma", "Vincent Busch", "Lieke Houtum", "Helga Emke", "Meredith L. Overman", "Mai J.M. Chinapaw", "Karien Stronks"],
        "date": "2021",
        "journal": "Obesity Reviews",
        "issue": "7"
      }],
      "unsdg": ""
    },
    "106": {
      "id": 106,
      "from": 11,
      "to": 36,
      "type": "+",
      "long": "Increased car accidents cause increased traffic density and congestion.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "107": {
      "id": 107,
      "from": 27,
      "to": 7,
      "type": "+",
      "long": "Increased presence of people on local streets leads to more exposure to other people.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }, {
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "108": {
      "id": 108,
      "from": 1,
      "to": 42,
      "type": "-",
      "long": "Increased access to goods and services leads to less disparities in access to work and training.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "109": {
      "id": 109,
      "from": 24,
      "to": 3,
      "type": "+",
      "long": "Increased use of active transport leads to more people getting enough daily exercise.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "110": {
      "id": 110,
      "from": 16,
      "to": 10,
      "type": "+",
      "long": "Increased community capacity and empowerment leads to increased community action to resolve minor anti-social behaviour.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "111": {
      "id": 111,
      "from": 16,
      "to": 37,
      "type": "+",
      "long": "Increased community capacity and empowerment leads to more community participation in planning.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "112": {
      "id": 112,
      "from": 35,
      "to": 41,
      "type": "-",
      "long": "Increased local walking and cycling injuries lead to feeling less safe during active transport.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "113": {
      "id": 113,
      "from": 22,
      "to": 1,
      "type": "+",
      "long": "Increased investment in walking and cycling infrastructure leads to increased access to goods and services.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": "10.3 Equity and affordability of access to education, employment, and health-promoting goods and services by income, gender, age and ethnicity"
    },
    "114": {
      "id": 114,
      "from": 17,
      "to": 4,
      "type": "+",
      "long": "Increased local property values leads to increased gentrification.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "115": {
      "id": 115,
      "from": 5,
      "to": 17,
      "type": "+",
      "long": "Streets and parks that are more attractive to locals lead to increased relative local property values.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "116": {
      "id": 116,
      "from": 5,
      "to": 27,
      "type": "+",
      "long": "Increased attractiveness of streets and parks to locals leads to more people being on the local streets.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "117": {
      "id": 117,
      "from": 40,
      "to": 16,
      "type": "+",
      "long": "Increased social connection in the local community leads to increased community capacity and empowerment.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "118": {
      "id": 118,
      "from": 36,
      "to": 45,
      "type": "+",
      "long": "Increased local vehicle volumes leads to an increase in non-communicable diseases.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "119": {
      "id": 119,
      "from": 9,
      "to": 19,
      "type": "-",
      "long": "Increasing environmental effects from cars lead to a decrease in local air quality.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "120": {
      "id": 120,
      "from": 36,
      "to": 47,
      "type": "-",
      "long": "Increased traffic congestion and density lead to a less attractive environment for active travelers.\n\nIncreased traffic density leads to a perception of decreased safety for parents and children.",
      "refs": [{
        "type": "article",
        "doi": "10.1111/obr.13185",
        "title": "Understanding obesity\u2010related behaviors in youth from a systems dynamics perspective: The use of causal loop diagrams",
        "authors": ["Wilma E. Waterlander", "Amika Singh", "Teatske Altenburg", "Coosje Dijkstra", "Angie Luna Pinzon", "Manou Anselma", "Vincent Busch", "Lieke Houtum", "Helga Emke", "Meredith L. Overman", "Mai J.M. Chinapaw", "Karien Stronks"],
        "date": "2021",
        "journal": "Obesity Reviews",
        "issue": "7"
      }],
      "unsdg": ""
    },
    "122": {
      "id": 122,
      "from": 43,
      "to": 35,
      "type": "+",
      "long": "Increased local vehicle speeds lead to increased walking and cycling injuries.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "123": {
      "id": 123,
      "from": 39,
      "to": 32,
      "type": "-",
      "long": "More equitable access to healthcare services leads to a decrease in communicable diseases.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "124": {
      "id": 124,
      "from": 34,
      "to": 25,
      "type": "-",
      "long": "Increased private vehicle use leads to less dense mixed land use.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "125": {
      "id": 125,
      "from": 27,
      "to": 2,
      "type": "-",
      "long": "Increased presence of people on local streets leads to a decrease in local crime.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "126": {
      "id": 126,
      "from": 9,
      "to": 46,
      "type": "+",
      "long": "Increased environmental effects from cars leads to increased greenhouse gas emissions.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "127": {
      "id": 127,
      "from": 34,
      "to": 31,
      "type": "+",
      "long": "Increased individual automobile use leads to increased exposure to traffic.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "128": {
      "id": 128,
      "from": 11,
      "to": 28,
      "type": "+",
      "long": "Increased car accidents lead to increased injuries in the community.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "129": {
      "id": 129,
      "from": 27,
      "to": 5,
      "type": "+",
      "long": "Presence of more people on local streets leads to more attractive streets and parks to locals.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "130": {
      "id": 130,
      "from": 26,
      "to": 40,
      "type": "+",
      "long": "Increased tenure length in the local community leads to increased social connection.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "131": {
      "id": 131,
      "from": 7,
      "to": 38,
      "type": "+",
      "long": "Increased exposure to other people leads to increased rate of disease spread.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "132": {
      "id": 132,
      "from": 1,
      "to": 45,
      "type": "-",
      "long": "Increased access to goods and services leads to decreased non-communicable disease in the community.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "133": {
      "id": 133,
      "from": 24,
      "to": 34,
      "type": "-",
      "long": "Increased active transport use leads to decreased private vehicle use.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "134": {
      "id": 134,
      "from": 25,
      "to": 7,
      "type": "+",
      "long": "Increased dense mixed land use leads to increased exposure to other people.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "135": {
      "id": 135,
      "from": 47,
      "to": 30,
      "type": "+",
      "long": "A more active-transport-friendly and safe environment leads to increased wellbeing in the community.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    },
    "136": {
      "id": 136,
      "from": 5,
      "to": 14,
      "type": "+",
      "long": "More attractive streets and parks leads to increased access to safe and inclusive public green spaces.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "137": {
      "id": 137,
      "from": 2,
      "to": 13,
      "type": "-",
      "long": "Increased local crime leads to decreased local sense of security (how safe people feel).",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "138": {
      "id": 138,
      "from": 6,
      "to": 5,
      "type": "+",
      "long": "Increased incorporation of culture & indigenous biodiversity in design leads to streets and parks which are more attractive to locals.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "139": {
      "id": 139,
      "from": 40,
      "to": 15,
      "type": "+",
      "long": "Increased social connection in the local community leads to increased place attachment.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "140": {
      "id": 140,
      "from": 37,
      "to": 40,
      "type": "+",
      "long": "Increased community participation in planning leads to increased social connection in the local community.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "141": {
      "id": 141,
      "from": 24,
      "to": 27,
      "type": "+",
      "long": "Increased use of active transport leads to more people on local streets.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "142": {
      "id": 142,
      "from": 2,
      "to": 40,
      "type": "-",
      "long": "Increased local crime leads to decreased social connection in the local community.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "143": {
      "id": 143,
      "from": 1,
      "to": 14,
      "type": "+",
      "long": "Increased access to goods and services leads to an increase in inclusive and safe access to public green spaces.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.scitotenv.2020.136678",
        "title": "Suburb-level changes for active transport to meet the SDGs: Causal theory and a New Zealand case study",
        "authors": ["Alexandra Macmillan", "Melody Smith", "Karen Witten", "Alistair Woodward", "Jamie Hosking", "Kirsty Wild", "Adrian Field"],
        "date": "2020",
        "journal": "Science of The Total Environment",
        "issue": ""
      }],
      "unsdg": ""
    },
    "144": {
      "id": 144,
      "from": 25,
      "to": 47,
      "type": "+",
      "long": "More dense mixed land use leads to a more walk/bike friendly and safe environment.",
      "refs": [{
        "type": "article",
        "doi": "10.1016/j.jth.2016.01.008",
        "title": "Contextualizing research on transportation and health: A systems perspective",
        "authors": ["Michael J. Widener", "Marianne Hatzopoulou"],
        "date": "2016",
        "journal": "Journal of Transport & Health",
        "issue": "3"
      }],
      "unsdg": ""
    }
  },
  "adaptations": {
    "145": {
      "id": 145,
      "variable": "daily_precip",
      "direction": "increase",
      "related": [41, 33, 47, 22, 5, 3],
      "short": "Install permeable paving",
      "long": "Permeable pavings drain storm water more rapidly and reduce the chance of pavements/roads flooding. ",
      "refs": [{
        "type": "article",
        "doi": "10.3390/su12031057",
        "title": "Flexible Pavements and Climate Change: A Comprehensive Review and Implications",
        "authors": ["Yaning Qiao", "Andrew R. Dawson", "Tony Parry", "Gerardo Flintsch", "Wenshun Wang"],
        "date": "2020",
        "journal": "Sustainability",
        "issue": "3"
      }, {
        "doi": "https://www.c40knowledgehub.org/s/article/Reducing-climate-change-impacts-on-walking-and-cycling?language=en_US",
        "type": "link",
        "link": "https://www.c40knowledgehub.org/s/article/Reducing-climate-change-impacts-on-walking-and-cycling?language=en_US"
      }],
      "case": "",
      "caseref": ""
    },
    "146": {
      "id": 146,
      "variable": "daily_precip",
      "direction": "increase",
      "related": [41, 33, 47, 22, 5, 3],
      "short": "Improve drainage",
      "long": "Improving drainage will maintain road use for active travel during periods of increased rainfall.",
      "refs": [{
        "type": "article",
        "doi": "10.3390/su12031057",
        "title": "Flexible Pavements and Climate Change: A Comprehensive Review and Implications",
        "authors": ["Yaning Qiao", "Andrew R. Dawson", "Tony Parry", "Gerardo Flintsch", "Wenshun Wang"],
        "date": "2020",
        "journal": "Sustainability",
        "issue": "3"
      }, {
        "doi": "https://www.c40knowledgehub.org/s/article/Reducing-climate-change-impacts-on-walking-and-cycling?language=en_US",
        "type": "link",
        "link": "https://www.c40knowledgehub.org/s/article/Reducing-climate-change-impacts-on-walking-and-cycling?language=en_US"
      }],
      "case": "",
      "caseref": ""
    },
    "147": {
      "id": 147,
      "variable": "daily_precip",
      "direction": "increase",
      "related": [41, 33, 47, 22, 5],
      "short": "Raise road surface levels",
      "long": "Where flooding is frequent, raising road surface levels to a higher level relative to the surrounding ground will help maintain the road for active travel.",
      "refs": [{
        "type": "article",
        "doi": "10.3390/su12031057",
        "title": "Flexible Pavements and Climate Change: A Comprehensive Review and Implications",
        "authors": ["Yaning Qiao", "Andrew R. Dawson", "Tony Parry", "Gerardo Flintsch", "Wenshun Wang"],
        "date": "2020",
        "journal": "Sustainability",
        "issue": "3"
      }],
      "case": "",
      "caseref": ""
    },
    "148": {
      "id": 148,
      "variable": "daily_precip",
      "direction": "increase",
      "related": [41, 11, 33, 47, 22, 5],
      "short": "Reduce use of fine materials in unbound granular layers",
      "long": "This should be done where existing groundwater levels are high. This process reduces the moisture content in paving, decreases the risk of pavement/road damage in the future, and prevents accidents related to paving deterioration.",
      "refs": [{
        "type": "article",
        "doi": "10.3390/su12031057",
        "title": "Flexible Pavements and Climate Change: A Comprehensive Review and Implications",
        "authors": ["Yaning Qiao", "Andrew R. Dawson", "Tony Parry", "Gerardo Flintsch", "Wenshun Wang"],
        "date": "2020",
        "journal": "Sustainability",
        "issue": "3"
      }],
      "case": "",
      "caseref": ""
    },
    "149": {
      "id": 149,
      "variable": "daily_precip",
      "direction": "increase",
      "related": [41, 33, 47, 22, 5],
      "short": "Install porous asphalt",
      "long": "Porous asphalt provides a surface that is free of water and improves driving safety. This will also create a safer active transport environment. \nHowever, porous asphalt is more prone to surface moisture damage and should be designed carefully.",
      "refs": [{
        "type": "article",
        "doi": "10.3390/su12031057",
        "title": "Flexible Pavements and Climate Change: A Comprehensive Review and Implications",
        "authors": ["Yaning Qiao", "Andrew R. Dawson", "Tony Parry", "Gerardo Flintsch", "Wenshun Wang"],
        "date": "2020",
        "journal": "Sustainability",
        "issue": "3"
      }],
      "case": "",
      "caseref": ""
    },
    "150": {
      "id": 150,
      "variable": "daily_precip",
      "direction": "increase",
      "related": [33, 47, 22],
      "short": "Make cycle hire flood-proof ",
      "long": "The electrical infrastructure for cycle hire stations needs to be flood proof so that the stations stay operational after heavy rain.",
      "refs": [{
        "doi": "https://www.c40knowledgehub.org/s/article/Reducing-climate-change-impacts-on-walking-and-cycling?language=en_US",
        "type": "link",
        "link": "https://www.c40knowledgehub.org/s/article/Reducing-climate-change-impacts-on-walking-and-cycling?language=en_US"
      }],
      "case": "",
      "caseref": ""
    },
    "151": {
      "id": 151,
      "variable": "daily_precip",
      "direction": "increase",
      "related": [41, 33, 47, 22, 5, 3],
      "short": "Improve visibility",
      "long": "Improving visibility by installing appropriate street lighting helps to maintain road use for active travel during periods of increased rainfall and decreased visibility.",
      "refs": [{
        "type": "article",
        "doi": "10.1161/cir.0000000000000878",
        "title": "Creating Built Environments That Expand Active Transportation and Active Living Across the United States: A Policy Statement From the American Heart Association",
        "authors": ["Deborah R. Young", "Angie L. Cradock", "Amy A. Eyler", "Mark Fenton", "Margo Pedroso", "James F. Sallis", "Laurie P. Whitsel"],
        "date": "2020",
        "journal": "Circulation",
        "issue": "11"
      }],
      "case": "Ruggedised: Designing smart, resilient cities for all",
      "caseref": "https://ruggedised.eu/fileadmin/repository/Factsheets/Ruggedised-factsheet-R11-Rotterdam.pdf|https://ruggedised.eu/fileadmin/repository/Factsheets/Ruggedised-factsheet-G6.pdf"
    },
    "152": {
      "id": 152,
      "variable": "mean_windspeed",
      "direction": "increase",
      "related": [33, 47, 22, 5, 3],
      "short": "Install windbreaks",
      "long": "Windbreaks using planting, trees, hedges or fences, can help mitigate the effects of strong prevailing winds, and make walking and cycling more attractive.",
      "refs": [{
        "doi": "https://www.gov.uk/government/publications/cycle-infrastructure-design-ltn-120",
        "type": "link",
        "link": "https://www.gov.uk/government/publications/cycle-infrastructure-design-ltn-120"
      }, {
        "type": "article",
        "doi": "10.1161/cir.0000000000000878",
        "title": "Creating Built Environments That Expand Active Transportation and Active Living Across the United States: A Policy Statement From the American Heart Association",
        "authors": ["Deborah R. Young", "Angie L. Cradock", "Amy A. Eyler", "Mark Fenton", "Margo Pedroso", "James F. Sallis", "Laurie P. Whitsel"],
        "date": "2020",
        "journal": "Circulation",
        "issue": "11"
      }],
      "case": "",
      "caseref": ""
    },
    "153": {
      "id": 153,
      "variable": "mean_temp",
      "direction": "increase",
      "related": [33, 47, 22, 5],
      "short": "Install permeable paving",
      "long": "Permeable pavings have a cooling effect and decrease nearby temperatures.",
      "refs": [{
        "type": "article",
        "doi": "10.3390/su12031057",
        "title": "Flexible Pavements and Climate Change: A Comprehensive Review and Implications",
        "authors": ["Yaning Qiao", "Andrew R. Dawson", "Tony Parry", "Gerardo Flintsch", "Wenshun Wang"],
        "date": "2020",
        "journal": "Sustainability",
        "issue": "3"
      }],
      "case": "",
      "caseref": ""
    },
    "154": {
      "id": 154,
      "variable": "mean_temp",
      "direction": "increase",
      "related": [33, 47, 22, 5],
      "short": "Install cool paving",
      "long": "Cool pavements/roads with highly reflective coating reduces air temperatures near paved surfaces. Consider installing these  in pedestrianized areas, cycling lanes and cycle hire stations. This is especially important in more urbanized areas.",
      "refs": [{
        "type": "article",
        "doi": "10.3390/su12031057",
        "title": "Flexible Pavements and Climate Change: A Comprehensive Review and Implications",
        "authors": ["Yaning Qiao", "Andrew R. Dawson", "Tony Parry", "Gerardo Flintsch", "Wenshun Wang"],
        "date": "2020",
        "journal": "Sustainability",
        "issue": "3"
      }, {
        "doi": "https://www.c40knowledgehub.org/s/article/Reducing-climate-change-impacts-on-walking-and-cycling?language=en_US",
        "type": "link",
        "link": "https://www.c40knowledgehub.org/s/article/Reducing-climate-change-impacts-on-walking-and-cycling?language=en_US"
      }],
      "case": "Cool pavement pilot program, City of Los Angeles",
      "caseref": "https://www.irf.global/information-on-cool-pavement-pilot-program-city-of-los-angeles/"
    },
    "155": {
      "id": 155,
      "variable": "mean_temp",
      "direction": "increase",
      "related": [33, 47, 22, 5, 3],
      "short": "Increase tree cover near pavements and roads",
      "long": "Shading provided by tree cover is effective at reducing the temperature of paving and surrounding areas.",
      "refs": [{
        "type": "article",
        "doi": "10.3390/su12031057",
        "title": "Flexible Pavements and Climate Change: A Comprehensive Review and Implications",
        "authors": ["Yaning Qiao", "Andrew R. Dawson", "Tony Parry", "Gerardo Flintsch", "Wenshun Wang"],
        "date": "2020",
        "journal": "Sustainability",
        "issue": "3"
      }, {
        "doi": "https://www.c40knowledgehub.org/s/article/Reducing-climate-change-impacts-on-walking-and-cycling?language=en_US",
        "type": "link",
        "link": "https://www.c40knowledgehub.org/s/article/Reducing-climate-change-impacts-on-walking-and-cycling?language=en_US"
      }, {
        "type": "article",
        "doi": "10.1161/cir.0000000000000878",
        "title": "Creating Built Environments That Expand Active Transportation and Active Living Across the United States: A Policy Statement From the American Heart Association",
        "authors": ["Deborah R. Young", "Angie L. Cradock", "Amy A. Eyler", "Mark Fenton", "Margo Pedroso", "James F. Sallis", "Laurie P. Whitsel"],
        "date": "2020",
        "journal": "Circulation",
        "issue": "11"
      }, {
        "doi": "https://www.fs.fed.us/psw/topics/urban_forestry/products/cufr639mcpherson-JOA-pavingshade.pdf",
        "type": "link",
        "link": "https://www.fs.fed.us/psw/topics/urban_forestry/products/cufr639mcpherson-JOA-pavingshade.pdf"
      }],
      "case": "Street Tree Master Plan, Miami",
      "caseref": "https://www8.miamidade.gov/global/recreation/milliontrees/street-tree-master-plan.page"
    },
    "156": {
      "id": 156,
      "variable": "mean_temp",
      "direction": "increase",
      "related": [33, 47, 22, 5, 3],
      "short": "Install drinking fountains",
      "long": "Drinking fountains next to cycle hire stations, along bike lanes and in pedestrianized areas help communities stay hydrated during active travel.",
      "refs": [{
        "doi": "https://www.c40knowledgehub.org/s/article/Reducing-climate-change-impacts-on-walking-and-cycling?language=en_US",
        "type": "link",
        "link": "https://www.c40knowledgehub.org/s/article/Reducing-climate-change-impacts-on-walking-and-cycling?language=en_US"
      }],
      "case": "",
      "caseref": ""
    },
    "157": {
      "id": 157,
      "variable": "mean_temp",
      "direction": "increase",
      "related": [33, 47, 22, 5, 3],
      "short": "Improve shading",
      "long": "Shading areas next to cycle hire stations and in pedestrianized zones decreases people\u2019s exposure to heat and makes active travel a more attractive option.",
      "refs": [{
        "doi": "https://www.c40knowledgehub.org/s/article/Reducing-climate-change-impacts-on-walking-and-cycling?language=en_US",
        "type": "link",
        "link": "https://www.c40knowledgehub.org/s/article/Reducing-climate-change-impacts-on-walking-and-cycling?language=en_US"
      }, {
        "type": "article",
        "doi": "10.1161/cir.0000000000000878",
        "title": "Creating Built Environments That Expand Active Transportation and Active Living Across the United States: A Policy Statement From the American Heart Association",
        "authors": ["Deborah R. Young", "Angie L. Cradock", "Amy A. Eyler", "Mark Fenton", "Margo Pedroso", "James F. Sallis", "Laurie P. Whitsel"],
        "date": "2020",
        "journal": "Circulation",
        "issue": "11"
      }],
      "case": "Street Tree Master Plan, Miami",
      "caseref": "https://www8.miamidade.gov/global/recreation/milliontrees/street-tree-master-plan.page"
    },
    "158": {
      "id": 158,
      "variable": "mean_temp",
      "direction": "increase",
      "related": [33, 47, 22, 5, 3],
      "short": "Route cyclists through parks",
      "long": "Designing cycling routes through parks provides cooling and promotes the use of active transport.",
      "refs": [{
        "doi": "https://www.c40knowledgehub.org/s/article/Reducing-climate-change-impacts-on-walking-and-cycling?language=en_US",
        "type": "link",
        "link": "https://www.c40knowledgehub.org/s/article/Reducing-climate-change-impacts-on-walking-and-cycling?language=en_US"
      }],
      "case": "",
      "caseref": ""
    },
    "159": {
      "id": 159,
      "variable": "",
      "direction": "",
      "related": [33, 47, 22, 5],
      "short": "Plan for more frequent maintenance on pavings",
      "long": "Paving damage (such as longitudinal cracking, alligator cracking, and rutting) will be exacerbated by climate change, and maintenance will have to be performed earlier and more often to mitigate the impacts.",
      "refs": [{
        "type": "article",
        "doi": "10.3390/su12031057",
        "title": "Flexible Pavements and Climate Change: A Comprehensive Review and Implications",
        "authors": ["Yaning Qiao", "Andrew R. Dawson", "Tony Parry", "Gerardo Flintsch", "Wenshun Wang"],
        "date": "2020",
        "journal": "Sustainability",
        "issue": "3"
      }],
      "case": "",
      "caseref": ""
    }
  }
};
exports.net = net;

},{}],40:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Network = void 0;

// Copyright (C) 2021 Then Try This
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
const $ = require("jquery");

const finder = require("./adaptation_finder.js");

const net = require("./net.js");

const vis = require("vis-network/standalone");

const node_size = 25;
const preview_font_size = 6;

class Network {
  constructor() {
    this.net = net.net;
    this.tiles = [];
    this.style = "simple";
    this.nodes = [];
    this.edges = [];
    this.url_cache = {};
    this.table = "future_winter_avg";
    this.finder = new finder.AdaptationFinder();
    this.type_cols = {
      "Equity": "#e6e6e6",
      "Community": "#e6e6e6",
      "Health": "#e6e6e6",
      "Travel": "#e6e6e6",
      "Sustainable-development": "#e6e6e6"
    };
    this.types = ["Health", "Equity", "Community", "Travel", "Sustainable-development"];
    this.filter = [];
    this.iconCache = {};
    this.iconCacheLoading = false;
    this.iconFnFix = {
      "Attractiveness of streets/parks to locals": "Attractiveness of streets parks to locals FILE NAME",
      "Community action to resolve minor anti-social behaviour": "Community action to resolve minor antisocial behaviour",
      "Walk/bike friendly & safe environment": "Walk bike friendly & safe environment FILE NAME",
      "Number of local walking & cycling injuries": "Number of walking & cycling injuries"
    };
    this.notFoundIcon = `<circle
             style="fill:#254747;fill-opacity:1;stroke-width:0.46499997"
             id="circle1093-0-8"
             cx="150"
             cy="125"
             r="100" />`; // this.paywalled = ["10.1016/j.jth.2016.01.008",
    // 				  "10.1016/j.scitotenv.2020.136678",
    // 				  "10.1016/j.trd.2019.09.022",
    // 				  "10.1016/j.jtrangeo.2019.04.016"]

    this.paywalled = [];
  }

  async loadIcon(fn) {
    let name = fn;

    if (this.iconFnFix[fn] != null) {
      name = this.iconFnFix[fn];
    }

    let xhr = new XMLHttpRequest();
    await xhr.open("GET", "images/icons/" + name + ".svg", false);
    xhr.overrideMimeType("image/svg+xml");

    xhr.onload = e => {
      if (xhr.responseXML != null) {
        this.iconCache[fn] = xhr.responseXML.documentElement.innerHTML;
      }
    };

    xhr.onerror = e => {
      console.log("problem loading: " + name);
    };

    await xhr.send("");
  }

  async loadIconCache() {
    if (!this.iconCacheLoading) {
      this.iconCacheLoading = true;

      for (let f in this.net.factors) {
        this.loadIcon(this.net.factors[f].short);
      }

      for (let f in this.net.causes) {
        this.loadIcon(this.net.causes[f].short);
      }
    }
  }

  printable(str) {
    return str.replace("&", "&amp;");
  }

  nodeImageURL(id, title, text, bg) {
    let height = 500;
    if (bg == undefined) bg = "#e6e6e6";
    let icon = this.notFoundIcon;

    if (this.iconCache[title] != null) {
      icon = `<g transform="translate(40,130) scale(7)">` + this.iconCache[title] + `</g>`;
    } else {
      console.log("icon for " + title + " not found");
    }

    let extra = "";

    if (text != "") {
      extra = `<center style="font-size: 1.5em;">` + text + `</center>`;
    }

    let svg = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" height="` + height + `" style="overflow:visible;">` + icon + `<foreignObject x="0" y="340" width="100%" height="100%">
        <div xmlns="http://www.w3.org/1999/xhtml" style="font-family: 'nunito',Arial,Helvetica,sans-serif; font-size: 1em; padding: 1em;">
        <center style="font-size: 2em;">` + this.printable(title) + `</center>` + extra + `</div>
        </foreignObject>
        </svg>`;
    let url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
    return url;
  }

  climateVariableText(variable) {
    let units = "celsius";

    if (variable.variable_name == "daily_precip") {
      units = "mm/day";
    }

    if (variable.variable_name == "mean_windspeed") {
      units = "m/s";
    }

    if (variable.direction == "rising") {
      return "Increasing by " + (variable.value - variable.reference).toFixed(2) + " " + units + " in next 70 years";
    } else {
      return "Decreasing by " + (variable.reference - variable.value).toFixed(2) + " " + units + " in next 70 years";
    }
  }

  causeImageURL(id, title, text, bg, variable) {
    let height = 500;
    if (bg == undefined) bg = "#e6e6e6";
    let icon = this.notFoundIcon;

    if (this.iconCache[title] != null) {
      icon = `<g transform="translate(40,130) scale(7)">` + this.iconCache[title] + `</g>`;
    } else {
      console.log("icon for " + title + " not found");
    }

    let svg = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" height="` + height + `" style="overflow:visible;">
        ` + icon + `			
        <foreignObject x="0" y="340" width="100%" height="100%">
        <div xmlns="http://www.w3.org/1999/xhtml" style="font-family: 'nunito',Arial,Helvetica,sans-serif; font-size: 1em; padding: 1em;">
        <center style="font-size: 2em;">` + this.printable(title) + `</center>
        <center style="font-size: 1.5em;">` + this.climateVariableText(variable) + `</center>
        </div>
        </foreignObject>
        </svg>`;
    let url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
    return url;
  }

  adaptationImageURL(id, title, text, bg) {
    let height = 450;
    if (text == "") height = 350;
    if (bg == undefined) bg = "#e6e6e6";
    let icon = this.notFoundIcon;
    let svg = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" height="` + height + `" style="overflow:visible;">
                   <rect x="0" y="0" width="100%" height="100%" fill="` + bg + `" stroke-width="5" stroke="#a4b3cd"  rx="15" ></rect>
        ` + icon + `			
        <foreignObject x="0" y="220" width="100%" height="100%">
        <div xmlns="http://www.w3.org/1999/xhtml" style="font-family: 'nunito',Arial,Helvetica,sans-serif; font-size: 1em; padding: 1em;">
        <center style="font-size: 2em;">` + this.printable(title) + `</center>
        <p>` + this.printable(text) + `</p>
        </div>
        </foreignObject>
        </svg>`;
    let url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
    return url;
  }

  referenceToHTML(ref) {
    if (ref.type == "link") {
      return "<a target=”_blank” href='" + ref.link + "'>" + ref.link + "</a>";
    } else {
      let ret = "";

      if (this.paywalled.includes(ref.doi)) {
        ret += "<b><a target=”_blank” style='color:red;' href='http://doi.org/" + ref.doi + "'>(PAYWALLED) " + ref.title + "</a></b> ";
      } else {
        ret += "<b><a target=”_blank” href='http://doi.org/" + ref.doi + "'>" + ref.title + "</a></b> ";
      }

      ret += ref.authors.join(", ");
      ret += ": " + ref.journal;

      if (ref.date != "") {
        ret += " " + ref.date;
      }

      if (ref.issue != "") {
        ret += " Issue: " + ref.issue;
      }

      ret += " DOI: " + ref.doi;
      return ret;
    }
  }

  causeToHTML(cause) {
    let s = "";
    s += `<h3>` + cause.short + `</h3>`;
    s += `<p>` + cause.long + `</p>`;
    s += "<ul>";

    if (cause.refs.length > 0) {
      s += "<li><b>References</b>: <ol>";

      for (let ref of cause.refs) {
        s += "<li>" + this.referenceToHTML(ref) + "</li>";
      }

      s += "</ol></li>";
    }

    s += "</ul>";
    return s;
  }

  factorToHTML(factor) {
    let s = "";
    s += `<h3>` + factor.short + `</h3>`;
    s += `<p>` + factor.long + `</p>`;
    s += "<ul>";

    if (factor.type != "") {
      s += "<li><b>Type</b>: " + factor.type + "</li>";
    }

    if (factor.unsdg != "") {
      s += "<li><b>UN SDG</b>: " + factor.unsdg + "</li>";
    }

    if (factor.refs.length > 0) {
      s += "<li><b>References</b>: <ol>";

      for (let ref of factor.refs) {
        s += "<li>" + this.referenceToHTML(ref) + "</li>";
      }

      s += "</ol></li>";
    }

    s += "</ul>";
    return s;
  }

  impactToHTML(impact) {
    let s = "";
    let direction = "increases";

    if (impact.type == "-") {
      direction = "decreases";
    }

    s += `<b>` + this.net.factors[impact.from].short + `</b> ` + direction + ` <b>` + this.net.factors[impact.to].short + `</b><br>`;

    if (impact.long != "") {
      s += `<p>` + impact.long + `</p>`;
    }

    s += "<ul>";
    /*if (impact.type!="") {
    	s+="<li><b>Type</b>: "+impact.type+"</li>"
    }*/

    if (impact.unsdg != "") {
      s += "<li><b>UN SDG</b>: " + impact.unsdg + "</li>";
    }

    if (impact.refs.length > 0) {
      s += "<li><b>References</b>: <ol>";

      for (let ref of impact.refs) {
        s += "<li>" + this.referenceToHTML(ref) + "</li>";
      }

      s += "</ol></li>";
    }

    s += "</ul>";
    return s;
  }

  factorToNodeFull(factor) {
    let text = "";

    if (factor.short == "Active transport use") {
      let v = this.finder.calculateFactorChange(factor);

      if (v > 0) {
        text = "Estimated increase of " + v.toFixed(2) + "% in your area";
      } else {
        text = "Estimated decrease of " + (-v).toFixed(2) + "% in your area";
      }
    }

    return {
      id: factor.id,
      shape: "image",
      label: "",
      size: node_size,
      // "#e6e6e6"
      image: this.nodeImageURL(factor.id, factor.short, text, this.type_cols[factor.type]),
      preview: false
    };
  }

  factorToNodePreview(factor) {
    let t = this.factorToNodeFull(factor);
    t.preview = true;
    return t;
    /*return {
    		id: factor.id,
    	shape: "text",
    	label: factor.short,
    	font: { size: preview_font_size },
    	preview: true
    }*/
  }

  isPaywalled(obj) {
    for (let ref of obj.refs) {
      if (ref.doi != undefined && this.paywalled.includes(ref.doi)) {
        return true;
      }
    }

    return false;
  }

  factorEdge(factor, impact, new_factor) {
    let label = impact.type;
    let colour = "#b0cacc";

    if (this.isPaywalled(impact)) {
      colour = "#ffcaca";
    }

    if (label == "-") label = "‐";
    return {
      id: impact.id,
      from: factor.id,
      to: impact.to,
      arrows: "to",
      //label: " "+label+" ",
      labelHighlightBold: false,
      arrowStrikethrough: false,
      font: {
        //background: "#fff",
        color: colour,
        size: 30 //vadjust: 10,
        //align: "bottom"

      },
      color: {
        color: colour,
        highlight: colour
      }
    };
  }

  causeEdge(cause, polarity_match) {
    let label = cause.type;

    if (!polarity_match) {
      if (label == "-") label = "+";else label = "-";
    }

    if (label == "-") {
      label = "‐";
    }

    let colour = "#b0cacc";

    if (this.isPaywalled(cause)) {
      colour = "#ffcaca";
    }

    return {
      id: cause.id,
      from: cause.id,
      to: cause.factor,
      arrows: "to",
      //label: " "+label+" ",
      labelHighlightBold: false,
      arrowStrikethrough: false,
      font: {
        //background: "#fff",
        color: colour,
        size: 30 //vadjust: 10,
        //align: "bottom"

      },
      color: {
        color: colour,
        highlight: colour
      }
    };
  }

  adaptationEdge(factor_id, adaptation) {
    return {
      from: factor_id,
      to: adaptation.id,
      arrows: "to",
      //value: 0.05,
      color: {
        color: "#b0cacc",
        highlight: "#b0cacc"
      }
    };
  }

  adaptationToNode(adaptation) {
    return {
      id: adaptation.id,
      shape: "image",
      label: "",
      size: node_size,
      image: this.adaptationImageURL(adaptation.id, adaptation.short, adaptation.long, "#ff0000")
    };
  }

  addImpacts(factor, pos) {
    let i = 0;

    for (let impact_id of factor.impacts) {
      let impact = this.net.impacts[impact_id];
      let new_factor = this.net.factors[impact.to]; // get a roughly ok position, downwind and spread out

      let fpos = {
        x: pos.x + 100,
        y: pos.y + (i - factor.impacts.length / 2) * node_size
      };

      if (new_factor.overview == "main element" || this.filter.includes(new_factor.type)) {
        this.addFactor(new_factor, false, fpos);
        this.edges.add([this.factorEdge(factor, impact, new_factor)]);
      } else {
        this.addFactor(new_factor, true, fpos);
        this.edges.add([this.factorEdge(factor, impact, new_factor)]);
      }

      i += 1;
    }
  }

  getRnd(min, max) {
    return Math.random() * (max - min) + min;
  }

  addFactor(factor, preview_node, pos) {
    if (!this.nodes.get(factor.id)) {
      if (preview_node == false) {
        let n = this.factorToNodeFull(factor);
        n.x = pos.x;
        n.y = pos.y;
        this.nodes.add([n]);
        this.addImpacts(factor, {
          x: n.x,
          y: n.y
        }); //this.searchAdaptations(factor.id,pos)
      } else {
        let n = this.factorToNodePreview(factor);
        n.x = pos.x;
        n.y = pos.y;
        this.nodes.add([n]);
      }
    }
  }

  addCause(cause, y) {
    if (!this.nodes.get(cause.id)) {
      let polarity_match = this.finder.causePolarityMatch(cause);
      let variable = this.finder.variables[cause.variable];
      this.nodes.add([{
        id: cause.id,
        shape: "image",
        size: node_size,
        image: this.causeImageURL(cause.id, cause.short, "", "#a4f9c8", variable),
        x: 0,
        y: y * 75,
        fixed: true
      }]);
      this.addFactor(this.net.factors[cause.factor], false, {
        x: 100,
        y: y * 75
      });
      this.edges.add([this.causeEdge(cause, polarity_match)]);
    }
  }

  addAdaptation(adaptation, pos) {
    if (!this.nodes.get(adaptation.id)) {
      let n = this.adaptationToNode(adaptation);
      n.x = pos.x;
      n.y = pos.y;
      this.nodes.add([n]);
    }
  }

  searchAdaptations(factor_id, pos) {
    for (let aid in this.net.adaptations) {
      let a = this.net.adaptations[aid];

      if (a.related.includes(factor_id)) {
        this.addAdaptation(a, pos);
        this.edges.add([this.adaptationEdge(factor_id, a)]);
      }
    }
  }

  async updateVariables(table) {
    if (table != undefined) {
      this.table = table;
    }

    await this.finder.loadVariables(this.table, this.tiles, ["daily_precip", "mean_temp", "mean_windspeed"], 2, 9);
    this.buildGraph(); // update adaptations from climate variables

    this.finder.updateHTML(this.net.adaptations);
  }

  async buildGraph() {
    this.nodes = new vis.DataSet([]);
    this.edges = new vis.DataSet([]); // read filter:

    this.filter = [];

    for (var t of this.types) {
      if ($('#' + t).prop('checked')) {
        this.filter.push(t);
      }
    }

    let c = 0;

    for (let cause of this.net.causes) {
      this.addCause(cause, c);
      c += 1;
    }
    /*for (let f in this.net.factors) {
    	let factor=this.net.factors[f]
    	if (factor.overview=="Y") {
    		this.addFactor(factor,false,{x:0, y:0})
    	}
    }*/


    const options = {
      physics: {
        enabled: true,
        //solver: "forceAtlas2Based",
        solver: "barnesHut",
        maxVelocity: 20,
        barnesHut: {//avoidOverlap: 0.5,
          //gravitationalConstant: -10000
        },
        wind: {
          x: 0.5,
          y: 0
        }
      },
      layout: {
        randomSeed: 5,
        improvedLayout: true,
        clusterThreshold: 1
        /*hierarchical: {
        	shakeTowards: "roots",
        	enabled: false,
        	direction: "LR",
        	levelSeparation: 200,
        },*/

      }
    }; // create a network

    var container = document.getElementById("network-holder");
    var network = new vis.Network(container, {
      nodes: this.nodes,
      edges: this.edges
    }, options);
    $("#network-info").empty();
    network.on('click', properties => {
      let ids = properties.nodes;
      let node_selected = false;

      for (let node of this.nodes.get(ids)) {
        let factor = this.net.factors[node.id];
        let pos = network.getPositions(node.id)[node.id];

        if (factor != undefined) {
          if (node.preview == true) {
            this.nodes.update(this.factorToNodeFull(factor));
            this.addImpacts(factor, pos);
          } else {
            $("#network-info").html(this.factorToHTML(factor));
          }

          node_selected = true;
        } else {
          for (let c of this.net.causes) {
            if (c.id == node.id) {
              $("#network-info").html(this.causeToHTML(c));
            }
          }
        }
      }

      if (!node_selected) {
        let ids = properties.edges;

        for (let edge of this.edges.get(ids)) {
          let impact = this.net.impacts[edge.id];

          if (impact != undefined) {
            $("#network-info").html(this.impactToHTML(impact));
          } else {
            for (let c of this.net.causes) {
              if (c.id == edge.id) {
                $("#network-info").html(this.causeToHTML(c));
              }
            }
          }
        }
      }
    });
  }

}

exports.Network = Network;

},{"./adaptation_finder.js":35,"./net.js":39,"jquery":28,"vis-network/standalone":34}],41:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SVG = void 0;

// Copyright (C) 2021 Then Try This
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
class SVG {
  constructor(w, h) {
    this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    this.svg.setAttributeNS(null, 'width', "100%");
    this.svg.setAttributeNS(null, 'height', "50%");
    this.svg.setAttributeNS(null, 'viewBox', '0 0 ' + w + ' ' + h);
  }

  add_line(x1, y1, x2, y2, w, s) {
    var c = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    c.setAttributeNS(null, 'x1', x1);
    c.setAttributeNS(null, 'y1', y1);
    c.setAttributeNS(null, 'x2', x2);
    c.setAttributeNS(null, 'y2', y2);
    c.setAttributeNS(null, 'stroke', s);
    this.svg.appendChild(c);
  }

  add_text(x, y, s, t) {
    var c = document.createElementNS("http://www.w3.org/2000/svg", "text");
    var myText = document.createTextNode(t);
    c.setAttributeNS(null, 'x', x);
    c.setAttributeNS(null, 'y', y);
    c.setAttributeNS(null, 'fill', "#42273b");
    c.setAttribute("font-size", s);
    c.appendChild(myText);
    this.svg.appendChild(c);
  }

  add_sideways_text(x, y, t) {
    var c = document.createElementNS("http://www.w3.org/2000/svg", "text");
    var myText = document.createTextNode(t);
    c.setAttributeNS(null, 'x', 0);
    c.setAttributeNS(null, 'y', 0);
    c.setAttributeNS(null, 'fill', "#42273b");
    c.setAttribute("font-size", "15");
    c.setAttribute("transform", "translate(" + x + "," + y + ") rotate(-90)");
    c.appendChild(myText);
    this.svg.appendChild(c);
  }

  add_bar(x, y, w, h, label, v, col) {
    var c = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    c.setAttributeNS(null, 'x', x);
    c.setAttributeNS(null, 'y', y - h);
    c.setAttributeNS(null, 'width', w);
    c.setAttributeNS(null, 'height', h);
    c.setAttributeNS(null, 'fill', col);
    this.svg.appendChild(c);
    this.add_text(x + 10, y + 30, "25", label);
    this.add_text(x + 20, y - h + 20, "15", "" + v.toFixed(2));
  }

  add_rect(x, y, w, h, col) {
    var c = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    c.setAttributeNS(null, 'x', x);
    c.setAttributeNS(null, 'y', y);
    c.setAttributeNS(null, 'width', w);
    c.setAttributeNS(null, 'height', h);
    c.setAttributeNS(null, 'fill', col);
    this.svg.appendChild(c);
  }

  add_2bar(x, y, w, h, h2, label, v, v2, col, col1) {
    let a = h;
    let b = h2;
    let av = v;
    let bv = v2;
    let ca = col; // winter

    let cb = col1; // summer

    if (v < v2) {
      a = h2;
      b = h;
      av = v2;
      bv = v;
      ca = "#4c9f70";
      cb = "#a4f9c8";
    }

    var c = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    c.setAttributeNS(null, 'x', x);
    c.setAttributeNS(null, 'y', y - a);
    c.setAttributeNS(null, 'width', w);
    c.setAttributeNS(null, 'height', a);
    c.setAttributeNS(null, 'fill', ca);
    this.svg.appendChild(c);
    this.add_text(x + 20, y - a + 20, 15, "" + av.toFixed(2));
    var c = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    c.setAttributeNS(null, 'x', x);
    c.setAttributeNS(null, 'y', y - b);
    c.setAttributeNS(null, 'width', w);
    c.setAttributeNS(null, 'height', b);
    c.setAttributeNS(null, 'fill', cb);
    this.svg.appendChild(c);
    this.add_text(x + 20, y - b + 20, 15, "" + bv.toFixed(2));
    this.add_text(x + 10, y + 30, 25, label);
  }

}

exports.SVG = SVG;

},{}],42:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculate_decades = calculate_decades;

// Copyright (C) 2021 Then Try This
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
function arr2avg(arr) {
  let ret = 0;

  for (let v of arr) {
    ret += v;
  }

  return ret / arr.length;
}

function calculate_decades(graph_data) {
  let decades = {}; // collect values for each decade

  for (let year of graph_data) {
    let dec = Math.floor(year.year % 2000 / 10);

    if (decades[dec] == undefined) {
      decades[dec] = [year.avg];
    } else {
      decades[dec].push(year.avg);
    }
  } // average them together


  for (let dec of Object.keys(decades)) {
    decades[dec] = arr2avg(decades[dec]);
  }

  return decades;
}

},{}]},{},[37]);
